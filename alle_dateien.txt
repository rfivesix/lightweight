
===== Datei: /Users/richard/Projects/Lightweight/lightweight/test/widget_test.dart =====

// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:lightweight/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/main.dart =====

// lib/main.dart
// VOLLSTÄNDIGER CODE (KORRIGIERT)

import 'package:dynamic_color/dynamic_color.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/main_screen.dart';
import 'package:lightweight/services/profile_service.dart';
import 'package:lightweight/services/workout_session_manager.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/screens/onboarding_screen.dart';
import 'package:lightweight/services/theme_service.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // 1. Erstelle die Manager-Instanz
  final workoutSessionManager = WorkoutSessionManager();

  // 2. Rufe die neue, gekapselte Wiederherstellungsmethode auf
  // Annahme: Diese Methode existiert jetzt in deinem WorkoutSessionManager
  await workoutSessionManager.tryRestoreSession();

  final themeService = ThemeService(); // Create an instance
  // 3. Starte die App mit der (möglicherweise wiederhergestellten) Instanz
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider.value(value: workoutSessionManager),
        ChangeNotifierProvider(
          create: (context) {
            final profileService = ProfileService();
            profileService.initialize();
            return profileService;
          },
        ),
        ChangeNotifierProvider.value(
            value: themeService), // Provide the ThemeService
      ],
      child: const MyApp(),
    ),
  );
}

Future<bool> _hasSeenOnboarding() async {
  final prefs = await SharedPreferences.getInstance();
  return prefs.getBool('hasSeenOnboarding') == true;
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(statusBarColor: Colors.transparent),
    );

    const cardDark = Color(0xFF171717);
    const cardLight = Color(0xFFF3F3F3);

    // HINWEIS: Provider.of<ThemeService>(context) wurde von hier entfernt.

    return DynamicColorBuilder(
      builder: (ColorScheme? lightDynamic, ColorScheme? darkDynamic) {
        // === Akzent/Seed aus Dynamic Color (Android 12+) oder Fallback ===
        final Color lightSeed = lightDynamic?.primary ?? Colors.blue;
        final Color darkSeed = darkDynamic?.primary ?? lightSeed;

        // --- Light Scheme aus Seed, aber ohne Material You UI ---
        final lightScheme = ColorScheme.fromSeed(
          seedColor: lightSeed,
          brightness: Brightness.light,
        ).copyWith(
          surface: Colors.white,
        );

        // --- Dark Scheme aus Seed + OLED-Schwarz ---
        final seededDark = ColorScheme.fromSeed(
          seedColor: darkSeed,
          brightness: Brightness.dark,
        );
        final darkScheme = seededDark.copyWith(
          surface: Colors.black,
          surfaceDim: Colors.black,
          surfaceBright: Colors.black,
          surfaceContainerLowest: Colors.black,
          surfaceContainerLow: Colors.black,
          surfaceContainer: Colors.black,
          surfaceContainerHigh: Colors.black,
          surfaceContainerHighest: Colors.black,
        );

        // --- Light Theme (Material2, aber mit ColorScheme aus Seed) ---
        final baseLightTheme = ThemeData(
          useMaterial3: false, // KEIN Material You
          colorScheme: lightScheme,
          primaryColor: lightScheme.primary, // Akzent in M2-Welten
          scaffoldBackgroundColor: Colors.white,
          canvasColor: Colors.white,
          cardColor: cardLight,
          // NEU / ANGEPASST:
          splashFactory: NoSplash.splashFactory,
          splashColor: Colors.transparent,
          highlightColor: Colors.transparent,
          hoverColor: Colors.transparent,

          pageTransitionsTheme: const PageTransitionsTheme(
            builders: {
              TargetPlatform.android: ZoomPageTransitionsBuilder(),
              TargetPlatform.iOS: CupertinoPageTransitionsBuilder(),
              TargetPlatform.macOS: CupertinoPageTransitionsBuilder(),
              TargetPlatform.windows: ZoomPageTransitionsBuilder(),
              TargetPlatform.linux: ZoomPageTransitionsBuilder(),
            },
          ),

          inputDecorationTheme: InputDecorationTheme(
            filled: true,
            fillColor: const Color(0xFFF3F3F3),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide.none,
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(color: lightScheme.primary, width: 2),
            ),
            contentPadding:
                const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
          ),

          bottomSheetTheme: const BottomSheetThemeData(
            backgroundColor: cardLight,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
            ),
            elevation: 0,
          ),

          snackBarTheme: SnackBarThemeData(
            backgroundColor: lightScheme.primary,
            contentTextStyle: TextStyle(
              color: lightScheme.onPrimary,
              fontWeight: FontWeight.w600,
            ),
            behavior: SnackBarBehavior.floating,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),

          dividerTheme: DividerThemeData(
            color: Colors.black.withOpacity(0.08),
            thickness: 1,
            space: 24,
          ),
          appBarTheme: AppBarTheme(
            elevation: 0,
            scrolledUnderElevation: 0,
            backgroundColor: Colors.white,
            foregroundColor: Colors.black,
            centerTitle: false,
            titleTextStyle: ThemeData.light().textTheme.titleLarge?.copyWith(
                  fontFamily: 'Inter',
                  fontWeight: FontWeight.w900,
                  color: Colors.black,
                ),
          ),

          textTheme: ThemeData.light().textTheme.apply(
                fontFamily: 'Inter', // Das ist weiterhin korrekt
                bodyColor: Colors.black87,
                displayColor: Colors.black87,
              ),
          // Stellen sicher, dass Akzent sichtbar "lebt"
          elevatedButtonTheme: ElevatedButtonThemeData(
            style: ElevatedButton.styleFrom(
              backgroundColor: lightScheme.primary,
              foregroundColor: lightScheme.onPrimary,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12)),
            ),
          ),
          floatingActionButtonTheme: FloatingActionButtonThemeData(
            backgroundColor: lightScheme.primary,
            foregroundColor: lightScheme.onPrimary,
          ),
          //toggleableActiveColor: lightScheme.primary,
          progressIndicatorTheme:
              ProgressIndicatorThemeData(color: lightScheme.primary),
          textSelectionTheme: TextSelectionThemeData(
            cursorColor: lightScheme.primary,
            selectionColor: lightScheme.primary.withOpacity(0.25),
            selectionHandleColor: lightScheme.primary,
          ),
          checkboxTheme: CheckboxThemeData(
            fillColor: WidgetStateProperty.all(lightScheme.primary),
          ),
          radioTheme: RadioThemeData(
            fillColor: WidgetStateProperty.all(lightScheme.primary),
          ),
          switchTheme: SwitchThemeData(
            thumbColor:
                WidgetStateProperty.resolveWith((s) => lightScheme.primary),
            trackColor: WidgetStateProperty.resolveWith(
                (s) => lightScheme.primary.withOpacity(0.5)),
          ),
          dialogTheme: DialogThemeData(
            backgroundColor: cardLight,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
          ),
        );

        // --- Dark Theme (Material2, OLED, Akzent aus Seed) ---
        final baseDarkTheme = ThemeData(
          useMaterial3: false, // KEIN Material You
          colorScheme: darkScheme,
          primaryColor: darkScheme.primary, // Akzent in M2-Welten
          scaffoldBackgroundColor: Colors.black,
          canvasColor: Colors.black,
          cardColor: cardDark,
          // NEU / ANGEPASST:
          splashFactory: NoSplash.splashFactory,
          splashColor: Colors.transparent,
          highlightColor: Colors.transparent,
          hoverColor: Colors.transparent,

          pageTransitionsTheme: const PageTransitionsTheme(
            builders: {
              TargetPlatform.android: ZoomPageTransitionsBuilder(),
              TargetPlatform.iOS: CupertinoPageTransitionsBuilder(),
              TargetPlatform.macOS: CupertinoPageTransitionsBuilder(),
              TargetPlatform.windows: ZoomPageTransitionsBuilder(),
              TargetPlatform.linux: ZoomPageTransitionsBuilder(),
            },
          ),

          inputDecorationTheme: InputDecorationTheme(
            filled: true,
            fillColor: const Color(0xFF1C1C1C),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide.none,
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(color: darkScheme.primary, width: 2),
            ),
            contentPadding:
                const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
          ),

          bottomSheetTheme: const BottomSheetThemeData(
            backgroundColor: cardDark,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
            ),
            elevation: 0,
          ),

          snackBarTheme: SnackBarThemeData(
            backgroundColor: darkScheme.primary,
            contentTextStyle: TextStyle(
              color: darkScheme.onPrimary,
              fontWeight: FontWeight.w600,
            ),
            behavior: SnackBarBehavior.floating,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),

          dividerTheme: DividerThemeData(
            color: Colors.white.withOpacity(0.08),
            thickness: 1,
            space: 24,
          ),
          appBarTheme: AppBarTheme(
            elevation: 0,
            scrolledUnderElevation: 0,
            backgroundColor: Colors.black,
            foregroundColor: Colors.white,
            centerTitle: false,
            titleTextStyle: ThemeData.dark().textTheme.titleLarge?.copyWith(
                  fontFamily: 'Inter',
                  fontWeight: FontWeight.w900,
                  color: Colors.white,
                ),
          ),

          textTheme: ThemeData.dark().textTheme.apply(
                fontFamily: 'Inter', // Das ist weiterhin korrekt
                bodyColor: Colors.white,
                displayColor: Colors.white,
              ),
          elevatedButtonTheme: ElevatedButtonThemeData(
            style: ElevatedButton.styleFrom(
              backgroundColor: darkScheme.primary,
              foregroundColor: darkScheme.onPrimary,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12)),
            ),
          ),
          floatingActionButtonTheme: FloatingActionButtonThemeData(
            backgroundColor: darkScheme.primary,
            foregroundColor: darkScheme.onPrimary,
          ),
          //toggleableActiveColor: darkScheme.primary,
          progressIndicatorTheme:
              ProgressIndicatorThemeData(color: darkScheme.primary),
          textSelectionTheme: TextSelectionThemeData(
            cursorColor: darkScheme.primary,
            selectionColor: darkScheme.primary.withOpacity(0.35),
            selectionHandleColor: darkScheme.primary,
          ),
          checkboxTheme: CheckboxThemeData(
            fillColor: WidgetStateProperty.all(darkScheme.primary),
          ),
          radioTheme: RadioThemeData(
            fillColor: WidgetStateProperty.all(darkScheme.primary),
          ),
          switchTheme: SwitchThemeData(
            thumbColor:
                WidgetStateProperty.resolveWith((s) => darkScheme.primary),
            trackColor: WidgetStateProperty.resolveWith(
                (s) => darkScheme.primary.withOpacity(0.5)),
          ),
          dialogTheme: DialogThemeData(
            backgroundColor: cardDark,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
          ),
        );
// KORREKTUR HIER: Wir verwenden einen Consumer, um an den ThemeService zu kommen.
        return Consumer<ThemeService>(
          builder: (context, themeService, child) {
            return MaterialApp(
              debugShowCheckedModeBanner: false,
              scrollBehavior: NoGlowScrollBehavior(),
              onGenerateTitle: (context) =>
                  AppLocalizations.of(context)!.appTitle,
              localizationsDelegates: AppLocalizations.localizationsDelegates,
              supportedLocales: AppLocalizations.supportedLocales,
              title: "LightWeight",
              theme: baseLightTheme,
              darkTheme: baseDarkTheme,
              themeMode:
                  themeService.themeMode, // Jetzt funktioniert der Zugriff
              home: child, // Das home-Widget wird weitergereicht
            );
          },
          // Der FutureBuilder wird zum 'child' des Consumers, um nicht bei jeder
          // Theme-Änderung neu aufgebaut zu werden.
          child: FutureBuilder<bool>(
            future: _hasSeenOnboarding(),
            builder: (context, snapshot) {
              if (!snapshot.hasData) {
                return const Scaffold(
                  body: Center(child: CircularProgressIndicator()),
                );
              }
              final seen = snapshot.data ?? false;
              return seen ? const MainScreen() : const OnboardingScreen();
            },
          ),
        );
      },
    );
  }
}

class NoGlowScrollBehavior extends ScrollBehavior {
  @override
  Widget buildOverscrollIndicator(
      BuildContext context, Widget child, ScrollableDetails details) {
    // Keine Glow-Effekte
    return child;
  }

  @override
  ScrollPhysics getScrollPhysics(BuildContext context) {
    // iOS-Style: Bouncing
    return const BouncingScrollPhysics();
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/generated/app_localizations.dart =====

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart' as intl;

import 'app_localizations_de.dart';
import 'app_localizations_en.dart';

// ignore_for_file: type=lint

/// Callers can lookup localized strings with an instance of AppLocalizations
/// returned by `AppLocalizations.of(context)`.
///
/// Applications need to include `AppLocalizations.delegate()` in their app's
/// `localizationDelegates` list, and the locales they support in the app's
/// `supportedLocales` list. For example:
///
/// ```dart
/// import 'generated/app_localizations.dart';
///
/// return MaterialApp(
///   localizationsDelegates: AppLocalizations.localizationsDelegates,
///   supportedLocales: AppLocalizations.supportedLocales,
///   home: MyApplicationHome(),
/// );
/// ```
///
/// ## Update pubspec.yaml
///
/// Please make sure to update your pubspec.yaml to include the following
/// packages:
///
/// ```yaml
/// dependencies:
///   # Internationalization support.
///   flutter_localizations:
///     sdk: flutter
///   intl: any # Use the pinned version from flutter_localizations
///
///   # Rest of dependencies
/// ```
///
/// ## iOS Applications
///
/// iOS applications define key application metadata, including supported
/// locales, in an Info.plist file that is built into the application bundle.
/// To configure the locales supported by your app, you’ll need to edit this
/// file.
///
/// First, open your project’s ios/Runner.xcworkspace Xcode workspace file.
/// Then, in the Project Navigator, open the Info.plist file under the Runner
/// project’s Runner folder.
///
/// Next, select the Information Property List item, select Add Item from the
/// Editor menu, then select Localizations from the pop-up menu.
///
/// Select and expand the newly-created Localizations item then, for each
/// locale your application supports, add a new item and select the locale
/// you wish to add from the pop-up menu in the Value field. This list should
/// be consistent with the languages listed in the AppLocalizations.supportedLocales
/// property.
abstract class AppLocalizations {
  AppLocalizations(String locale)
      : localeName = intl.Intl.canonicalizedLocale(locale.toString());

  final String localeName;

  static AppLocalizations? of(BuildContext context) {
    return Localizations.of<AppLocalizations>(context, AppLocalizations);
  }

  static const LocalizationsDelegate<AppLocalizations> delegate =
      _AppLocalizationsDelegate();

  /// A list of this localizations delegate along with the default localizations
  /// delegates.
  ///
  /// Returns a list of localizations delegates containing this delegate along with
  /// GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate,
  /// and GlobalWidgetsLocalizations.delegate.
  ///
  /// Additional delegates can be added by appending to this list in
  /// MaterialApp. This list does not have to be used at all if a custom list
  /// of delegates is preferred or required.
  static const List<LocalizationsDelegate<dynamic>> localizationsDelegates =
      <LocalizationsDelegate<dynamic>>[
    delegate,
    GlobalMaterialLocalizations.delegate,
    GlobalCupertinoLocalizations.delegate,
    GlobalWidgetsLocalizations.delegate,
  ];

  /// A list of this localizations delegate's supported locales.
  static const List<Locale> supportedLocales = <Locale>[
    Locale('de'),
    Locale('en')
  ];

  /// No description provided for @appTitle.
  ///
  /// In en, this message translates to:
  /// **'Vita'**
  String get appTitle;

  /// No description provided for @bannerText.
  ///
  /// In en, this message translates to:
  /// **'Recommendation / Current Workout'**
  String get bannerText;

  /// No description provided for @calories.
  ///
  /// In en, this message translates to:
  /// **'Calories'**
  String get calories;

  /// No description provided for @water.
  ///
  /// In en, this message translates to:
  /// **'Water'**
  String get water;

  /// No description provided for @protein.
  ///
  /// In en, this message translates to:
  /// **'Protein'**
  String get protein;

  /// No description provided for @carbs.
  ///
  /// In en, this message translates to:
  /// **'Carbs'**
  String get carbs;

  /// No description provided for @fat.
  ///
  /// In en, this message translates to:
  /// **'Fat'**
  String get fat;

  /// No description provided for @daily.
  ///
  /// In en, this message translates to:
  /// **'Daily'**
  String get daily;

  /// No description provided for @today.
  ///
  /// In en, this message translates to:
  /// **'Today'**
  String get today;

  /// No description provided for @workoutSection.
  ///
  /// In en, this message translates to:
  /// **'Workout section - not yet implemented'**
  String get workoutSection;

  /// No description provided for @addMenuTitle.
  ///
  /// In en, this message translates to:
  /// **'What do you want to add?'**
  String get addMenuTitle;

  /// No description provided for @addFoodOption.
  ///
  /// In en, this message translates to:
  /// **'Food'**
  String get addFoodOption;

  /// No description provided for @addLiquidOption.
  ///
  /// In en, this message translates to:
  /// **'Liquid'**
  String get addLiquidOption;

  /// No description provided for @searchHintText.
  ///
  /// In en, this message translates to:
  /// **'Search...'**
  String get searchHintText;

  /// No description provided for @mealtypeBreakfast.
  ///
  /// In en, this message translates to:
  /// **'Breakfast'**
  String get mealtypeBreakfast;

  /// No description provided for @mealtypeLunch.
  ///
  /// In en, this message translates to:
  /// **'Lunch'**
  String get mealtypeLunch;

  /// No description provided for @mealtypeDinner.
  ///
  /// In en, this message translates to:
  /// **'Dinner'**
  String get mealtypeDinner;

  /// No description provided for @mealtypeSnack.
  ///
  /// In en, this message translates to:
  /// **'Snack'**
  String get mealtypeSnack;

  /// No description provided for @waterHeader.
  ///
  /// In en, this message translates to:
  /// **'Water & Drinks'**
  String get waterHeader;

  /// No description provided for @openFoodFactsSource.
  ///
  /// In en, this message translates to:
  /// **'Data from Open Food Facts'**
  String get openFoodFactsSource;

  /// No description provided for @tabRecent.
  ///
  /// In en, this message translates to:
  /// **'Recent'**
  String get tabRecent;

  /// No description provided for @tabSearch.
  ///
  /// In en, this message translates to:
  /// **'Search'**
  String get tabSearch;

  /// No description provided for @tabFavorites.
  ///
  /// In en, this message translates to:
  /// **'Favorites'**
  String get tabFavorites;

  /// No description provided for @fabCreateOwnFood.
  ///
  /// In en, this message translates to:
  /// **'Custom Food'**
  String get fabCreateOwnFood;

  /// No description provided for @recentEmptyState.
  ///
  /// In en, this message translates to:
  /// **'Your recently used food items\nwill appear here.'**
  String get recentEmptyState;

  /// No description provided for @favoritesEmptyState.
  ///
  /// In en, this message translates to:
  /// **'You don\'t have any favorites yet.\nMark a food with the heart icon to see it here.'**
  String get favoritesEmptyState;

  /// No description provided for @searchInitialHint.
  ///
  /// In en, this message translates to:
  /// **'Please enter a search term.'**
  String get searchInitialHint;

  /// No description provided for @searchNoResults.
  ///
  /// In en, this message translates to:
  /// **'No results found.'**
  String get searchNoResults;

  /// No description provided for @createFoodScreenTitle.
  ///
  /// In en, this message translates to:
  /// **'Create Custom Food'**
  String get createFoodScreenTitle;

  /// No description provided for @formFieldName.
  ///
  /// In en, this message translates to:
  /// **'Name of the food'**
  String get formFieldName;

  /// No description provided for @formFieldBrand.
  ///
  /// In en, this message translates to:
  /// **'Brand (optional)'**
  String get formFieldBrand;

  /// No description provided for @formSectionMainNutrients.
  ///
  /// In en, this message translates to:
  /// **'Main Nutrients (per 100g)'**
  String get formSectionMainNutrients;

  /// No description provided for @formFieldCalories.
  ///
  /// In en, this message translates to:
  /// **'Calories (kcal)'**
  String get formFieldCalories;

  /// No description provided for @formFieldProtein.
  ///
  /// In en, this message translates to:
  /// **'Protein (g)'**
  String get formFieldProtein;

  /// No description provided for @formFieldCarbs.
  ///
  /// In en, this message translates to:
  /// **'Carbohydrates (g)'**
  String get formFieldCarbs;

  /// No description provided for @formFieldFat.
  ///
  /// In en, this message translates to:
  /// **'Fat (g)'**
  String get formFieldFat;

  /// No description provided for @formSectionOptionalNutrients.
  ///
  /// In en, this message translates to:
  /// **'Additional Nutrients (optional, per 100g)'**
  String get formSectionOptionalNutrients;

  /// No description provided for @formFieldSugar.
  ///
  /// In en, this message translates to:
  /// **'Of which sugars (g)'**
  String get formFieldSugar;

  /// No description provided for @formFieldFiber.
  ///
  /// In en, this message translates to:
  /// **'Fiber (g)'**
  String get formFieldFiber;

  /// No description provided for @formFieldKj.
  ///
  /// In en, this message translates to:
  /// **'Kilojoules (kJ)'**
  String get formFieldKj;

  /// No description provided for @formFieldSalt.
  ///
  /// In en, this message translates to:
  /// **'Salt (g)'**
  String get formFieldSalt;

  /// No description provided for @formFieldSodium.
  ///
  /// In en, this message translates to:
  /// **'Sodium (mg)'**
  String get formFieldSodium;

  /// No description provided for @formFieldCalcium.
  ///
  /// In en, this message translates to:
  /// **'Calcium (mg)'**
  String get formFieldCalcium;

  /// No description provided for @buttonSave.
  ///
  /// In en, this message translates to:
  /// **'Save'**
  String get buttonSave;

  /// No description provided for @validatorPleaseEnterName.
  ///
  /// In en, this message translates to:
  /// **'Please enter a name.'**
  String get validatorPleaseEnterName;

  /// No description provided for @validatorPleaseEnterNumber.
  ///
  /// In en, this message translates to:
  /// **'Please enter a valid number.'**
  String get validatorPleaseEnterNumber;

  /// No description provided for @snackbarSaveSuccess.
  ///
  /// In en, this message translates to:
  /// **'{foodName} was saved successfully.'**
  String snackbarSaveSuccess(String foodName);

  /// No description provided for @foodDetailSegmentPortion.
  ///
  /// In en, this message translates to:
  /// **'Portion'**
  String get foodDetailSegmentPortion;

  /// No description provided for @foodDetailSegment100g.
  ///
  /// In en, this message translates to:
  /// **'100g'**
  String get foodDetailSegment100g;

  /// No description provided for @sugar.
  ///
  /// In en, this message translates to:
  /// **'Sugar'**
  String get sugar;

  /// No description provided for @fiber.
  ///
  /// In en, this message translates to:
  /// **'Fiber'**
  String get fiber;

  /// No description provided for @salt.
  ///
  /// In en, this message translates to:
  /// **'Salt'**
  String get salt;

  /// No description provided for @explorerScreenTitle.
  ///
  /// In en, this message translates to:
  /// **'Food Explorer'**
  String get explorerScreenTitle;

  /// No description provided for @nutritionScreenTitle.
  ///
  /// In en, this message translates to:
  /// **'Nutrition Analysis'**
  String get nutritionScreenTitle;

  /// No description provided for @entriesForDateRangeLabel.
  ///
  /// In en, this message translates to:
  /// **'Entries for'**
  String get entriesForDateRangeLabel;

  /// No description provided for @noEntriesForPeriod.
  ///
  /// In en, this message translates to:
  /// **'No entries for this period yet.'**
  String get noEntriesForPeriod;

  /// No description provided for @waterEntryTitle.
  ///
  /// In en, this message translates to:
  /// **'Water'**
  String get waterEntryTitle;

  /// No description provided for @profileScreenTitle.
  ///
  /// In en, this message translates to:
  /// **'Profile'**
  String get profileScreenTitle;

  /// No description provided for @profileDailyGoals.
  ///
  /// In en, this message translates to:
  /// **'Daily Goals'**
  String get profileDailyGoals;

  /// No description provided for @snackbarGoalsSaved.
  ///
  /// In en, this message translates to:
  /// **'Goals saved successfully!'**
  String get snackbarGoalsSaved;

  /// No description provided for @measurementsScreenTitle.
  ///
  /// In en, this message translates to:
  /// **'Measurements'**
  String get measurementsScreenTitle;

  /// No description provided for @measurementsEmptyState.
  ///
  /// In en, this message translates to:
  /// **'No measurements recorded yet.\nStart with the \'+\' button.'**
  String get measurementsEmptyState;

  /// No description provided for @addMeasurementDialogTitle.
  ///
  /// In en, this message translates to:
  /// **'Add New Measurement'**
  String get addMeasurementDialogTitle;

  /// No description provided for @formFieldMeasurementType.
  ///
  /// In en, this message translates to:
  /// **'Type of Measurement'**
  String get formFieldMeasurementType;

  /// No description provided for @formFieldMeasurementValue.
  ///
  /// In en, this message translates to:
  /// **'Value ({unit})'**
  String formFieldMeasurementValue(Object unit);

  /// No description provided for @validatorPleaseEnterValue.
  ///
  /// In en, this message translates to:
  /// **'Please enter a value'**
  String get validatorPleaseEnterValue;

  /// No description provided for @measurementWeight.
  ///
  /// In en, this message translates to:
  /// **'Body Weight'**
  String get measurementWeight;

  /// No description provided for @measurementFatPercent.
  ///
  /// In en, this message translates to:
  /// **'Body Fat'**
  String get measurementFatPercent;

  /// No description provided for @measurementNeck.
  ///
  /// In en, this message translates to:
  /// **'Neck'**
  String get measurementNeck;

  /// No description provided for @measurementShoulder.
  ///
  /// In en, this message translates to:
  /// **'Shoulder'**
  String get measurementShoulder;

  /// No description provided for @measurementChest.
  ///
  /// In en, this message translates to:
  /// **'Chest'**
  String get measurementChest;

  /// No description provided for @measurementLeftBicep.
  ///
  /// In en, this message translates to:
  /// **'Left Bicep'**
  String get measurementLeftBicep;

  /// No description provided for @measurementRightBicep.
  ///
  /// In en, this message translates to:
  /// **'Right Bicep'**
  String get measurementRightBicep;

  /// No description provided for @measurementLeftForearm.
  ///
  /// In en, this message translates to:
  /// **'Left Forearm'**
  String get measurementLeftForearm;

  /// No description provided for @measurementRightForearm.
  ///
  /// In en, this message translates to:
  /// **'Right Forearm'**
  String get measurementRightForearm;

  /// No description provided for @measurementAbdomen.
  ///
  /// In en, this message translates to:
  /// **'Abdomen'**
  String get measurementAbdomen;

  /// No description provided for @measurementWaist.
  ///
  /// In en, this message translates to:
  /// **'Waist'**
  String get measurementWaist;

  /// No description provided for @measurementHips.
  ///
  /// In en, this message translates to:
  /// **'Hips'**
  String get measurementHips;

  /// No description provided for @measurementLeftThigh.
  ///
  /// In en, this message translates to:
  /// **'Left Thigh'**
  String get measurementLeftThigh;

  /// No description provided for @measurementRightThigh.
  ///
  /// In en, this message translates to:
  /// **'Right Thigh'**
  String get measurementRightThigh;

  /// No description provided for @measurementLeftCalf.
  ///
  /// In en, this message translates to:
  /// **'Left Calf'**
  String get measurementLeftCalf;

  /// No description provided for @measurementRightCalf.
  ///
  /// In en, this message translates to:
  /// **'Right Calf'**
  String get measurementRightCalf;

  /// No description provided for @drawerMenuTitle.
  ///
  /// In en, this message translates to:
  /// **'Vita Menu'**
  String get drawerMenuTitle;

  /// No description provided for @drawerDashboard.
  ///
  /// In en, this message translates to:
  /// **'Dashboard'**
  String get drawerDashboard;

  /// No description provided for @drawerFoodExplorer.
  ///
  /// In en, this message translates to:
  /// **'Food Explorer'**
  String get drawerFoodExplorer;

  /// No description provided for @drawerDataManagement.
  ///
  /// In en, this message translates to:
  /// **'Data Backup'**
  String get drawerDataManagement;

  /// No description provided for @drawerMeasurements.
  ///
  /// In en, this message translates to:
  /// **'Measurements'**
  String get drawerMeasurements;

  /// No description provided for @dataManagementTitle.
  ///
  /// In en, this message translates to:
  /// **'Data Backup'**
  String get dataManagementTitle;

  /// No description provided for @exportCardTitle.
  ///
  /// In en, this message translates to:
  /// **'Export Data'**
  String get exportCardTitle;

  /// No description provided for @exportCardDescription.
  ///
  /// In en, this message translates to:
  /// **'Saves all your journal entries, favorites, and custom foods into a single backup file.'**
  String get exportCardDescription;

  /// No description provided for @exportCardButton.
  ///
  /// In en, this message translates to:
  /// **'Create Backup'**
  String get exportCardButton;

  /// No description provided for @importCardTitle.
  ///
  /// In en, this message translates to:
  /// **'Import Data'**
  String get importCardTitle;

  /// No description provided for @importCardDescription.
  ///
  /// In en, this message translates to:
  /// **'Restores your data from a previously created backup file. WARNING: All data currently stored in the app will be overwritten!'**
  String get importCardDescription;

  /// No description provided for @importCardButton.
  ///
  /// In en, this message translates to:
  /// **'Restore Backup'**
  String get importCardButton;

  /// No description provided for @recommendationDefault.
  ///
  /// In en, this message translates to:
  /// **'Track your first meal!'**
  String get recommendationDefault;

  /// No description provided for @recommendationOverTarget.
  ///
  /// In en, this message translates to:
  /// **'Last {count} days: +{difference} kcal over target'**
  String recommendationOverTarget(Object count, Object difference);

  /// No description provided for @recommendationUnderTarget.
  ///
  /// In en, this message translates to:
  /// **'Last {count} days: {difference} kcal under target'**
  String recommendationUnderTarget(Object count, Object difference);

  /// No description provided for @recommendationOnTarget.
  ///
  /// In en, this message translates to:
  /// **'Last {count} days: Target achieved ✅'**
  String recommendationOnTarget(Object count);

  /// No description provided for @recommendationFirstEntry.
  ///
  /// In en, this message translates to:
  /// **'Great, your first entry is logged!'**
  String get recommendationFirstEntry;

  /// No description provided for @dialogConfirmTitle.
  ///
  /// In en, this message translates to:
  /// **'Confirmation Required'**
  String get dialogConfirmTitle;

  /// No description provided for @dialogConfirmImportContent.
  ///
  /// In en, this message translates to:
  /// **'Do you really want to restore data from this backup?\n\nWARNING: All your current entries, favorites, and custom foods will be permanently deleted and replaced.'**
  String get dialogConfirmImportContent;

  /// No description provided for @dialogButtonCancel.
  ///
  /// In en, this message translates to:
  /// **'Cancel'**
  String get dialogButtonCancel;

  /// No description provided for @dialogButtonOverwrite.
  ///
  /// In en, this message translates to:
  /// **'Yes, overwrite all'**
  String get dialogButtonOverwrite;

  /// No description provided for @snackbarNoFileSelected.
  ///
  /// In en, this message translates to:
  /// **'No file selected.'**
  String get snackbarNoFileSelected;

  /// No description provided for @snackbarImportSuccessTitle.
  ///
  /// In en, this message translates to:
  /// **'Import successful!'**
  String get snackbarImportSuccessTitle;

  /// No description provided for @snackbarImportSuccessContent.
  ///
  /// In en, this message translates to:
  /// **'Your data has been restored. It is recommended to restart the app for a correct display.'**
  String get snackbarImportSuccessContent;

  /// No description provided for @snackbarButtonOK.
  ///
  /// In en, this message translates to:
  /// **'OK'**
  String get snackbarButtonOK;

  /// No description provided for @snackbarImportError.
  ///
  /// In en, this message translates to:
  /// **'Error while importing data.'**
  String get snackbarImportError;

  /// No description provided for @snackbarExportSuccess.
  ///
  /// In en, this message translates to:
  /// **'Backup file has been passed to the system. Please choose a location to save.'**
  String get snackbarExportSuccess;

  /// No description provided for @snackbarExportFailed.
  ///
  /// In en, this message translates to:
  /// **'Export canceled or failed.'**
  String get snackbarExportFailed;

  /// No description provided for @profileUserHeight.
  ///
  /// In en, this message translates to:
  /// **'Height (cm)'**
  String get profileUserHeight;

  /// No description provided for @workoutRoutinesTitle.
  ///
  /// In en, this message translates to:
  /// **'Routines'**
  String get workoutRoutinesTitle;

  /// No description provided for @workoutHistoryTitle.
  ///
  /// In en, this message translates to:
  /// **'Workout History'**
  String get workoutHistoryTitle;

  /// No description provided for @workoutHistoryButton.
  ///
  /// In en, this message translates to:
  /// **'History'**
  String get workoutHistoryButton;

  /// No description provided for @emptyRoutinesTitle.
  ///
  /// In en, this message translates to:
  /// **'No Routines Found'**
  String get emptyRoutinesTitle;

  /// No description provided for @emptyRoutinesSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Create your first routine or start a blank workout.'**
  String get emptyRoutinesSubtitle;

  /// No description provided for @createFirstRoutineButton.
  ///
  /// In en, this message translates to:
  /// **'Create First Routine'**
  String get createFirstRoutineButton;

  /// No description provided for @startEmptyWorkoutButton.
  ///
  /// In en, this message translates to:
  /// **'Free Workout'**
  String get startEmptyWorkoutButton;

  /// No description provided for @editRoutineSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Tap to edit, or start the workout.'**
  String get editRoutineSubtitle;

  /// No description provided for @startButton.
  ///
  /// In en, this message translates to:
  /// **'Start'**
  String get startButton;

  /// No description provided for @addRoutineButton.
  ///
  /// In en, this message translates to:
  /// **'New Routine'**
  String get addRoutineButton;

  /// No description provided for @freeWorkoutTitle.
  ///
  /// In en, this message translates to:
  /// **'Free Workout'**
  String get freeWorkoutTitle;

  /// No description provided for @finishWorkoutButton.
  ///
  /// In en, this message translates to:
  /// **'Finish'**
  String get finishWorkoutButton;

  /// No description provided for @addSetButton.
  ///
  /// In en, this message translates to:
  /// **'Add Set'**
  String get addSetButton;

  /// No description provided for @addExerciseToWorkoutButton.
  ///
  /// In en, this message translates to:
  /// **'Add Exercise to Workout'**
  String get addExerciseToWorkoutButton;

  /// No description provided for @lastTimeLabel.
  ///
  /// In en, this message translates to:
  /// **'Last Time'**
  String get lastTimeLabel;

  /// No description provided for @setLabel.
  ///
  /// In en, this message translates to:
  /// **'Set'**
  String get setLabel;

  /// No description provided for @kgLabel.
  ///
  /// In en, this message translates to:
  /// **'Weight (kg)'**
  String get kgLabel;

  /// No description provided for @repsLabel.
  ///
  /// In en, this message translates to:
  /// **'Reps'**
  String get repsLabel;

  /// No description provided for @restTimerLabel.
  ///
  /// In en, this message translates to:
  /// **'Rest'**
  String get restTimerLabel;

  /// No description provided for @skipButton.
  ///
  /// In en, this message translates to:
  /// **'Skip'**
  String get skipButton;

  /// No description provided for @emptyHistory.
  ///
  /// In en, this message translates to:
  /// **'No completed workouts yet.'**
  String get emptyHistory;

  /// No description provided for @workoutDetailsTitle.
  ///
  /// In en, this message translates to:
  /// **'Workout Details'**
  String get workoutDetailsTitle;

  /// No description provided for @workoutNotFound.
  ///
  /// In en, this message translates to:
  /// **'Workout not found.'**
  String get workoutNotFound;

  /// No description provided for @totalVolumeLabel.
  ///
  /// In en, this message translates to:
  /// **'Total Volume'**
  String get totalVolumeLabel;

  /// No description provided for @notesLabel.
  ///
  /// In en, this message translates to:
  /// **'Notes'**
  String get notesLabel;

  /// No description provided for @hevyImportTitle.
  ///
  /// In en, this message translates to:
  /// **'Hevy Import'**
  String get hevyImportTitle;

  /// No description provided for @hevyImportDescription.
  ///
  /// In en, this message translates to:
  /// **'Import your entire training history from a Hevy CSV export file.'**
  String get hevyImportDescription;

  /// No description provided for @hevyImportButton.
  ///
  /// In en, this message translates to:
  /// **'Import Hevy Data'**
  String get hevyImportButton;

  /// No description provided for @hevyImportSuccess.
  ///
  /// In en, this message translates to:
  /// **'Successfully imported {count} workouts!'**
  String hevyImportSuccess(Object count);

  /// No description provided for @hevyImportFailed.
  ///
  /// In en, this message translates to:
  /// **'Import failed. Please check the file.'**
  String get hevyImportFailed;

  /// No description provided for @startWorkout.
  ///
  /// In en, this message translates to:
  /// **'Start Workout'**
  String get startWorkout;

  /// No description provided for @addMeasurement.
  ///
  /// In en, this message translates to:
  /// **'Add Measurement'**
  String get addMeasurement;

  /// No description provided for @filterToday.
  ///
  /// In en, this message translates to:
  /// **'Today'**
  String get filterToday;

  /// No description provided for @filter7Days.
  ///
  /// In en, this message translates to:
  /// **'7 Days'**
  String get filter7Days;

  /// No description provided for @filter30Days.
  ///
  /// In en, this message translates to:
  /// **'30 Days'**
  String get filter30Days;

  /// No description provided for @filterAll.
  ///
  /// In en, this message translates to:
  /// **'All'**
  String get filterAll;

  /// No description provided for @showLess.
  ///
  /// In en, this message translates to:
  /// **'Show less'**
  String get showLess;

  /// No description provided for @showMoreDetails.
  ///
  /// In en, this message translates to:
  /// **'Show more details'**
  String get showMoreDetails;

  /// No description provided for @deleteConfirmTitle.
  ///
  /// In en, this message translates to:
  /// **'Confirm Deletion'**
  String get deleteConfirmTitle;

  /// No description provided for @deleteConfirmContent.
  ///
  /// In en, this message translates to:
  /// **'Do you really want to delete this entry?'**
  String get deleteConfirmContent;

  /// No description provided for @cancel.
  ///
  /// In en, this message translates to:
  /// **'Cancel'**
  String get cancel;

  /// No description provided for @delete.
  ///
  /// In en, this message translates to:
  /// **'Delete'**
  String get delete;

  /// No description provided for @save.
  ///
  /// In en, this message translates to:
  /// **'Save'**
  String get save;

  /// No description provided for @tabBaseFoods.
  ///
  /// In en, this message translates to:
  /// **'Base Foods'**
  String get tabBaseFoods;

  /// No description provided for @baseFoodsEmptyState.
  ///
  /// In en, this message translates to:
  /// **'This section will soon be filled with a curated list of base foods like fruits, vegetables, and more.'**
  String get baseFoodsEmptyState;

  /// No description provided for @noBrand.
  ///
  /// In en, this message translates to:
  /// **'No Brand'**
  String get noBrand;

  /// No description provided for @unknown.
  ///
  /// In en, this message translates to:
  /// **'Unknown'**
  String get unknown;

  /// No description provided for @backupFileSubject.
  ///
  /// In en, this message translates to:
  /// **'Vita App Backup - {timestamp}'**
  String backupFileSubject(String timestamp);

  /// No description provided for @foodItemSubtitle.
  ///
  /// In en, this message translates to:
  /// **'{brand} - {calories} kcal / 100g'**
  String foodItemSubtitle(String brand, int calories);

  /// No description provided for @foodListSubtitle.
  ///
  /// In en, this message translates to:
  /// **'{grams}g - {time}'**
  String foodListSubtitle(int grams, String time);

  /// No description provided for @foodListTrailingKcal.
  ///
  /// In en, this message translates to:
  /// **'{calories} kcal'**
  String foodListTrailingKcal(int calories);

  /// No description provided for @waterListTrailingMl.
  ///
  /// In en, this message translates to:
  /// **'{milliliters} ml'**
  String waterListTrailingMl(int milliliters);

  /// No description provided for @exerciseCatalogTitle.
  ///
  /// In en, this message translates to:
  /// **'Exercise Catalog'**
  String get exerciseCatalogTitle;

  /// No description provided for @filterByMuscle.
  ///
  /// In en, this message translates to:
  /// **'Filter by muscle group'**
  String get filterByMuscle;

  /// No description provided for @noExercisesFound.
  ///
  /// In en, this message translates to:
  /// **'No exercises found.'**
  String get noExercisesFound;

  /// No description provided for @noDescriptionAvailable.
  ///
  /// In en, this message translates to:
  /// **'No description available.'**
  String get noDescriptionAvailable;

  /// No description provided for @filterByCategory.
  ///
  /// In en, this message translates to:
  /// **'Filter by category'**
  String get filterByCategory;

  /// No description provided for @edit.
  ///
  /// In en, this message translates to:
  /// **'Edit'**
  String get edit;

  /// No description provided for @repsLabelShort.
  ///
  /// In en, this message translates to:
  /// **'reps'**
  String get repsLabelShort;

  /// No description provided for @titleNewRoutine.
  ///
  /// In en, this message translates to:
  /// **'New Routine'**
  String get titleNewRoutine;

  /// No description provided for @titleEditRoutine.
  ///
  /// In en, this message translates to:
  /// **'Edit Routine'**
  String get titleEditRoutine;

  /// No description provided for @validatorPleaseEnterRoutineName.
  ///
  /// In en, this message translates to:
  /// **'Please enter a name for the routine.'**
  String get validatorPleaseEnterRoutineName;

  /// No description provided for @snackbarRoutineCreated.
  ///
  /// In en, this message translates to:
  /// **'Routine created. Now add some exercises.'**
  String get snackbarRoutineCreated;

  /// No description provided for @snackbarRoutineSaved.
  ///
  /// In en, this message translates to:
  /// **'Routine saved.'**
  String get snackbarRoutineSaved;

  /// No description provided for @formFieldRoutineName.
  ///
  /// In en, this message translates to:
  /// **'Name of the routine'**
  String get formFieldRoutineName;

  /// No description provided for @emptyStateAddFirstExercise.
  ///
  /// In en, this message translates to:
  /// **'Add your first exercise.'**
  String get emptyStateAddFirstExercise;

  /// No description provided for @setCount.
  ///
  /// In en, this message translates to:
  /// **'{count,plural, =1{1 set}other{{count} sets}}'**
  String setCount(int count);

  /// No description provided for @fabAddExercise.
  ///
  /// In en, this message translates to:
  /// **'Add Exercise'**
  String get fabAddExercise;

  /// No description provided for @kgLabelShort.
  ///
  /// In en, this message translates to:
  /// **'kg'**
  String get kgLabelShort;

  /// No description provided for @drawerExerciseCatalog.
  ///
  /// In en, this message translates to:
  /// **'Exercise Catalog'**
  String get drawerExerciseCatalog;

  /// No description provided for @lastWorkoutTitle.
  ///
  /// In en, this message translates to:
  /// **'Last Workout'**
  String get lastWorkoutTitle;

  /// No description provided for @repeatButton.
  ///
  /// In en, this message translates to:
  /// **'Repeat'**
  String get repeatButton;

  /// No description provided for @weightHistoryTitle.
  ///
  /// In en, this message translates to:
  /// **'Weight History'**
  String get weightHistoryTitle;

  /// No description provided for @hideSummary.
  ///
  /// In en, this message translates to:
  /// **'Hide Summary'**
  String get hideSummary;

  /// No description provided for @showSummary.
  ///
  /// In en, this message translates to:
  /// **'Show Summary'**
  String get showSummary;

  /// No description provided for @exerciseDataAttribution.
  ///
  /// In en, this message translates to:
  /// **'Exercise data from'**
  String get exerciseDataAttribution;

  /// No description provided for @duplicate.
  ///
  /// In en, this message translates to:
  /// **'Duplicate'**
  String get duplicate;

  /// No description provided for @deleteRoutineConfirmContent.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to permanently delete the routine \'{routineName}\'?'**
  String deleteRoutineConfirmContent(String routineName);

  /// No description provided for @editPauseTimeTitle.
  ///
  /// In en, this message translates to:
  /// **'Edit Pause Duration'**
  String get editPauseTimeTitle;

  /// No description provided for @pauseInSeconds.
  ///
  /// In en, this message translates to:
  /// **'Pause in seconds'**
  String get pauseInSeconds;

  /// No description provided for @editPauseTime.
  ///
  /// In en, this message translates to:
  /// **'Edit Pause'**
  String get editPauseTime;

  /// No description provided for @pauseDuration.
  ///
  /// In en, this message translates to:
  /// **'{seconds} second pause'**
  String pauseDuration(int seconds);

  /// No description provided for @maxPauseDuration.
  ///
  /// In en, this message translates to:
  /// **'Pauses up to {seconds}s'**
  String maxPauseDuration(int seconds);

  /// No description provided for @deleteWorkoutConfirmContent.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to permanently delete this workout log?'**
  String get deleteWorkoutConfirmContent;

  /// No description provided for @removeExercise.
  ///
  /// In en, this message translates to:
  /// **'Remove Exercise'**
  String get removeExercise;

  /// No description provided for @deleteExerciseConfirmTitle.
  ///
  /// In en, this message translates to:
  /// **'Remove Exercise?'**
  String get deleteExerciseConfirmTitle;

  /// No description provided for @deleteExerciseConfirmContent.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to remove \'{exerciseName}\' from this routine?'**
  String deleteExerciseConfirmContent(String exerciseName);

  /// No description provided for @doneButtonLabel.
  ///
  /// In en, this message translates to:
  /// **'Done'**
  String get doneButtonLabel;

  /// No description provided for @setRestTimeButton.
  ///
  /// In en, this message translates to:
  /// **'Set rest time'**
  String get setRestTimeButton;

  /// No description provided for @deleteExerciseButton.
  ///
  /// In en, this message translates to:
  /// **'Delete exercise'**
  String get deleteExerciseButton;

  /// No description provided for @restOverLabel.
  ///
  /// In en, this message translates to:
  /// **'Pause is over'**
  String get restOverLabel;

  /// No description provided for @workoutRunningLabel.
  ///
  /// In en, this message translates to:
  /// **'Workout is active …'**
  String get workoutRunningLabel;

  /// No description provided for @continueButton.
  ///
  /// In en, this message translates to:
  /// **'Continue'**
  String get continueButton;

  /// No description provided for @discardButton.
  ///
  /// In en, this message translates to:
  /// **'Discard'**
  String get discardButton;

  /// No description provided for @workoutStatsTitle.
  ///
  /// In en, this message translates to:
  /// **'Training (7 days)'**
  String get workoutStatsTitle;

  /// No description provided for @workoutsLabel.
  ///
  /// In en, this message translates to:
  /// **'Workouts'**
  String get workoutsLabel;

  /// Label for workout duration summary
  ///
  /// In en, this message translates to:
  /// **'Duration'**
  String get durationLabel;

  /// No description provided for @volumeLabel.
  ///
  /// In en, this message translates to:
  /// **'Volume'**
  String get volumeLabel;

  /// Label for number of sets summary
  ///
  /// In en, this message translates to:
  /// **'Sets'**
  String get setsLabel;

  /// Label for muscle split bar chart
  ///
  /// In en, this message translates to:
  /// **'Muscle Split'**
  String get muscleSplitLabel;

  /// No description provided for @snackbar_could_not_open_open_link.
  ///
  /// In en, this message translates to:
  /// **'Konnte Link nicht öffnen'**
  String get snackbar_could_not_open_open_link;

  /// No description provided for @chart_no_data_for_period.
  ///
  /// In en, this message translates to:
  /// **'Keine Daten für diesen Zeitraum.'**
  String get chart_no_data_for_period;

  /// No description provided for @amount_in_milliliters.
  ///
  /// In en, this message translates to:
  /// **'Menge in Millilitern'**
  String get amount_in_milliliters;

  /// No description provided for @amount_in_grams.
  ///
  /// In en, this message translates to:
  /// **'Menge in Gramm'**
  String get amount_in_grams;

  /// No description provided for @meal_label.
  ///
  /// In en, this message translates to:
  /// **'Mahlzeit'**
  String get meal_label;

  /// No description provided for @add_to_water_intake.
  ///
  /// In en, this message translates to:
  /// **'Zur Trinkmenge hinzufügen'**
  String get add_to_water_intake;

  /// No description provided for @create_exercise_screen_title.
  ///
  /// In en, this message translates to:
  /// **'Eigene Übung erstellen'**
  String get create_exercise_screen_title;

  /// No description provided for @exercise_name_label.
  ///
  /// In en, this message translates to:
  /// **'Name der Übung'**
  String get exercise_name_label;

  /// No description provided for @category_label.
  ///
  /// In en, this message translates to:
  /// **'Kategorie'**
  String get category_label;

  /// No description provided for @description_optional_label.
  ///
  /// In en, this message translates to:
  /// **'Beschreibung (optional)'**
  String get description_optional_label;

  /// No description provided for @primary_muscles_label.
  ///
  /// In en, this message translates to:
  /// **'Primäre Muskeln'**
  String get primary_muscles_label;

  /// No description provided for @primary_muscles_hint.
  ///
  /// In en, this message translates to:
  /// **'z.B. Brust, Trizeps'**
  String get primary_muscles_hint;

  /// No description provided for @secondary_muscles_label.
  ///
  /// In en, this message translates to:
  /// **'Sekundäre Muskeln (optional)'**
  String get secondary_muscles_label;

  /// No description provided for @secondary_muscles_hint.
  ///
  /// In en, this message translates to:
  /// **'z.B. Schultern'**
  String get secondary_muscles_hint;

  /// No description provided for @set_type_normal.
  ///
  /// In en, this message translates to:
  /// **'Normal'**
  String get set_type_normal;

  /// No description provided for @set_type_warmup.
  ///
  /// In en, this message translates to:
  /// **'Warmup'**
  String get set_type_warmup;

  /// No description provided for @set_type_failure.
  ///
  /// In en, this message translates to:
  /// **'Failure'**
  String get set_type_failure;

  /// No description provided for @set_type_dropset.
  ///
  /// In en, this message translates to:
  /// **'Dropset'**
  String get set_type_dropset;

  /// No description provided for @set_reps_hint.
  ///
  /// In en, this message translates to:
  /// **'8-12'**
  String get set_reps_hint;

  /// No description provided for @data_export_button.
  ///
  /// In en, this message translates to:
  /// **'Export'**
  String get data_export_button;

  /// No description provided for @data_import_button.
  ///
  /// In en, this message translates to:
  /// **'Import'**
  String get data_import_button;

  /// No description provided for @snackbar_button_ok.
  ///
  /// In en, this message translates to:
  /// **'OK'**
  String get snackbar_button_ok;

  /// No description provided for @measurement_session_detail_view.
  ///
  /// In en, this message translates to:
  /// **'Detailview of measurement session'**
  String get measurement_session_detail_view;

  /// No description provided for @unit_grams.
  ///
  /// In en, this message translates to:
  /// **'g'**
  String get unit_grams;

  /// No description provided for @unit_kcal.
  ///
  /// In en, this message translates to:
  /// **'kcal'**
  String get unit_kcal;

  /// No description provided for @delete_profile_picture_button.
  ///
  /// In en, this message translates to:
  /// **'Delete profile picture'**
  String get delete_profile_picture_button;

  /// No description provided for @attribution_title.
  ///
  /// In en, this message translates to:
  /// **'Attribution'**
  String get attribution_title;

  /// No description provided for @add_liquid_title.
  ///
  /// In en, this message translates to:
  /// **'Add fluid'**
  String get add_liquid_title;

  /// No description provided for @add_button.
  ///
  /// In en, this message translates to:
  /// **'Add'**
  String get add_button;

  /// No description provided for @discard_button.
  ///
  /// In en, this message translates to:
  /// **'Discard'**
  String get discard_button;

  /// No description provided for @continue_workout_button.
  ///
  /// In en, this message translates to:
  /// **'Continue'**
  String get continue_workout_button;

  /// No description provided for @soon_available_snackbar.
  ///
  /// In en, this message translates to:
  /// **'This screen will be available soon'**
  String get soon_available_snackbar;

  /// No description provided for @start_button.
  ///
  /// In en, this message translates to:
  /// **'Start'**
  String get start_button;

  /// No description provided for @today_overview_text.
  ///
  /// In en, this message translates to:
  /// **'TODAY IN FOCUS'**
  String get today_overview_text;

  /// No description provided for @quick_add_text.
  ///
  /// In en, this message translates to:
  /// **'QUICK ADD'**
  String get quick_add_text;

  /// No description provided for @scann_barcode_capslock.
  ///
  /// In en, this message translates to:
  /// **'Scan barcode'**
  String get scann_barcode_capslock;

  /// No description provided for @protocol_today_capslock.
  ///
  /// In en, this message translates to:
  /// **'TODAY\'S PROTOCOL'**
  String get protocol_today_capslock;

  /// No description provided for @my_plans_capslock.
  ///
  /// In en, this message translates to:
  /// **'MY PLANS'**
  String get my_plans_capslock;

  /// No description provided for @overview_capslock.
  ///
  /// In en, this message translates to:
  /// **'OVERVIEW'**
  String get overview_capslock;

  /// No description provided for @manage_all_plans.
  ///
  /// In en, this message translates to:
  /// **'Manage all plans'**
  String get manage_all_plans;

  /// No description provided for @free_training.
  ///
  /// In en, this message translates to:
  /// **'free training'**
  String get free_training;

  /// No description provided for @my_consistency.
  ///
  /// In en, this message translates to:
  /// **'MY CONSISTENCY'**
  String get my_consistency;

  /// No description provided for @calendar_currently_not_available.
  ///
  /// In en, this message translates to:
  /// **'The calendar view will be available soon.'**
  String get calendar_currently_not_available;

  /// No description provided for @in_depth_analysis.
  ///
  /// In en, this message translates to:
  /// **'IN-DEPTH ANALYSIS'**
  String get in_depth_analysis;

  /// No description provided for @body_measurements.
  ///
  /// In en, this message translates to:
  /// **'Body measurements'**
  String get body_measurements;

  /// No description provided for @measurements_description.
  ///
  /// In en, this message translates to:
  /// **'Analyze weight, body fat percentage and circumference.'**
  String get measurements_description;

  /// No description provided for @nutrition_description.
  ///
  /// In en, this message translates to:
  /// **'Evaluate macros, calories and trends.'**
  String get nutrition_description;

  /// No description provided for @training_analysis.
  ///
  /// In en, this message translates to:
  /// **'Training analysis'**
  String get training_analysis;

  /// No description provided for @training_analysis_description.
  ///
  /// In en, this message translates to:
  /// **'Track volume, strength and progression.'**
  String get training_analysis_description;

  /// No description provided for @load_dots.
  ///
  /// In en, this message translates to:
  /// **'loading...'**
  String get load_dots;

  /// No description provided for @profile_capslock.
  ///
  /// In en, this message translates to:
  /// **'PROFILE'**
  String get profile_capslock;

  /// No description provided for @settings_capslock.
  ///
  /// In en, this message translates to:
  /// **'SETTINGS'**
  String get settings_capslock;

  /// No description provided for @settingsTitle.
  ///
  /// In en, this message translates to:
  /// **'Settings'**
  String get settingsTitle;

  /// No description provided for @my_goals.
  ///
  /// In en, this message translates to:
  /// **'My goals'**
  String get my_goals;

  /// No description provided for @my_goals_description.
  ///
  /// In en, this message translates to:
  /// **'Adjust calories, macros and water.'**
  String get my_goals_description;

  /// No description provided for @backup_and_import.
  ///
  /// In en, this message translates to:
  /// **'Data backup & import'**
  String get backup_and_import;

  /// No description provided for @backup_and_import_description.
  ///
  /// In en, this message translates to:
  /// **'Create backups, restore, and import data.'**
  String get backup_and_import_description;

  /// No description provided for @about_and_legal_capslock.
  ///
  /// In en, this message translates to:
  /// **'ABOUT & LEGAL'**
  String get about_and_legal_capslock;

  /// No description provided for @attribution_and_license.
  ///
  /// In en, this message translates to:
  /// **'Attribution & Licenses'**
  String get attribution_and_license;

  /// No description provided for @data_from_off_and_wger.
  ///
  /// In en, this message translates to:
  /// **'Data from Open Food Facts and wger.'**
  String get data_from_off_and_wger;

  /// No description provided for @app_version.
  ///
  /// In en, this message translates to:
  /// **'App version'**
  String get app_version;

  /// No description provided for @all_measurements.
  ///
  /// In en, this message translates to:
  /// **'ALL MEASUREMENTS'**
  String get all_measurements;

  /// No description provided for @date_and_time_of_measurement.
  ///
  /// In en, this message translates to:
  /// **'Date & time of measurement'**
  String get date_and_time_of_measurement;

  /// Onboarding slide 1 title
  ///
  /// In en, this message translates to:
  /// **'Welcome to Lightweight'**
  String get onbWelcomeTitle;

  /// Onboarding slide 1 description
  ///
  /// In en, this message translates to:
  /// **'Let’s start by setting personal goals to guide training and nutrition.'**
  String get onbWelcomeBody;

  /// Onboarding slide 2 title
  ///
  /// In en, this message translates to:
  /// **'Track everything'**
  String get onbTrackTitle;

  /// Onboarding slide 2 description
  ///
  /// In en, this message translates to:
  /// **'Log nutrition, workouts, and measurements — all in one place.'**
  String get onbTrackBody;

  /// Onboarding slide 3 title
  ///
  /// In en, this message translates to:
  /// **'Offline-first & privacy'**
  String get onbPrivacyTitle;

  /// Onboarding slide 3 description
  ///
  /// In en, this message translates to:
  /// **'Your data stays on the device. No cloud accounts, no background sync.'**
  String get onbPrivacyBody;

  /// Onboarding final slide title
  ///
  /// In en, this message translates to:
  /// **'All set'**
  String get onbFinishTitle;

  /// Onboarding final slide description
  ///
  /// In en, this message translates to:
  /// **'You’re ready to explore the app. You can adjust settings anytime.'**
  String get onbFinishBody;

  /// Final button label to finish onboarding
  ///
  /// In en, this message translates to:
  /// **'Let’s go!'**
  String get onbFinishCta;

  /// Settings item to reopen onboarding
  ///
  /// In en, this message translates to:
  /// **'Show tutorial again'**
  String get onbShowTutorialAgain;

  /// Optional CTA linking to Goals screen from onboarding
  ///
  /// In en, this message translates to:
  /// **'Set goals'**
  String get onbSetGoalsCta;

  /// Onboarding header title
  ///
  /// In en, this message translates to:
  /// **'Tutorial'**
  String get onbHeaderTitle;

  /// Skip button label in onboarding header
  ///
  /// In en, this message translates to:
  /// **'Skip'**
  String get onbHeaderSkip;

  /// Back button in onboarding footer
  ///
  /// In en, this message translates to:
  /// **'Back'**
  String get onbBack;

  /// Next button in onboarding footer
  ///
  /// In en, this message translates to:
  /// **'Next'**
  String get onbNext;

  /// Guide banner title in onboarding
  ///
  /// In en, this message translates to:
  /// **'How this tutorial works'**
  String get onbGuideTitle;

  /// Guide banner description in onboarding
  ///
  /// In en, this message translates to:
  /// **'Swipe between slides or use Next. Tap the buttons on each slide to try features. You can finish anytime with Skip.'**
  String get onbGuideBody;

  /// CTA to open nutrition tracking from onboarding
  ///
  /// In en, this message translates to:
  /// **'Open nutrition'**
  String get onbCtaOpenNutrition;

  /// CTA to learn more about privacy/offline
  ///
  /// In en, this message translates to:
  /// **'Learn more'**
  String get onbCtaLearnMore;

  /// Badge label shown after completing CTA
  ///
  /// In en, this message translates to:
  /// **'Done'**
  String get onbBadgeDone;

  /// Hint text on goals slide
  ///
  /// In en, this message translates to:
  /// **'Tip: adjust targets first'**
  String get onbTipSetGoals;

  /// Hint text on nutrition slide
  ///
  /// In en, this message translates to:
  /// **'Tip: add one entry today'**
  String get onbTipAddEntry;

  /// Hint on privacy slide about local data control
  ///
  /// In en, this message translates to:
  /// **'You control all data locally'**
  String get onbTipLocalControl;

  /// Onboarding slide 2 replacement body: step-by-step nutrition logging instructions
  ///
  /// In en, this message translates to:
  /// **'How to log nutrition:\n• Open the Food tab.\n• Tap the + button.\n• Search products or scan a barcode.\n• Adjust portion and time.\n• Save to your diary.'**
  String get onbTrackHowBody;

  /// Onboarding slide title for measurements
  ///
  /// In en, this message translates to:
  /// **'Track measurements'**
  String get onbMeasureTitle;

  /// Step-by-step instructions for adding measurements
  ///
  /// In en, this message translates to:
  /// **'How to add measurements:\n• Open the Stats tab.\n• Tap the + button.\n• Choose a metric (e.g., weight, waist, body fat).\n• Enter value and time.\n• Save to your history.'**
  String get onbMeasureBody;

  /// Hint for measurements slide
  ///
  /// In en, this message translates to:
  /// **'Tip: add today’s weight to start your graph'**
  String get onbTipMeasureToday;

  /// Onboarding slide title for training routines
  ///
  /// In en, this message translates to:
  /// **'Train with routines'**
  String get onbTrainTitle;

  /// Instructions for creating a routine and starting a workout
  ///
  /// In en, this message translates to:
  /// **'Create a routine and start a workout:\n• Open the Train tab.\n• Tap Create routine to add exercises and sets.\n• Save the routine.\n• Tap Start to begin, or use “Start empty workout”.'**
  String get onbTrainBody;

  /// Hint for training slide
  ///
  /// In en, this message translates to:
  /// **'Tip: start an empty workout to log a quick session'**
  String get onbTipStartWorkout;

  /// No description provided for @unitsSection.
  ///
  /// In en, this message translates to:
  /// **'units'**
  String get unitsSection;

  /// No description provided for @weightUnit.
  ///
  /// In en, this message translates to:
  /// **'Weight units'**
  String get weightUnit;

  /// No description provided for @lengthUnit.
  ///
  /// In en, this message translates to:
  /// **'unit of length'**
  String get lengthUnit;

  /// No description provided for @comingSoon.
  ///
  /// In en, this message translates to:
  /// **'Coming soon'**
  String get comingSoon;

  /// No description provided for @noFavorites.
  ///
  /// In en, this message translates to:
  /// **'No Favorites'**
  String get noFavorites;

  /// No description provided for @nothingTrackedYet.
  ///
  /// In en, this message translates to:
  /// **'Nothing tracked yet'**
  String get nothingTrackedYet;

  /// No description provided for @snackbarBarcodeNotFound.
  ///
  /// In en, this message translates to:
  /// **'No product found for barcode \"{barcode}\".'**
  String snackbarBarcodeNotFound(String barcode);

  /// No description provided for @categoryHint.
  ///
  /// In en, this message translates to:
  /// **'e.g. Chest, Back, Legs...'**
  String get categoryHint;

  /// No description provided for @validatorPleaseEnterCategory.
  ///
  /// In en, this message translates to:
  /// **'Please enter a category.'**
  String get validatorPleaseEnterCategory;

  /// No description provided for @dialogEnterPasswordImport.
  ///
  /// In en, this message translates to:
  /// **'Enter password to import backup'**
  String get dialogEnterPasswordImport;

  /// No description provided for @dataManagementBackupTitle.
  ///
  /// In en, this message translates to:
  /// **'Lightweight Data Backup'**
  String get dataManagementBackupTitle;

  /// No description provided for @dataManagementBackupDescription.
  ///
  /// In en, this message translates to:
  /// **'Back up or restore all your app data. Ideal for changing devices.'**
  String get dataManagementBackupDescription;

  /// No description provided for @exportEncrypted.
  ///
  /// In en, this message translates to:
  /// **'Export Encrypted'**
  String get exportEncrypted;

  /// No description provided for @dialogPasswordForExport.
  ///
  /// In en, this message translates to:
  /// **'Password for encrypted export'**
  String get dialogPasswordForExport;

  /// No description provided for @snackbarEncryptedBackupShared.
  ///
  /// In en, this message translates to:
  /// **'Encrypted backup shared.'**
  String get snackbarEncryptedBackupShared;

  /// No description provided for @exportFailed.
  ///
  /// In en, this message translates to:
  /// **'Export failed.'**
  String get exportFailed;

  /// No description provided for @csvExportTitle.
  ///
  /// In en, this message translates to:
  /// **'Data Export (CSV)'**
  String get csvExportTitle;

  /// No description provided for @csvExportDescription.
  ///
  /// In en, this message translates to:
  /// **'Export parts of your data as a CSV file for analysis in other programs.'**
  String get csvExportDescription;

  /// No description provided for @snackbarSharingNutrition.
  ///
  /// In en, this message translates to:
  /// **'Sharing nutrition diary...'**
  String get snackbarSharingNutrition;

  /// No description provided for @snackbarExportFailedNoEntries.
  ///
  /// In en, this message translates to:
  /// **'Export failed. There may be no entries yet.'**
  String get snackbarExportFailedNoEntries;

  /// No description provided for @snackbarSharingMeasurements.
  ///
  /// In en, this message translates to:
  /// **'Sharing measurements...'**
  String get snackbarSharingMeasurements;

  /// No description provided for @snackbarSharingWorkouts.
  ///
  /// In en, this message translates to:
  /// **'Sharing workout history...'**
  String get snackbarSharingWorkouts;

  /// No description provided for @mapExercisesTitle.
  ///
  /// In en, this message translates to:
  /// **'Map Exercises'**
  String get mapExercisesTitle;

  /// No description provided for @mapExercisesDescription.
  ///
  /// In en, this message translates to:
  /// **'Map unknown names from logs to wger exercises.'**
  String get mapExercisesDescription;

  /// No description provided for @mapExercisesButton.
  ///
  /// In en, this message translates to:
  /// **'Start Mapping'**
  String get mapExercisesButton;

  /// No description provided for @autoBackupTitle.
  ///
  /// In en, this message translates to:
  /// **'Automatic Backups'**
  String get autoBackupTitle;

  /// No description provided for @autoBackupDescription.
  ///
  /// In en, this message translates to:
  /// **'Periodically saves a backup in the folder. Current folder:'**
  String get autoBackupDescription;

  /// No description provided for @autoBackupDefaultFolder.
  ///
  /// In en, this message translates to:
  /// **'App-Documents/Backups (Default)'**
  String get autoBackupDefaultFolder;

  /// No description provided for @autoBackupChooseFolder.
  ///
  /// In en, this message translates to:
  /// **'Choose Folder'**
  String get autoBackupChooseFolder;

  /// No description provided for @autoBackupCopyPath.
  ///
  /// In en, this message translates to:
  /// **'Copy Path'**
  String get autoBackupCopyPath;

  /// No description provided for @autoBackupRunNow.
  ///
  /// In en, this message translates to:
  /// **'Check & Run Auto-Backup Now'**
  String get autoBackupRunNow;

  /// No description provided for @snackbarAutoBackupSuccess.
  ///
  /// In en, this message translates to:
  /// **'Auto-Backup completed.'**
  String get snackbarAutoBackupSuccess;

  /// No description provided for @snackbarAutoBackupFailed.
  ///
  /// In en, this message translates to:
  /// **'Auto-Backup failed or was canceled.'**
  String get snackbarAutoBackupFailed;

  /// No description provided for @noUnknownExercisesFound.
  ///
  /// In en, this message translates to:
  /// **'No unknown exercises found'**
  String get noUnknownExercisesFound;

  /// No description provided for @snackbarAutoBackupFolderSet.
  ///
  /// In en, this message translates to:
  /// **'Auto-backup folder set:\n{path}'**
  String snackbarAutoBackupFolderSet(String path);

  /// No description provided for @snackbarPathCopied.
  ///
  /// In en, this message translates to:
  /// **'Path copied'**
  String get snackbarPathCopied;

  /// No description provided for @passwordLabel.
  ///
  /// In en, this message translates to:
  /// **'Password'**
  String get passwordLabel;

  /// No description provided for @descriptionLabel.
  ///
  /// In en, this message translates to:
  /// **'Description'**
  String get descriptionLabel;

  /// No description provided for @involvedMuscles.
  ///
  /// In en, this message translates to:
  /// **'Involved Muscles'**
  String get involvedMuscles;

  /// No description provided for @primaryLabel.
  ///
  /// In en, this message translates to:
  /// **'Primary:'**
  String get primaryLabel;

  /// No description provided for @secondaryLabel.
  ///
  /// In en, this message translates to:
  /// **'Secondary:'**
  String get secondaryLabel;

  /// No description provided for @noMusclesSpecified.
  ///
  /// In en, this message translates to:
  /// **'No muscles specified.'**
  String get noMusclesSpecified;

  /// No description provided for @noSelection.
  ///
  /// In en, this message translates to:
  /// **'No selection'**
  String get noSelection;

  /// No description provided for @selectButton.
  ///
  /// In en, this message translates to:
  /// **'Select'**
  String get selectButton;

  /// No description provided for @applyingChanges.
  ///
  /// In en, this message translates to:
  /// **'Applying changes...'**
  String get applyingChanges;

  /// No description provided for @applyMapping.
  ///
  /// In en, this message translates to:
  /// **'Apply Mapping'**
  String get applyMapping;

  /// No description provided for @personalData.
  ///
  /// In en, this message translates to:
  /// **'Personal Data'**
  String get personalData;

  /// No description provided for @macroDistribution.
  ///
  /// In en, this message translates to:
  /// **'Macronutrient Distribution'**
  String get macroDistribution;

  /// No description provided for @dialogFinishWorkoutBody.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to finish this workout?'**
  String get dialogFinishWorkoutBody;

  /// No description provided for @attributionText.
  ///
  /// In en, this message translates to:
  /// **'This app uses data from external sources:\n\n● Exercise data and images from wger (wger.de), licensed under CC-BY-SA 4.0.\n\n● Food database from Open Food Facts (openfoodfacts.org), available under the Open Database License (ODbL).'**
  String get attributionText;

  /// No description provided for @errorRoutineNotFound.
  ///
  /// In en, this message translates to:
  /// **'Routine not found'**
  String get errorRoutineNotFound;

  /// No description provided for @workoutHistoryEmptyTitle.
  ///
  /// In en, this message translates to:
  /// **'Your history is empty'**
  String get workoutHistoryEmptyTitle;

  /// No description provided for @workoutSummaryTitle.
  ///
  /// In en, this message translates to:
  /// **'Workout Complete'**
  String get workoutSummaryTitle;

  /// No description provided for @workoutSummaryExerciseOverview.
  ///
  /// In en, this message translates to:
  /// **'Exercise Overview'**
  String get workoutSummaryExerciseOverview;

  /// No description provided for @nutritionDiary.
  ///
  /// In en, this message translates to:
  /// **'Diary'**
  String get nutritionDiary;

  /// No description provided for @detailedNutrientGoals.
  ///
  /// In en, this message translates to:
  /// **'Detailed Nutrients'**
  String get detailedNutrientGoals;

  /// No description provided for @supplementTrackerTitle.
  ///
  /// In en, this message translates to:
  /// **'Supplement Tracker'**
  String get supplementTrackerTitle;

  /// No description provided for @supplementTrackerDescription.
  ///
  /// In en, this message translates to:
  /// **'Track goals, limits, and intake.'**
  String get supplementTrackerDescription;

  /// No description provided for @createSupplementTitle.
  ///
  /// In en, this message translates to:
  /// **'Create Supplement'**
  String get createSupplementTitle;

  /// No description provided for @supplementNameLabel.
  ///
  /// In en, this message translates to:
  /// **'Supplement Name'**
  String get supplementNameLabel;

  /// No description provided for @defaultDoseLabel.
  ///
  /// In en, this message translates to:
  /// **'Default Dose'**
  String get defaultDoseLabel;

  /// No description provided for @unitLabel.
  ///
  /// In en, this message translates to:
  /// **'Unit'**
  String get unitLabel;

  /// No description provided for @dailyGoalLabel.
  ///
  /// In en, this message translates to:
  /// **'Daily Goal (optional)'**
  String get dailyGoalLabel;

  /// No description provided for @dailyLimitLabel.
  ///
  /// In en, this message translates to:
  /// **'Daily Limit (optional)'**
  String get dailyLimitLabel;

  /// No description provided for @dailyProgressTitle.
  ///
  /// In en, this message translates to:
  /// **'Daily Progress'**
  String get dailyProgressTitle;

  /// No description provided for @todaysLogTitle.
  ///
  /// In en, this message translates to:
  /// **'Today\'s Log'**
  String get todaysLogTitle;

  /// No description provided for @logIntakeTitle.
  ///
  /// In en, this message translates to:
  /// **'Log Intake'**
  String get logIntakeTitle;

  /// No description provided for @emptySupplementGoals.
  ///
  /// In en, this message translates to:
  /// **'Set goals or limits for supplements to see your progress here.'**
  String get emptySupplementGoals;

  /// No description provided for @emptySupplementLogs.
  ///
  /// In en, this message translates to:
  /// **'No intake logged for today yet.'**
  String get emptySupplementLogs;

  /// No description provided for @doseLabel.
  ///
  /// In en, this message translates to:
  /// **'Dose'**
  String get doseLabel;

  /// No description provided for @settingsDescription.
  ///
  /// In en, this message translates to:
  /// **'Theme, units, data and more'**
  String get settingsDescription;

  /// No description provided for @settingsAppearance.
  ///
  /// In en, this message translates to:
  /// **'Appearance'**
  String get settingsAppearance;

  /// No description provided for @themeSystem.
  ///
  /// In en, this message translates to:
  /// **'System'**
  String get themeSystem;

  /// No description provided for @themeLight.
  ///
  /// In en, this message translates to:
  /// **'Light'**
  String get themeLight;

  /// No description provided for @themeDark.
  ///
  /// In en, this message translates to:
  /// **'Dark'**
  String get themeDark;

  /// No description provided for @caffeinePrompt.
  ///
  /// In en, this message translates to:
  /// **'Caffeine (optional)'**
  String get caffeinePrompt;

  /// No description provided for @caffeineUnit.
  ///
  /// In en, this message translates to:
  /// **'mg per 100ml'**
  String get caffeineUnit;

  /// No description provided for @profile.
  ///
  /// In en, this message translates to:
  /// **'Profile'**
  String get profile;

  /// No description provided for @measurementWeightCapslock.
  ///
  /// In en, this message translates to:
  /// **'BODY WEIGHT'**
  String get measurementWeightCapslock;

  /// No description provided for @diary.
  ///
  /// In en, this message translates to:
  /// **'Diary'**
  String get diary;

  /// No description provided for @analysis.
  ///
  /// In en, this message translates to:
  /// **'Analysis'**
  String get analysis;

  /// No description provided for @yesterday.
  ///
  /// In en, this message translates to:
  /// **'Yesterday'**
  String get yesterday;

  /// No description provided for @dayBeforeYesterday.
  ///
  /// In en, this message translates to:
  /// **'Two days ago'**
  String get dayBeforeYesterday;

  /// No description provided for @statistics.
  ///
  /// In en, this message translates to:
  /// **'Statistics'**
  String get statistics;

  /// No description provided for @workout.
  ///
  /// In en, this message translates to:
  /// **'Workout'**
  String get workout;

  /// No description provided for @addFoodTitle.
  ///
  /// In en, this message translates to:
  /// **'add food'**
  String get addFoodTitle;

  /// No description provided for @supplement_caffeine.
  ///
  /// In en, this message translates to:
  /// **'Caffeine'**
  String get supplement_caffeine;

  /// No description provided for @supplement_creatine_monohydrate.
  ///
  /// In en, this message translates to:
  /// **'Creatine Monohydrate'**
  String get supplement_creatine_monohydrate;

  /// No description provided for @manageSupplementsTitle.
  ///
  /// In en, this message translates to:
  /// **'Manage supplements'**
  String get manageSupplementsTitle;

  /// No description provided for @deleted.
  ///
  /// In en, this message translates to:
  /// **'deleted'**
  String get deleted;

  /// No description provided for @operationNotAllowed.
  ///
  /// In en, this message translates to:
  /// **'This operation isn\'t allowed'**
  String get operationNotAllowed;

  /// No description provided for @emptySupplements.
  ///
  /// In en, this message translates to:
  /// **'No supplements available'**
  String get emptySupplements;

  /// No description provided for @undo.
  ///
  /// In en, this message translates to:
  /// **'Rückgängig'**
  String get undo;

  /// No description provided for @deleteSupplementConfirm.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to delete this supplement? All related entries will be removed.'**
  String get deleteSupplementConfirm;

  /// No description provided for @fieldRequired.
  ///
  /// In en, this message translates to:
  /// **'Required'**
  String get fieldRequired;

  /// No description provided for @unitNotSupported.
  ///
  /// In en, this message translates to:
  /// **'Unit not supported.'**
  String get unitNotSupported;

  /// No description provided for @caffeineUnitLocked.
  ///
  /// In en, this message translates to:
  /// **'For caffeine the unit is fixed: mg.'**
  String get caffeineUnitLocked;

  /// No description provided for @caffeineMustBeMg.
  ///
  /// In en, this message translates to:
  /// **'Caffeine must be recorded in mg.'**
  String get caffeineMustBeMg;

  /// No description provided for @tabCatalogSearch.
  ///
  /// In en, this message translates to:
  /// **'Catalog'**
  String get tabCatalogSearch;

  /// No description provided for @tabMeals.
  ///
  /// In en, this message translates to:
  /// **'Meals'**
  String get tabMeals;

  /// No description provided for @emptyCategory.
  ///
  /// In en, this message translates to:
  /// **'No entries'**
  String get emptyCategory;

  /// No description provided for @searchSectionBase.
  ///
  /// In en, this message translates to:
  /// **'Base foods'**
  String get searchSectionBase;

  /// No description provided for @searchSectionOther.
  ///
  /// In en, this message translates to:
  /// **'Other results'**
  String get searchSectionOther;

  /// No description provided for @mealsComingSoonTitle.
  ///
  /// In en, this message translates to:
  /// **'Meals (coming soon)'**
  String get mealsComingSoonTitle;

  /// No description provided for @mealsComingSoonBody.
  ///
  /// In en, this message translates to:
  /// **'Soon you will be able to create your own meals from multiple foods.'**
  String get mealsComingSoonBody;

  /// No description provided for @mealsEmptyTitle.
  ///
  /// In en, this message translates to:
  /// **'No meals yet'**
  String get mealsEmptyTitle;

  /// No description provided for @mealsEmptyBody.
  ///
  /// In en, this message translates to:
  /// **'Create meals to quickly log multiple foods at once.'**
  String get mealsEmptyBody;

  /// No description provided for @mealsCreate.
  ///
  /// In en, this message translates to:
  /// **'Create meal'**
  String get mealsCreate;

  /// No description provided for @mealsEdit.
  ///
  /// In en, this message translates to:
  /// **'Edit meal'**
  String get mealsEdit;

  /// No description provided for @mealsDelete.
  ///
  /// In en, this message translates to:
  /// **'Delete meal'**
  String get mealsDelete;

  /// No description provided for @mealsAddToDiary.
  ///
  /// In en, this message translates to:
  /// **'Add to diary'**
  String get mealsAddToDiary;

  /// No description provided for @mealNameLabel.
  ///
  /// In en, this message translates to:
  /// **'Meal name'**
  String get mealNameLabel;

  /// No description provided for @mealNotesLabel.
  ///
  /// In en, this message translates to:
  /// **'Notes'**
  String get mealNotesLabel;

  /// No description provided for @mealIngredientsTitle.
  ///
  /// In en, this message translates to:
  /// **'Ingredients'**
  String get mealIngredientsTitle;

  /// No description provided for @mealAddIngredient.
  ///
  /// In en, this message translates to:
  /// **'Add ingredient'**
  String get mealAddIngredient;

  /// No description provided for @mealIngredientAmountLabel.
  ///
  /// In en, this message translates to:
  /// **'Amount'**
  String get mealIngredientAmountLabel;

  /// No description provided for @mealDeleteConfirmTitle.
  ///
  /// In en, this message translates to:
  /// **'Delete meal'**
  String get mealDeleteConfirmTitle;

  /// No description provided for @mealDeleteConfirmBody.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to delete the meal \'{name}\'? All its ingredients will also be removed.'**
  String mealDeleteConfirmBody(Object name);

  /// No description provided for @mealAddedToDiary.
  ///
  /// In en, this message translates to:
  /// **'Meal \'{name}\' has been added to your diary.'**
  String mealAddedToDiary(Object name);

  /// No description provided for @mealSaved.
  ///
  /// In en, this message translates to:
  /// **'Meal saved.'**
  String get mealSaved;

  /// No description provided for @mealDeleted.
  ///
  /// In en, this message translates to:
  /// **'Meal deleted.'**
  String get mealDeleted;

  /// No description provided for @confirm.
  ///
  /// In en, this message translates to:
  /// **'Confirm'**
  String get confirm;

  /// No description provided for @addMealToDiaryTitle.
  ///
  /// In en, this message translates to:
  /// **'Add to diary'**
  String get addMealToDiaryTitle;

  /// No description provided for @mealTypeLabel.
  ///
  /// In en, this message translates to:
  /// **'Meal'**
  String get mealTypeLabel;

  /// No description provided for @amountLabel.
  ///
  /// In en, this message translates to:
  /// **'Amount'**
  String get amountLabel;

  /// No description provided for @mealAddedToDiarySuccess.
  ///
  /// In en, this message translates to:
  /// **'Meal added to diary'**
  String get mealAddedToDiarySuccess;

  /// No description provided for @error.
  ///
  /// In en, this message translates to:
  /// **'Error'**
  String get error;

  /// No description provided for @mealsViewTitle.
  ///
  /// In en, this message translates to:
  /// **'mealsViewTitle'**
  String get mealsViewTitle;

  /// No description provided for @noNotes.
  ///
  /// In en, this message translates to:
  /// **'No notes'**
  String get noNotes;

  /// No description provided for @ingredientsCapsLock.
  ///
  /// In en, this message translates to:
  /// **'INGREDIENTS'**
  String get ingredientsCapsLock;

  /// No description provided for @nutritionSectionLabel.
  ///
  /// In en, this message translates to:
  /// **'NUTRITION FACTS'**
  String get nutritionSectionLabel;

  /// No description provided for @nutritionCalculatedForCurrentAmounts.
  ///
  /// In en, this message translates to:
  /// **'for current quantities'**
  String get nutritionCalculatedForCurrentAmounts;

  /// No description provided for @startCapsLock.
  ///
  /// In en, this message translates to:
  /// **'START'**
  String get startCapsLock;

  /// No description provided for @nutritionHubSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Discover insights, track meals, and plan your nutrition here soon.'**
  String get nutritionHubSubtitle;

  /// No description provided for @nutritionHubTitle.
  ///
  /// In en, this message translates to:
  /// **'Nutrition'**
  String get nutritionHubTitle;

  /// No description provided for @nutrition.
  ///
  /// In en, this message translates to:
  /// **'nutrition'**
  String get nutrition;
}

class _AppLocalizationsDelegate
    extends LocalizationsDelegate<AppLocalizations> {
  const _AppLocalizationsDelegate();

  @override
  Future<AppLocalizations> load(Locale locale) {
    return SynchronousFuture<AppLocalizations>(lookupAppLocalizations(locale));
  }

  @override
  bool isSupported(Locale locale) =>
      <String>['de', 'en'].contains(locale.languageCode);

  @override
  bool shouldReload(_AppLocalizationsDelegate old) => false;
}

AppLocalizations lookupAppLocalizations(Locale locale) {
  // Lookup logic when only language code is specified.
  switch (locale.languageCode) {
    case 'de':
      return AppLocalizationsDe();
    case 'en':
      return AppLocalizationsEn();
  }

  throw FlutterError(
      'AppLocalizations.delegate failed to load unsupported locale "$locale". This is likely '
      'an issue with the localizations generation tool. Please file an issue '
      'on GitHub with a reproducible sample app and the gen-l10n configuration '
      'that was used.');
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/generated/app_localizations_de.dart =====

// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for German (`de`).
class AppLocalizationsDe extends AppLocalizations {
  AppLocalizationsDe([String locale = 'de']) : super(locale);

  @override
  String get appTitle => 'Vita';

  @override
  String get bannerText => 'Empfehlung / Aktuelles Workout';

  @override
  String get calories => 'Kalorien';

  @override
  String get water => 'Wasser';

  @override
  String get protein => 'Protein';

  @override
  String get carbs => 'Kohlenhydrate';

  @override
  String get fat => 'Fett';

  @override
  String get daily => 'Täglich';

  @override
  String get today => 'Heute';

  @override
  String get workoutSection => 'Workout-Bereich - noch nicht implementiert';

  @override
  String get addMenuTitle => 'Was möchtest du hinzufügen?';

  @override
  String get addFoodOption => 'Lebensmittel';

  @override
  String get addLiquidOption => 'Flüssigkeit';

  @override
  String get searchHintText => 'Suchen...';

  @override
  String get mealtypeBreakfast => 'Frühstück';

  @override
  String get mealtypeLunch => 'Mittagessen';

  @override
  String get mealtypeDinner => 'Abendessen';

  @override
  String get mealtypeSnack => 'Snack';

  @override
  String get waterHeader => 'Wasser & Getränke';

  @override
  String get openFoodFactsSource => 'Daten von Open Food Facts';

  @override
  String get tabRecent => 'Zuletzt';

  @override
  String get tabSearch => 'Suchen';

  @override
  String get tabFavorites => 'Favoriten';

  @override
  String get fabCreateOwnFood => 'Eigenes Lebensmittel';

  @override
  String get recentEmptyState =>
      'Deine zuletzt verwendeten Lebensmittel\nerscheinen hier.';

  @override
  String get favoritesEmptyState =>
      'Du hast noch keine Favoriten.\nMarkiere ein Lebensmittel mit dem Herz-Icon, um es hier zu sehen.';

  @override
  String get searchInitialHint => 'Bitte gib einen Suchbegriff ein.';

  @override
  String get searchNoResults => 'Keine Ergebnisse gefunden.';

  @override
  String get createFoodScreenTitle => 'Eigenes Lebensmittel erstellen';

  @override
  String get formFieldName => 'Name des Lebensmittels';

  @override
  String get formFieldBrand => 'Marke (optional)';

  @override
  String get formSectionMainNutrients => 'Haupt-Nährwerte (pro 100g)';

  @override
  String get formFieldCalories => 'Kalorien (kcal)';

  @override
  String get formFieldProtein => 'Protein (g)';

  @override
  String get formFieldCarbs => 'Kohlenhydrate (g)';

  @override
  String get formFieldFat => 'Fett (g)';

  @override
  String get formSectionOptionalNutrients =>
      'Weitere Nährwerte (optional, pro 100g)';

  @override
  String get formFieldSugar => 'Davon Zucker (g)';

  @override
  String get formFieldFiber => 'Ballaststoffe (g)';

  @override
  String get formFieldKj => 'Kilojoule (kJ)';

  @override
  String get formFieldSalt => 'Salz (g)';

  @override
  String get formFieldSodium => 'Natrium (mg)';

  @override
  String get formFieldCalcium => 'Kalzium (mg)';

  @override
  String get buttonSave => 'Speichern';

  @override
  String get validatorPleaseEnterName => 'Bitte gib einen Namen ein.';

  @override
  String get validatorPleaseEnterNumber => 'Bitte gib eine gültige Zahl ein.';

  @override
  String snackbarSaveSuccess(String foodName) {
    return '$foodName wurde erfolgreich gespeichert.';
  }

  @override
  String get foodDetailSegmentPortion => 'Portion';

  @override
  String get foodDetailSegment100g => '100g';

  @override
  String get sugar => 'Zucker';

  @override
  String get fiber => 'Ballaststoffe';

  @override
  String get salt => 'Salz';

  @override
  String get explorerScreenTitle => 'Lebensmittel-Explorer';

  @override
  String get nutritionScreenTitle => 'Ernährungsanalyse';

  @override
  String get entriesForDateRangeLabel => 'Einträge für';

  @override
  String get noEntriesForPeriod => 'Noch keine Einträge für diesen Zeitraum.';

  @override
  String get waterEntryTitle => 'Wasser';

  @override
  String get profileScreenTitle => 'Profil';

  @override
  String get profileDailyGoals => 'Tägliche Ziele';

  @override
  String get snackbarGoalsSaved => 'Ziele erfolgreich gespeichert!';

  @override
  String get measurementsScreenTitle => 'Messwerte';

  @override
  String get measurementsEmptyState =>
      'Noch keine Messwerte erfasst.\nBeginne mit dem \'+\' Button.';

  @override
  String get addMeasurementDialogTitle => 'Neuer Messwert';

  @override
  String get formFieldMeasurementType => 'Art der Messung';

  @override
  String formFieldMeasurementValue(Object unit) {
    return 'Wert ($unit)';
  }

  @override
  String get validatorPleaseEnterValue => 'Bitte Wert eingeben';

  @override
  String get measurementWeight => 'Körpergewicht';

  @override
  String get measurementFatPercent => 'Körperfett';

  @override
  String get measurementNeck => 'Nacken';

  @override
  String get measurementShoulder => 'Schulter';

  @override
  String get measurementChest => 'Brust';

  @override
  String get measurementLeftBicep => 'Linker Bizeps';

  @override
  String get measurementRightBicep => 'Rechter Bizeps';

  @override
  String get measurementLeftForearm => 'Linker Unterarm';

  @override
  String get measurementRightForearm => 'Rechter Unterarm';

  @override
  String get measurementAbdomen => 'Bauch';

  @override
  String get measurementWaist => 'Taille';

  @override
  String get measurementHips => 'Hüfte';

  @override
  String get measurementLeftThigh => 'Linker Oberschenkel';

  @override
  String get measurementRightThigh => 'Rechter Oberschenkel';

  @override
  String get measurementLeftCalf => 'Linke Wade';

  @override
  String get measurementRightCalf => 'Rechte Wade';

  @override
  String get drawerMenuTitle => 'Vita Menü';

  @override
  String get drawerDashboard => 'Dashboard';

  @override
  String get drawerFoodExplorer => 'Lebensmittel-Explorer';

  @override
  String get drawerDataManagement => 'Datensicherung';

  @override
  String get drawerMeasurements => 'Messwerte';

  @override
  String get dataManagementTitle => 'Datensicherung';

  @override
  String get exportCardTitle => 'Daten exportieren';

  @override
  String get exportCardDescription =>
      'Sichert alle deine Tagebucheinträge, Favoriten und eigenen Lebensmittel in einer einzigen Backup-Datei.';

  @override
  String get exportCardButton => 'Backup erstellen';

  @override
  String get importCardTitle => 'Daten importieren';

  @override
  String get importCardDescription =>
      'Stellt deine Daten aus einer zuvor erstellten Backup-Datei wieder her. ACHTUNG: Alle aktuell in der App gespeicherten Daten werden dabei überschrieben!';

  @override
  String get importCardButton => 'Backup wiederherstellen';

  @override
  String get recommendationDefault => 'Tracke deine erste Mahlzeit!';

  @override
  String recommendationOverTarget(Object count, Object difference) {
    return 'Letzte $count Tage: +$difference kcal über dem Ziel';
  }

  @override
  String recommendationUnderTarget(Object count, Object difference) {
    return 'Letzte $count Tage: $difference kcal unter dem Ziel';
  }

  @override
  String recommendationOnTarget(Object count) {
    return 'Letzte $count Tage: Ziel erreicht ✅';
  }

  @override
  String get recommendationFirstEntry =>
      'Super, dein erster Eintrag ist gemacht!';

  @override
  String get dialogConfirmTitle => 'Bestätigung erforderlich';

  @override
  String get dialogConfirmImportContent =>
      'Möchtest du wirklich die Daten aus diesem Backup wiederherstellen?\n\nACHTUNG: Alle deine aktuellen Einträge, Favoriten und eigenen Lebensmittel werden unwiderruflich gelöscht und ersetzt.';

  @override
  String get dialogButtonCancel => 'Abbrechen';

  @override
  String get dialogButtonOverwrite => 'Ja, alles überschreiben';

  @override
  String get snackbarNoFileSelected => 'Keine Datei ausgewählt.';

  @override
  String get snackbarImportSuccessTitle => 'Import erfolgreich!';

  @override
  String get snackbarImportSuccessContent =>
      'Deine Daten wurden wiederhergestellt. Für eine korrekte Anzeige wird empfohlen, die App jetzt neu zu starten.';

  @override
  String get snackbarButtonOK => 'OK';

  @override
  String get snackbarImportError => 'Fehler beim Importieren der Daten.';

  @override
  String get snackbarExportSuccess =>
      'Backup-Datei wurde an das System übergeben. Bitte wähle einen Speicherort.';

  @override
  String get snackbarExportFailed => 'Export abgebrochen oder fehlgeschlagen.';

  @override
  String get profileUserHeight => 'Körpergröße (cm)';

  @override
  String get workoutRoutinesTitle => 'Trainingspläne';

  @override
  String get workoutHistoryTitle => 'Workout-Verlauf';

  @override
  String get workoutHistoryButton => 'Verlauf';

  @override
  String get emptyRoutinesTitle => 'Keine Trainingspläne gefunden';

  @override
  String get emptyRoutinesSubtitle =>
      'Erstelle deinen ersten Trainingsplan oder starte ein freies Training.';

  @override
  String get createFirstRoutineButton => 'Ersten Plan erstellen';

  @override
  String get startEmptyWorkoutButton => 'Freies Training';

  @override
  String get editRoutineSubtitle =>
      'Tippen zum Bearbeiten, oder starte das Training.';

  @override
  String get startButton => 'Start';

  @override
  String get addRoutineButton => 'Neue Routine';

  @override
  String get freeWorkoutTitle => 'Freies Training';

  @override
  String get finishWorkoutButton => 'Beenden';

  @override
  String get addSetButton => 'Satz hinzufügen';

  @override
  String get addExerciseToWorkoutButton => 'Übung zum Workout hinzufügen';

  @override
  String get lastTimeLabel => 'Letztes Mal';

  @override
  String get setLabel => 'Satz';

  @override
  String get kgLabel => 'Gewicht (kg)';

  @override
  String get repsLabel => 'Wdh';

  @override
  String get restTimerLabel => 'Pause';

  @override
  String get skipButton => 'Überspringen';

  @override
  String get emptyHistory => 'Noch keine Workouts abgeschlossen.';

  @override
  String get workoutDetailsTitle => 'Workout-Details';

  @override
  String get workoutNotFound => 'Workout nicht gefunden.';

  @override
  String get totalVolumeLabel => 'Gesamtvolumen';

  @override
  String get notesLabel => 'Notizen';

  @override
  String get hevyImportTitle => 'Hevy Import';

  @override
  String get hevyImportDescription =>
      'Importiere deine gesamte Trainings-Historie aus einer Hevy CSV-Exportdatei.';

  @override
  String get hevyImportButton => 'Hevy-Daten importieren';

  @override
  String hevyImportSuccess(Object count) {
    return '$count Workouts erfolgreich importiert!';
  }

  @override
  String get hevyImportFailed =>
      'Import fehlgeschlagen. Bitte überprüfe die Datei.';

  @override
  String get startWorkout => 'Workout starten';

  @override
  String get addMeasurement => 'Messwert hinzufügen';

  @override
  String get filterToday => 'Heute';

  @override
  String get filter7Days => '7 Tage';

  @override
  String get filter30Days => '30 Tage';

  @override
  String get filterAll => 'Alle';

  @override
  String get showLess => 'Weniger anzeigen';

  @override
  String get showMoreDetails => 'Mehr Details anzeigen';

  @override
  String get deleteConfirmTitle => 'Löschen bestätigen';

  @override
  String get deleteConfirmContent =>
      'Möchtest du diesen Eintrag wirklich löschen?';

  @override
  String get cancel => 'Abbrechen';

  @override
  String get delete => 'Löschen';

  @override
  String get save => 'Speichern';

  @override
  String get tabBaseFoods => 'Grundnahrungsmittel';

  @override
  String get baseFoodsEmptyState =>
      'Dieser Bereich wird bald mit einer kuratierten Liste von Grundnahrungsmitteln wie Obst, Gemüse und mehr gefüllt sein.';

  @override
  String get noBrand => 'Keine Marke';

  @override
  String get unknown => 'Unbekannt';

  @override
  String backupFileSubject(String timestamp) {
    return 'Vita App Backup - $timestamp';
  }

  @override
  String foodItemSubtitle(String brand, int calories) {
    return '$brand - $calories kcal / 100g';
  }

  @override
  String foodListSubtitle(int grams, String time) {
    return '${grams}g - $time';
  }

  @override
  String foodListTrailingKcal(int calories) {
    return '$calories kcal';
  }

  @override
  String waterListTrailingMl(int milliliters) {
    return '$milliliters ml';
  }

  @override
  String get exerciseCatalogTitle => 'Übungskatalog';

  @override
  String get filterByMuscle => 'Nach Muskelgruppe filtern';

  @override
  String get noExercisesFound => 'Keine Übungen gefunden.';

  @override
  String get noDescriptionAvailable => 'Keine Beschreibung verfügbar.';

  @override
  String get filterByCategory => 'Nach Kategorie filtern';

  @override
  String get edit => 'Bearbeiten';

  @override
  String get repsLabelShort => 'Wdh';

  @override
  String get titleNewRoutine => 'Neue Routine';

  @override
  String get titleEditRoutine => 'Routine bearbeiten';

  @override
  String get validatorPleaseEnterRoutineName =>
      'Bitte gib der Routine einen Namen.';

  @override
  String get snackbarRoutineCreated =>
      'Routine erstellt. Füge nun Übungen hinzu.';

  @override
  String get snackbarRoutineSaved => 'Routine gespeichert.';

  @override
  String get formFieldRoutineName => 'Name der Routine';

  @override
  String get emptyStateAddFirstExercise => 'Füge deine erste Übung hinzu.';

  @override
  String setCount(int count) {
    String _temp0 = intl.Intl.pluralLogic(
      count,
      locale: localeName,
      other: '$count Sätze',
      one: '1 Satz',
    );
    return '$_temp0';
  }

  @override
  String get fabAddExercise => 'Übung hinzufügen';

  @override
  String get kgLabelShort => 'kg';

  @override
  String get drawerExerciseCatalog => 'Übungskatalog';

  @override
  String get lastWorkoutTitle => 'Letztes Workout';

  @override
  String get repeatButton => 'Wiederholen';

  @override
  String get weightHistoryTitle => 'Gewichtsverlauf';

  @override
  String get hideSummary => 'Übersicht ausblenden';

  @override
  String get showSummary => 'Übersicht einblenden';

  @override
  String get exerciseDataAttribution => 'Übungsdaten von';

  @override
  String get duplicate => 'Duplizieren';

  @override
  String deleteRoutineConfirmContent(String routineName) {
    return 'Möchtest du den Trainingsplan \'$routineName\' wirklich unwiderruflich löschen?';
  }

  @override
  String get editPauseTimeTitle => 'Pausendauer bearbeiten';

  @override
  String get pauseInSeconds => 'Pause in Sekunden';

  @override
  String get editPauseTime => 'Pause bearbeiten';

  @override
  String pauseDuration(int seconds) {
    return '$seconds Sekunden Pause';
  }

  @override
  String maxPauseDuration(int seconds) {
    return 'Pausen bis zu ${seconds}s';
  }

  @override
  String get deleteWorkoutConfirmContent =>
      'Möchtest du dieses protokollierte Workout wirklich unwiderruflich löschen?';

  @override
  String get removeExercise => 'Übung entfernen';

  @override
  String get deleteExerciseConfirmTitle => 'Übung entfernen?';

  @override
  String deleteExerciseConfirmContent(String exerciseName) {
    return 'Möchtest du \'$exerciseName\' wirklich aus diesem Trainingsplan entfernen?';
  }

  @override
  String get doneButtonLabel => 'Fertig';

  @override
  String get setRestTimeButton => 'Pause einstellen';

  @override
  String get deleteExerciseButton => 'Übung löschen';

  @override
  String get restOverLabel => 'Pause vorbei';

  @override
  String get workoutRunningLabel => 'Workout läuft …';

  @override
  String get continueButton => 'Weiter';

  @override
  String get discardButton => 'Verwerfen';

  @override
  String get workoutStatsTitle => 'Training (7 Tage)';

  @override
  String get workoutsLabel => 'Workouts';

  @override
  String get durationLabel => 'Dauer';

  @override
  String get volumeLabel => 'Volumen';

  @override
  String get setsLabel => 'Sätze';

  @override
  String get muscleSplitLabel => 'Muskel-Split';

  @override
  String get snackbar_could_not_open_open_link => 'Konnte Link nicht öffnen';

  @override
  String get chart_no_data_for_period => 'Keine Daten für diesen Zeitraum.';

  @override
  String get amount_in_milliliters => 'Menge in Millilitern';

  @override
  String get amount_in_grams => 'Menge in Gramm';

  @override
  String get meal_label => 'Mahlzeit';

  @override
  String get add_to_water_intake => 'Zur Trinkmenge hinzufügen';

  @override
  String get create_exercise_screen_title => 'Eigene Übung erstellen';

  @override
  String get exercise_name_label => 'Name der Übung';

  @override
  String get category_label => 'Kategorie';

  @override
  String get description_optional_label => 'Beschreibung (optional)';

  @override
  String get primary_muscles_label => 'Primäre Muskeln';

  @override
  String get primary_muscles_hint => 'z.B. Brust, Trizeps';

  @override
  String get secondary_muscles_label => 'Sekundäre Muskeln (optional)';

  @override
  String get secondary_muscles_hint => 'z.B. Schultern';

  @override
  String get set_type_normal => 'Normal';

  @override
  String get set_type_warmup => 'Warmup';

  @override
  String get set_type_failure => 'Failure';

  @override
  String get set_type_dropset => 'Dropset';

  @override
  String get set_reps_hint => '8-12';

  @override
  String get data_export_button => 'Exportieren';

  @override
  String get data_import_button => 'Importieren';

  @override
  String get snackbar_button_ok => 'OK';

  @override
  String get measurement_session_detail_view =>
      'Detailansicht der Messsession.';

  @override
  String get unit_grams => 'g';

  @override
  String get unit_kcal => 'kcal';

  @override
  String get delete_profile_picture_button => 'Profilbild löschen';

  @override
  String get attribution_title => 'Attribution';

  @override
  String get add_liquid_title => 'Flüssigkeit hinzufügen';

  @override
  String get add_button => 'Hinzufügen';

  @override
  String get discard_button => 'Verwerfen';

  @override
  String get continue_workout_button => 'Fortsetzen';

  @override
  String get soon_available_snackbar =>
      'Dieser Screen wird bald verfügbar sein!';

  @override
  String get start_button => 'Start';

  @override
  String get today_overview_text => 'HEUTE IM BLICK';

  @override
  String get quick_add_text => 'SCHNELLES HINZUFÜGEN';

  @override
  String get scann_barcode_capslock => 'Barcode scannen';

  @override
  String get protocol_today_capslock => 'HEUTIGES PROTOKOLL';

  @override
  String get my_plans_capslock => 'MEINE PLÄNE';

  @override
  String get overview_capslock => 'ÜBERBLICK';

  @override
  String get manage_all_plans => 'Alle Pläne verwalten';

  @override
  String get free_training => 'Freies Training';

  @override
  String get my_consistency => 'MEINE KONSISTENZ';

  @override
  String get calendar_currently_not_available =>
      'Die Kalender-Ansicht ist in Kürze verfügbar.';

  @override
  String get in_depth_analysis => 'TIEFEN-ANALYSE';

  @override
  String get body_measurements => 'Körpermaße';

  @override
  String get measurements_description =>
      'Gewicht, KFA und Umfänge analysieren.';

  @override
  String get nutrition_description => 'Makros, Kalorien und Trends auswerten.';

  @override
  String get training_analysis => 'Trainings-Analyse';

  @override
  String get training_analysis_description =>
      'Volumen, Kraft und Progression verfolgen.';

  @override
  String get load_dots => 'lade...';

  @override
  String get profile_capslock => 'PROFIL';

  @override
  String get settings_capslock => 'EINSTELLUNGEN';

  @override
  String get settingsTitle => 'Einstellungen';

  @override
  String get my_goals => 'Meine Ziele';

  @override
  String get my_goals_description => 'Kalorien, Makros und Wasser anpassen.';

  @override
  String get backup_and_import => 'Datensicherung & Import';

  @override
  String get backup_and_import_description =>
      'Backups erstellen, wiederherstellen und Daten importieren.';

  @override
  String get about_and_legal_capslock => 'ÜBER & RECHTLICHES';

  @override
  String get attribution_and_license => 'Attribution & Lizenzen';

  @override
  String get data_from_off_and_wger => 'Daten von Open Food Facts und wger.';

  @override
  String get app_version => 'App Version';

  @override
  String get all_measurements => 'ALLE MESSWERTE';

  @override
  String get date_and_time_of_measurement => 'Datum & Uhrzeit der Messung';

  @override
  String get onbWelcomeTitle => 'Willkommen bei Lightweight';

  @override
  String get onbWelcomeBody =>
      'Starte mit deinen persönlichen Zielen für Training und Ernährung.';

  @override
  String get onbTrackTitle => 'Alles tracken';

  @override
  String get onbTrackBody =>
      'Erfasse Ernährung, Workouts und Messwerte — alles an einem Ort.';

  @override
  String get onbPrivacyTitle => 'Offline-first & Privatsphäre';

  @override
  String get onbPrivacyBody =>
      'Deine Daten bleiben auf dem Gerät. Keine Cloud-Konten, kein Hintergrund-Sync.';

  @override
  String get onbFinishTitle => 'Alles bereit';

  @override
  String get onbFinishBody =>
      'Du kannst loslegen. Einstellungen lassen sich jederzeit anpassen.';

  @override
  String get onbFinishCta => 'Los geht’s!';

  @override
  String get onbShowTutorialAgain => 'Tutorial erneut anzeigen';

  @override
  String get onbSetGoalsCta => 'Ziele festlegen';

  @override
  String get onbHeaderTitle => 'Tutorial';

  @override
  String get onbHeaderSkip => 'Überspringen';

  @override
  String get onbBack => 'Zurück';

  @override
  String get onbNext => 'Weiter';

  @override
  String get onbGuideTitle => 'So funktioniert das Tutorial';

  @override
  String get onbGuideBody =>
      'Wische zwischen den Folien oder nutze Weiter. Tippe die Buttons auf jeder Folie, um Funktionen auszuprobieren. Du kannst jederzeit über Überspringen beenden.';

  @override
  String get onbCtaOpenNutrition => 'Ernährung öffnen';

  @override
  String get onbCtaLearnMore => 'Mehr erfahren';

  @override
  String get onbBadgeDone => 'Erledigt';

  @override
  String get onbTipSetGoals => 'Tipp: Lege zuerst deine Ziele fest';

  @override
  String get onbTipAddEntry => 'Tipp: Füge heute einen Eintrag hinzu';

  @override
  String get onbTipLocalControl => 'Du kontrollierst alle Daten lokal';

  @override
  String get onbTrackHowBody =>
      'So erfasst du Ernährung:\n• Öffne den Tab „Food“.\n• Tippe auf das + Symbol.\n• Suche Produkte oder scanne einen Barcode.\n• Passe Portion und Uhrzeit an.\n• Speichere in deinem Tagebuch.';

  @override
  String get onbMeasureTitle => 'Messwerte erfassen';

  @override
  String get onbMeasureBody =>
      'So fügst du Messungen hinzu:\n• Öffne den Tab „Stats“.\n• Tippe auf das + Symbol.\n• Wähle eine Messgröße (z. B. Gewicht, Taille, KFA).\n• Gib Wert und Uhrzeit ein.\n• Speichere deinen Eintrag.';

  @override
  String get onbTipMeasureToday =>
      'Tipp: Trage dein heutiges Gewicht ein, um den Graphen zu starten';

  @override
  String get onbTrainTitle => 'Trainieren mit Routinen';

  @override
  String get onbTrainBody =>
      'Routine erstellen und Workout starten:\n• Öffne den Tab „Train“.\n• Tippe auf Routine erstellen und füge Übungen und Sätze hinzu.\n• Speichere die Routine.\n• Tippe auf Start, um zu beginnen – oder nutze „Freies Training starten“.';

  @override
  String get onbTipStartWorkout =>
      'Tipp: Starte ein freies Training für eine schnelle Einheit';

  @override
  String get unitsSection => 'Einheiten';

  @override
  String get weightUnit => 'Gewichtseinheit';

  @override
  String get lengthUnit => 'Längeneinheit';

  @override
  String get comingSoon => 'In Kürze verfügbar';

  @override
  String get noFavorites => 'Keine Favoriten';

  @override
  String get nothingTrackedYet => 'Noch nichts erfasst';

  @override
  String snackbarBarcodeNotFound(String barcode) {
    return 'Kein Produkt für Barcode \"$barcode\" gefunden.';
  }

  @override
  String get categoryHint => 'z.B. Brust, Rücken, Beine...';

  @override
  String get validatorPleaseEnterCategory => 'Bitte eine Kategorie angeben.';

  @override
  String get dialogEnterPasswordImport => 'Passwort für den Import eingeben';

  @override
  String get dataManagementBackupTitle => 'Lightweight Datensicherung';

  @override
  String get dataManagementBackupDescription =>
      'Sichere oder wiederherstelle alle deine App-Daten. Ideal für einen Gerätewechsel.';

  @override
  String get exportEncrypted => 'Verschlüsselt exportieren';

  @override
  String get dialogPasswordForExport => 'Passwort für verschlüsselten Export';

  @override
  String get snackbarEncryptedBackupShared => 'Verschlüsseltes Backup geteilt.';

  @override
  String get exportFailed => 'Export fehlgeschlagen.';

  @override
  String get csvExportTitle => 'Daten-Export (CSV)';

  @override
  String get csvExportDescription =>
      'Exportiere Teile deiner Daten als CSV-Datei zur Analyse in anderen Programmen.';

  @override
  String get snackbarSharingNutrition => 'Ernährungstagebuch wird geteilt...';

  @override
  String get snackbarExportFailedNoEntries =>
      'Export fehlgeschlagen. Eventuell existieren noch keine Einträge.';

  @override
  String get snackbarSharingMeasurements => 'Messwerte werden geteilt...';

  @override
  String get snackbarSharingWorkouts => 'Trainingsverlauf wird geteilt...';

  @override
  String get mapExercisesTitle => 'Übungen zuordnen';

  @override
  String get mapExercisesDescription =>
      'Unbekannte Namen aus Logs auf wger-Übungen mappen.';

  @override
  String get mapExercisesButton => 'Mapping starten';

  @override
  String get autoBackupTitle => 'Automatische Backups';

  @override
  String get autoBackupDescription =>
      'Legt periodisch eine Sicherung im Ordner ab. Derzeitiger Ordner:';

  @override
  String get autoBackupDefaultFolder => 'App-Dokumente/Backups (Standard)';

  @override
  String get autoBackupChooseFolder => 'Ordner wählen';

  @override
  String get autoBackupCopyPath => 'Pfad kopieren';

  @override
  String get autoBackupRunNow => 'Jetzt Auto-Backup prüfen & ausführen';

  @override
  String get snackbarAutoBackupSuccess => 'Auto-Backup durchgeführt.';

  @override
  String get snackbarAutoBackupFailed =>
      'Auto-Backup fehlgeschlagen oder abgebrochen.';

  @override
  String get noUnknownExercisesFound => 'Keine unbekannten Übungen gefunden';

  @override
  String snackbarAutoBackupFolderSet(String path) {
    return 'Auto-Backup-Ordner gesetzt:\n$path';
  }

  @override
  String get snackbarPathCopied => 'Pfad kopiert';

  @override
  String get passwordLabel => 'Passwort';

  @override
  String get descriptionLabel => 'Beschreibung';

  @override
  String get involvedMuscles => 'Involvierte Muskeln';

  @override
  String get primaryLabel => 'Primär:';

  @override
  String get secondaryLabel => 'Sekundär:';

  @override
  String get noMusclesSpecified => 'Keine Muskeln angegeben.';

  @override
  String get noSelection => 'Keine Auswahl';

  @override
  String get selectButton => 'Auswählen';

  @override
  String get applyingChanges => 'Wird angewendet...';

  @override
  String get applyMapping => 'Zuordnung anwenden';

  @override
  String get personalData => 'Persönliche Daten';

  @override
  String get macroDistribution => 'Makronährstoff-Verteilung';

  @override
  String get dialogFinishWorkoutBody =>
      'Möchtest du dieses Workout wirklich abschließen?';

  @override
  String get attributionText =>
      'Diese App verwendet Daten von externen Quellen:\n\n● Übungsdaten und Bilder von wger (wger.de), lizenziert unter der CC-BY-SA 4.0 Lizenz.\n\n● Lebensmittel-Datenbank von Open Food Facts (openfoodfacts.org), verfügbar unter der Open Database License (ODbL).';

  @override
  String get errorRoutineNotFound => 'Routine nicht gefunden';

  @override
  String get workoutHistoryEmptyTitle => 'Dein Verlauf ist leer';

  @override
  String get workoutSummaryTitle => 'Workout Abgeschlossen';

  @override
  String get workoutSummaryExerciseOverview => 'Übersicht der Übungen';

  @override
  String get nutritionDiary => 'Ernährungstagebuch';

  @override
  String get detailedNutrientGoals => 'Detail-Nährwerte';

  @override
  String get supplementTrackerTitle => 'Supplement-Tracker';

  @override
  String get supplementTrackerDescription =>
      'Ziele, Limits und Einnahmen verfolgen.';

  @override
  String get createSupplementTitle => 'Supplement erstellen';

  @override
  String get supplementNameLabel => 'Name des Supplements';

  @override
  String get defaultDoseLabel => 'Standard-Dosis';

  @override
  String get unitLabel => 'Einheit';

  @override
  String get dailyGoalLabel => 'Tagesziel (optional)';

  @override
  String get dailyLimitLabel => 'Tageslimit (optional)';

  @override
  String get dailyProgressTitle => 'Tagesfortschritt';

  @override
  String get todaysLogTitle => 'Heutiges Protokoll';

  @override
  String get logIntakeTitle => 'Einnahme protokollieren';

  @override
  String get emptySupplementGoals =>
      'Lege Ziele oder Limits für Supplements fest, um deinen Fortschritt hier zu sehen.';

  @override
  String get emptySupplementLogs =>
      'Noch keine Einnahmen für heute protokolliert.';

  @override
  String get doseLabel => 'Dosis';

  @override
  String get settingsDescription => 'Thema, Einheiten, Daten und mehr';

  @override
  String get settingsAppearance => 'Erscheinungsbild';

  @override
  String get themeSystem => 'System';

  @override
  String get themeLight => 'Hell';

  @override
  String get themeDark => 'Dunkel';

  @override
  String get caffeinePrompt => 'Koffein (optional)';

  @override
  String get caffeineUnit => 'mg pro 100ml';

  @override
  String get profile => 'Profil';

  @override
  String get measurementWeightCapslock => 'KÖRPERGEWICHT';

  @override
  String get diary => 'Tagebuch';

  @override
  String get analysis => 'Analyse';

  @override
  String get yesterday => 'Gestern';

  @override
  String get dayBeforeYesterday => 'Vorgestern';

  @override
  String get statistics => 'Statistiken';

  @override
  String get workout => 'Workout';

  @override
  String get addFoodTitle => 'Lebensmittel hinzufügen';

  @override
  String get supplement_caffeine => 'Koffein';

  @override
  String get supplement_creatine_monohydrate => 'Kreatin Monohydrat';

  @override
  String get manageSupplementsTitle => 'Supplements verwalten';

  @override
  String get deleted => 'Gelöscht';

  @override
  String get operationNotAllowed => 'Diese Aktion nicht erlaubt.';

  @override
  String get emptySupplements => 'Noch keine Supplements vorhanden';

  @override
  String get undo => 'Rückgängig';

  @override
  String get deleteSupplementConfirm =>
      'Supplement wirklich löschen? Alle zugehörigen Einträge werden entfernt.';

  @override
  String get fieldRequired => 'Pflichtfeld';

  @override
  String get unitNotSupported => 'Einheit wird nicht unterstützt.';

  @override
  String get caffeineUnitLocked => 'Bei Koffein ist die Einheit fest: mg.';

  @override
  String get caffeineMustBeMg => 'Koffein muss in mg erfasst werden.';

  @override
  String get tabCatalogSearch => 'Katalog';

  @override
  String get tabMeals => 'Mahlzeiten';

  @override
  String get emptyCategory => 'Keine Einträge';

  @override
  String get searchSectionBase => 'Grundnahrungsmittel';

  @override
  String get searchSectionOther => 'Weitere Treffer';

  @override
  String get mealsComingSoonTitle => 'Mahlzeiten (in Vorbereitung)';

  @override
  String get mealsComingSoonBody =>
      'Bald kannst du eigene Mahlzeiten aus mehreren Lebensmitteln zusammenstellen.';

  @override
  String get mealsEmptyTitle => 'Noch keine Mahlzeiten';

  @override
  String get mealsEmptyBody =>
      'Lege Mahlzeiten an, um mehrere Lebensmittel mit einem Klick einzutragen.';

  @override
  String get mealsCreate => 'Mahlzeit erstellen';

  @override
  String get mealsEdit => 'Mahlzeit bearbeiten';

  @override
  String get mealsDelete => 'Mahlzeit löschen';

  @override
  String get mealsAddToDiary => 'Zum Tagebuch hinzufügen';

  @override
  String get mealNameLabel => 'Name der Mahlzeit';

  @override
  String get mealNotesLabel => 'Notizen';

  @override
  String get mealIngredientsTitle => 'Zutaten';

  @override
  String get mealAddIngredient => 'Zutat hinzufügen';

  @override
  String get mealIngredientAmountLabel => 'Menge';

  @override
  String get mealDeleteConfirmTitle => 'Mahlzeit löschen';

  @override
  String mealDeleteConfirmBody(Object name) {
    return 'Möchtest du die Mahlzeit \'$name\' wirklich löschen? Alle Zutaten werden ebenfalls entfernt.';
  }

  @override
  String mealAddedToDiary(Object name) {
    return 'Mahlzeit \'$name\' wurde ins Tagebuch übernommen.';
  }

  @override
  String get mealSaved => 'Mahlzeit gespeichert.';

  @override
  String get mealDeleted => 'Mahlzeit gelöscht.';

  @override
  String get confirm => 'bestätigen';

  @override
  String get addMealToDiaryTitle => 'Zum Tagebuch hinzufügen';

  @override
  String get mealTypeLabel => 'Mahlzeit';

  @override
  String get amountLabel => 'Menge';

  @override
  String get mealAddedToDiarySuccess => 'Mahlzeit zum Tagebuch hinzugefügt';

  @override
  String get error => 'Fehler';

  @override
  String get mealsViewTitle => 'mealsViewTitle';

  @override
  String get noNotes => 'Keine Notizen';

  @override
  String get ingredientsCapsLock => 'ZUTATEN';

  @override
  String get nutritionSectionLabel => 'NÄHRWERTE';

  @override
  String get nutritionCalculatedForCurrentAmounts => 'für aktuelle Mengen';

  @override
  String get startCapsLock => 'START';

  @override
  String get nutritionHubSubtitle =>
      'Entdecke Einblicke, verfolge Mahlzeiten und erstelle hier bald deinen Ernährungsplan.';

  @override
  String get nutritionHubTitle => 'Ernährung';

  @override
  String get nutrition => 'Ernährung';
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/generated/app_localizations_en.dart =====

// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for English (`en`).
class AppLocalizationsEn extends AppLocalizations {
  AppLocalizationsEn([String locale = 'en']) : super(locale);

  @override
  String get appTitle => 'Vita';

  @override
  String get bannerText => 'Recommendation / Current Workout';

  @override
  String get calories => 'Calories';

  @override
  String get water => 'Water';

  @override
  String get protein => 'Protein';

  @override
  String get carbs => 'Carbs';

  @override
  String get fat => 'Fat';

  @override
  String get daily => 'Daily';

  @override
  String get today => 'Today';

  @override
  String get workoutSection => 'Workout section - not yet implemented';

  @override
  String get addMenuTitle => 'What do you want to add?';

  @override
  String get addFoodOption => 'Food';

  @override
  String get addLiquidOption => 'Liquid';

  @override
  String get searchHintText => 'Search...';

  @override
  String get mealtypeBreakfast => 'Breakfast';

  @override
  String get mealtypeLunch => 'Lunch';

  @override
  String get mealtypeDinner => 'Dinner';

  @override
  String get mealtypeSnack => 'Snack';

  @override
  String get waterHeader => 'Water & Drinks';

  @override
  String get openFoodFactsSource => 'Data from Open Food Facts';

  @override
  String get tabRecent => 'Recent';

  @override
  String get tabSearch => 'Search';

  @override
  String get tabFavorites => 'Favorites';

  @override
  String get fabCreateOwnFood => 'Custom Food';

  @override
  String get recentEmptyState =>
      'Your recently used food items\nwill appear here.';

  @override
  String get favoritesEmptyState =>
      'You don\'t have any favorites yet.\nMark a food with the heart icon to see it here.';

  @override
  String get searchInitialHint => 'Please enter a search term.';

  @override
  String get searchNoResults => 'No results found.';

  @override
  String get createFoodScreenTitle => 'Create Custom Food';

  @override
  String get formFieldName => 'Name of the food';

  @override
  String get formFieldBrand => 'Brand (optional)';

  @override
  String get formSectionMainNutrients => 'Main Nutrients (per 100g)';

  @override
  String get formFieldCalories => 'Calories (kcal)';

  @override
  String get formFieldProtein => 'Protein (g)';

  @override
  String get formFieldCarbs => 'Carbohydrates (g)';

  @override
  String get formFieldFat => 'Fat (g)';

  @override
  String get formSectionOptionalNutrients =>
      'Additional Nutrients (optional, per 100g)';

  @override
  String get formFieldSugar => 'Of which sugars (g)';

  @override
  String get formFieldFiber => 'Fiber (g)';

  @override
  String get formFieldKj => 'Kilojoules (kJ)';

  @override
  String get formFieldSalt => 'Salt (g)';

  @override
  String get formFieldSodium => 'Sodium (mg)';

  @override
  String get formFieldCalcium => 'Calcium (mg)';

  @override
  String get buttonSave => 'Save';

  @override
  String get validatorPleaseEnterName => 'Please enter a name.';

  @override
  String get validatorPleaseEnterNumber => 'Please enter a valid number.';

  @override
  String snackbarSaveSuccess(String foodName) {
    return '$foodName was saved successfully.';
  }

  @override
  String get foodDetailSegmentPortion => 'Portion';

  @override
  String get foodDetailSegment100g => '100g';

  @override
  String get sugar => 'Sugar';

  @override
  String get fiber => 'Fiber';

  @override
  String get salt => 'Salt';

  @override
  String get explorerScreenTitle => 'Food Explorer';

  @override
  String get nutritionScreenTitle => 'Nutrition Analysis';

  @override
  String get entriesForDateRangeLabel => 'Entries for';

  @override
  String get noEntriesForPeriod => 'No entries for this period yet.';

  @override
  String get waterEntryTitle => 'Water';

  @override
  String get profileScreenTitle => 'Profile';

  @override
  String get profileDailyGoals => 'Daily Goals';

  @override
  String get snackbarGoalsSaved => 'Goals saved successfully!';

  @override
  String get measurementsScreenTitle => 'Measurements';

  @override
  String get measurementsEmptyState =>
      'No measurements recorded yet.\nStart with the \'+\' button.';

  @override
  String get addMeasurementDialogTitle => 'Add New Measurement';

  @override
  String get formFieldMeasurementType => 'Type of Measurement';

  @override
  String formFieldMeasurementValue(Object unit) {
    return 'Value ($unit)';
  }

  @override
  String get validatorPleaseEnterValue => 'Please enter a value';

  @override
  String get measurementWeight => 'Body Weight';

  @override
  String get measurementFatPercent => 'Body Fat';

  @override
  String get measurementNeck => 'Neck';

  @override
  String get measurementShoulder => 'Shoulder';

  @override
  String get measurementChest => 'Chest';

  @override
  String get measurementLeftBicep => 'Left Bicep';

  @override
  String get measurementRightBicep => 'Right Bicep';

  @override
  String get measurementLeftForearm => 'Left Forearm';

  @override
  String get measurementRightForearm => 'Right Forearm';

  @override
  String get measurementAbdomen => 'Abdomen';

  @override
  String get measurementWaist => 'Waist';

  @override
  String get measurementHips => 'Hips';

  @override
  String get measurementLeftThigh => 'Left Thigh';

  @override
  String get measurementRightThigh => 'Right Thigh';

  @override
  String get measurementLeftCalf => 'Left Calf';

  @override
  String get measurementRightCalf => 'Right Calf';

  @override
  String get drawerMenuTitle => 'Vita Menu';

  @override
  String get drawerDashboard => 'Dashboard';

  @override
  String get drawerFoodExplorer => 'Food Explorer';

  @override
  String get drawerDataManagement => 'Data Backup';

  @override
  String get drawerMeasurements => 'Measurements';

  @override
  String get dataManagementTitle => 'Data Backup';

  @override
  String get exportCardTitle => 'Export Data';

  @override
  String get exportCardDescription =>
      'Saves all your journal entries, favorites, and custom foods into a single backup file.';

  @override
  String get exportCardButton => 'Create Backup';

  @override
  String get importCardTitle => 'Import Data';

  @override
  String get importCardDescription =>
      'Restores your data from a previously created backup file. WARNING: All data currently stored in the app will be overwritten!';

  @override
  String get importCardButton => 'Restore Backup';

  @override
  String get recommendationDefault => 'Track your first meal!';

  @override
  String recommendationOverTarget(Object count, Object difference) {
    return 'Last $count days: +$difference kcal over target';
  }

  @override
  String recommendationUnderTarget(Object count, Object difference) {
    return 'Last $count days: $difference kcal under target';
  }

  @override
  String recommendationOnTarget(Object count) {
    return 'Last $count days: Target achieved ✅';
  }

  @override
  String get recommendationFirstEntry => 'Great, your first entry is logged!';

  @override
  String get dialogConfirmTitle => 'Confirmation Required';

  @override
  String get dialogConfirmImportContent =>
      'Do you really want to restore data from this backup?\n\nWARNING: All your current entries, favorites, and custom foods will be permanently deleted and replaced.';

  @override
  String get dialogButtonCancel => 'Cancel';

  @override
  String get dialogButtonOverwrite => 'Yes, overwrite all';

  @override
  String get snackbarNoFileSelected => 'No file selected.';

  @override
  String get snackbarImportSuccessTitle => 'Import successful!';

  @override
  String get snackbarImportSuccessContent =>
      'Your data has been restored. It is recommended to restart the app for a correct display.';

  @override
  String get snackbarButtonOK => 'OK';

  @override
  String get snackbarImportError => 'Error while importing data.';

  @override
  String get snackbarExportSuccess =>
      'Backup file has been passed to the system. Please choose a location to save.';

  @override
  String get snackbarExportFailed => 'Export canceled or failed.';

  @override
  String get profileUserHeight => 'Height (cm)';

  @override
  String get workoutRoutinesTitle => 'Routines';

  @override
  String get workoutHistoryTitle => 'Workout History';

  @override
  String get workoutHistoryButton => 'History';

  @override
  String get emptyRoutinesTitle => 'No Routines Found';

  @override
  String get emptyRoutinesSubtitle =>
      'Create your first routine or start a blank workout.';

  @override
  String get createFirstRoutineButton => 'Create First Routine';

  @override
  String get startEmptyWorkoutButton => 'Free Workout';

  @override
  String get editRoutineSubtitle => 'Tap to edit, or start the workout.';

  @override
  String get startButton => 'Start';

  @override
  String get addRoutineButton => 'New Routine';

  @override
  String get freeWorkoutTitle => 'Free Workout';

  @override
  String get finishWorkoutButton => 'Finish';

  @override
  String get addSetButton => 'Add Set';

  @override
  String get addExerciseToWorkoutButton => 'Add Exercise to Workout';

  @override
  String get lastTimeLabel => 'Last Time';

  @override
  String get setLabel => 'Set';

  @override
  String get kgLabel => 'Weight (kg)';

  @override
  String get repsLabel => 'Reps';

  @override
  String get restTimerLabel => 'Rest';

  @override
  String get skipButton => 'Skip';

  @override
  String get emptyHistory => 'No completed workouts yet.';

  @override
  String get workoutDetailsTitle => 'Workout Details';

  @override
  String get workoutNotFound => 'Workout not found.';

  @override
  String get totalVolumeLabel => 'Total Volume';

  @override
  String get notesLabel => 'Notes';

  @override
  String get hevyImportTitle => 'Hevy Import';

  @override
  String get hevyImportDescription =>
      'Import your entire training history from a Hevy CSV export file.';

  @override
  String get hevyImportButton => 'Import Hevy Data';

  @override
  String hevyImportSuccess(Object count) {
    return 'Successfully imported $count workouts!';
  }

  @override
  String get hevyImportFailed => 'Import failed. Please check the file.';

  @override
  String get startWorkout => 'Start Workout';

  @override
  String get addMeasurement => 'Add Measurement';

  @override
  String get filterToday => 'Today';

  @override
  String get filter7Days => '7 Days';

  @override
  String get filter30Days => '30 Days';

  @override
  String get filterAll => 'All';

  @override
  String get showLess => 'Show less';

  @override
  String get showMoreDetails => 'Show more details';

  @override
  String get deleteConfirmTitle => 'Confirm Deletion';

  @override
  String get deleteConfirmContent => 'Do you really want to delete this entry?';

  @override
  String get cancel => 'Cancel';

  @override
  String get delete => 'Delete';

  @override
  String get save => 'Save';

  @override
  String get tabBaseFoods => 'Base Foods';

  @override
  String get baseFoodsEmptyState =>
      'This section will soon be filled with a curated list of base foods like fruits, vegetables, and more.';

  @override
  String get noBrand => 'No Brand';

  @override
  String get unknown => 'Unknown';

  @override
  String backupFileSubject(String timestamp) {
    return 'Vita App Backup - $timestamp';
  }

  @override
  String foodItemSubtitle(String brand, int calories) {
    return '$brand - $calories kcal / 100g';
  }

  @override
  String foodListSubtitle(int grams, String time) {
    return '${grams}g - $time';
  }

  @override
  String foodListTrailingKcal(int calories) {
    return '$calories kcal';
  }

  @override
  String waterListTrailingMl(int milliliters) {
    return '$milliliters ml';
  }

  @override
  String get exerciseCatalogTitle => 'Exercise Catalog';

  @override
  String get filterByMuscle => 'Filter by muscle group';

  @override
  String get noExercisesFound => 'No exercises found.';

  @override
  String get noDescriptionAvailable => 'No description available.';

  @override
  String get filterByCategory => 'Filter by category';

  @override
  String get edit => 'Edit';

  @override
  String get repsLabelShort => 'reps';

  @override
  String get titleNewRoutine => 'New Routine';

  @override
  String get titleEditRoutine => 'Edit Routine';

  @override
  String get validatorPleaseEnterRoutineName =>
      'Please enter a name for the routine.';

  @override
  String get snackbarRoutineCreated =>
      'Routine created. Now add some exercises.';

  @override
  String get snackbarRoutineSaved => 'Routine saved.';

  @override
  String get formFieldRoutineName => 'Name of the routine';

  @override
  String get emptyStateAddFirstExercise => 'Add your first exercise.';

  @override
  String setCount(int count) {
    String _temp0 = intl.Intl.pluralLogic(
      count,
      locale: localeName,
      other: '$count sets',
      one: '1 set',
    );
    return '$_temp0';
  }

  @override
  String get fabAddExercise => 'Add Exercise';

  @override
  String get kgLabelShort => 'kg';

  @override
  String get drawerExerciseCatalog => 'Exercise Catalog';

  @override
  String get lastWorkoutTitle => 'Last Workout';

  @override
  String get repeatButton => 'Repeat';

  @override
  String get weightHistoryTitle => 'Weight History';

  @override
  String get hideSummary => 'Hide Summary';

  @override
  String get showSummary => 'Show Summary';

  @override
  String get exerciseDataAttribution => 'Exercise data from';

  @override
  String get duplicate => 'Duplicate';

  @override
  String deleteRoutineConfirmContent(String routineName) {
    return 'Are you sure you want to permanently delete the routine \'$routineName\'?';
  }

  @override
  String get editPauseTimeTitle => 'Edit Pause Duration';

  @override
  String get pauseInSeconds => 'Pause in seconds';

  @override
  String get editPauseTime => 'Edit Pause';

  @override
  String pauseDuration(int seconds) {
    return '$seconds second pause';
  }

  @override
  String maxPauseDuration(int seconds) {
    return 'Pauses up to ${seconds}s';
  }

  @override
  String get deleteWorkoutConfirmContent =>
      'Are you sure you want to permanently delete this workout log?';

  @override
  String get removeExercise => 'Remove Exercise';

  @override
  String get deleteExerciseConfirmTitle => 'Remove Exercise?';

  @override
  String deleteExerciseConfirmContent(String exerciseName) {
    return 'Are you sure you want to remove \'$exerciseName\' from this routine?';
  }

  @override
  String get doneButtonLabel => 'Done';

  @override
  String get setRestTimeButton => 'Set rest time';

  @override
  String get deleteExerciseButton => 'Delete exercise';

  @override
  String get restOverLabel => 'Pause is over';

  @override
  String get workoutRunningLabel => 'Workout is active …';

  @override
  String get continueButton => 'Continue';

  @override
  String get discardButton => 'Discard';

  @override
  String get workoutStatsTitle => 'Training (7 days)';

  @override
  String get workoutsLabel => 'Workouts';

  @override
  String get durationLabel => 'Duration';

  @override
  String get volumeLabel => 'Volume';

  @override
  String get setsLabel => 'Sets';

  @override
  String get muscleSplitLabel => 'Muscle Split';

  @override
  String get snackbar_could_not_open_open_link => 'Konnte Link nicht öffnen';

  @override
  String get chart_no_data_for_period => 'Keine Daten für diesen Zeitraum.';

  @override
  String get amount_in_milliliters => 'Menge in Millilitern';

  @override
  String get amount_in_grams => 'Menge in Gramm';

  @override
  String get meal_label => 'Mahlzeit';

  @override
  String get add_to_water_intake => 'Zur Trinkmenge hinzufügen';

  @override
  String get create_exercise_screen_title => 'Eigene Übung erstellen';

  @override
  String get exercise_name_label => 'Name der Übung';

  @override
  String get category_label => 'Kategorie';

  @override
  String get description_optional_label => 'Beschreibung (optional)';

  @override
  String get primary_muscles_label => 'Primäre Muskeln';

  @override
  String get primary_muscles_hint => 'z.B. Brust, Trizeps';

  @override
  String get secondary_muscles_label => 'Sekundäre Muskeln (optional)';

  @override
  String get secondary_muscles_hint => 'z.B. Schultern';

  @override
  String get set_type_normal => 'Normal';

  @override
  String get set_type_warmup => 'Warmup';

  @override
  String get set_type_failure => 'Failure';

  @override
  String get set_type_dropset => 'Dropset';

  @override
  String get set_reps_hint => '8-12';

  @override
  String get data_export_button => 'Export';

  @override
  String get data_import_button => 'Import';

  @override
  String get snackbar_button_ok => 'OK';

  @override
  String get measurement_session_detail_view =>
      'Detailview of measurement session';

  @override
  String get unit_grams => 'g';

  @override
  String get unit_kcal => 'kcal';

  @override
  String get delete_profile_picture_button => 'Delete profile picture';

  @override
  String get attribution_title => 'Attribution';

  @override
  String get add_liquid_title => 'Add fluid';

  @override
  String get add_button => 'Add';

  @override
  String get discard_button => 'Discard';

  @override
  String get continue_workout_button => 'Continue';

  @override
  String get soon_available_snackbar => 'This screen will be available soon';

  @override
  String get start_button => 'Start';

  @override
  String get today_overview_text => 'TODAY IN FOCUS';

  @override
  String get quick_add_text => 'QUICK ADD';

  @override
  String get scann_barcode_capslock => 'Scan barcode';

  @override
  String get protocol_today_capslock => 'TODAY\'S PROTOCOL';

  @override
  String get my_plans_capslock => 'MY PLANS';

  @override
  String get overview_capslock => 'OVERVIEW';

  @override
  String get manage_all_plans => 'Manage all plans';

  @override
  String get free_training => 'free training';

  @override
  String get my_consistency => 'MY CONSISTENCY';

  @override
  String get calendar_currently_not_available =>
      'The calendar view will be available soon.';

  @override
  String get in_depth_analysis => 'IN-DEPTH ANALYSIS';

  @override
  String get body_measurements => 'Body measurements';

  @override
  String get measurements_description =>
      'Analyze weight, body fat percentage and circumference.';

  @override
  String get nutrition_description => 'Evaluate macros, calories and trends.';

  @override
  String get training_analysis => 'Training analysis';

  @override
  String get training_analysis_description =>
      'Track volume, strength and progression.';

  @override
  String get load_dots => 'loading...';

  @override
  String get profile_capslock => 'PROFILE';

  @override
  String get settings_capslock => 'SETTINGS';

  @override
  String get settingsTitle => 'Settings';

  @override
  String get my_goals => 'My goals';

  @override
  String get my_goals_description => 'Adjust calories, macros and water.';

  @override
  String get backup_and_import => 'Data backup & import';

  @override
  String get backup_and_import_description =>
      'Create backups, restore, and import data.';

  @override
  String get about_and_legal_capslock => 'ABOUT & LEGAL';

  @override
  String get attribution_and_license => 'Attribution & Licenses';

  @override
  String get data_from_off_and_wger => 'Data from Open Food Facts and wger.';

  @override
  String get app_version => 'App version';

  @override
  String get all_measurements => 'ALL MEASUREMENTS';

  @override
  String get date_and_time_of_measurement => 'Date & time of measurement';

  @override
  String get onbWelcomeTitle => 'Welcome to Lightweight';

  @override
  String get onbWelcomeBody =>
      'Let’s start by setting personal goals to guide training and nutrition.';

  @override
  String get onbTrackTitle => 'Track everything';

  @override
  String get onbTrackBody =>
      'Log nutrition, workouts, and measurements — all in one place.';

  @override
  String get onbPrivacyTitle => 'Offline-first & privacy';

  @override
  String get onbPrivacyBody =>
      'Your data stays on the device. No cloud accounts, no background sync.';

  @override
  String get onbFinishTitle => 'All set';

  @override
  String get onbFinishBody =>
      'You’re ready to explore the app. You can adjust settings anytime.';

  @override
  String get onbFinishCta => 'Let’s go!';

  @override
  String get onbShowTutorialAgain => 'Show tutorial again';

  @override
  String get onbSetGoalsCta => 'Set goals';

  @override
  String get onbHeaderTitle => 'Tutorial';

  @override
  String get onbHeaderSkip => 'Skip';

  @override
  String get onbBack => 'Back';

  @override
  String get onbNext => 'Next';

  @override
  String get onbGuideTitle => 'How this tutorial works';

  @override
  String get onbGuideBody =>
      'Swipe between slides or use Next. Tap the buttons on each slide to try features. You can finish anytime with Skip.';

  @override
  String get onbCtaOpenNutrition => 'Open nutrition';

  @override
  String get onbCtaLearnMore => 'Learn more';

  @override
  String get onbBadgeDone => 'Done';

  @override
  String get onbTipSetGoals => 'Tip: adjust targets first';

  @override
  String get onbTipAddEntry => 'Tip: add one entry today';

  @override
  String get onbTipLocalControl => 'You control all data locally';

  @override
  String get onbTrackHowBody =>
      'How to log nutrition:\n• Open the Food tab.\n• Tap the + button.\n• Search products or scan a barcode.\n• Adjust portion and time.\n• Save to your diary.';

  @override
  String get onbMeasureTitle => 'Track measurements';

  @override
  String get onbMeasureBody =>
      'How to add measurements:\n• Open the Stats tab.\n• Tap the + button.\n• Choose a metric (e.g., weight, waist, body fat).\n• Enter value and time.\n• Save to your history.';

  @override
  String get onbTipMeasureToday =>
      'Tip: add today’s weight to start your graph';

  @override
  String get onbTrainTitle => 'Train with routines';

  @override
  String get onbTrainBody =>
      'Create a routine and start a workout:\n• Open the Train tab.\n• Tap Create routine to add exercises and sets.\n• Save the routine.\n• Tap Start to begin, or use “Start empty workout”.';

  @override
  String get onbTipStartWorkout =>
      'Tip: start an empty workout to log a quick session';

  @override
  String get unitsSection => 'units';

  @override
  String get weightUnit => 'Weight units';

  @override
  String get lengthUnit => 'unit of length';

  @override
  String get comingSoon => 'Coming soon';

  @override
  String get noFavorites => 'No Favorites';

  @override
  String get nothingTrackedYet => 'Nothing tracked yet';

  @override
  String snackbarBarcodeNotFound(String barcode) {
    return 'No product found for barcode \"$barcode\".';
  }

  @override
  String get categoryHint => 'e.g. Chest, Back, Legs...';

  @override
  String get validatorPleaseEnterCategory => 'Please enter a category.';

  @override
  String get dialogEnterPasswordImport => 'Enter password to import backup';

  @override
  String get dataManagementBackupTitle => 'Lightweight Data Backup';

  @override
  String get dataManagementBackupDescription =>
      'Back up or restore all your app data. Ideal for changing devices.';

  @override
  String get exportEncrypted => 'Export Encrypted';

  @override
  String get dialogPasswordForExport => 'Password for encrypted export';

  @override
  String get snackbarEncryptedBackupShared => 'Encrypted backup shared.';

  @override
  String get exportFailed => 'Export failed.';

  @override
  String get csvExportTitle => 'Data Export (CSV)';

  @override
  String get csvExportDescription =>
      'Export parts of your data as a CSV file for analysis in other programs.';

  @override
  String get snackbarSharingNutrition => 'Sharing nutrition diary...';

  @override
  String get snackbarExportFailedNoEntries =>
      'Export failed. There may be no entries yet.';

  @override
  String get snackbarSharingMeasurements => 'Sharing measurements...';

  @override
  String get snackbarSharingWorkouts => 'Sharing workout history...';

  @override
  String get mapExercisesTitle => 'Map Exercises';

  @override
  String get mapExercisesDescription =>
      'Map unknown names from logs to wger exercises.';

  @override
  String get mapExercisesButton => 'Start Mapping';

  @override
  String get autoBackupTitle => 'Automatic Backups';

  @override
  String get autoBackupDescription =>
      'Periodically saves a backup in the folder. Current folder:';

  @override
  String get autoBackupDefaultFolder => 'App-Documents/Backups (Default)';

  @override
  String get autoBackupChooseFolder => 'Choose Folder';

  @override
  String get autoBackupCopyPath => 'Copy Path';

  @override
  String get autoBackupRunNow => 'Check & Run Auto-Backup Now';

  @override
  String get snackbarAutoBackupSuccess => 'Auto-Backup completed.';

  @override
  String get snackbarAutoBackupFailed => 'Auto-Backup failed or was canceled.';

  @override
  String get noUnknownExercisesFound => 'No unknown exercises found';

  @override
  String snackbarAutoBackupFolderSet(String path) {
    return 'Auto-backup folder set:\n$path';
  }

  @override
  String get snackbarPathCopied => 'Path copied';

  @override
  String get passwordLabel => 'Password';

  @override
  String get descriptionLabel => 'Description';

  @override
  String get involvedMuscles => 'Involved Muscles';

  @override
  String get primaryLabel => 'Primary:';

  @override
  String get secondaryLabel => 'Secondary:';

  @override
  String get noMusclesSpecified => 'No muscles specified.';

  @override
  String get noSelection => 'No selection';

  @override
  String get selectButton => 'Select';

  @override
  String get applyingChanges => 'Applying changes...';

  @override
  String get applyMapping => 'Apply Mapping';

  @override
  String get personalData => 'Personal Data';

  @override
  String get macroDistribution => 'Macronutrient Distribution';

  @override
  String get dialogFinishWorkoutBody =>
      'Are you sure you want to finish this workout?';

  @override
  String get attributionText =>
      'This app uses data from external sources:\n\n● Exercise data and images from wger (wger.de), licensed under CC-BY-SA 4.0.\n\n● Food database from Open Food Facts (openfoodfacts.org), available under the Open Database License (ODbL).';

  @override
  String get errorRoutineNotFound => 'Routine not found';

  @override
  String get workoutHistoryEmptyTitle => 'Your history is empty';

  @override
  String get workoutSummaryTitle => 'Workout Complete';

  @override
  String get workoutSummaryExerciseOverview => 'Exercise Overview';

  @override
  String get nutritionDiary => 'Diary';

  @override
  String get detailedNutrientGoals => 'Detailed Nutrients';

  @override
  String get supplementTrackerTitle => 'Supplement Tracker';

  @override
  String get supplementTrackerDescription => 'Track goals, limits, and intake.';

  @override
  String get createSupplementTitle => 'Create Supplement';

  @override
  String get supplementNameLabel => 'Supplement Name';

  @override
  String get defaultDoseLabel => 'Default Dose';

  @override
  String get unitLabel => 'Unit';

  @override
  String get dailyGoalLabel => 'Daily Goal (optional)';

  @override
  String get dailyLimitLabel => 'Daily Limit (optional)';

  @override
  String get dailyProgressTitle => 'Daily Progress';

  @override
  String get todaysLogTitle => 'Today\'s Log';

  @override
  String get logIntakeTitle => 'Log Intake';

  @override
  String get emptySupplementGoals =>
      'Set goals or limits for supplements to see your progress here.';

  @override
  String get emptySupplementLogs => 'No intake logged for today yet.';

  @override
  String get doseLabel => 'Dose';

  @override
  String get settingsDescription => 'Theme, units, data and more';

  @override
  String get settingsAppearance => 'Appearance';

  @override
  String get themeSystem => 'System';

  @override
  String get themeLight => 'Light';

  @override
  String get themeDark => 'Dark';

  @override
  String get caffeinePrompt => 'Caffeine (optional)';

  @override
  String get caffeineUnit => 'mg per 100ml';

  @override
  String get profile => 'Profile';

  @override
  String get measurementWeightCapslock => 'BODY WEIGHT';

  @override
  String get diary => 'Diary';

  @override
  String get analysis => 'Analysis';

  @override
  String get yesterday => 'Yesterday';

  @override
  String get dayBeforeYesterday => 'Two days ago';

  @override
  String get statistics => 'Statistics';

  @override
  String get workout => 'Workout';

  @override
  String get addFoodTitle => 'add food';

  @override
  String get supplement_caffeine => 'Caffeine';

  @override
  String get supplement_creatine_monohydrate => 'Creatine Monohydrate';

  @override
  String get manageSupplementsTitle => 'Manage supplements';

  @override
  String get deleted => 'deleted';

  @override
  String get operationNotAllowed => 'This operation isn\'t allowed';

  @override
  String get emptySupplements => 'No supplements available';

  @override
  String get undo => 'Rückgängig';

  @override
  String get deleteSupplementConfirm =>
      'Are you sure you want to delete this supplement? All related entries will be removed.';

  @override
  String get fieldRequired => 'Required';

  @override
  String get unitNotSupported => 'Unit not supported.';

  @override
  String get caffeineUnitLocked => 'For caffeine the unit is fixed: mg.';

  @override
  String get caffeineMustBeMg => 'Caffeine must be recorded in mg.';

  @override
  String get tabCatalogSearch => 'Catalog';

  @override
  String get tabMeals => 'Meals';

  @override
  String get emptyCategory => 'No entries';

  @override
  String get searchSectionBase => 'Base foods';

  @override
  String get searchSectionOther => 'Other results';

  @override
  String get mealsComingSoonTitle => 'Meals (coming soon)';

  @override
  String get mealsComingSoonBody =>
      'Soon you will be able to create your own meals from multiple foods.';

  @override
  String get mealsEmptyTitle => 'No meals yet';

  @override
  String get mealsEmptyBody =>
      'Create meals to quickly log multiple foods at once.';

  @override
  String get mealsCreate => 'Create meal';

  @override
  String get mealsEdit => 'Edit meal';

  @override
  String get mealsDelete => 'Delete meal';

  @override
  String get mealsAddToDiary => 'Add to diary';

  @override
  String get mealNameLabel => 'Meal name';

  @override
  String get mealNotesLabel => 'Notes';

  @override
  String get mealIngredientsTitle => 'Ingredients';

  @override
  String get mealAddIngredient => 'Add ingredient';

  @override
  String get mealIngredientAmountLabel => 'Amount';

  @override
  String get mealDeleteConfirmTitle => 'Delete meal';

  @override
  String mealDeleteConfirmBody(Object name) {
    return 'Are you sure you want to delete the meal \'$name\'? All its ingredients will also be removed.';
  }

  @override
  String mealAddedToDiary(Object name) {
    return 'Meal \'$name\' has been added to your diary.';
  }

  @override
  String get mealSaved => 'Meal saved.';

  @override
  String get mealDeleted => 'Meal deleted.';

  @override
  String get confirm => 'Confirm';

  @override
  String get addMealToDiaryTitle => 'Add to diary';

  @override
  String get mealTypeLabel => 'Meal';

  @override
  String get amountLabel => 'Amount';

  @override
  String get mealAddedToDiarySuccess => 'Meal added to diary';

  @override
  String get error => 'Error';

  @override
  String get mealsViewTitle => 'mealsViewTitle';

  @override
  String get noNotes => 'No notes';

  @override
  String get ingredientsCapsLock => 'INGREDIENTS';

  @override
  String get nutritionSectionLabel => 'NUTRITION FACTS';

  @override
  String get nutritionCalculatedForCurrentAmounts => 'for current quantities';

  @override
  String get startCapsLock => 'START';

  @override
  String get nutritionHubSubtitle =>
      'Discover insights, track meals, and plan your nutrition here soon.';

  @override
  String get nutritionHubTitle => 'Nutrition';

  @override
  String get nutrition => 'nutrition';
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/time_util.dart =====

// lib/util/time_util.dart

/// Formatiert eine Duration in einen String wie "HH:MM:SS" oder "MM:SS".
String formatDuration(Duration d) {
  // .abs() stellt sicher, dass wir keine negativen Werte anzeigen,
  // falls es zu kleinen Zeit-Inkonsistenzen kommt.
  d = d.abs();

  var seconds = d.inSeconds;
  final hours = seconds ~/ Duration.secondsPerHour;
  seconds -= hours * Duration.secondsPerHour;
  final minutes = seconds ~/ Duration.secondsPerMinute;
  seconds -= minutes * Duration.secondsPerMinute;

  final hoursString = hours > 0 ? '${hours.toString()}:' : '';
  final minutesString = minutes.toString().padLeft(2, '0');
  final secondsString = seconds.toString().padLeft(2, '0');

  return '$hoursString$minutesString:$secondsString';
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/encryption_util.dart =====

// lib/util/encryption_util.dart
import 'dart:convert';
import 'dart:math';
import 'package:cryptography/cryptography.dart';

class EncryptionUtil {
  static final _algo = AesGcm.with256bits();
  static const wrapperVersion = 'LWENC-1';

  static Future<Map<String, dynamic>> encryptString(
      String plaintext, String passphrase) async {
    final salt = _randomBytes(16);
    final nonce = _randomBytes(12);
    final key = await _deriveKey(passphrase, salt);
    final box = await _algo.encrypt(
      utf8.encode(plaintext),
      secretKey: key,
      nonce: nonce,
    );
    return {
      'enc': wrapperVersion,
      'salt': base64Encode(salt),
      'nonce': base64Encode(nonce),
      'cipher': base64Encode(box.cipherText),
      'mac': base64Encode(box.mac.bytes),
    };
  }

  static Future<String> decryptToString(
      Map<String, dynamic> wrapper, String passphrase) async {
    if (wrapper['enc'] != wrapperVersion) {
      throw ArgumentError('Unknown encryption wrapper');
    }
    final salt = base64Decode(wrapper['salt'] as String);
    final nonce = base64Decode(wrapper['nonce'] as String);
    final cipher = base64Decode(wrapper['cipher'] as String);
    final mac = Mac(base64Decode(wrapper['mac'] as String));
    final key = await _deriveKey(passphrase, salt);
    final clear = await _algo.decrypt(
      SecretBox(cipher, nonce: nonce, mac: mac),
      secretKey: key,
    );
    return utf8.decode(clear);
  }

  static Future<SecretKey> _deriveKey(String passphrase, List<int> salt) async {
    final pbkdf2 = Pbkdf2(
      macAlgorithm: Hmac.sha256(),
      iterations: 150000,
      bits: 256,
    );
    return await pbkdf2.deriveKey(
      secretKey: SecretKey(utf8.encode(passphrase)),
      nonce: salt,
    );
  }

  static List<int> _randomBytes(int length) {
    final rnd = Random.secure();
    return List<int>.generate(length, (_) => rnd.nextInt(256));
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/util_convert.dart =====

// lib/util/unit_convert.dart
double convert(double value, String from, String to) {
  if (from == to) return value;
  if (from == 'g' && to == 'mg') return value * 1000.0;
  if (from == 'mg' && to == 'g') return value / 1000.0;
  if (from == 'l' && to == 'ml') return value * 1000.0;
  if (from == 'ml' && to == 'l') return value / 1000.0;
  // sonst keine Konvertierung
  return value;
}

// Empfehlungs-Liste zulässiger Einheiten:
const allowedUnits = <String>['mg', 'g', 'IU', 'ml', 'l'];


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/date_util.dart =====

// lib/util/date_util.dart

extension DateOnlyCompare on DateTime {
  bool isSameDate(DateTime other) {
    return year == other.year && month == other.month && day == other.day;
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/l10n_ext.dart =====

// lib/util/l10n_ext.dart
import 'package:flutter/widgets.dart';
import 'package:lightweight/generated/app_localizations.dart';

// Bestehende Extension für den BuildContext
extension L10nX on BuildContext {
  AppLocalizations get l10n => AppLocalizations.of(this)!;
}

// NEU: Extension für die AppLocalizations-Klasse
extension AppLocalizationsX on AppLocalizations {
  String getLocalizedMeasurementName(String key) {
    switch (key) {
      case 'weight':
        return measurementWeight;
      case 'fat_percent':
        return measurementFatPercent;
      case 'neck':
        return measurementNeck;
      case 'shoulder':
        return measurementShoulder;
      case 'chest':
        return measurementChest;
      case 'left_bicep':
        return measurementLeftBicep;
      case 'right_bicep':
        return measurementRightBicep;
      case 'left_forearm':
        return measurementLeftForearm;
      case 'right_forearm':
        return measurementRightForearm;
      case 'abdomen':
        return measurementAbdomen;
      case 'waist':
        return measurementWaist;
      case 'hips':
        return measurementHips;
      case 'left_thigh':
        return measurementLeftThigh;
      case 'right_thigh':
        return measurementRightThigh;
      case 'left_calf':
        return measurementLeftCalf;
      case 'right_calf':
        return measurementRightCalf;
      default:
        return key;
    }
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/design_constants.dart =====

// lib/util/design_constants.dart
import 'package:flutter/material.dart';

class DesignConstants {
  // === SPACING ===
  // Card Padding
  static const double cardPaddingInternal = 16.0; // Innenabstand von Cards
  static const double cardPaddingExternal = 8.0; // Außenabstand zwischen Cards

  // General Spacing
  static const double spacingXS = 4.0; // Sehr kleine Abstände
  static const double spacingS = 8.0; // Kleine Abstände
  static const double spacingM = 12.0; // Mittlere Abstände
  static const double spacingL = 16.0; // Standard-Abstände
  static const double spacingXL = 24.0; // Große Abstände
  static const double spacingXXL = 32.0; // Sehr große Abstände

  // Screen Padding
  static const double screenPaddingHorizontal = 16.0;
  static const double screenPaddingVertical = 8.0;

  // === BORDER RADIUS ===
  static const double borderRadiusS = 8.0; // Kleine Rundung
  static const double borderRadiusM = 12.0; // Standard Rundung
  static const double borderRadiusL = 16.0; // Große Rundung

  // === LIST SPACING ===
  static const double listItemSpacing = 8.0;
  static const double listSectionSpacing = 24.0;

  // === BUTTON SPACING ===
  static const double buttonPadding = 16.0;
  static const double buttonSpacing = 12.0;

  // === ICON SIZES ===
  static const double iconSizeS = 16.0;
  static const double iconSizeM = 20.0;
  static const double iconSizeL = 24.0;
  static const double iconSizeXL = 32.0;

  // === EDGE INSETS SHORTCUTS ===
  static const EdgeInsets cardPadding = EdgeInsets.all(cardPaddingInternal);
  static const EdgeInsets cardMargin =
      EdgeInsets.symmetric(vertical: cardPaddingExternal);
  static const EdgeInsets screenPadding = EdgeInsets.symmetric(
    horizontal: screenPaddingHorizontal,
    vertical: screenPaddingVertical,
  );
  static const EdgeInsets listPadding = EdgeInsets.all(spacingL);
  static const EdgeInsets buttonContentPadding = EdgeInsets.symmetric(
    horizontal: buttonPadding,
    vertical: spacingM,
  );
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/supplement_l10n.dart =====

// lib/util/supplement_l10n.dart
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/supplement.dart';

String localizeSupplementName(Supplement s, AppLocalizations l10n) {
  switch (s.code) {
    case 'caffeine':
      return l10n.supplement_caffeine;
    case 'creatine_monohydrate':
      return l10n.supplement_creatine_monohydrate;
    default:
      return s.name;
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/mapping_prefs.dart =====

// lib/util/mapping_prefs.dart
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';

class MappingPrefs {
  static const _kKey = 'exercise_name_mappings_v1';

  // Lädt Map<externalName, targetName> (case-insensitive Lookup via normalize).
  static Future<Map<String, String>> load() async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_kKey);
    if (raw == null || raw.isEmpty) return {};
    try {
      final Map<String, dynamic> m = jsonDecode(raw);
      return m.map((k, v) => MapEntry(_norm(k), (v as String?)?.trim() ?? ''));
    } catch (_) {
      return {};
    }
  }

  // Fügt/aktualisiert Einträge und speichert als JSON-String.
  static Future<void> upsert(Map<String, String> entries) async {
    if (entries.isEmpty) return;
    final prefs = await SharedPreferences.getInstance();
    final current = await load();
    entries.forEach((k, v) {
      final key = _norm(k);
      final val = (v).trim();
      if (val.isNotEmpty) current[key] = val;
    });
    await prefs.setString(_kKey, jsonEncode(current));
  }

  // Holt eine Zielzuordnung, falls vorhanden.
  static Future<String?> lookup(String externalName) async {
    final m = await load();
    return m[_norm(externalName)];
  }

  static String _norm(String s) => s.trim().toLowerCase();
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/config/dev_flags.dart =====

//import 'package:flutter/material.dart';

const bool kDevEditEnabled = true;


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/exercise.dart =====

// lib/models/exercise.dart

import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';

class Exercise {
  final int? id;
  final String nameDe;
  final String nameEn;
  final String descriptionDe;
  final String descriptionEn;
  final String categoryName;
  final List<String> primaryMuscles;
  final List<String> secondaryMuscles;

  Exercise({
    this.id,
    required this.nameDe,
    required this.nameEn,
    required this.descriptionDe,
    required this.descriptionEn,
    required this.categoryName,
    required this.primaryMuscles,
    required this.secondaryMuscles,
  });

  String getLocalizedName(BuildContext context) {
    final locale = Localizations.localeOf(context);
    return locale.languageCode == 'de' ? nameDe : nameEn;
  }

  String getLocalizedDescription(BuildContext context) {
    final locale = Localizations.localeOf(context);
    final desc = locale.languageCode == 'de' ? descriptionDe : descriptionEn;
    // Fallback, falls eine Beschreibung leer ist
    if (desc.trim().isEmpty) {
      return AppLocalizations.of(context)!.noDescriptionAvailable;
    }
    return desc;
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name_de': nameDe,
      'name_en': nameEn,
      'description_de': descriptionDe,
      'description_en': descriptionEn,
      'category_name': categoryName,
      'primaryMuscles': jsonEncode(primaryMuscles),
      'secondaryMuscles': jsonEncode(secondaryMuscles),
    };
  }

  factory Exercise.fromMap(Map<String, dynamic> map) {
    // Diese Hilfsfunktion wandelt den JSON-String aus der DB in eine List<String> um
    List<String> parseMuscles(String? jsonString) {
      if (jsonString == null || jsonString.isEmpty) return [];
      try {
        // jsonDecode kann eine List<dynamic> zurückgeben, daher der cast.
        return (jsonDecode(jsonString) as List)
            .map((item) => item.toString())
            .toList();
      } catch (e) {
        return []; // Im Fehlerfall leere Liste zurückgeben
      }
    }

    return Exercise(
      id: map['id'],
      nameDe: map['name_de'] ?? '',
      nameEn: map['name_en'] ?? '',
      descriptionDe: map['description_de'] ?? '',
      descriptionEn: map['description_en'] ?? '',
      categoryName: map['category_name'] ?? '',
      // KORREKTUR: Schlüsselnamen auf camelCase ('primaryMuscles') geändert
      primaryMuscles: parseMuscles(map['primaryMuscles']),
      secondaryMuscles: parseMuscles(map['secondaryMuscles']),
    );
  }

  Exercise copyWith({int? id}) {
    return Exercise(
      id: id ?? this.id,
      nameDe: nameDe,
      nameEn: nameEn,
      descriptionDe: descriptionDe,
      descriptionEn: descriptionEn,
      categoryName: categoryName,
      primaryMuscles: primaryMuscles,
      secondaryMuscles: secondaryMuscles,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/lightweight_backup.dart =====

// lib/models/lightweight_backup.dart

import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/measurement.dart';
import 'package:lightweight/models/measurement_session.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/models/routine_exercise.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/set_template.dart';
import 'package:lightweight/models/fluid_entry.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';

class LightweightBackup {
  final int schemaVersion;
  final List<FoodEntry> foodEntries;
  final List<FluidEntry> fluidEntries;
  final List<String> favoriteBarcodes;
  final List<FoodItem> customFoodItems;
  final List<MeasurementSession> measurementSessions;
  final List<Routine> routines;
  final List<WorkoutLog> workoutLogs;
  // HINZUGEFÜGT: Ein Feld für die Benutzereinstellungen
  final Map<String, dynamic> userPreferences;
  final List<Supplement> supplements;
  final List<SupplementLog> supplementLogs;

  LightweightBackup({
    required this.schemaVersion,
    required this.foodEntries,
    required this.fluidEntries,
    required this.favoriteBarcodes,
    required this.customFoodItems,
    required this.measurementSessions,
    required this.routines,
    required this.workoutLogs,
    required this.userPreferences, // HINZUGEFÜGT
    required this.supplements, // NEU
    required this.supplementLogs, // NEU
  });

  // KORRIGIERTE VERSION
  factory LightweightBackup.fromJson(Map<String, dynamic> json) {
    return LightweightBackup(
      schemaVersion: json['schemaVersion'] as int? ?? 1,
      foodEntries: (json['foodEntries'] as List<dynamic>?)
              ?.map((e) => FoodEntry(
                    id: e['id'],
                    barcode: e['barcode'],
                    timestamp: DateTime.parse(e['timestamp']),
                    quantityInGrams: e['quantity_in_grams'],
                    mealType: e['meal_type'],
                  ))
              .toList() ??
          [],
      fluidEntries: (json['fluidEntries'] as List<dynamic>?)
              ?.map((e) => FluidEntry.fromMap(e as Map<String, dynamic>))
              .toList() ??
          [],
      favoriteBarcodes: List<String>.from(json['favoriteBarcodes'] ?? []),
      customFoodItems: (json['customFoodItems'] as List<dynamic>?)
              ?.map((e) => FoodItem.fromMap(e as Map<String, dynamic>,
                  source: FoodItemSource.user))
              .toList() ??
          [],
      measurementSessions: (json['measurementSessions'] as List<dynamic>?)
              ?.map((s) {
            final sessionMap = s as Map<String, dynamic>;
            final measurements = (sessionMap['measurements'] as List<dynamic>?)
                    ?.map((m) => Measurement.fromMap(m as Map<String, dynamic>))
                    .toList() ??
                [];
            return MeasurementSession(
              id: sessionMap['id'],
              timestamp: DateTime.parse(sessionMap['timestamp']),
              measurements: measurements,
            );
          }).toList() ??
          [],

      // KORRIGIERT: Detaillierte Deserialisierung für Routinen
      routines: (json['routines'] as List<dynamic>?)?.map((r) {
            final routineMap = r as Map<String, dynamic>;
            return Routine(
              id: routineMap['id'],
              name: routineMap['name'],
              exercises: (routineMap['exercises'] as List<dynamic>?)?.map((re) {
                    final reMap = re as Map<String, dynamic>;
                    return RoutineExercise(
                      id: reMap['id'],
                      // Rekursiver Aufruf der .fromMap Konstruktoren
                      exercise: Exercise.fromMap(
                          reMap['exercise'] as Map<String, dynamic>),
                      setTemplates: (reMap['setTemplates'] as List<dynamic>?)
                              ?.map((st) => SetTemplate.fromMap(
                                  st as Map<String, dynamic>))
                              .toList() ??
                          [],
                      pauseSeconds: reMap['pause_seconds'],
                    );
                  }).toList() ??
                  [],
            );
          }).toList() ??
          [],

      workoutLogs: (json['workoutLogs'] as List<dynamic>?)?.map((log) {
            final logMap = log as Map<String, dynamic>;
            final sets = (logMap['sets'] as List<dynamic>?)
                    ?.map((set) => SetLog.fromMap(set as Map<String, dynamic>))
                    .toList() ??
                [];
            return WorkoutLog.fromMap(logMap, sets: sets);
          }).toList() ??
          [],
      userPreferences: Map<String, dynamic>.from(json['userPreferences'] ?? {}),
      supplements: (json['supplements'] as List<dynamic>?)
              ?.map((e) => Supplement.fromMap(e as Map<String, dynamic>))
              .toList() ??
          [],
      supplementLogs: (json['supplementLogs'] as List<dynamic>?)
              ?.map((e) => SupplementLog.fromMap(e as Map<String, dynamic>))
              .toList() ??
          [],
    );
  }

  // Diese Methode nutzt jetzt die .toMap() Methoden deiner Modelle
  Map<String, dynamic> toJson() {
    return {
      'schemaVersion': schemaVersion,
      'foodEntries': foodEntries.map((e) => e.toMap()).toList(),
      'fluidEntries': fluidEntries.map((e) => e.toMap()).toList(),
      'favoriteBarcodes': favoriteBarcodes,
      'customFoodItems': customFoodItems.map((e) => e.toMap()).toList(),
      'measurementSessions': measurementSessions
          .map((s) => {
                'id': s.id,
                'timestamp': s.timestamp.toIso8601String(),
                'measurements': s.measurements.map((m) => m.toMap()).toList(),
              })
          .toList(),
      // Platzhalter für die komplexe Serialisierung von Routinen
      'routines': routines.map((r) => r.toMap()).toList(),
      'workoutLogs': workoutLogs
          .map((log) => {
                ...log.toMap(), // Nutzt die existierende toMap-Methode
                'sets': log.sets
                    .map((s) => s.toMap())
                    .toList(), // Hängt die Sets an
              })
          .toList(),
      'userPreferences': userPreferences,
      'supplements': supplements.map((e) => e.toMap()).toList(),
      'supplementLogs': supplementLogs.map((e) => e.toMap()).toList(),
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/workout_log.dart =====

// lib/models/workout_log.dart

import 'package:lightweight/models/set_log.dart';

class WorkoutLog {
  final int? id;
  final String? routineName;
  final DateTime startTime;
  final DateTime? endTime;
  final String? notes;
  final List<SetLog> sets;

  WorkoutLog({
    this.id,
    this.routineName,
    required this.startTime,
    this.endTime,
    this.notes,
    this.sets = const [],
  });

  factory WorkoutLog.fromMap(Map<String, dynamic> map,
      {List<SetLog> sets = const []}) {
    return WorkoutLog(
      id: map['id'],
      routineName: map['routine_name'],
      startTime: DateTime.parse(map['start_time'] as String),
      endTime: map['end_time'] != null
          ? DateTime.parse(map['end_time'] as String)
          : null,
      notes: map['notes'],
      sets: sets,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'routine_name': routineName,
      'start_time': startTime.toIso8601String(),
      'end_time': endTime?.toIso8601String(),
      'notes': notes,
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/food_entry.dart =====

// lib/models/food_entry.dart

class FoodEntry {
  final int? id;
  final String barcode;
  final DateTime timestamp;
  final int quantityInGrams;
  final String mealType;

  FoodEntry({
    this.id,
    required this.barcode,
    required this.timestamp,
    required this.quantityInGrams,
    required this.mealType,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'barcode': barcode,
      'timestamp': timestamp.toIso8601String(),
      'quantity_in_grams': quantityInGrams,
      'meal_type': mealType,
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/daily_nutrition.dart =====

// lib/models/daily_nutrition.dart

class DailyNutrition {
  // Verbrauchte Nährwerte
  int calories;
  int water;
  int protein;
  int carbs;
  int fat;
  double fiber;
  double sugar;
  double salt;
  double caffeine;

  // Ziele
  int targetCalories;
  int targetWater;
  int targetProtein;
  int targetCarbs;
  int targetFat;

  // DOC: NEUE ZIELFELDER
  int targetSugar;
  int targetFiber;
  int targetSalt;
  int targetCaffeine;

  DailyNutrition({
    this.calories = 0,
    this.water = 0,
    this.protein = 0,
    this.carbs = 0,
    this.fat = 0,
    this.fiber = 0.0,
    this.sugar = 0.0,
    this.salt = 0.0,
    this.caffeine = 0.0,
    this.targetCalories = 0,
    this.targetWater = 0,
    this.targetProtein = 0,
    this.targetCarbs = 0,
    this.targetFat = 0,

    // DOC: Initialisierung der neuen Ziele
    this.targetSugar = 0,
    this.targetFiber = 0,
    this.targetSalt = 0,
    this.targetCaffeine = 0,
  });
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/water_entry.dart =====

class WaterEntry {
  final int? id;
  final DateTime timestamp;
  final int quantityInMl;

  WaterEntry({
    this.id,
    required this.timestamp,
    required this.quantityInMl,
  });

  factory WaterEntry.fromMap(Map<String, dynamic> map) {
    return WaterEntry(
      id: map['id'],
      timestamp: DateTime.parse(map['timestamp']),
      quantityInMl: map['quantity_in_ml'],
    );
  }
  // DOC: DIESE METHODE HINZUFÜGEN
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'timestamp': timestamp.toIso8601String(),
      'quantity_in_ml': quantityInMl,
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/supplement_log.dart =====

// lib/models/supplement_log.dart

class SupplementLog {
  final int? id;
  final int supplementId;
  final double dose;
  final String unit;
  final DateTime timestamp;
  // --- KORREKTUR START ---
  final int? source_food_entry_id;
  final int? source_fluid_entry_id;

  SupplementLog({
    this.id,
    required this.supplementId,
    required this.dose,
    required this.unit,
    required this.timestamp,
    this.source_food_entry_id, // Jetzt als optionaler Parameter verfügbar
    this.source_fluid_entry_id, // Jetzt als optionaler Parameter verfügbar
  });
  // --- KORREKTUR ENDE ---

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'supplement_id': supplementId,
      'dose': dose,
      'unit': unit,
      'timestamp': timestamp.toIso8601String(),
      // --- KORREKTUR START ---
      'source_food_entry_id': source_food_entry_id,
      'source_fluid_entry_id': source_fluid_entry_id,
      // --- KORREKTUR ENDE ---
    };
  }

  factory SupplementLog.fromMap(Map<String, dynamic> map) {
    return SupplementLog(
      id: map['id'],
      supplementId: map['supplement_id'],
      dose: map['dose'],
      unit: map['unit'],
      timestamp: DateTime.parse(map['timestamp']),
      // --- KORREKTUR START ---
      source_food_entry_id: map['source_food_entry_id'],
      source_fluid_entry_id: map['source_fluid_entry_id'],
      // --- KORREKTUR ENDE ---
    );
  }
}

===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/tracked_supplement.dart =====

// lib/models/tracked_supplement.dart
import 'package:lightweight/models/supplement.dart';

class TrackedSupplement {
  final Supplement supplement;
  final double totalDosedToday;

  const TrackedSupplement({
    required this.supplement,
    required this.totalDosedToday,
  });
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/measurement_session.dart =====

// lib/models/measurement_session.dart
import 'package:lightweight/models/measurement.dart';

class MeasurementSession {
  final int? id;
  final DateTime timestamp;
  final List<Measurement> measurements; // Hält die Detailwerte

  MeasurementSession({
    this.id,
    required this.timestamp,
    this.measurements = const [],
  });
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/routine_exercise.dart =====

// lib/models/routine_exercise.dart

import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/set_template.dart';

class RoutineExercise {
  final int? id;
  final Exercise exercise;
  List<SetTemplate> setTemplates;
  final int? pauseSeconds; // NEUES FELD

  RoutineExercise({
    this.id,
    required this.exercise,
    this.setTemplates = const [],
    this.pauseSeconds, // NEUES FELD
  });

  // BITTE DIESE METHODE HINZUFÜGEN ODER ERSETZEN
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'exercise': exercise.toMap(), // Annahme: Exercise hat eine toMap-Methode
      'setTemplates': setTemplates.map((st) => st.toMap()).toList(),
      'pause_seconds': pauseSeconds,
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/chart_data_point.dart =====

// lib/models/chart_data_point.dart

class ChartDataPoint {
  final DateTime date;
  final double value;

  ChartDataPoint({required this.date, required this.value});
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/measurement.dart =====

// lib/models/measurement.dart

class Measurement {
  final int? id;
  final int sessionId;
  final String type;
  final double value;
  final String unit;

  Measurement({
    this.id,
    required this.sessionId,
    required this.type,
    required this.value,
    required this.unit,
  });

  factory Measurement.fromMap(Map<String, dynamic> map) {
    return Measurement(
      id: map['id'],
      sessionId: map['session_id'],
      type: map['type'],
      value: map['value'],
      unit: map['unit'],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'session_id': sessionId,
      'type': type,
      'value': value,
      'unit': unit,
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/fluid_entry.dart =====

// lib/models/fluid_entry.dart

class FluidEntry {
  final int? id;
  final DateTime timestamp;
  final int quantityInMl;
  final String name;
  final int? kcal;
  final double? sugarPer100ml;
  final double? carbsPer100ml;
  final double? caffeinePer100ml;
  final int? linked_food_entry_id; // *** NEU ***

  FluidEntry({
    this.id,
    required this.timestamp,
    required this.quantityInMl,
    required this.name,
    this.kcal,
    this.sugarPer100ml,
    this.carbsPer100ml,
    this.caffeinePer100ml,
    this.linked_food_entry_id, // *** NEU ***
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'timestamp': timestamp.toIso8601String(),
      'quantity_in_ml': quantityInMl,
      'name': name,
      'kcal': kcal,
      'sugar_per_100ml': sugarPer100ml,
      'carbs_per_100ml': carbsPer100ml,
      'caffeine_per_100ml': caffeinePer100ml,
      'linked_food_entry_id': linked_food_entry_id, // *** NEU ***
    };
  }

  static FluidEntry fromMap(Map<String, dynamic> map) {
    return FluidEntry(
      id: map['id'],
      timestamp: DateTime.parse(map['timestamp']),
      quantityInMl: map['quantity_in_ml'],
      name: map['name'],
      kcal: map['kcal'],
      sugarPer100ml: map['sugar_per_100ml'],
      carbsPer100ml: map['carbs_per_100ml'],
      caffeinePer100ml: map['caffeine_per_100ml'],
      linked_food_entry_id: map['linked_food_entry_id'], // *** NEU ***
    );
  }
}

===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/supplement.dart =====

// lib/models/supplement.dart
class Supplement {
  final int? id;
  final String? code; // <— NEU, optional
  final String name;
  final double defaultDose;
  final String unit;
  final double? dailyGoal;
  final double? dailyLimit;
  final String? notes;
  final bool isBuiltin; // <— NEU

  Supplement({
    this.id,
    this.code,
    required this.name,
    required this.defaultDose,
    required this.unit,
    this.dailyGoal,
    this.dailyLimit,
    this.notes,
    this.isBuiltin = false,
  });

  factory Supplement.fromMap(Map<String, dynamic> map) {
    return Supplement(
      id: map['id'] as int?,
      code: map['code'] as String?, // NEU
      name: map['name'] as String,
      defaultDose: (map['default_dose'] as num).toDouble(),
      unit: map['unit'] as String,
      dailyGoal: (map['daily_goal'] as num?)?.toDouble(),
      dailyLimit: (map['daily_limit'] as num?)?.toDouble(),
      notes: map['notes'] as String?,
      isBuiltin: (map['is_builtin'] as int? ?? 0) == 1, // NEU
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'code': code, // NEU
      'name': name,
      'default_dose': defaultDose,
      'unit': unit,
      'daily_goal': dailyGoal,
      'daily_limit': dailyLimit,
      'notes': notes,
      'is_builtin': isBuiltin ? 1 : 0, // NEU
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/set_log.dart =====

// lib/models/set_log.dart
// VOLLSTÄNDIGER CODE

class SetLog {
  final int? id;
  final int workoutLogId;
  final String exerciseName;
  final String setType;
  final double? weightKg;
  final int? reps;
  final int? restTimeSeconds;
  final bool?
      isCompleted; // WAR bool?, ist es schon, perfekt. Keine Änderung nötig.
  final int? log_order;
  final String? notes;
  final double? distanceKm;
  final int? durationSeconds;
  final int? rpe;
  final int? supersetId;

  SetLog({
    this.id,
    required this.workoutLogId,
    required this.exerciseName,
    required this.setType,
    this.weightKg,
    this.reps,
    this.restTimeSeconds,
    this.isCompleted,
    this.log_order,
    this.notes,
    this.distanceKm,
    this.durationSeconds,
    this.rpe,
    this.supersetId,
  });

  factory SetLog.fromMap(Map<String, dynamic> map) {
    return SetLog(
      id: map['id'],
      workoutLogId: map['workout_log_id'],
      exerciseName: map['exercise_name'],
      setType: map['set_type'],
      weightKg: map['weight_kg'],
      reps: map['reps'],
      restTimeSeconds: map['rest_time_seconds'],
      // MODIFIKATION: isCompleted kann null sein, wir mappen 1 zu true, alles andere (0, null) zu false.
      isCompleted: map['is_completed'] == 1,
      log_order: map['log_order'],
      notes: map['notes'],
      distanceKm: map['distance_km'],
      durationSeconds: map['duration_seconds'],
      rpe: map['rpe'],
      supersetId: map['superset_id'],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'workout_log_id': workoutLogId,
      'exercise_name': exerciseName,
      'set_type': setType,
      'weight_kg': weightKg,
      'reps': reps,
      'rest_time_seconds': restTimeSeconds,
      // MODIFIKATION: Speichere true als 1, false/null als 0.
      'is_completed': isCompleted == true ? 1 : 0,
      'log_order': log_order,
      'notes': notes,
      'distance_km': distanceKm,
      'duration_seconds': durationSeconds,
      'rpe': rpe,
      'superset_id': supersetId,
    };
  }

  SetLog copyWith({
    int? id,
    int? workoutLogId,
    String? exerciseName,
    String? setType,
    double? weightKg,
    int? reps,
    int? restTimeSeconds,
    bool? isCompleted,
    int? log_order,
    String? notes,
    double? distanceKm,
    int? durationSeconds,
    int? rpe,
    int? supersetId,
  }) {
    return SetLog(
      id: id ?? this.id,
      workoutLogId: workoutLogId ?? this.workoutLogId,
      exerciseName: exerciseName ?? this.exerciseName,
      setType: setType ?? this.setType,
      weightKg: weightKg ?? this.weightKg,
      reps: reps ?? this.reps,
      restTimeSeconds: restTimeSeconds ?? this.restTimeSeconds,
      isCompleted: isCompleted ?? this.isCompleted,
      log_order: log_order ?? this.log_order,
      notes: notes ?? this.notes,
      distanceKm: distanceKm ?? this.distanceKm,
      durationSeconds: durationSeconds ?? this.durationSeconds,
      rpe: rpe ?? this.rpe,
      supersetId: supersetId ?? this.supersetId,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/timeline_entry.dart =====

// lib/models/timeline_entry.dart

import 'package:lightweight/models/tracked_food_item.dart';
import 'package:lightweight/models/water_entry.dart';

// DOC: Dies ist eine "abstrakte" Klasse. Sie dient als gemeinsame
// Schablone für alle Arten von Einträgen in unserem Tagebuch.
// Jedes Timeline-Item MUSS einen Zeitstempel haben, damit wir es sortieren können.
abstract class TimelineEntry {
  DateTime get timestamp;
}

// Ein Eintrag für ein Lebensmittel
class FoodTimelineEntry extends TimelineEntry {
  final TrackedFoodItem trackedItem;
  FoodTimelineEntry(this.trackedItem);

  @override
  DateTime get timestamp => trackedItem.entry.timestamp;
}

// Ein Eintrag für Wasser
class WaterTimelineEntry extends TimelineEntry {
  final WaterEntry waterEntry;
  WaterTimelineEntry(this.waterEntry);

  @override
  DateTime get timestamp => waterEntry.timestamp;
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/tracked_food_item.dart =====

import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/food_item.dart';

// DOC: Diese Klasse ist ein reines "Anzeige-Modell". Sie kombiniert die Daten
// aus zwei verschiedenen Quellen (unserem Tagebucheintrag und dem Produktkatalog),
// damit die UI sie einfach an einem Ort abgreifen kann.
class TrackedFoodItem {
  final FoodEntry
      entry; // Der eigentliche Tagebucheintrag (mit ID, Menge, Zeit)
  final FoodItem
      item; // Die Details des Lebensmittels (mit Name, Kalorien etc.)

  TrackedFoodItem({
    required this.entry,
    required this.item,
  });

  // Eine kleine Helfer-Eigenschaft, um die berechneten Kalorien für diesen Eintrag zu bekommen.
  int get calculatedCalories {
    return (item.calories / 100 * entry.quantityInGrams).round();
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/routine.dart =====

// lib/models/routine.dart
import 'package:lightweight/models/routine_exercise.dart';

class Routine {
  final int? id;
  final String name;
  final List<RoutineExercise> exercises;

  Routine({
    this.id,
    required this.name,
    this.exercises = const [],
  });

  // BITTE DIESE METHODE HINZUFÜGEN
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'exercises': exercises.map((re) => re.toMap()).toList(),
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/set_template.dart =====

// lib/models/set_template.dart

class SetTemplate {
  final int? id;
  final String setType;
  final String? targetReps;
  final double? targetWeight;

  SetTemplate({
    this.id,
    required this.setType,
    this.targetReps,
    this.targetWeight,
  });

  factory SetTemplate.fromMap(Map<String, dynamic> map) {
    return SetTemplate(
      id: map['id'],
      setType: map['set_type'] ?? 'normal',
      targetReps: map['target_reps'],
      targetWeight: map['target_weight'],
    );
  }

  // In lib/models/set_template.dart
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'set_type': setType,
      'target_reps': targetReps,
      'target_weight': targetWeight,
    };
  }

  // NEUE, BENÖTIGTE METHODE
  // Erstellt eine Kopie des Objekts und überschreibt nur die übergebenen Werte.
  SetTemplate copyWith({
    int? id,
    String? setType,
    String? targetReps,
    double? targetWeight,
  }) {
    return SetTemplate(
      id: id ?? this.id,
      setType: setType ?? this.setType,
      targetReps: targetReps ?? this.targetReps,
      targetWeight: targetWeight ?? this.targetWeight,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/food_item.dart =====

// lib/models/food_item.dart

enum FoodItemSource {
  off, // Open Food Facts
  base, // Grundnahrungsmittel-DB
  user // Vom Benutzer erstellt (Standard)
}

class FoodItem {
  final String barcode;
  final String name;
  final String brand;
  final int calories; // pro 100g
  final double protein; // pro 100g
  final double carbs; // pro 100g
  final double fat; // pro 100g
  final FoodItemSource source;

  final double? kj;
  final double? fiber;
  final double? sugar;
  final double? salt;
  final double? sodium;
  final double? calcium;
  final bool? isLiquid; // NEW (nullable)
  final double? caffeineMgPer100ml; // NEW (nullable)

  FoodItem({
    required this.barcode,
    required this.name,
    this.brand = '',
    required this.calories,
    required this.protein,
    required this.carbs,
    required this.fat,
    this.source = FoodItemSource.user,
    this.kj,
    this.fiber,
    this.sugar,
    this.salt,
    this.sodium,
    this.calcium,
    this.isLiquid,
    this.caffeineMgPer100ml,
  });

  factory FoodItem.fromMap(Map<String, dynamic> map,
      {required FoodItemSource source}) {
    return FoodItem(
      barcode: map['barcode'] ?? '',
      // KORREKTUR: Kein hartcodierter Fallback mehr. Die UI kümmert sich darum.
      name: map['name'] ?? '',
      brand: map['brand'] ?? '',
      calories: (map['calories_100g'] as num?)?.round() ?? 0,
      protein: (map['protein_100g'] as num?)?.toDouble() ?? 0.0,
      carbs: (map['carbs_100g'] as num?)?.toDouble() ?? 0.0,
      fat: (map['fat_100g'] as num?)?.toDouble() ?? 0.0,
      source: source,
      kj: (map['kj_100g'] as num?)?.toDouble(),
      fiber: (map['fiber_100g'] as num?)?.toDouble(),
      sugar: (map['sugar_100g'] as num?)?.toDouble(),
      salt: (map['salt_100g'] as num?)?.toDouble(),
      sodium: (map['sodium_100g'] as num?)?.toDouble(),
      calcium: (map['calcium_100g'] as num?)?.toDouble(),
      isLiquid: _readBool(map['is_liquid']),
      caffeineMgPer100ml: _toDoubleOrNull(map['caffeine_mg_per_100ml']),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'barcode': barcode,
      'name': name,
      'brand': brand,
      'calories_100g': calories,
      'protein_100g': protein,
      'carbs_100g': carbs,
      'fat_100g': fat,
      'kj_100g': kj,
      'fiber_100g': fiber,
      'sugar_100g': sugar,
      'salt_100g': salt,
      'sodium_100g': sodium,
      'calcium_100g': calcium,
      'is_liquid': (isLiquid == null) ? null : (isLiquid! ? 1 : 0),
      'caffeine_mg_per_100ml': caffeineMgPer100ml,
    };
  }

  static bool? _readBool(dynamic v) {
    if (v == null) return null;
    if (v is bool) return v;
    if (v is num) return v != 0;
    if (v is String) {
      final s = v.toLowerCase().trim();
      return s == '1' || s == 'true' || s == 'yes';
    }
    return null;
  }

  static double? _toDoubleOrNull(dynamic v) {
    if (v == null) return null;
    if (v is num) return v.toDouble();
    if (v is String) return double.tryParse(v.replaceAll(',', '.'));
    return null;
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/nutrition_screen.dart =====

// lib/screens/nutrition_screen.dart (Final & De-Materialisiert - Endgültige Korrektur)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/dialogs/fluid_dialog_content.dart';
import 'package:lightweight/models/fluid_entry.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/dialogs/quantity_dialog_content.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/tracked_food_item.dart';
import 'package:lightweight/models/timeline_entry.dart';
import 'package:lightweight/services/ui_state_service.dart';
import 'package:lightweight/widgets/nutrition_summary_widget.dart';
import 'package:lightweight/widgets/summary_card.dart';
import './food_detail_screen.dart';
import 'package:lightweight/util/date_util.dart';

class NutritionScreen extends StatefulWidget {
  const NutritionScreen({super.key});

  @override
  State<NutritionScreen> createState() => _NutritionScreenState();
}

class FluidTimelineEntry extends TimelineEntry {
  final FluidEntry fluidEntry;

  FluidTimelineEntry(this.fluidEntry);

  @override
  DateTime get timestamp => fluidEntry.timestamp;
}

class _NutritionScreenState extends State<NutritionScreen> {
  DailyNutrition? _nutritionData;
  List<dynamic> _displayItems = [];
  bool _isLoading = true;
  DateTimeRange _selectedDateRange = DateTime.now().isSameDate(DateTime.now())
      ? DateTimeRange(
          start: DateTime.now(), end: DateTime.now()) // Einzeltag für heute
      : DateTimeRange(
          start: DateTime.now().subtract(const Duration(days: 6)),
          end: DateTime.now()); // Standard: Letzte 7 Tage
  bool _isSummaryExpanded = UiStateService.instance.isNutritionSummaryExpanded;
  String _selectedRangeKey = '1D';
  bool _isHeaderVisible = true;

  @override
  void initState() {
    super.initState();
    _loadEntriesForDateRange(_selectedDateRange);
  }

  Future<void> _loadEntriesForDateRange(DateTimeRange range) async {
    if (!mounted) return;
    setState(() {
      _isLoading = true;
    });

    final prefs = await SharedPreferences.getInstance();
    final targetCalories = prefs.getInt('targetCalories') ?? 2500;
    final targetProtein = prefs.getInt('targetProtein') ?? 180;
    final targetCarbs = prefs.getInt('targetCarbs') ?? 250;
    final targetFat = prefs.getInt('targetFat') ?? 80;
    final targetWater = prefs.getInt('targetWater') ?? 3000;
    final targetSugar = prefs.getInt('targetSugar') ?? 50;
    final targetFiber = prefs.getInt('targetFiber') ?? 30;
    final targetSalt = prefs.getInt('targetSalt') ?? 6;
    final targetCaffeine = prefs.getInt('targetCaffeine') ?? 400;

    final foodEntries = await DatabaseHelper.instance
        .getEntriesForDateRange(range.start, range.end);
    final fluidEntries = await DatabaseHelper.instance
        .getFluidEntriesForDateRange(range.start, range.end);
    final supplementLogs = await DatabaseHelper.instance.getAllSupplementLogs(); // Annahme: Methode existiert
    final supplements = await DatabaseHelper.instance.getAllSupplements();
    
    final caffeineSupplementId = supplements.firstWhere((s) => s.code == 'caffeine').id;


    final numberOfDays = range.duration.inDays + 1;
    final newNutritionSummary = DailyNutrition(
      targetCalories: targetCalories * numberOfDays,
      targetProtein: targetProtein * numberOfDays,
      targetCarbs: targetCarbs * numberOfDays,
      targetFat: targetFat * numberOfDays,
      targetWater: targetWater * numberOfDays,
      targetSugar: targetSugar * numberOfDays,
      targetFiber: targetFiber * numberOfDays,
      targetSalt: targetSalt * numberOfDays,
      targetCaffeine: targetCaffeine * numberOfDays,
    );

    final List<FoodTimelineEntry> foodTimeline = [];
    for (final entry in foodEntries) {
      final foodItem = await ProductDatabaseHelper.instance
          .getProductByBarcode(entry.barcode);
      if (foodItem != null) {
        final factor = entry.quantityInGrams / 100.0;
        newNutritionSummary.calories += (foodItem.calories * factor).round();
        newNutritionSummary.protein += (foodItem.protein * factor).round();
        newNutritionSummary.carbs += (foodItem.carbs * factor).round();
        newNutritionSummary.fat += (foodItem.fat * factor).round();
        newNutritionSummary.sugar += (foodItem.sugar ?? 0) * factor;
        newNutritionSummary.fiber += (foodItem.fiber ?? 0) * factor;
        newNutritionSummary.salt += (foodItem.salt ?? 0) * factor;
        foodTimeline.add(
            FoodTimelineEntry(TrackedFoodItem(entry: entry, item: foodItem)));
      }
    }

    // *** KORREKTURBLOCK START ***
    // Nährwerte aus Flüssigkeiten zur Summe addieren
    newNutritionSummary.water = fluidEntries.fold(0, (sum, entry) => sum + entry.quantityInMl);
    for (final entry in fluidEntries) {
        final factor = entry.quantityInMl / 100.0;
        newNutritionSummary.calories += entry.kcal ?? 0;
        newNutritionSummary.carbs += ((entry.carbsPer100ml ?? 0) * factor).round();
        newNutritionSummary.sugar += (entry.sugarPer100ml ?? 0) * factor;
    }

    // Koffein aus Supplement-Logs berechnen
    if (caffeineSupplementId != null) {
        final relevantLogs = supplementLogs.where((log) =>
            log.supplementId == caffeineSupplementId &&
            log.timestamp.isAfter(range.start) &&
            log.timestamp.isBefore(range.end));
        newNutritionSummary.caffeine = relevantLogs.fold(0.0, (sum, log) => sum + log.dose);
    }
    
    final fluidTimeline = fluidEntries.map((e) => FluidTimelineEntry(e)).toList();
    // *** KORREKTURBLOCK ENDE ***


    final List<dynamic> finalDisplayList = [];

    if (range.duration.inDays == 0) {
      // ... (Rest der Methode bleibt unverändert)
      final Map<String, List<FoodTimelineEntry>> groupedFood = {};
      for (final entry in foodTimeline) {
        final mealType = entry.trackedItem.entry.mealType;
        if (groupedFood.containsKey(mealType)) {
          groupedFood[mealType]!.add(entry);
        } else {
          groupedFood[mealType] = [entry];
        }
      }

      const mealOrder = [
        "mealtypeBreakfast",
        "mealtypeLunch",
        "mealtypeDinner",
        "mealtypeSnack"
      ];
      for (final mealKey in mealOrder) {
        if (groupedFood.containsKey(mealKey)) {
          finalDisplayList.add(mealKey);
          groupedFood[mealKey]!
              .sort((a, b) => b.timestamp.compareTo(a.timestamp));
          finalDisplayList.addAll(groupedFood[mealKey]!);
        }
      }

      if (fluidTimeline.isNotEmpty) {
        finalDisplayList.add("fluidsHeader");
        fluidTimeline.sort((a, b) => b.timestamp.compareTo(a.timestamp));
        finalDisplayList.addAll(fluidTimeline);
      }
    } else {
      final List<TimelineEntry> combinedList = [
        ...foodTimeline,
        ...fluidTimeline
      ];
      combinedList.sort((a, b) => b.timestamp.compareTo(a.timestamp));

      DateTime? lastDate;
      for (final entry in combinedList) {
        final entryDate = entry.timestamp;
        if (lastDate == null || !entryDate.isSameDate(lastDate)) {
          finalDisplayList.add(entryDate);
          lastDate = entryDate;
        }
        finalDisplayList.add(entry);
      }
    }

    if (mounted) {
      setState(() {
        _nutritionData = newNutritionSummary;
        _displayItems = finalDisplayList;
        _isLoading = false;
      });
    }
  }

  void _navigateDay(bool forward) {
    final currentDay = _selectedDateRange.start;
    final newDay = currentDay.add(Duration(days: forward ? 1 : -1));
    // Navigation über den heutigen Tag hinaus verhindern
    if (forward && newDay.isAfter(DateTime.now())) return;

    setState(() {
      _selectedDateRange = DateTimeRange(start: newDay, end: newDay);
      _selectedRangeKey = 'custom'; // De-selektiert die Filter-Chips
    });
    _loadEntriesForDateRange(_selectedDateRange);
  }

  Future<void> _setTimeRange(String key) async {
    setState(() => _selectedRangeKey = key);
    final now = DateTime.now();
    DateTime start;
    DateTime end = DateTime(now.year, now.month, now.day, 23, 59, 59);

    switch (key) {
      case '1W':
        start = now.subtract(const Duration(days: 6));
        break;
      case '1M':
        start = now.subtract(const Duration(days: 29));
        break;
      case 'All':
        final earliest =
            await DatabaseHelper.instance.getEarliestFoodEntryDate();
        start = earliest ?? now;
        break;
      case '1D':
      default:
        start = now;
    }

    final normalizedStart = DateTime(start.year, start.month, start.day);
    setState(() =>
        _selectedDateRange = DateTimeRange(start: normalizedStart, end: end));
    _loadEntriesForDateRange(_selectedDateRange);
  }

  Future<void> _deleteFoodEntry(int id) async {
    await DatabaseHelper.instance.deleteFoodEntry(id);
    _loadEntriesForDateRange(_selectedDateRange);
  }

  Future<void> _deleteFluidEntry(int id) async {
    await DatabaseHelper.instance.deleteFluidEntry(id);
    _loadEntriesForDateRange(_selectedDateRange);
  }

  Future<void> _editFoodEntry(TrackedFoodItem trackedItem) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<QuantityDialogContentState> dialogStateKey = GlobalKey();

    final result = await showDialog<(int, DateTime, String, double?)?>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(trackedItem.item.name,
              maxLines: 2, overflow: TextOverflow.ellipsis),
          content: QuantityDialogContent(
            key: dialogStateKey,
            item: trackedItem.item,
            initialQuantity: trackedItem.entry.quantityInGrams,
            initialTimestamp: trackedItem.entry.timestamp,
            initialMealType: trackedItem.entry.mealType,
          ),
          actions: [
            TextButton(
                child: Text(l10n.cancel),
                onPressed: () => Navigator.of(context).pop()),
            FilledButton(
                child: Text(l10n.save),
                onPressed: () {
                  final state = dialogStateKey.currentState;
                  if (state != null) {
                    final quantity = int.tryParse(state.quantityText);
                    if (quantity != null && quantity > 0) {
                      Navigator.of(context).pop((
                        quantity,
                        state.selectedDateTime,
                        state.selectedMealType,
                        double.tryParse(state.caffeineText.replaceAll(',', '.'))
                      ));
                    }
                  }
                }),
          ],
        );
      },
    );

    if (result != null) {
      final updatedEntry = FoodEntry(
        id: trackedItem.entry.id,
        barcode: trackedItem.item.barcode,
        quantityInGrams: result.$1,
        timestamp: result.$2,
        mealType: result.$3,
      );
      await DatabaseHelper.instance.updateFoodEntry(updatedEntry);
      _loadEntriesForDateRange(_selectedDateRange);
    }
  }

  Future<void> _editFluidEntry(FluidEntry fluidEntry) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<FluidDialogContentState> dialogStateKey = GlobalKey();

    final result = await showDialog<(String, int, double?, double?)?>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(l10n.waterEntryTitle),
          content: FluidDialogContent(
            key: dialogStateKey,
            initialQuantity: fluidEntry.quantityInMl,
            initialTimestamp: fluidEntry.timestamp,
          ),
          actions: [
            TextButton(
                child: Text(l10n.cancel),
                onPressed: () => Navigator.of(context).pop()),
            FilledButton(
                child: Text(l10n.save),
                onPressed: () {
                  final state = dialogStateKey.currentState;
                  if (state != null) {
                    final quantity = int.tryParse(state.quantityText);
                    if (quantity != null && quantity > 0) {
                      Navigator.of(context).pop((
                        state.nameText,
                        quantity,
                        double.tryParse(state.sugarText.replaceAll(',', '.')),
                        double.tryParse(state.caffeineText.replaceAll(',', '.'))
                      ));
                    }
                  }
                }),
          ],
        );
      },
    );

    if (result != null) {
      final sugarPer100ml = result.$3;
      final quantity = result.$2;
      final kcal = (sugarPer100ml != null) ? ((sugarPer100ml / 100) * quantity * 4).round() : null;

      final updatedEntry = FluidEntry(
        id: fluidEntry.id,
        name: result.$1,
        quantityInMl: quantity,
        kcal: kcal,
        sugarPer100ml: sugarPer100ml,
        caffeinePer100ml: result.$4,
        timestamp: fluidEntry.timestamp,
      );
      await DatabaseHelper.instance.updateFluidEntry(updatedEntry);
      _loadEntriesForDateRange(_selectedDateRange);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    final locale = Localizations.localeOf(context).toString();

    final rangeText = _selectedDateRange.duration.inDays == 0
        ? DateFormat.yMMMMd(locale).format(_selectedDateRange.start)
        : "${DateFormat.yMMMMd(locale).format(_selectedDateRange.start)} - ${DateFormat.yMMMMd(locale).format(_selectedDateRange.end)}";

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          l10n.nutritionScreenTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: SafeArea(
        top: true,
        child: Stack(
          children: [
            Column(
              children: [
                Container(
                  color: Theme.of(context).scaffoldBackgroundColor,
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                        horizontal: 16.0, vertical: 0.0),
                    //padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 24.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        //SizedBox(height: DesignConstants.spacingL), // <- DIESE ZEILE
                        //SizedBox(height: DesignConstants.spacingXL),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            IconButton(
                                icon: const Icon(Icons.chevron_left),
                                onPressed: () => _navigateDay(false)),
                            Expanded(
                              child: InkWell(
                                onTap: () async {
                                  final picked = await showDateRangePicker(
                                      context: context,
                                      initialDateRange: _selectedDateRange,
                                      firstDate: DateTime(2020),
                                      lastDate: DateTime.now());
                                  if (picked != null) {
                                    setState(() {
                                      _selectedDateRange = picked;
                                      _selectedRangeKey = 'custom';
                                    });
                                    _loadEntriesForDateRange(picked);
                                  }
                                },
                                child: Text(
                                  rangeText,
                                  style: textTheme.titleMedium
                                      ?.copyWith(fontWeight: FontWeight.bold),
                                  textAlign: TextAlign.center,
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ),
                            IconButton(
                                icon: const Icon(Icons.chevron_right),
                                onPressed: _selectedDateRange.end
                                        .isSameDate(DateTime.now())
                                    ? null
                                    : () => _navigateDay(true)),
                          ],
                        ),
                        const SizedBox(height: DesignConstants.spacingL),
                        Row(
                          children: [
                            _buildFilterButton(l10n.filterToday, '1D'),
                            _buildFilterButton(l10n.filter7Days, '1W'),
                            _buildFilterButton(l10n.filter30Days, '1M'),
                            _buildFilterButton(l10n.filterAll, 'All'),
                          ],
                        ),
                        const SizedBox(
                            height: DesignConstants.spacingL), // <- DIESE ZEILE
                      ],
                    ),
                  ),
                ),
                Divider(
                    height: 1,
                    thickness: 1,
                    color: colorScheme.onSurfaceVariant.withOpacity(0.1)),
                AnimatedSize(
                  duration: const Duration(milliseconds: 300),
                  curve: Curves.easeInOut,
                  child: _isHeaderVisible
                      ? Column(
                          children: [
                            if (_nutritionData != null)
                              Column(
                                children: [
                                  // KORREKTUR: NutritionSummaryWidget in einem Padding, das dem horizontalen ListView-Padding entspricht.
                                  Padding(
                                    padding: const EdgeInsets.symmetric(
                                        horizontal:
                                            16.0), // <- Dieser Padding ist wichtig!
                                    child: NutritionSummaryWidget(
                                        nutritionData: _nutritionData!,
                                        isExpandedView: _isSummaryExpanded,
                                        l10n: l10n),
                                  ),
                                  Row(
                                    mainAxisAlignment:
                                        MainAxisAlignment.spaceEvenly,
                                    children: [
                                      TextButton(
                                        onPressed: () {
                                          setState(() {
                                            _isSummaryExpanded =
                                                !_isSummaryExpanded;
                                            UiStateService.instance
                                                    .isNutritionSummaryExpanded =
                                                _isSummaryExpanded;
                                          });
                                        },
                                        child: Text(_isSummaryExpanded
                                            ? l10n.showLess
                                            : l10n.showMoreDetails),
                                      ),
                                      TextButton(
                                        onPressed: () => setState(
                                            () => _isHeaderVisible = false),
                                        child: Text(l10n.hideSummary),
                                      ),
                                    ],
                                  ),
                                ],
                              ),
                          ],
                        )
                      : Align(
                          alignment: Alignment.centerRight,
                          child: Padding(
                            padding:
                                const EdgeInsets.symmetric(horizontal: 16.0),
                            child: TextButton(
                              onPressed: () =>
                                  setState(() => _isHeaderVisible = true),
                              child: Text(l10n.showSummary),
                            ),
                          ),
                        ),
                ),
                Divider(
                    height: 1,
                    thickness: 1,
                    color: colorScheme.onSurfaceVariant.withOpacity(0.1)),
                Expanded(
                  child: _displayItems.isEmpty
                      ? Center(child: Text(l10n.noEntriesForPeriod))
                      : ListView.separated(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 16.0, vertical: 8.0),
                          itemCount: _displayItems.length,
                          separatorBuilder: (context, index) => const SizedBox(
                              height: DesignConstants
                                  .spacingM), // KORREKTUR: Trenner
                          itemBuilder: (context, index) {
                            final item = _displayItems[index];

                            String getLocalizedMealName(String key) {
                              switch (key) {
                                case "mealtypeBreakfast":
                                  return l10n.mealtypeBreakfast;
                                case "mealtypeLunch":
                                  return l10n.mealtypeLunch;
                                case "mealtypeDinner":
                                  return l10n.mealtypeDinner;
                                case "mealtypeSnack":
                                  return l10n.mealtypeSnack;
                                case "fluidsHeader":
                                  return l10n.waterHeader;
                                default:
                                  return key;
                              }
                            }

                            if (item is DateTime) {
                              return Padding(
                                padding: const EdgeInsets.only(
                                    top: 24.0, bottom: 8.0, left: 8.0),
                                child: Text(
                                  DateFormat.yMMMMEEEEd(locale).format(item),
                                  style: textTheme.titleLarge?.copyWith(
                                      fontWeight: FontWeight.bold,
                                      color: colorScheme.primary),
                                ),
                              );
                            }

                            if (item is String) {
                              return Padding(
                                padding: const EdgeInsets.only(
                                    top: 24.0, bottom: 8.0, left: 8.0),
                                child: Text(getLocalizedMealName(item),
                                    style: textTheme.titleLarge?.copyWith(
                                        fontWeight: FontWeight.bold)),
                              );
                            }

                            if (item is FoodTimelineEntry) {
                              final trackedItem = item.trackedItem;
                              return Dismissible(
                                key: Key('food_${trackedItem.entry.id}'),
                                direction: DismissDirection.horizontal,
                                background: const SwipeActionBackground(
                                  color: Colors.blueAccent,
                                  icon: Icons.edit,
                                  alignment: Alignment.centerLeft,
                                ),
                                secondaryBackground:
                                    const SwipeActionBackground(
                                  color: Colors.redAccent,
                                  icon: Icons.delete,
                                  alignment: Alignment.centerRight,
                                ),
                                confirmDismiss: (direction) async {
                                  if (direction ==
                                      DismissDirection.startToEnd) {
                                    _editFoodEntry(trackedItem);
                                    return false;
                                  } else {
                                    return await showDialog(
                                          context: context,
                                          builder: (BuildContext context) {
                                            return AlertDialog(
                                              title:
                                                  Text(l10n.deleteConfirmTitle),
                                              content: Text(
                                                  l10n.deleteConfirmContent),
                                              actions: <Widget>[
                                                TextButton(
                                                    onPressed: () =>
                                                        Navigator.of(context)
                                                            .pop(false),
                                                    child: Text(l10n.cancel)),
                                                TextButton(
                                                    onPressed: () =>
                                                        Navigator.of(context)
                                                            .pop(true),
                                                    child: Text(l10n.delete)),
                                              ],
                                            );
                                          },
                                        ) ??
                                        false;
                                  }
                                },
                                onDismissed: (direction) {
                                  if (direction ==
                                      DismissDirection.endToStart) {
                                    _deleteFoodEntry(trackedItem.entry.id!);
                                  }
                                },
                                child: SummaryCard(
                                  //externalMargin: EdgeInsets.zero,
                                  child: ListTile(
                                    leading: const Icon(Icons.restaurant),
                                    title: Text(trackedItem.item.name),
                                    subtitle: Text(l10n.foodListSubtitle(
                                        trackedItem.entry.quantityInGrams,
                                        DateFormat.Hm(locale).format(
                                            trackedItem.entry.timestamp))),
                                    trailing: Text(l10n.foodListTrailingKcal(
                                        trackedItem.calculatedCalories)),
                                    onTap: () => Navigator.of(context)
                                        .push(MaterialPageRoute(
                                            builder: (context) =>
                                                FoodDetailScreen(
                                                    trackedItem: trackedItem)))
                                        .then((_) => _loadEntriesForDateRange(
                                            _selectedDateRange)),
                                  ),
                                ),
                              );
                            }

                            if (item is FluidTimelineEntry) {
                              final fluidEntry = item.fluidEntry;
                              return Dismissible(
                                key: Key('fluid_${fluidEntry.id}'),
                                direction: DismissDirection.horizontal,
                                background: const SwipeActionBackground(
                                  color: Colors.blueAccent,
                                  icon: Icons.edit,
                                  alignment: Alignment.centerLeft,
                                ),
                                secondaryBackground:
                                    const SwipeActionBackground(
                                  color: Colors.redAccent,
                                  icon: Icons.delete,
                                  alignment: Alignment.centerRight,
                                ),
                                confirmDismiss: (direction) async {
                                  if (direction ==
                                      DismissDirection.startToEnd) {
                                    _editFluidEntry(fluidEntry);
                                    return false;
                                  } else {
                                    return await showDialog<bool>(
                                          context: context,
                                          builder: (BuildContext context) {
                                            return AlertDialog(
                                              title:
                                                  Text(l10n.deleteConfirmTitle),
                                              content: Text(
                                                  l10n.deleteConfirmContent),
                                              actions: <Widget>[
                                                TextButton(
                                                    onPressed: () =>
                                                        Navigator.of(context)
                                                            .pop(false),
                                                    child: Text(l10n.cancel)),
                                                TextButton(
                                                    onPressed: () =>
                                                        Navigator.of(context)
                                                            .pop(true),
                                                    child: Text(l10n.delete)),
                                              ],
                                            );
                                          },
                                        ) ??
                                        false;
                                  }
                                },
                                onDismissed: (direction) {
                                  if (direction ==
                                      DismissDirection.endToStart) {
                                    _deleteFluidEntry(fluidEntry.id!);
                                  }
                                },
                                child: SummaryCard(
                                  //externalMargin: EdgeInsets.zero,
                                  child: ListTile(
                                    leading: Icon(Icons.local_drink,
                                        color: colorScheme.primary),
                                    title: Text(fluidEntry.name),
                                    subtitle: Text(DateFormat.Hm(locale)
                                        .format(fluidEntry.timestamp)),
                                    trailing: Text(
                                        l10n.waterListTrailingMl(
                                            fluidEntry.quantityInMl),
                                        style: const TextStyle(
                                            fontWeight: FontWeight.bold)),
                                  ),
                                ),
                              );
                            }
                            return const SizedBox.shrink();
                          },
                        ),
                ),
              ],
            ),
            if (_isLoading)
              Positioned.fill(
                child: Container(
                  color: Colors.black.withOpacity(0.5),
                  child: const Center(child: CircularProgressIndicator()),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildFilterButton(String label, String key) {
    final theme = Theme.of(context);
    final isSelected = _selectedRangeKey == key;
    return Expanded(
      child: GestureDetector(
        onTap: () => _setTimeRange(key),
        child: Container(
          margin: const EdgeInsets.symmetric(horizontal: 4.0),
          padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
          decoration: BoxDecoration(
            color: isSelected
                ? theme.colorScheme.primary
                : theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
            borderRadius: BorderRadius.circular(10.0),
          ),
          child: Text(
            label,
            textAlign: TextAlign.center,
            style: theme.textTheme.labelLarge?.copyWith(
              color: isSelected
                  ? theme.colorScheme.onPrimary
                  : theme.colorScheme.onSurfaceVariant,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/workout_log_detail_screen.dart =====

// lib/screens/workout_log_detail_screen.dart (Final & Korrigiert - Edit Mode - Neu mit WorkoutCard)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/screens/exercise_catalog_screen.dart';
import 'package:lightweight/screens/exercise_detail_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/wger_attribution_widget.dart';
import 'package:lightweight/widgets/workout_summary_bar.dart';
import 'package:lightweight/widgets/workout_card.dart';

class WorkoutLogDetailScreen extends StatefulWidget {
  final int logId;
  const WorkoutLogDetailScreen({super.key, required this.logId});

  @override
  State<WorkoutLogDetailScreen> createState() => _WorkoutLogDetailScreenState();
}

class _WorkoutLogDetailScreenState extends State<WorkoutLogDetailScreen> {
  bool _isLoading = true;
  WorkoutLog? _log;
  Map<String, List<SetLog>> _groupedSets = {};
  Map<String, Exercise> _exerciseDetails = {};
  bool _isEditMode = false;
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _notesController;
  final Map<int, TextEditingController> _weightControllers = {};
  final Map<int, TextEditingController> _repsControllers = {};
  DateTime? _editedStartTime;
  Map<String, double> _categoryVolume = {};

  @override
  void initState() {
    super.initState();
    _notesController = TextEditingController();
    _loadDetails();
  }

  @override
  void dispose() {
    _notesController.dispose();
    _clearControllers();
    super.dispose();
  }

  void _clearControllers() {
    for (var controller in _weightControllers.values) {
      controller.dispose();
    }
    for (var controller in _repsControllers.values) {
      controller.dispose();
    }
    _weightControllers.clear();
    _repsControllers.clear();
  }

  /// Gibt den anzuzeigenden Text für den Set zurück
  String _getSetDisplayText(String setType, int setIndex) {
    switch (setType) {
      case 'warmup':
        return 'W';
      case 'failure':
        return 'F';
      case 'dropset':
        return 'D';
      default:
        return '$setIndex';
    }
  }

  Future<void> _loadDetails({bool preserveEditState = false}) async {
    if (!preserveEditState) {
      setState(() => _isLoading = true);
    }

    final data =
        await WorkoutDatabaseHelper.instance.getWorkoutLogById(widget.logId);
    if (data == null) {
      if (mounted) setState(() => _isLoading = false);
      return;
    }

    final groups = <String, List<SetLog>>{};
    for (var set in data.sets) {
      groups.putIfAbsent(set.exerciseName, () => []).add(set);
    }

    final Map<String, double> categoryVolume = {};
    for (final set in data.sets) {
      final exercise = await WorkoutDatabaseHelper.instance
          .getExerciseByName(set.exerciseName);
      if (exercise != null) {
        final volumeForSet = (set.weightKg ?? 0) * (set.reps ?? 0);
        categoryVolume.update(
            exercise.categoryName, (value) => value + volumeForSet,
            ifAbsent: () => volumeForSet);
      }
    }

    final tempExerciseDetails = <String, Exercise>{};
    for (var name in groups.keys) {
      final exercise =
          await WorkoutDatabaseHelper.instance.getExerciseByName(name);
      if (exercise != null) tempExerciseDetails[name] = exercise;
    }

    _notesController.text = data.notes ?? '';
    _editedStartTime = data.startTime;

    _clearControllers();
    for (final setLog in data.sets) {
      _weightControllers[setLog.id!] = TextEditingController(
          text: setLog.weightKg?.toStringAsFixed(1).replaceAll('.0', '') ?? '');
      _repsControllers[setLog.id!] =
          TextEditingController(text: setLog.reps?.toString() ?? '');
    }

    if (!mounted) return;
    setState(() {
      _log = data;
      _groupedSets = groups;
      _exerciseDetails = tempExerciseDetails;
      _categoryVolume = categoryVolume;
      if (!preserveEditState) {
        _isLoading = false;
      }
    });
  }

  void _toggleEditMode() {
    setState(() {
      _isEditMode = !_isEditMode;
      if (_isEditMode) {
        _loadDetails(preserveEditState: true);
      } else {
        _loadDetails();
      }
    });
  }

  Future<void> _pickDateTime() async {
    final date = await showDatePicker(
      context: context,
      initialDate: _editedStartTime ?? DateTime.now(),
      firstDate: DateTime(2020),
      lastDate: DateTime.now().add(const Duration(days: 1)),
    );
    if (date == null) return;

    final time = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(_editedStartTime ?? DateTime.now()),
    );
    if (time == null) return;

    setState(() {
      _editedStartTime =
          DateTime(date.year, date.month, date.day, time.hour, time.minute);
    });
  }

  Future<void> _saveChanges() async {
    FocusScope.of(context).unfocus();
    if (!(_formKey.currentState?.validate() ?? false)) return;

    final l10n = AppLocalizations.of(context)!;
    final dbHelper = WorkoutDatabaseHelper.instance;

    final initialSetIds = _log!.sets.map((s) => s.id!).toSet();
    final currentSets = _groupedSets.values.expand((sets) => sets).toList();

    final idsToDelete = initialSetIds
        .difference(currentSets.map((s) => s.id!).toSet())
        .toList();

    final List<SetLog> setsToUpdate = [];
    final List<SetLog> setsToInsert = [];

    for (final setLog in currentSets) {
      final weight = double.tryParse(
              _weightControllers[setLog.id!]?.text.replaceAll(',', '.') ??
                  '0') ??
          0.0;
      final reps = int.tryParse(_repsControllers[setLog.id!]?.text ?? '0') ?? 0;

      final updatedSet = setLog.copyWith(weightKg: weight, reps: reps);

      if (initialSetIds.contains(setLog.id)) {
        setsToUpdate.add(updatedSet);
      } else {
        setsToInsert.add(updatedSet);
      }
    }

    await dbHelper.updateWorkoutLogDetails(
        widget.logId, _editedStartTime!, _notesController.text);
    if (idsToDelete.isNotEmpty) await dbHelper.deleteSetLogs(idsToDelete);
    if (setsToUpdate.isNotEmpty) await dbHelper.updateSetLogs(setsToUpdate);
    for (final set in setsToInsert) {
      await dbHelper
          .insertSetLog(set.copyWith(id: null, workoutLogId: widget.logId));
    }

    if (mounted) {
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(l10n.snackbarRoutineSaved)));
    }

    setState(() => _isEditMode = false);
    _loadDetails();
  }

  Widget _buildHeader(String text) => Expanded(
      child: Text(text,
          textAlign: TextAlign.center,
          style: TextStyle(
              color: Colors.grey[600],
              fontSize: 12,
              fontWeight: FontWeight.bold)));

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).toString();
    final textTheme = Theme.of(context).textTheme;
    final colorScheme = Theme.of(context).colorScheme;

    double totalVolume = 0.0;
    if (_log != null) {
      for (final set in _log!.sets) {
        totalVolume += (set.weightKg ?? 0) * (set.reps ?? 0);
      }
    }
    final Duration duration =
        _log?.endTime?.difference(_log!.startTime) ?? Duration.zero;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        title: Text(
          l10n.workoutDetailsTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
        actions: [
          if (!_isLoading && _log != null)
            _isEditMode
                ? TextButton(
                    onPressed: _saveChanges,
                    child: Text(l10n.save,
                        style: TextStyle(
                          color: colorScheme.primary,
                          fontWeight: FontWeight.bold,
                        )),
                  )
                : IconButton(
                    icon: const Icon(Icons.edit),
                    onPressed: _toggleEditMode,
                  ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _log == null
              ? Center(child: Text(l10n.workoutNotFound))
              : Column(
                  children: [
                    WorkoutSummaryBar(
                      duration: duration,
                      volume: totalVolume,
                      sets: _log!.sets.length,
                      progress: null,
                    ),
                    Divider(
                        height: 1,
                        thickness: 1,
                        color: colorScheme.onSurfaceVariant.withOpacity(0.1)),
                    Expanded(
                      child: ListView(
                        padding: EdgeInsets.zero,
                        children: [
                          // Header Info Section mit SummaryCard
                          Padding(
                            padding: DesignConstants.cardPadding,
                            child: SummaryCard(
                              child: Padding(
                                padding: const EdgeInsets.all(16.0),
                                child: Form(
                                  key: _formKey,
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      Text(
                                        _log!.routineName ??
                                            l10n.freeWorkoutTitle,
                                        style: textTheme.headlineMedium,
                                      ),
                                      Row(
                                        children: [
                                          Text(DateFormat.yMMMMd(locale)
                                              .add_Hm()
                                              .format(_editedStartTime ??
                                                  _log!.startTime)),
                                          if (_isEditMode)
                                            IconButton(
                                              icon: Icon(Icons.calendar_today,
                                                  size: 18,
                                                  color: colorScheme.primary),
                                              onPressed: _pickDateTime,
                                            )
                                        ],
                                      ),
                                      const SizedBox(
                                          height: DesignConstants.spacingM),
                                      _isEditMode
                                          ? TextFormField(
                                              controller: _notesController,
                                              decoration: InputDecoration(
                                                  labelText: l10n.notesLabel),
                                              maxLines: 3,
                                            )
                                          : (_log!.notes != null &&
                                                  _log!.notes!.isNotEmpty
                                              ? Text(
                                                  '${l10n.notesLabel}: ${_log!.notes!}',
                                                  style: const TextStyle(
                                                      fontStyle:
                                                          FontStyle.italic))
                                              : const SizedBox.shrink()),
                                      if (_categoryVolume.isNotEmpty) ...[
                                        const Divider(height: 24),
                                        Text(l10n.muscleSplitLabel,
                                            style: textTheme.titleMedium),
                                        const SizedBox(
                                            height: DesignConstants.spacingS),
                                        ..._buildCategoryBars(context),
                                      ],
                                    ],
                                  ),
                                ),
                              ),
                            ),
                          ),

                          // Exercise Sets mit WorkoutCard
                          ..._buildSetList(context, l10n),

                          // Add Exercise Button
                          if (_isEditMode)
                            Padding(
                              padding: const EdgeInsets.all(16.0),
                              child: TextButton.icon(
                                onPressed: () async {
                                  final selectedExercise =
                                      await Navigator.of(context)
                                          .push<Exercise>(
                                    MaterialPageRoute(
                                        builder: (context) =>
                                            const ExerciseCatalogScreen(
                                                isSelectionMode: true)),
                                  );
                                  if (selectedExercise != null) {
                                    setState(() {
                                      final newSet = SetLog(
                                          id: DateTime.now()
                                              .millisecondsSinceEpoch,
                                          workoutLogId: _log!.id!,
                                          exerciseName: selectedExercise
                                              .getLocalizedName(context),
                                          setType: 'normal');
                                      _groupedSets[selectedExercise
                                          .getLocalizedName(context)] = [
                                        newSet
                                      ];
                                      _weightControllers[newSet.id!] =
                                          TextEditingController();
                                      _repsControllers[newSet.id!] =
                                          TextEditingController();
                                    });
                                  }
                                },
                                icon: const Icon(Icons.add),
                                label: Text(l10n.addExerciseToWorkoutButton),
                              ),
                            ),

                          Padding(
                            padding: const EdgeInsets.fromLTRB(
                                16.0, 24.0, 16.0, 8.0),
                            child: WgerAttributionWidget(
                              textStyle: textTheme.bodySmall
                                  ?.copyWith(color: Colors.grey[600]),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
    );
  }

  List<Widget> _buildCategoryBars(BuildContext context) {
    final total = _categoryVolume.values.fold<double>(0, (a, b) => a + b);
    return _categoryVolume.entries.map((entry) {
      final fraction = total > 0 ? entry.value / total : 0.0;
      return Padding(
        padding: const EdgeInsets.symmetric(vertical: 4.0),
        child: Row(
          children: [
            Expanded(
                flex: 2,
                child: Text(entry.key, style: const TextStyle(fontSize: 12))),
            Expanded(
              flex: 5,
              child: LinearProgressIndicator(
                value: fraction,
                backgroundColor: Colors.grey.shade300,
                color: Theme.of(context).colorScheme.primary,
                minHeight: 12,
              ),
            ),
            const SizedBox(width: 8),
            Text("${(fraction * 100).toStringAsFixed(0)}%"),
          ],
        ),
      );
    }).toList();
  }

  Widget _buildSetRow(
    SetLog setLog,
    int rowIndex, // Der Index in der Liste der Sätze für DIESE Übung
    int workingSetIndex, // Der "Arbeitssatz"-Index
    String exerciseName,
    AppLocalizations l10n,
  ) {
    final setType = setLog.setType;
    final isLightMode = Theme.of(context).brightness == Brightness.light;

    final bool isColoredRow = rowIndex > 0 && rowIndex.isOdd;
    final Color rowColor;
    if (isColoredRow) {
      rowColor = isLightMode
          ? Colors.grey.withOpacity(0.1)
          // HIER DIE ÄNDERUNG: Erhöhte Opazität für Dark Mode
          : Colors.white.withOpacity(0.1);
    } else {
      rowColor = Colors.transparent;
    }

    return Container(
      color: rowColor,
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 4.0),
        child: Row(
          children: [
            // ... restlicher Code der Methode bleibt unverändert
            Expanded(
              flex: 2,
              child: Center(
                child: Builder(
                  builder: (_) {
                    Color textColor;
                    switch (setType) {
                      case 'warmup':
                        textColor = Colors.orange;
                        break;
                      case 'dropset':
                        textColor = Colors.blue;
                        break;
                      case 'failure':
                        textColor = Colors.red;
                        break;
                      default:
                        textColor = Colors.grey;
                    }
                    return GestureDetector(
                      onTap: () {
                        if (_isEditMode) _showSetTypePicker(setLog.id!);
                      },
                      child: Text(
                        _getSetDisplayText(setType, workingSetIndex),
                        style: TextStyle(
                          color: textColor,
                          fontSize: 20,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    );
                  },
                ),
              ),
            ),
            const Expanded(
              flex: 3,
              child: Center(
                child: Text(
                  "-",
                  textAlign: TextAlign.center,
                  style: TextStyle(color: Colors.grey, fontSize: 12),
                ),
              ),
            ),
            Expanded(
              flex: 2,
              child: _isEditMode
                  ? TextFormField(
                      controller: _weightControllers[setLog.id!],
                      textAlign: TextAlign.center,
                      keyboardType:
                          const TextInputType.numberWithOptions(decimal: true),
                      decoration: const InputDecoration(
                          border: InputBorder.none,
                          isDense: true,
                          fillColor: Colors.transparent),
                    )
                  : Text(
                      setLog.weightKg
                              ?.toStringAsFixed(1)
                              .replaceAll('.0', '') ??
                          '0',
                      textAlign: TextAlign.center,
                      style: const TextStyle(fontSize: 16),
                    ),
            ),
            const SizedBox(width: 8),
            Expanded(
              flex: 2,
              child: _isEditMode
                  ? TextFormField(
                      controller: _repsControllers[setLog.id!],
                      textAlign: TextAlign.center,
                      keyboardType: TextInputType.number,
                      decoration: const InputDecoration(
                          border: InputBorder.none,
                          isDense: true,
                          fillColor: Colors.transparent),
                    )
                  : Text(
                      "${setLog.reps ?? '0'}",
                      textAlign: TextAlign.center,
                      style: const TextStyle(fontSize: 16),
                    ),
            ),
            Padding(
              padding: const EdgeInsets.only(right: 8.0),
              child: SizedBox(
                width: 48,
                child: _isEditMode
                    ? IconButton(
                        icon: const Icon(Icons.delete_outline,
                            color: Colors.redAccent),
                        onPressed: () {
                          setState(() {
                            _groupedSets[exerciseName]
                                ?.removeWhere((s) => s.id == setLog.id);
                            _weightControllers.remove(setLog.id!)?.dispose();
                            _repsControllers.remove(setLog.id!)?.dispose();
                          });
                        },
                      )
                    : const Icon(
                        Icons.check_circle,
                        color: Colors.green,
                      ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  List<Widget> _buildSetList(BuildContext context, AppLocalizations l10n) {
    final textTheme = Theme.of(context).textTheme;
    final entries = _groupedSets.entries.toList();

    if (!_isEditMode) {
      // Normale Liste ohne Reorder-Funktionalität
      return entries
          .map((entry) => _buildExerciseCard(context, l10n, entry, -1))
          .toList();
    } else {
      // ReorderableListView für Edit-Modus
      return [
        ReorderableListView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          padding: EdgeInsets.zero,
          onReorder: (int oldIndex, int newIndex) {
            setState(() {
              if (newIndex > oldIndex) {
                newIndex -= 1;
              }
              final item = entries.removeAt(oldIndex);
              entries.insert(newIndex, item);

              // Gruppierte Sets Map neu aufbauen
              _groupedSets.clear();
              for (var entry in entries) {
                _groupedSets[entry.key] = entry.value;
              }
            });
          },
          itemCount: entries.length,
          itemBuilder: (context, index) {
            return _buildExerciseCard(context, l10n, entries[index], index);
          },
        ),
      ];
    }
  }

  Widget _buildExerciseCard(BuildContext context, AppLocalizations l10n,
      MapEntry<String, List<SetLog>> entry, int index) {
    final String exerciseName = entry.key;
    final Exercise? exercise = _exerciseDetails[exerciseName];
    final List<SetLog> sets = entry.value;
    final textTheme = Theme.of(context).textTheme;

    return WorkoutCard(
      key: _isEditMode ? ValueKey(exerciseName) : null,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          ListTile(
            contentPadding:
                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
            leading: _isEditMode
                ? ReorderableDragStartListener(
                    index: index,
                    child: const Icon(Icons.drag_handle),
                  )
                : null,
            title: InkWell(
              onTap: () {
                if (exercise != null) {
                  Navigator.of(context).push(MaterialPageRoute(
                    builder: (context) =>
                        ExerciseDetailScreen(exercise: exercise),
                  ));
                }
              },
              child: Padding(
                padding: const EdgeInsets.symmetric(vertical: 4.0),
                child: Text(
                  exercise?.getLocalizedName(context) ?? exerciseName,
                  style: textTheme.titleLarge
                      ?.copyWith(fontWeight: FontWeight.bold),
                ),
              ),
            ),
            trailing: _isEditMode
                ? IconButton(
                    icon: const Icon(Icons.delete_outline,
                        color: Colors.redAccent),
                    tooltip: l10n.removeExercise,
                    onPressed: () {
                      setState(() {
                        for (var set in sets) {
                          _weightControllers.remove(set.id!)?.dispose();
                          _repsControllers.remove(set.id!)?.dispose();
                        }
                        _groupedSets.remove(exerciseName);
                      });
                    },
                  )
                : const Icon(Icons.info_outline),
          ),

          // Header Row
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 0.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      flex: 2,
                      child: Center(
                          child: Text(
                        l10n.setLabel,
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          color: Colors.grey[600],
                          fontSize: 12,
                          fontWeight: FontWeight.bold,
                        ),
                      )),
                    ),
                    Expanded(
                      flex: 3,
                      child: Center(
                          child: Text(
                        l10n.lastTimeLabel,
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          color: Colors.grey[600],
                          fontSize: 12,
                          fontWeight: FontWeight.bold,
                        ),
                      )),
                    ),
                    Expanded(
                      flex: 2,
                      child: Center(
                          child: Text(
                        l10n.kgLabel,
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          color: Colors.grey[600],
                          fontSize: 12,
                          fontWeight: FontWeight.bold,
                        ),
                      )),
                    ),
                    Expanded(
                      flex: 2,
                      child: Center(
                          child: Text(
                        l10n.repsLabel,
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          color: Colors.grey[600],
                          fontSize: 12,
                          fontWeight: FontWeight.bold,
                        ),
                      )),
                    ),
                    const SizedBox(width: 48),
                  ],
                ),

                // Set Rows
                ...sets.asMap().entries.map((setEntry) {
                  final setLog = setEntry.value;
                  final rowIndex = setEntry
                      .key; // Der Index in der Liste der Sätze für DIESE Übung

                  // Normale Sätze zählen (ohne Warmup)
                  int workingSetIndex = 0;
                  for (int i = 0; i <= rowIndex; i++) {
                    if (sets[i].setType != 'warmup') {
                      workingSetIndex++;
                    }
                  }

                  return _buildSetRow(
                      setLog, rowIndex, workingSetIndex, exerciseName, l10n);
                }),

                // Add Set Button
                if (_isEditMode)
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16.0),
                    child: TextButton.icon(
                      onPressed: () {
                        final newSet = SetLog(
                            id: DateTime.now().millisecondsSinceEpoch,
                            workoutLogId: _log!.id!,
                            exerciseName: exerciseName,
                            setType: 'normal');
                        setState(() {
                          sets.add(newSet);
                          _weightControllers[newSet.id!] =
                              TextEditingController();
                          _repsControllers[newSet.id!] =
                              TextEditingController();
                        });
                      },
                      icon: const Icon(Icons.add),
                      label: Text(l10n.addSetButton),
                    ),
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  void _changeSetType(int setLogId, String newType) {
    setState(() {
      // Finde den SetLog und ändere den setType
      for (var entry in _groupedSets.entries) {
        for (var setLog in entry.value) {
          if (setLog.id == setLogId) {
            // Erstelle eine neue Instanz mit geändertem setType
            final index = entry.value.indexOf(setLog);
            entry.value[index] = setLog.copyWith(setType: newType);
            break;
          }
        }
      }
    });
    Navigator.pop(context);
  }

  void _showSetTypePicker(int setLogId) {
    showModalBottomSheet(
      context: context,
      builder: (context) {
        return Wrap(
          children: <Widget>[
            ListTile(
                title: const Text('Normal'),
                onTap: () => _changeSetType(setLogId, 'normal')),
            ListTile(
                title: const Text('Warmup'),
                onTap: () => _changeSetType(setLogId, 'warmup')),
            ListTile(
                title: const Text('Failure'),
                onTap: () => _changeSetType(setLogId, 'failure')),
            ListTile(
                title: const Text('Dropset'),
                onTap: () => _changeSetType(setLogId, 'dropset')),
          ],
        );
      },
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/home.dart =====

// lib/screens/home.dart (Final & SWR-Lade-Logik)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/models/tracked_supplement.dart';
//import 'package:lightweight/screens/supplement_hub_screen.dart';
import 'package:lightweight/screens/supplement_track_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/supplement_summary_widget.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/chart_data_point.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/screens/measurements_screen.dart';
import 'package:lightweight/screens/nutrition_screen.dart';
import 'package:lightweight/widgets/measurement_chart_widget.dart';
import 'package:lightweight/widgets/nutrition_summary_widget.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/util/date_util.dart';

class Home extends StatefulWidget {
  const Home({super.key});

  @override
  HomeState createState() => HomeState();
}

class HomeState extends State<Home> {
  DailyNutrition? _nutritionData;
  String _recommendationText = "";
  // KORREKTUR: _isLoading wird jetzt nur für den ERSTEN Ladevorgang auf true gesetzt
  bool _isLoading = true;

  List<ChartDataPoint> _weightChartData = [];
  DateTimeRange _currentDateRange = DateTimeRange(
      start: DateTime.now().subtract(const Duration(days: 29)),
      end: DateTime.now());
  final String _chartType = 'weight';
  Map<String, int> _workoutStats = {};
  bool _isFirstLoad = true;
  List<TrackedSupplement> _trackedSupplements = [];

  final List<String> _chartDateRangeKeys = ['30D', '90D', 'All'];
  String _selectedChartRangeKey = '30D';

  @override
  void initState() {
    super.initState();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (_isFirstLoad) {
      loadAllHomeScreenData(
          showLoadingIndicator:
              true); // KORREKTUR: Zeige Indikator nur beim ersten Mal
      _isFirstLoad = false;
    }
  }

  Future<void> loadAllHomeScreenData(
      {bool showLoadingIndicator = false}) async {
    if (!mounted) return;

    // KORREKTUR: Setze _isLoading nur, wenn der Indikator wirklich gezeigt werden soll
    if (showLoadingIndicator) {
      setState(() => _isLoading = true);
    }

    // --- DATEN HIER LADEN ---
    final l10n = AppLocalizations.of(context)!;
    final dbHelper = DatabaseHelper.instance;
    final prefs = await SharedPreferences.getInstance();
    final targetCalories = prefs.getInt('targetCalories') ?? 2500;
    final targetProtein = prefs.getInt('targetProtein') ?? 180;
    final targetCarbs = prefs.getInt('targetCarbs') ?? 250;
    final targetFat = prefs.getInt('targetFat') ?? 80;
    final targetWater = prefs.getInt('targetWater') ?? 3000;

    final entries = await dbHelper.getEntriesForDate(DateTime.now());
    final fluidEntries = await dbHelper.getFluidEntriesForDate(DateTime.now());
    final waterIntake = fluidEntries.fold<int>(0, (sum, entry) => sum + entry.quantityInMl);
    final newTodaysNutrition = DailyNutrition(
        targetCalories: targetCalories,
        targetProtein: targetProtein,
        targetCarbs: targetCarbs,
        targetFat: targetFat,
        targetWater: targetWater);
    newTodaysNutrition.water = waterIntake;

    final newWorkoutStats =
        await _getWorkoutStats(); // KORREKTUR: Methode umbenannt
    await _loadChartData(); // Lädt Chart-Daten und setzt _weightChartData

    for (final entry in entries) {
      final foodItem = await ProductDatabaseHelper.instance
          .getProductByBarcode(entry.barcode);
      if (foodItem != null) {
        newTodaysNutrition.calories +=
            (foodItem.calories / 100 * entry.quantityInGrams).round();
        newTodaysNutrition.protein +=
            (foodItem.protein / 100 * entry.quantityInGrams).round();
        newTodaysNutrition.carbs +=
            (foodItem.carbs / 100 * entry.quantityInGrams).round();
        newTodaysNutrition.fat +=
            (foodItem.fat / 100 * entry.quantityInGrams).round();
      }
    }

    final today = DateTime.now();
    final sevenDaysAgo = today.subtract(const Duration(days: 6));
    final recentEntries =
        await dbHelper.getEntriesForDateRange(sevenDaysAgo, today);
    String newRecommendation = l10n.recommendationDefault;
    if (recentEntries.isNotEmpty) {
      final uniqueDaysTracked = recentEntries
          .map((e) => DateFormat.yMd().format(e.timestamp))
          .toSet();
      final numberOfTrackedDays = uniqueDaysTracked.length;
      int totalRecentCalories = 0;
      for (final entry in recentEntries) {
        final foodItem = await ProductDatabaseHelper.instance
            .getProductByBarcode(entry.barcode);
        if (foodItem != null) {
          totalRecentCalories +=
              (foodItem.calories / 100 * entry.quantityInGrams).round();
        }
      }
      final totalTargetCalories = targetCalories * numberOfTrackedDays;
      final difference = totalRecentCalories - totalTargetCalories;
      if (numberOfTrackedDays > 1) {
        final tolerance = totalTargetCalories * 0.05;
        if (difference > tolerance) {
          newRecommendation = l10n.recommendationOverTarget(
              numberOfTrackedDays, difference.round());
        } else if (difference < -tolerance) {
          newRecommendation = l10n.recommendationUnderTarget(
              numberOfTrackedDays, (-difference).round());
        } else {
          newRecommendation = l10n.recommendationOnTarget(numberOfTrackedDays);
        }
      } else {
        newRecommendation = l10n.recommendationFirstEntry;
      }
    }

    // NEU: Lade Supplement-Daten
    final allSupplements = await dbHelper.getAllSupplements();
    final todaysSupplementLogs =
        await dbHelper.getSupplementLogsForDate(DateTime.now());
    final Map<int, double> todaysDoses = {};
    for (final log in todaysSupplementLogs) {
      todaysDoses.update(log.supplementId, (value) => value + log.dose,
          ifAbsent: () => log.dose);
    }
    final trackedSupps = allSupplements
        .map((s) => TrackedSupplement(
              supplement: s,
              totalDosedToday: todaysDoses[s.id] ?? 0.0,
            ))
        .toList();

    // --- DATEN LADEN ENDE ---

    if (mounted) {
      setState(() {
        _nutritionData = newTodaysNutrition; // Neue Daten
        _recommendationText = newRecommendation; // Neue Daten
        _workoutStats = newWorkoutStats; // Neue Daten
        _trackedSupplements = trackedSupps; // NEU
        _isLoading = false; // Ladezustand beenden
      });
    }
  }

  Future<void> _loadChartData() async {
    // KORRIGIERT: Die Logik zur Berechnung des Zeitraums wird hierher verschoben.
    final now = DateTime.now();
    DateTime start;
    DateTime end = DateTime(now.year, now.month, now.day, 23, 59, 59);

    switch (_selectedChartRangeKey) {
      case '90D':
        start = now.subtract(const Duration(days: 89));
        break;
      case 'All':
        // Für "Alle" holen wir das früheste Datum aus der Datenbank
        final earliest =
            await DatabaseHelper.instance.getEarliestMeasurementDate();
        start = earliest ?? now;
        break;
      case '30D':
      default:
        start = now.subtract(const Duration(days: 29));
    }

    final normalizedStart = DateTime(start.year, start.month, start.day);

    // Wichtig: Den State für den Datumsbereich hier aktualisieren!
    if (!mounted) return;
    setState(() {
      _currentDateRange = DateTimeRange(start: normalizedStart, end: end);
    });

    // Der Rest der Methode bleibt gleich, lädt aber jetzt mit dem korrekten Zeitbereich.
    final sessions = await DatabaseHelper.instance.getMeasurementSessions();
    final points = <ChartDataPoint>[];

    for (final s in sessions) {
      if (s.timestamp.isBefore(normalizedStart) || s.timestamp.isAfter(end)) {
        continue;
      }

      for (final m in s.measurements) {
        if (m.type == _chartType) {
          points.add(
              ChartDataPoint(date: s.timestamp, value: m.value.toDouble()));
        }
      }
    }

    points.sort((a, b) => a.date.compareTo(b.date));

    if (!mounted) return;
    setState(() {
      _weightChartData = points;
    });
  }

  // KORREKTUR: Methode umbenannt, damit sie Daten ZURÜCKGIBT
  Future<Map<String, int>> _getWorkoutStats() async {
    final today = DateTime.now();
    final sevenDaysAgo = today.subtract(const Duration(days: 6));

    final logs = await WorkoutDatabaseHelper.instance
        .getWorkoutLogsForDateRange(sevenDaysAgo, today);

    int count = logs.length;
    int duration = 0;
    int volume = 0;

    for (final log in logs) {
      if (log.endTime != null) {
        duration += log.endTime!.difference(log.startTime).inMinutes;
      }
      for (final set in log.sets) {
        volume += ((set.weightKg ?? 0) * (set.reps ?? 0)).round();
      }
    }
    return {
      'count': count,
      'duration': duration,
      'volume': volume,
    };
  }

  void _navigateTimeRange(bool forward) {
    // "All" deckt sowieso alles ab – kein Paging
    if (_selectedChartRangeKey == 'All') return;

    final int days = _selectedChartRangeKey == '90D' ? 90 : 30;
    final delta = Duration(days: days);

    final newStart = forward
        ? _currentDateRange.start.add(delta)
        : _currentDateRange.start.subtract(delta);
    final newEnd = forward
        ? _currentDateRange.end.add(delta)
        : _currentDateRange.end.subtract(delta);

    setState(() {
      _currentDateRange = DateTimeRange(start: newStart, end: newEnd);
    });

    // Daten für die neue Range nachladen
    _loadChartData();
  }

  void _navigateToNutritionScreen() {
    Navigator.of(context)
        .push(MaterialPageRoute(builder: (context) => const NutritionScreen()))
        .then((_) => loadAllHomeScreenData(showLoadingIndicator: false));
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;

    // KORREKTUR: Zeige den Ladeindikator nur, wenn _isLoading true UND keine Daten vorhanden sind
    final showLoadingOverlay = _isLoading && _nutritionData == null;

    return Scaffold(
      body: Stack(
        children: [
          // KORREKTUR: Der RefreshIndicator ist immer da, damit man ziehen kann.
          // Der Inhalt wird immer angezeigt, auch wenn _isLoading true ist (alte Daten).
          RefreshIndicator(
            onRefresh: () => loadAllHomeScreenData(
                showLoadingIndicator:
                    false), // KORREKTUR: Kein Ladeindikator bei manueller Aktualisierung
            child: ListView(
              padding: DesignConstants.screenPadding,
              children: [
                _buildBannerCard(l10n),
                const SizedBox(height: DesignConstants.spacingS),
                GestureDetector(
                    onTap: _navigateToNutritionScreen,
                    child: _nutritionData != null
                        ? NutritionSummaryWidget(
                            nutritionData: _nutritionData!,
                            isExpandedView: false,
                            l10n: l10n)
                        : const SizedBox.shrink()),
                const SizedBox(height: DesignConstants.spacingS),
                SupplementSummaryWidget(
                  trackedSupplements: _trackedSupplements,
                  onTap: () => Navigator.of(context)
                      .push(MaterialPageRoute(
                          builder: (context) => const SupplementTrackScreen()))
                      .then((_) =>
                          loadAllHomeScreenData(showLoadingIndicator: false)),
                ),
                if (_weightChartData.isNotEmpty)
                  const SizedBox(height: DesignConstants.spacingS),
                GestureDetector(
                    onTap: () => Navigator.of(context)
                        .push(MaterialPageRoute(
                            builder: (context) => const MeasurementsScreen()))
                        .then((_) => loadAllHomeScreenData()),
                    child: _buildWeightChartCard(context, colorScheme, l10n)),
                const SizedBox(height: DesignConstants.spacingS),
                _buildWorkoutStatsCard(l10n),
              ],
            ),
          ),
          // KORREKTUR: Lade-Overlay nur anzeigen, wenn showLoadingOverlay true ist
          if (showLoadingOverlay)
            Positioned.fill(
              child: Container(
                color: Colors.black.withOpacity(0.5),
                child: const Center(child: CircularProgressIndicator()),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildBannerCard(AppLocalizations l10n) {
    // KORREKTUR: externalMargin wird jetzt gesetzt
    return SummaryCard(
      //internalPadding: const EdgeInsets.symmetric(horizontal: 16.0),
      //externalMargin: EdgeInsets.zero, // Wichtig, da ListView.separated den Abstand steuert
      child: Container(
        height: 100,
        alignment: Alignment.center,
        child: Text(
          _recommendationText,
          textAlign: TextAlign.center,
          style: TextStyle(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
              fontSize: 22,
              fontWeight: FontWeight.w500),
        ),
      ),
    );
  }

// In lib/screens/home.dart, innerhalb von HomeState

  Widget _buildWeightChartCard(
      BuildContext context, ColorScheme colorScheme, AppLocalizations l10n) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(l10n.weightHistoryTitle,
                    style: Theme.of(context)
                        .textTheme
                        .titleMedium
                        ?.copyWith(fontWeight: FontWeight.bold)),
                Expanded(
                  child: Align(
                    alignment: Alignment.centerRight,
                    child: Wrap(
                      spacing: 8.0,
                      alignment: WrapAlignment.end,
                      children: _chartDateRangeKeys
                          .map((key) => _buildFilterButton(key, key))
                          .toList(),
                    ),
                  ),
                ),
              ],
            ),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                IconButton(
                  icon: const Icon(Icons.chevron_left),
                  onPressed: () => _navigateTimeRange(false),
                ),
                Text(
                    "${DateFormat.MMMd().format(_currentDateRange.start)} - ${DateFormat.MMMd().format(_currentDateRange.end)}",
                    style: Theme.of(context).textTheme.bodySmall),
                IconButton(
                  icon: const Icon(Icons.chevron_right),
                  onPressed: _currentDateRange.end.isSameDate(DateTime.now())
                      ? null
                      : () => _navigateTimeRange(true),
                ),
              ],
            ),
            const SizedBox(height: DesignConstants.spacingL),
            MeasurementChartWidget(
              chartType: _chartType,
              dateRange: _currentDateRange,
              // KORREKTUR: Die folgende Zeile wurde entfernt
              // lineColor: colorScheme.secondary,
              unit: "kg",
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFilterButton(String label, String key) {
    final theme = Theme.of(context);
    final isSelected = _selectedChartRangeKey == key;
    return GestureDetector(
      onTap: () {
        setState(() {
          _selectedChartRangeKey = key;
        });
        _loadChartData();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10.0, vertical: 6.0),
        decoration: BoxDecoration(
          color: isSelected
              ? theme.colorScheme.primary
              : theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
          borderRadius: BorderRadius.circular(8.0),
        ),
        child: Text(
          label,
          style: theme.textTheme.labelSmall?.copyWith(
            color: isSelected
                ? theme.colorScheme.onPrimary
                : theme.colorScheme.onSurfaceVariant,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  Widget _buildWorkoutStatsCard(AppLocalizations l10n) {
    // KORREKTUR: externalMargin wird jetzt gesetzt
    return SummaryCard(
      //externalMargin: EdgeInsets.zero, // Wichtig
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              l10n.workoutStatsTitle,
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: DesignConstants.spacingM),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                Column(
                  children: [
                    const Icon(Icons.fitness_center, size: 28),
                    const SizedBox(height: 4),
                    Text(
                      "${_workoutStats['count'] ?? 0}",
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(l10n.workoutsLabel,
                        style: const TextStyle(fontSize: 12)),
                  ],
                ),
                Column(
                  children: [
                    const Icon(Icons.timer, size: 28),
                    const SizedBox(height: 4),
                    Text(
                      "${_workoutStats['duration'] ?? 0} min",
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(l10n.durationLabel,
                        style: const TextStyle(fontSize: 12)),
                  ],
                ),
                Column(
                  children: [
                    const Icon(Icons.monitor_weight, size: 28),
                    const SizedBox(height: 4),
                    Text(
                      "${_workoutStats['volume'] ?? 0} kg",
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(l10n.volumeLabel,
                        style: const TextStyle(fontSize: 12)),
                  ],
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/supplement_hub_screen.dart =====

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/dialogs/log_supplement_dialog_content.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';
import 'package:lightweight/models/tracked_supplement.dart';
import 'package:lightweight/screens/create_supplement_screen.dart';
import 'package:lightweight/util/date_util.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';

class SupplementHubScreen extends StatefulWidget {
  const SupplementHubScreen({super.key});
  @override
  State<SupplementHubScreen> createState() => _SupplementHubScreenState();
}

class _SupplementHubScreenState extends State<SupplementHubScreen> {
  bool _isLoading = true;
  List<TrackedSupplement> _trackedSupplements = [];
  List<SupplementLog> _todaysLogs = [];
  final Map<int, Supplement> _supplementsById = {};
  DateTime _selectedDate = DateTime.now();

  @override
  void initState() {
    super.initState();
    _loadData(_selectedDate);
  }

  String localizeSupplementName(Supplement s, AppLocalizations l10n) {
    switch (s.code) {
      case 'caffeine':
        return l10n.supplement_caffeine;
      case 'creatine_monohydrate':
        return l10n.supplement_creatine_monohydrate;
      default:
        // Fallback: benutzerdefinierte Supplements behalten ihren Namen
        return s.name;
    }
  }

  Future<void> _loadData(DateTime date) async {
    setState(() => _isLoading = true);

    final db = DatabaseHelper.instance;
    final allSupplements = await db.getAllSupplements();
    final logsForDate = await db.getSupplementLogsForDate(date);

    // Map: supplementId -> Supplement (für l10n-Lookup im Log)
    final Map<int, Supplement> byId = {
      for (final s in allSupplements)
        if (s.id != null) s.id!: s,
    };

    // Tagesdosen akkumulieren
    final Map<int, double> todaysDoses = {};
    for (final log in logsForDate) {
      todaysDoses.update(
        log.supplementId,
        (value) => value + log.dose,
        ifAbsent: () => log.dose,
      );
    }

    // Progress-Karten Daten
    final tracked = allSupplements.map((s) {
      return TrackedSupplement(
        supplement: s,
        totalDosedToday: todaysDoses[s.id] ?? 0.0,
      );
    }).toList();

    if (!mounted) return;
    setState(() {
      _supplementsById
        ..clear()
        ..addAll(byId);
      _trackedSupplements = tracked;
      _todaysLogs = logsForDate;
      _isLoading = false;
    });
  }

  Future<void> _logSupplement(Supplement supplement) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<LogSupplementDialogContentState> dialogStateKey =
        GlobalKey();

    final result = await showDialog<(double, DateTime)?>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(localizeSupplementName(supplement, l10n)),
          content: LogSupplementDialogContent(
              key: dialogStateKey, supplement: supplement),
          actions: [
            TextButton(
                child: Text(l10n.cancel),
                onPressed: () => Navigator.of(context).pop(null)),
            FilledButton(
              child: Text(l10n.add_button),
              onPressed: () {
                final state = dialogStateKey.currentState;
                if (state != null) {
                  final dose =
                      double.tryParse(state.doseText.replaceAll(',', '.'));
                  if (dose != null && dose > 0) {
                    Navigator.of(context).pop((dose, state.selectedDateTime));
                  }
                }
              },
            ),
          ],
        );
      },
    );

    if (result != null) {
      final newLog = SupplementLog(
        supplementId: supplement.id!,
        dose: result.$1,
        unit: supplement.unit,
        timestamp: result.$2,
      );
      await DatabaseHelper.instance.insertSupplementLog(newLog);
      _loadData(_selectedDate);
    }
  }

  Future<void> _deleteLogEntry(int logId) async {
    await DatabaseHelper.instance.deleteSupplementLog(logId);
    _loadData(_selectedDate);
  }

  void _navigateDay(bool forward) {
    final newDay = _selectedDate.add(Duration(days: forward ? 1 : -1));
    if (forward && newDay.isAfter(DateTime.now())) return;

    setState(() {
      _selectedDate = newDay;
    });
    _loadData(_selectedDate);
  }

  Future<void> _pickDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (picked != null && picked != _selectedDate) {
      setState(() {
        _selectedDate = picked;
      });
      _loadData(_selectedDate);
    }
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildProgressCard(TrackedSupplement ts) {
    final supplement = ts.supplement;
    final isLimit = supplement.dailyLimit != null;
    final target = (isLimit ? supplement.dailyLimit : supplement.dailyGoal)!;
    final overTarget = isLimit && ts.totalDosedToday > target;
    final hasTarget = target > 0;
    final rawProgress = hasTarget ? (ts.totalDosedToday / target) : 0.0;
    final progress = rawProgress.clamp(0.0, 1.0);
    final progressColor =
        overTarget ? Colors.red.shade400 : Colors.green.shade400;
    final l10n = AppLocalizations.of(context)!;

    return Container(
      height: 60,
      margin: const EdgeInsets.symmetric(vertical: 6.0),
      decoration: BoxDecoration(
        color: Theme.of(context)
            .colorScheme
            .surfaceContainerHighest
            .withOpacity(0.3),
        borderRadius: BorderRadius.circular(20),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(20),
        child: Stack(
          fit: StackFit.expand,
          children: [
            Align(
              alignment: Alignment.centerLeft,
              child: FractionallySizedBox(
                widthFactor: progress,
                child: Container(color: progressColor),
              ),
            ),
            Padding(
              padding:
                  const EdgeInsets.symmetric(horizontal: 12.0, vertical: 4.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  FittedBox(
                    fit: BoxFit.scaleDown,
                    child: Text(
                      localizeSupplementName(supplement, l10n),
                      maxLines: 1,
                      style: const TextStyle(
                          fontSize: 16, fontWeight: FontWeight.bold),
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    '${ts.totalDosedToday.toStringAsFixed(1)} / ${target.toStringAsFixed(1)} ${supplement.unit}',
                    style: TextStyle(
                      color: Theme.of(context)
                          .colorScheme
                          .onSurface
                          .withOpacity(0.8),
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildLogEntry(SupplementLog log, AppLocalizations l10n) {
    final s = _supplementsById[log.supplementId];
    final titleText = (s != null)
        ? localizeSupplementName(s, l10n) // l10n über code (z.B. 'caffeine')
        : 'Unknown';

    return Dismissible(
      key: Key('log_${log.id}'),
      direction: DismissDirection.horizontal,
      background: const SwipeActionBackground(
        color: Colors.blueAccent,
        icon: Icons.edit,
        alignment: Alignment.centerLeft,
      ),
      secondaryBackground: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      confirmDismiss: (direction) async {
        if (direction == DismissDirection.startToEnd) {
          _editLogEntry(log);
          return false; // nicht aus der Liste entfernen
        } else {
          return await showDialog<bool>(
                context: context,
                builder: (BuildContext context) {
                  return AlertDialog(
                    title: Text(l10n.deleteConfirmTitle),
                    content: Text(l10n.deleteConfirmContent),
                    actions: <Widget>[
                      TextButton(
                          onPressed: () => Navigator.of(context).pop(false),
                          child: Text(l10n.cancel)),
                      TextButton(
                          onPressed: () => Navigator.of(context).pop(true),
                          child: Text(l10n.delete)),
                    ],
                  );
                },
              ) ??
              false;
        }
      },
      onDismissed: (direction) {
        if (direction == DismissDirection.endToStart) {
          _deleteLogEntry(log.id!);
        }
      },
      child: SummaryCard(
        child: ListTile(
          leading: const Icon(Icons.check_circle, color: Colors.grey),
          title: Text(titleText),
          subtitle: Text(DateFormat.Hm().format(log.timestamp)),
          trailing: Text('${log.dose.toStringAsFixed(1)} ${log.unit}'),
        ),
      ),
    );
  }

  Future<void> _navigateToEditSupplement(Supplement supplement) async {
    final reloaded = await Navigator.of(context).push<bool>(
      MaterialPageRoute(
        builder: (context) =>
            CreateSupplementScreen(supplementToEdit: supplement),
      ),
    );
    if (reloaded == true) {
      _loadData(_selectedDate);
    }
  }

  Future<void> _deleteSupplement(Supplement supplement) async {
    final l10n = AppLocalizations.of(context)!;
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.deleteConfirmTitle),
        // TODO: This confirmation message should be localized
        content: Text(
            "Are you sure you want to permanently delete the supplement '${localizeSupplementName(supplement, l10n)}'? All of its log entries will also be removed."),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(false),
            child: Text(l10n.cancel),
          ),
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(true),
            child: Text(l10n.delete),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await DatabaseHelper.instance.deleteSupplement(supplement.id!);
      _loadData(_selectedDate);
    }
  }

  Widget _buildLogActionCard(Supplement supplement) {
    final l10n = AppLocalizations.of(context)!;
    // Check if the supplement is the non-editable "Caffeine"
    final isBuiltin = supplement.isBuiltin || supplement.code == 'caffeine';

    // If it is Caffeine, return a simple, non-dismissible ListTile.
    if (isBuiltin) {
      return SummaryCard(
        child: ListTile(
          leading: const Icon(Icons.add_circle_outline),
          title: Text(localizeSupplementName(supplement, l10n)),
          onTap: () => _logSupplement(supplement),
        ),
      );
    }

    // Otherwise, return the original Dismissible widget for all other supplements.
    return Dismissible(
      key: Key('supplement_${supplement.id}'),
      direction: DismissDirection.horizontal,
      background: const SwipeActionBackground(
        color: Colors.blueAccent,
        icon: Icons.edit,
        alignment: Alignment.centerLeft,
      ),
      secondaryBackground: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      confirmDismiss: (direction) async {
        if (direction == DismissDirection.startToEnd) {
          _navigateToEditSupplement(supplement);
          return false; // Don't dismiss, just navigate
        } else {
          // We trigger the dialog and let it handle the deletion.
          // We return false because the list is rebuilt anyway, avoiding a visual glitch.
          _deleteSupplement(supplement);
          return false;
        }
      },
      child: SummaryCard(
        child: ListTile(
          leading: const Icon(Icons.add_circle_outline),
          title: Text(localizeSupplementName(supplement, l10n)),
          onTap: () => _logSupplement(supplement),
        ),
      ),
    );
  }

  Future<void> _editLogEntry(SupplementLog log) async {
    final l10n = AppLocalizations.of(context)!;
    // Find the full supplement object to pass its details (like unit) to the dialog.
    final supplement = _trackedSupplements
        .firstWhere((ts) => ts.supplement.id == log.supplementId)
        .supplement;
    final GlobalKey<LogSupplementDialogContentState> dialogStateKey =
        GlobalKey();

    final result = await showDialog<(double, DateTime)?>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(localizeSupplementName(supplement, l10n)),
          content: LogSupplementDialogContent(
            key: dialogStateKey,
            supplement: supplement,
            initialDose: log.dose,
            initialTimestamp: log.timestamp,
          ),
          actions: [
            TextButton(
                child: Text(l10n.cancel),
                onPressed: () => Navigator.of(context).pop(null)),
            FilledButton(
              child: Text(l10n.save), // Use 'Save' for editing
              onPressed: () {
                final state = dialogStateKey.currentState;
                if (state != null) {
                  final dose =
                      double.tryParse(state.doseText.replaceAll(',', '.'));
                  if (dose != null && dose > 0) {
                    Navigator.of(context).pop((dose, state.selectedDateTime));
                  }
                }
              },
            ),
          ],
        );
      },
    );

    if (result != null) {
      final updatedLog = SupplementLog(
        id: log.id,
        supplementId: supplement.id!,
        dose: result.$1,
        unit: supplement.unit,
        timestamp: result.$2,
      );
      await DatabaseHelper.instance.updateSupplementLog(updatedLog);
      _loadData(_selectedDate);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).toString();
    final textTheme = Theme.of(context).textTheme;

    return Scaffold(
      appBar: AppBar(
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        elevation: 0,
        scrolledUnderElevation: 0,
        title: Text(
          l10n.supplementTrackerTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      body: Column(
        children: [
          Padding(
            padding:
                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                IconButton(
                    icon: const Icon(Icons.chevron_left),
                    onPressed: () => _navigateDay(false)),
                Expanded(
                  child: InkWell(
                    onTap: _pickDate,
                    child: Text(
                      DateFormat.yMMMMd(locale).format(_selectedDate),
                      style: textTheme.titleMedium
                          ?.copyWith(fontWeight: FontWeight.bold),
                      textAlign: TextAlign.center,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ),
                IconButton(
                    icon: const Icon(Icons.chevron_right),
                    onPressed: _selectedDate.isSameDate(DateTime.now())
                        ? null
                        : () => _navigateDay(true)),
              ],
            ),
          ),
          Divider(
              height: 1,
              thickness: 1,
              color: Theme.of(context)
                  .colorScheme
                  .onSurfaceVariant
                  .withOpacity(0.1)),
          Expanded(
            child: _isLoading
                ? const Center(child: CircularProgressIndicator())
                : RefreshIndicator(
                    onRefresh: () => _loadData(_selectedDate),
                    child: ListView(
                      padding: DesignConstants.cardPadding,
                      children: [
                        _buildSectionTitle(context, l10n.dailyProgressTitle),
                        if (_trackedSupplements
                            .where((ts) =>
                                ts.supplement.dailyGoal != null ||
                                ts.supplement.dailyLimit != null)
                            .isEmpty)
                          Padding(
                            padding: const EdgeInsets.symmetric(vertical: 8.0),
                            child: Text(l10n.emptySupplementGoals,
                                textAlign: TextAlign.center),
                          ),
                        ..._trackedSupplements
                            .where((ts) =>
                                ts.supplement.dailyGoal != null ||
                                ts.supplement.dailyLimit != null)
                            .map((ts) => _buildProgressCard(ts)),
                        const SizedBox(height: DesignConstants.spacingXL),
                        _buildSectionTitle(context, l10n.logIntakeTitle),
                        ..._trackedSupplements
                            .map((ts) => _buildLogActionCard(ts.supplement)),
                        const SizedBox(height: DesignConstants.spacingXL),
                        _buildSectionTitle(context, l10n.todaysLogTitle),
                        if (_todaysLogs.isEmpty)
                          Padding(
                            padding: const EdgeInsets.symmetric(vertical: 8.0),
                            child: Text(l10n.emptySupplementLogs,
                                textAlign: TextAlign.center),
                          )
                        else
                          ..._todaysLogs
                              .map((log) => _buildLogEntry(log, l10n)),
                      ],
                    ),
                  ),
          ),
        ],
      ),
      floatingActionButton: GlassFab(
        label: l10n.createSupplementTitle,
        onPressed: () async {
          final created = await Navigator.of(context).push<bool>(
            MaterialPageRoute(
                builder: (context) => const CreateSupplementScreen()),
          );
          if (created == true) {
            _loadData(_selectedDate);
          }
        },
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/food_detail_screen.dart =====

// lib/screens/food_detail_screen.dart (Final & De-Materialisiert - OLED Ready)

import 'package:flutter/material.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/tracked_food_item.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/off_attribution_widget.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart' as p;
import 'package:share_plus/share_plus.dart';

// Dev-Flag: später einfach auf false setzen oder die Dev-Blöcke entfernen.
const bool kDevEditEnabled = true;

class FoodDetailScreen extends StatefulWidget {
  final TrackedFoodItem? trackedItem;
  final FoodItem? foodItem;

  const FoodDetailScreen({super.key, this.trackedItem, this.foodItem})
      : assert(trackedItem != null || foodItem != null);

  @override
  State<FoodDetailScreen> createState() => _FoodDetailScreenState();
}

class _FoodDetailScreenState extends State<FoodDetailScreen> {
  bool _isFavorite = false;
  bool _showPer100g = false;

  late FoodItem _displayItem;
  int? _trackedQuantity;
  bool get _hasPortionInfo => _trackedQuantity != null;

  // ---------- DEV: Inline-Editing ----------
  bool _devEditing = false; // via Secret-Tap toggeln

  final _deCtrl = TextEditingController();
  final _enCtrl = TextEditingController();
  final _catCtrl = TextEditingController();

  final _calCtrl = TextEditingController();
  final _proCtrl = TextEditingController();
  final _carbCtrl = TextEditingController();
  final _fatCtrl = TextEditingController();
  final _kjCtrl = TextEditingController();
  final _fibCtrl = TextEditingController();
  final _sugCtrl = TextEditingController();
  final _saltCtrl = TextEditingController();
  final _sodCtrl = TextEditingController();
  final _calciumCtrl = TextEditingController();

  void _fillControllers(FoodItem item, {Map<String, dynamic>? rawRow}) {
    _deCtrl.text = (rawRow?['name_de'] as String?) ?? item.name;
    _enCtrl.text = (rawRow?['name_en'] as String?) ?? '';
    _catCtrl.text = (rawRow?['category_key'] as String?) ?? '';

    _calCtrl.text = (item.calories).toString();
    _proCtrl.text = (item.protein).toString();
    _carbCtrl.text = (item.carbs).toString();
    _fatCtrl.text = (item.fat).toString();
    _kjCtrl.text = (rawRow?['kj_100g'] as num?)?.toString() ?? '';
    _fibCtrl.text = (rawRow?['fiber_100g'] as num?)?.toString() ?? '';
    _sugCtrl.text = (rawRow?['sugar_100g'] as num?)?.toString() ?? '';
    _saltCtrl.text = (rawRow?['salt_100g'] as num?)?.toString() ?? '';
    _sodCtrl.text = (rawRow?['sodium_100g'] as num?)?.toString() ?? '';
    _calciumCtrl.text = (rawRow?['calcium_100g'] as num?)?.toString() ?? '';
  }

  @override
  void initState() {
    super.initState();
    if (widget.trackedItem != null) {
      _displayItem = widget.trackedItem!.item;
      _trackedQuantity = widget.trackedItem!.entry.quantityInGrams;
    } else {
      _displayItem = widget.foodItem!;
      _trackedQuantity = null;
      _showPer100g = true;
    }
    _checkIfFavorite();
  }

  @override
  void dispose() {
    _deCtrl.dispose();
    _enCtrl.dispose();
    _catCtrl.dispose();
    _calCtrl.dispose();
    _proCtrl.dispose();
    _carbCtrl.dispose();
    _fatCtrl.dispose();
    _kjCtrl.dispose();
    _fibCtrl.dispose();
    _sugCtrl.dispose();
    _saltCtrl.dispose();
    _sodCtrl.dispose();
    _calciumCtrl.dispose();
    super.dispose();
  }

  // ---------- DEV: Basis-DB Hilfen ----------

  Future<String> _getBaseDbPath() async {
    // Versuche erst den bekannten Namen der Base-DB im App-DB-Verzeichnis
    final dbDir = await getDatabasesPath();
    return p.join(dbDir, 'vita_base_foods.db');
  }

  Future<Database> _openBaseDb({bool readOnly = false}) async {
    final path = await _getBaseDbPath();
    return openDatabase(path, readOnly: readOnly);
  }

  Future<Map<String, dynamic>?> _loadRawRow(String barcode) async {
    final base = await _openBaseDb(readOnly: true);
    try {
      final rows = await base.query('products',
          where: 'barcode = ?', whereArgs: [barcode], limit: 1);
      return rows.isNotEmpty ? rows.first : null;
    } finally {
      await base.close();
    }
  }

  Future<void> _saveDevEdits() async {
    try {
      final barcode = _displayItem.barcode;
      final Map<String, Object?> fields = {
        // Spiegel beachten: name = name_de
        'name_de': _deCtrl.text.trim(),
        'name_en': _enCtrl.text.trim().isEmpty ? null : _enCtrl.text.trim(),
        'name': _deCtrl.text.trim(),
        'category_key':
            _catCtrl.text.trim().isEmpty ? null : _catCtrl.text.trim(),
        // Nährwerte
        'calories_100g': int.tryParse(_calCtrl.text.trim()),
        'protein_100g': double.tryParse(_proCtrl.text.trim()),
        'carbs_100g': double.tryParse(_carbCtrl.text.trim()),
        'fat_100g': double.tryParse(_fatCtrl.text.trim()),
        'kj_100g': double.tryParse(_kjCtrl.text.trim()),
        'fiber_100g': double.tryParse(_fibCtrl.text.trim()),
        'sugar_100g': double.tryParse(_sugCtrl.text.trim()),
        'salt_100g': double.tryParse(_saltCtrl.text.trim()),
        'sodium_100g': double.tryParse(_sodCtrl.text.trim()),
        'calcium_100g': double.tryParse(_calciumCtrl.text.trim()),
      };

      // leere Strings zu null; 'barcode' niemals überschreiben
      fields.removeWhere((k, v) => v == null);

      final db = await _openBaseDb();
      try {
        await db.update(
          'products',
          fields,
          where: 'barcode = ?',
          whereArgs: [barcode],
          conflictAlgorithm: ConflictAlgorithm.replace,
        );
      } finally {
        await db.close();
      }
      await ProductDatabaseHelper.instance.reloadBaseDb();

      // Für sichtbares Refresh: Eintrag neu aus Base-DB laden
      final baseDb = await _openBaseDb(readOnly: true);
      Map<String, dynamic>? row;
      try {
        final rows = await baseDb.query('products',
            where: 'barcode = ?', whereArgs: [barcode], limit: 1);
        if (rows.isNotEmpty) row = rows.first;
      } finally {
        await baseDb.close();
      }
      if (row != null) {
        setState(() {
          _displayItem = FoodItem.fromMap(row!, source: FoodItemSource.base);
        });
      }

      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Gespeichert (Basis-DB)')),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Fehler: $e')),
      );
    }
  }

  Future<void> _exportBaseDb() async {
    try {
      final path = await _getBaseDbPath();
      final file = XFile(path, name: p.basename(path));
      await Share.shareXFiles([file], subject: 'Export: vita_base_foods.db');
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Export-Fehler: $e')),
      );
    }
  }

  // ---------- Favoriten / Anzeige ----------

  Future<void> _checkIfFavorite() async {
    final isFav =
        await DatabaseHelper.instance.isFavorite(_displayItem.barcode);
    if (mounted) setState(() => _isFavorite = isFav);
  }

  Future<void> _toggleFavorite() async {
    if (_isFavorite) {
      await DatabaseHelper.instance.removeFavorite(_displayItem.barcode);
    } else {
      await DatabaseHelper.instance.addFavorite(_displayItem.barcode);
    }
    _checkIfFavorite();
  }

  double _getDisplayValue(double? valuePer100g) {
    if (valuePer100g == null) return 0.0;
    if (_showPer100g || !_hasPortionInfo) {
      return valuePer100g;
    }
    return (valuePer100g / 100 * _trackedQuantity!);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    final displayQuantity =
        _showPer100g || !_hasPortionInfo ? 100 : _trackedQuantity!;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      floatingActionButton: GlassFab(
        onPressed: () {
          Navigator.of(context).pop(widget.foodItem);
   }, label: l10n.mealsAddToDiary ),
      appBar: AppBar(
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        elevation: 0,
        scrolledUnderElevation: 0,
        title: GestureDetector(
          onLongPress: () async {
            if (!kDevEditEnabled) return;
            setState(() => _devEditing = !_devEditing);
            if (_devEditing) {
              final raw = await _loadRawRow(_displayItem.barcode);
              _fillControllers(_displayItem, rawRow: raw);
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('DEV-Edit-Modus aktiv')),
                );
              }
            }
          },
          child: Text(
            _displayItem.name,
            style: textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w900),
          ),
        ),
        actions: [
          if (kDevEditEnabled && _devEditing)
            IconButton(
              tooltip: 'Basis-DB exportieren',
              onPressed: _exportBaseDb,
              icon: const Icon(Icons.ios_share),
            ),
          IconButton(
            icon: Icon(
              _isFavorite ? Icons.favorite : Icons.favorite_border,
              color:
                  _isFavorite ? Colors.redAccent : colorScheme.onSurfaceVariant,
            ),
            onPressed: _toggleFavorite,
          )
        ],
      ),
      body: SingleChildScrollView(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (_displayItem.brand.isNotEmpty)
              Text(
                _displayItem.brand,
                style: textTheme.titleMedium?.copyWith(color: Colors.grey[600]),
              ),
            Divider(
              height: 32,
              thickness: 1,
              color: colorScheme.onSurfaceVariant.withOpacity(0.1),
            ),
            if (_hasPortionInfo)
              SummaryCard(
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                      horizontal: 16.0, vertical: 8.0),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceAround,
                    children: [
                      _buildToggleButton(
                          context, l10n.foodDetailSegmentPortion, false),
                      _buildToggleButton(
                          context, l10n.foodDetailSegment100g, true),
                    ],
                  ),
                ),
              ),
            if (_hasPortionInfo)
              const SizedBox(height: DesignConstants.spacingL),
            Text("Nährwerte pro ${displayQuantity}g",
                style: textTheme.titleLarge),
            const SizedBox(height: DesignConstants.spacingS),
            SummaryCard(
              child: Column(
                children: [
                  _buildNutrientRow(l10n.calories,
                      "${_getDisplayValue(_displayItem.calories.toDouble()).round()} kcal"),
                  _buildNutrientRow(l10n.protein,
                      "${_getDisplayValue(_displayItem.protein).toStringAsFixed(1)} g"),
                  _buildNutrientRow(l10n.carbs,
                      "${_getDisplayValue(_displayItem.carbs).toStringAsFixed(1)} g"),
                  _buildNutrientRow(l10n.fat,
                      "${_getDisplayValue(_displayItem.fat).toStringAsFixed(1)} g"),
                ],
              ),
            ),
            if (_displayItem.sugar != null ||
                _displayItem.fiber != null ||
                _displayItem.salt != null) ...[
              const SizedBox(height: DesignConstants.spacingM),
              SummaryCard(
                child: Column(
                  children: [
                    if (_displayItem.sugar != null)
                      _buildNutrientRow(l10n.sugar,
                          "${_getDisplayValue(_displayItem.sugar).toStringAsFixed(1)} g"),
                    if (_displayItem.fiber != null)
                      _buildNutrientRow(l10n.fiber,
                          "${_getDisplayValue(_displayItem.fiber).toStringAsFixed(1)} g"),
                    if (_displayItem.salt != null)
                      _buildNutrientRow(l10n.salt,
                          "${_getDisplayValue(_displayItem.salt).toStringAsFixed(1)} g"),
                  ],
                ),
              ),
            ],

            // ---------- DEV: Inline-Edit Panel ----------
            if (kDevEditEnabled && _devEditing) ...[
              const SizedBox(height: DesignConstants.spacingM),
              SummaryCard(
                child: Padding(
                  padding: const EdgeInsets.all(12.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text('DEV: Eintrag bearbeiten',
                          style: textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.bold,
                          )),
                      const SizedBox(height: 8),
                      _row('Name (DE)', _deCtrl),
                      const SizedBox(height: 8),
                      _row('Name (EN)', _enCtrl),
                      const SizedBox(height: 8),
                      _row('Kategorie-Key', _catCtrl),
                      const SizedBox(height: 12),
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: [
                          _num('kcal/100g', _calCtrl),
                          _num('Protein/100g', _proCtrl),
                          _num('Carbs/100g', _carbCtrl),
                          _num('Fett/100g', _fatCtrl),
                          _num('kJ/100g', _kjCtrl),
                          _num('Ballastst./100g', _fibCtrl),
                          _num('Zucker/100g', _sugCtrl),
                          _num('Salz/100g', _saltCtrl),
                          _num('Natrium/100g', _sodCtrl),
                          _num('Calcium/100g', _calciumCtrl),
                        ],
                      ),
                      const SizedBox(height: 12),
                      Row(
                        children: [
                          ElevatedButton.icon(
                            onPressed: _saveDevEdits,
                            icon: const Icon(Icons.save),
                            label: const Text('Speichern'),
                          ),
                          const SizedBox(width: 12),
                          TextButton.icon(
                            onPressed: () =>
                                setState(() => _devEditing = false),
                            icon: const Icon(Icons.close),
                            label: const Text('Fertig'),
                          ),
                          const Spacer(),
                          IconButton(
                            tooltip: 'Basis-DB exportieren',
                            onPressed: _exportBaseDb,
                            icon: const Icon(Icons.ios_share),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ],

            if (!_displayItem.barcode.startsWith('user_created_'))
              Padding(
                padding: const EdgeInsets.only(top: 24.0, bottom: 8.0),
                child: OffAttributionWidget(
                  textStyle:
                      textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildToggleButton(
      BuildContext context, String label, bool is100gOption) {
    final theme = Theme.of(context);
    final isSelected = _showPer100g == is100gOption;
    return Expanded(
      child: InkWell(
        onTap: () => setState(() => _showPer100g = is100gOption),
        borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM),
        child: Container(
          padding: const EdgeInsets.symmetric(vertical: 12.0, horizontal: 8.0),
          decoration: BoxDecoration(
            color: isSelected
                ? theme.colorScheme.primary.withOpacity(0.2)
                : Colors.transparent,
            borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM),
            border: Border.all(
              color: isSelected
                  ? theme.colorScheme.primary
                  : theme.colorScheme.onSurfaceVariant.withOpacity(0.3),
            ),
          ),
          child: Text(
            label,
            textAlign: TextAlign.center,
            style: theme.textTheme.titleMedium?.copyWith(
              color: isSelected
                  ? theme.colorScheme.primary
                  : theme.colorScheme.onSurface,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildNutrientRow(String label, String value) {
    return ListTile(
      dense: true,
      title: Text(label),
      trailing: Text(
        value,
        style: const TextStyle(fontWeight: FontWeight.bold),
      ),
    );
  }

  // ---------- DEV: kleine Helfer-Inputs ----------

  Widget _row(String label, TextEditingController c) => TextField(
        controller: c,
        decoration: InputDecoration(
          labelText: label,
          border: const OutlineInputBorder(),
          isDense: true,
        ),
      );

  Widget _num(String label, TextEditingController c) => SizedBox(
        width: 160,
        child: TextField(
          controller: c,
          keyboardType: const TextInputType.numberWithOptions(
              decimal: true, signed: false),
          decoration: InputDecoration(
            labelText: label,
            border: const OutlineInputBorder(),
            isDense: true,
          ),
        ),
      );
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/add_food_screen.dart =====

// lib/screens/add_food_screen.dart (Final & De-Materialisiert)

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';
import 'package:lightweight/screens/create_food_screen.dart';
import 'package:lightweight/screens/food_detail_screen.dart';
import 'package:lightweight/screens/meal_screen.dart';
import 'package:lightweight/screens/scanner_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/off_attribution_widget.dart';
import 'package:lightweight/widgets/summary_card.dart';

class AddFoodScreen extends StatefulWidget {
  const AddFoodScreen({super.key});

  @override
  State<AddFoodScreen> createState() => _AddFoodScreenState();
}

class _AddFoodScreenState extends State<AddFoodScreen>
    with SingleTickerProviderStateMixin {
  List<FoodItem> _foundFoodItems = [];
  bool _isLoadingSearch = false;
  String _searchInitialText = "";
  final _searchController = TextEditingController();

  List<FoodItem> _favoriteFoodItems = [];
  bool _isLoadingFavorites = true;

  List<FoodItem> _recentFoodItems = [];
  bool _isLoadingRecent = true;

  late TabController _tabController;
  final TextEditingController _baseSearchCtrl = TextEditingController();
  String _baseSearch = '';
  Timer? _baseSearchDebounce;

  List<Map<String, dynamic>> _baseCategories = [];
  final Map<String, List<FoodItem>> _catItems = {}; // key -> Produkte
  final Set<String> _loadingCats = {}; // ladeanzeige je Kategorie
  // Meals
  List<Map<String, dynamic>> _meals = [];
  final Map<int, List<Map<String, dynamic>>> _mealItemsCache = {};
  bool _isLoadingMeals = true;
  int _currentTab = 0; // 0=Katalog, 1=Zuletzt, 2=Favoriten, 3=Mahlzeiten
  bool _suspendFab = false;

  Future<void> _loadMeals() async {
    setState(() => _isLoadingMeals = true);
    final rows = await DatabaseHelper.instance.getMeals();
    setState(() {
      _meals = rows;
      _isLoadingMeals = false;
    });
  }

  Future<List<Map<String, dynamic>>> _getMealItems(int mealId) async {
    if (_mealItemsCache.containsKey(mealId)) return _mealItemsCache[mealId]!;
    final rows = await DatabaseHelper.instance.getMealItems(mealId);
    _mealItemsCache[mealId] = rows;
    return rows;
  }

  Future<void> _loadBaseCategories() async {
    _baseCategories = await ProductDatabaseHelper.instance.getBaseCategories();
    if (mounted) setState(() {});
  }

  Future<void> _loadCategoryItems(String key) async {
    if (_catItems.containsKey(key) || _loadingCats.contains(key)) return;
    _loadingCats.add(key);
    if (mounted) setState(() {});
    final items = await ProductDatabaseHelper.instance.getBaseFoods(
      categoryKey: key,
      limit: 500, // großzügig – DB ist lokal
    );
    _catItems[key] = items;
    _loadingCats.remove(key);
    if (mounted) setState(() {});
  }

  void _onBaseSearchChanged(String v) {
    _baseSearchDebounce?.cancel();
    _baseSearchDebounce = Timer(const Duration(milliseconds: 250), () {
      setState(() => _baseSearch = v.trim());
    });
  }

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 4, vsync: this); // 4 Tabs
    _currentTab = _tabController.index;
    _tabController.addListener(() {
      if (_currentTab != _tabController.index) {
        setState(() {
          _currentTab = _tabController.index;
        });
      }
    });

    _searchController.addListener(() => setState(() {}));
    _loadFavorites();
    _loadRecentItems();
    _baseSearchCtrl
        .addListener(() => _onBaseSearchChanged(_baseSearchCtrl.text));
    _loadBaseCategories();
    _loadMeals();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (_searchInitialText.isEmpty) {
      _searchInitialText = AppLocalizations.of(context)!.searchInitialHint;
    }
  }

  @override
  void dispose() {
    _searchController.dispose();
    _tabController.dispose();
    _baseSearchDebounce?.cancel();
    _baseSearchCtrl.dispose();
    super.dispose();
  }

  void _runFilter(String enteredKeyword) async {
    final l10n = AppLocalizations.of(context)!;
    if (enteredKeyword.isEmpty) {
      setState(() {
        _foundFoodItems = [];
        _searchInitialText = l10n.searchInitialHint;
      });
      return;
    }
    setState(() {
      _isLoadingSearch = true;
    });

    final results =
        await ProductDatabaseHelper.instance.searchProducts(enteredKeyword);

    if (mounted) {
      setState(() {
        _foundFoodItems = results;
        _isLoadingSearch = false;
        if (results.isEmpty) {
          _searchInitialText = l10n.searchNoResults;
        }
      });
    }
  }

  void _navigateAndCreateFood() {
    Navigator.of(context)
        .push(
      MaterialPageRoute(builder: (context) => const CreateFoodScreen()),
    )
        .then((_) {
      _searchController.clear();
      _runFilter('');
      _loadFavorites();
      _loadRecentItems();
    });
  }

  Future<void> _loadFavorites() async {
    setState(() {
      _isLoadingFavorites = true;
    });
    final results = await ProductDatabaseHelper.instance.getFavoriteProducts();
    if (mounted) {
      setState(() {
        _favoriteFoodItems = results;
        _isLoadingFavorites = false;
      });
    }
  }

  Future<void> _loadRecentItems() async {
    setState(() {
      _isLoadingRecent = true;
    });
    final results = await ProductDatabaseHelper.instance.getRecentProducts();
    if (mounted) {
      setState(() {
        _recentFoodItems = results;
        _isLoadingRecent = false;
      });
    }
  }

  Future<void> _createMealAndOpenEditor(AppLocalizations l10n) async {
    // Solider Default-Name (nicht leer wegen NOT NULL in DB)
    final defaultName = l10n.mealTypeLabel; // z.B. "Mahlzeit" / "Meal"
    final newMealId = await DatabaseHelper.instance.insertMeal(
      name: defaultName,
      notes: '',
    );

    final meal = {'id': newMealId, 'name': defaultName, 'notes': ''};

    await Navigator.of(context).push(
      MaterialPageRoute(
        builder: (_) => MealScreen(meal: meal, startInEdit: true),
      ),
    );

    // Nach Rückkehr Liste aktualisieren
    await _loadMeals();

    // (Optionaler Feinschliff)
    // Wenn Nutzer abbricht und nichts geändert hat: Platzhalter wieder entfernen.
    try {
      final items = await DatabaseHelper.instance.getMealItems(newMealId);
      // Falls noch mit Defaultnamen und ohne Zutaten → löschen
      final created = _meals.firstWhere((m) => m['id'] == newMealId);
      if ((created['name'] as String) == defaultName && items.isEmpty) {
        await DatabaseHelper.instance.deleteMeal(newMealId);
        await _loadMeals();
      }
    } catch (_) {/* egal, Cleanup ist optional */}
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final isLightMode = Theme.of(context).brightness == Brightness.light;

    // FAB-Konfiguration je Tab
    VoidCallback? fabOnPressed;
    String fabLabel;
    if (_suspendFab) {
      fabOnPressed = null;
      fabLabel = '';
    } else if (_currentTab == 3) {
      // Mahlzeiten-Tab
      fabLabel = l10n.mealsCreate;
      fabOnPressed = () => _createMealAndOpenEditor(l10n);
    } else {
      // Alle anderen Tabs
      fabLabel = l10n.fabCreateOwnFood;
      fabOnPressed = _navigateAndCreateFood;
    }

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        automaticallyImplyLeading: true,
        title: Text(
          l10n.addFoodTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      body: Column(
        children: [
          Padding(
            padding:
                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                TabBar(
                  controller: _tabController,
                  isScrollable: false,
                  indicator: const BoxDecoration(),
                  splashFactory: NoSplash.splashFactory,
                  overlayColor: WidgetStateProperty.all(Colors.transparent),
                  labelPadding: EdgeInsets.zero,
                  labelColor: isLightMode ? Colors.black : Colors.white,
                  unselectedLabelColor: Colors.grey.shade600,
                  labelStyle: const TextStyle(
                      fontSize: 16, fontWeight: FontWeight.w800),
                  unselectedLabelStyle: const TextStyle(
                      fontSize: 16, fontWeight: FontWeight.w800),
                  tabs: [
                    Tab(text: l10n.tabCatalogSearch),
                    Tab(text: l10n.tabRecent),
                    Tab(text: l10n.tabFavorites),
                    Tab(text: l10n.tabMeals),
                  ],
                ),
              ],
            ),
          ),
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildCatalogSearchTab(l10n),
                _buildRecentTab(l10n),
                _buildFavoritesTab(l10n),
                _buildMealsTab(l10n),
              ],
            ),
          ),
        ],
      ),
      floatingActionButton: _suspendFab
          ? null
          : GlassFab(
              label: fabLabel,
              onPressed: fabOnPressed ?? () {}, // ✅ Fallback: immer non-null
            ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  Widget _buildSearchTab(AppLocalizations l10n) {
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    return Padding(
      // KORREKTUR 4: Horizontaler Padding hier angepasst, um das Abschneiden zu verhindern
      padding: const EdgeInsets.symmetric(
          horizontal: 16.0, vertical: 0), // Vertikalen Padding auf 0 setzen
      child: Column(
        children: [
          Row(
            children: [
              // Die Suchleiste füllt jetzt den verfügbaren Platz
              Expanded(
                child: TextField(
                    controller: _searchController,
                    onChanged: (value) => _runFilter(value),
                    decoration: InputDecoration(
                        hintText: l10n.searchHintText,
                        prefixIcon: Icon(Icons.search,
                            color: colorScheme.onSurfaceVariant, size: 20),
                        suffixIcon: _searchController.text.isNotEmpty
                            ? IconButton(
                                icon: Icon(Icons.clear,
                                    color: colorScheme.onSurfaceVariant),
                                onPressed: () {
                                  _searchController.clear();
                                  _runFilter('');
                                })
                            : null)),
              ),
              const SizedBox(width: 8), // Kleiner Abstand
              // Der neue Scanner-Button
              IconButton(
                style: IconButton.styleFrom(
                  backgroundColor: colorScheme.surfaceContainerHighest,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
                icon: Icon(Icons.qr_code_scanner, color: colorScheme.primary),
                onPressed: _scanBarcodeAndPop, // Ruft die neue Methode auf
              ),
            ],
          ),
          const SizedBox(height: 20),
          Expanded(
            child: _isLoadingSearch
                ? const Center(child: CircularProgressIndicator())
                : _foundFoodItems.isNotEmpty
                    ? ListView.builder(
                        itemCount: _foundFoodItems.length,
                        itemBuilder: (context, index) =>
                            _buildFoodListItem(_foundFoodItems[index]))
                    : Center(
                        child: Text(_searchInitialText,
                            style: textTheme.titleMedium)),
          ),
          if (_foundFoodItems.any((item) => item.source == FoodItemSource.off))
            const OffAttributionWidget(),
        ],
      ),
    );
  }

  Widget _buildBaseFoodsTab(AppLocalizations l10n) {
    // Kopf: Suche
    final searchField = Padding(
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
      child: TextField(
        controller: _baseSearchCtrl,
        textInputAction: TextInputAction.search,
        decoration: InputDecoration(
          hintText: 'Suche Grundnahrungsmittel', //l10n.searchBaseFoodHintText
          prefixIcon: const Icon(Icons.search),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
          isDense: true,
        ),
      ),
    );

    // Modus 1: mit Suchbegriff → Trefferliste
    if (_baseSearch.isNotEmpty) {
      return Column(
        children: [
          searchField,
          Expanded(
            child: FutureBuilder<List<FoodItem>>(
              future: ProductDatabaseHelper.instance.getBaseFoods(
                search: _baseSearch,
                limit: 200,
              ),
              builder: (context, snap) {
                if (snap.connectionState == ConnectionState.waiting) {
                  return const Center(child: CircularProgressIndicator());
                }
                final items = snap.data ?? [];
                if (items.isEmpty) {
                  return const Center(child: Text('Keine Treffer.'));
                }
                return ListView.builder(
                  padding: DesignConstants.cardPadding,
                  itemCount: items.length,
                  itemBuilder: (_, i) => _buildFoodListItem(items[i]),
                );
              },
            ),
          ),
        ],
      );
    }

    // Modus 2: kein Suchbegriff → Kategorien mit Emoji (Accordion)
    return Column(
      children: [
        searchField,
        if (_baseCategories.isEmpty)
          const LinearProgressIndicator(minHeight: 2),
        Expanded(
          child: RefreshIndicator(
            onRefresh: () async {
              _catItems.clear();
              await _loadBaseCategories();
            },
            child: ListView.builder(
              padding: const EdgeInsets.only(bottom: 24),
              itemCount: _baseCategories.length,
              itemBuilder: (context, idx) {
                final cat = _baseCategories[idx];
                final key = cat['key'] as String;
                final emoji = (cat['emoji'] as String?)?.trim();
                final title =
                    (cat['name_de'] as String?)?.trim().isNotEmpty == true
                        ? cat['name_de'] as String
                        : (cat['name_en'] as String? ?? key);

                final loading = _loadingCats.contains(key);
                final items = _catItems[key];

                return Theme(
                  data: Theme.of(context)
                      .copyWith(dividerColor: Colors.transparent),
                  child: ExpansionTile(
                    leading: Text(emoji?.isNotEmpty == true ? emoji! : '🗂️',
                        style: const TextStyle(fontSize: 20)),
                    title: Text(title),
                    initiallyExpanded: false,
                    onExpansionChanged: (expanded) {
                      if (expanded) _loadCategoryItems(key);
                    },
                    children: [
                      if (loading)
                        const Padding(
                          padding: EdgeInsets.symmetric(vertical: 12),
                          child: Center(child: CircularProgressIndicator()),
                        )
                      else if (items == null || items.isEmpty)
                        const Padding(
                          padding: EdgeInsets.symmetric(vertical: 12),
                          child: Center(child: Text('Keine Einträge')),
                        )
                      else
                        ListView.builder(
                          shrinkWrap: true,
                          physics: const NeverScrollableScrollPhysics(),
                          padding: DesignConstants.cardPadding.copyWith(top: 0),
                          itemCount: items.length,
                          itemBuilder: (_, i) => _buildFoodListItem(items[i]),
                        ),
                    ],
                  ),
                );
              },
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildFavoritesTab(AppLocalizations l10n) {
    if (_isLoadingFavorites) {
      return const Center(child: CircularProgressIndicator());
    }
    if (_favoriteFoodItems.isEmpty) {
      // NEUER, AUFGEWERTETER EMPTY STATE
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.favorite_border,
                  size: 80, color: Colors.grey.shade400),
              const SizedBox(height: DesignConstants.spacingL),
              Text(
                l10n.noFavorites,
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: DesignConstants.spacingS),
              Text(
                l10n.favoritesEmptyState,
                textAlign: TextAlign.center,
                style: Theme.of(context)
                    .textTheme
                    .bodyLarge
                    ?.copyWith(color: Colors.grey.shade600),
              ),
            ],
          ),
        ),
      );
    }
    return Column(children: [
      Expanded(
          child: ListView.builder(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              itemCount: _favoriteFoodItems.length,
              itemBuilder: (context, index) =>
                  _buildFoodListItem(_favoriteFoodItems[index]))),
      if (_favoriteFoodItems.any((item) => item.source == FoodItemSource.off))
        const OffAttributionWidget()
    ]);
  }

  Widget _buildRecentTab(AppLocalizations l10n) {
    if (_isLoadingRecent) {
      return const Center(child: CircularProgressIndicator());
    }
    if (_recentFoodItems.isEmpty) {
      // NEUER, AUFGEWERTETER EMPTY STATE
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.history, size: 80, color: Colors.grey.shade400),
              const SizedBox(height: DesignConstants.spacingL),
              Text(
                l10n.nothingTrackedYet,
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: DesignConstants.spacingS),
              Text(
                l10n.recentEmptyState,
                textAlign: TextAlign.center,
                style: Theme.of(context)
                    .textTheme
                    .bodyLarge
                    ?.copyWith(color: Colors.grey.shade600),
              ),
            ],
          ),
        ),
      );
    }
    return Column(children: [
      Expanded(
          child: ListView.builder(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              itemCount: _recentFoodItems.length,
              itemBuilder: (context, index) =>
                  _buildFoodListItem(_recentFoodItems[index]))),
      if (_recentFoodItems.any((item) => item.source == FoodItemSource.off))
        const OffAttributionWidget()
    ]);
  }

  Widget _buildFoodListItem(FoodItem item) {
    final colorScheme = Theme.of(context).colorScheme;
    final l10n = AppLocalizations.of(context)!;

    IconData sourceIcon;
    switch (item.source) {
      case FoodItemSource.base:
        sourceIcon = Icons.star;
        break;
      case FoodItemSource.off:
      case FoodItemSource.user:
        sourceIcon = Icons.inventory_2;
        break;
    }

    return SummaryCard(
      // KORREKTUR: Jetzt mit SummaryCard
      child: ListTile(
        leading: Icon(sourceIcon, color: colorScheme.primary),
        title: Text(item.name.isNotEmpty ? item.name : l10n.unknown,
            style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Text(l10n.foodItemSubtitle(
            item.brand.isNotEmpty ? item.brand : l10n.noBrand, item.calories)),
        trailing: IconButton(
          icon: Icon(Icons.add_circle_outline,
              color: colorScheme.primary, size: 28),
          onPressed: () => Navigator.of(context).pop(item),
        ),
        onTap: () async {
          // KORREKTUR HIER: Navigiere zum Detail-Screen anstatt zu poppen.
          final result = await Navigator.of(context)
              .push(
            MaterialPageRoute(
              builder: (context) => FoodDetailScreen(foodItem: item),
            ),
          );

          if (result is FoodItem) {
            Navigator.of(context).pop(result);
          } else {
            // Lade die Listen neu, falls sich Favoriten geändert haben.
            _loadFavorites();
            _loadRecentItems();
          }
        },
      ),
    );
  }

  // FÜGE DIESE NEUE METHODE HINZU
  void _scanBarcodeAndPop() async {
    final l10n = AppLocalizations.of(context)!;
    // Öffne den Scanner und warte auf einen Barcode (String) als Ergebnis
    final String? barcode = await Navigator.of(context).push<String>(
      MaterialPageRoute(builder: (context) => const ScannerScreen()),
    );

    // Wenn ein Barcode zurückgegeben wurde und der Screen noch existiert...
    if (barcode != null && mounted) {
      // ...suche das Produkt in der Datenbank.
      final foodItem =
          await ProductDatabaseHelper.instance.getProductByBarcode(barcode);

      // Wenn das Produkt gefunden wurde...
      if (foodItem != null) {
        // ...schließe den AddFoodScreen und gib das gefundene Item zurück.
        Navigator.of(context).pop(foodItem);
      } else {
        // Wenn nicht, zeige eine kurze Info-Nachricht.
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(SnackBar(
            content: Text(l10n.snackbarBarcodeNotFound(barcode)),
          ));
        }
      }
    }
  }

  Widget _buildCatalogSearchTab(AppLocalizations l10n) {
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    // UI: Suchleiste + Scanner-Button (wie in _buildSearchTab)
    final searchRow = Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 0),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: _searchController,
              onChanged: _runFilter, // nutzt deine bestehende Suche
              decoration: InputDecoration(
                hintText: l10n.searchHintText,
                prefixIcon: Icon(Icons.search,
                    color: colorScheme.onSurfaceVariant, size: 20),
                suffixIcon: _searchController.text.isNotEmpty
                    ? IconButton(
                        icon: Icon(Icons.clear,
                            color: colorScheme.onSurfaceVariant),
                        onPressed: () {
                          _searchController.clear();
                          _runFilter('');
                        },
                      )
                    : null,
              ),
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            style: IconButton.styleFrom(
              backgroundColor: colorScheme.surfaceContainerHighest,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12)),
            ),
            icon: Icon(Icons.qr_code_scanner, color: colorScheme.primary),
            onPressed: _scanBarcodeAndPop,
          ),
        ],
      ),
    );

    // FALL A: Kein Query → Kategorien/Accordion aus Base-DB (deine vorhandene Logik)
    final String q = _searchController.text.trim();
    if (q.isEmpty) {
      return Column(
        children: [
          const SizedBox(height: 12),
          searchRow,
          const SizedBox(height: 8),
          if (_baseCategories.isEmpty)
            const LinearProgressIndicator(minHeight: 2),
          Expanded(
            child: RefreshIndicator(
              onRefresh: () async {
                _catItems.clear();
                await _loadBaseCategories();
              },
              child: ListView.builder(
                padding: const EdgeInsets.only(bottom: 24),
                itemCount: _baseCategories.length,
                itemBuilder: (context, idx) {
                  final cat = _baseCategories[idx];
                  final key = cat['key'] as String;
                  final emoji = (cat['emoji'] as String?)?.trim();
                  final locale = Localizations.localeOf(context).languageCode;
                  final title = () {
                    final de = (cat['name_de'] as String?)?.trim();
                    final en = (cat['name_en'] as String?)?.trim();
                    if (locale == 'de') {
                      return (de?.isNotEmpty == true)
                          ? de!
                          : (en?.isNotEmpty == true ? en! : key);
                    } else {
                      return (en?.isNotEmpty == true)
                          ? en!
                          : (de?.isNotEmpty == true ? de! : key);
                    }
                  }();

                  final loading = _loadingCats.contains(key);
                  final items = _catItems[key];

                  return Theme(
                    data: Theme.of(context)
                        .copyWith(dividerColor: Colors.transparent),
                    child: ExpansionTile(
                      leading: Text(emoji?.isNotEmpty == true ? emoji! : '🗂️',
                          style: const TextStyle(fontSize: 20)),
                      title: Text(title),
                      initiallyExpanded: false,
                      onExpansionChanged: (expanded) {
                        if (expanded) _loadCategoryItems(key);
                      },
                      children: [
                        if (loading)
                          const Padding(
                            padding: EdgeInsets.symmetric(vertical: 12),
                            child: Center(child: CircularProgressIndicator()),
                          )
                        else if (items == null || items.isEmpty)
                          Padding(
                            padding: const EdgeInsets.symmetric(vertical: 12),
                            child: Center(child: Text(l10n.emptyCategory)),
                          )
                        else
                          ListView.builder(
                            shrinkWrap: true,
                            physics: const NeverScrollableScrollPhysics(),
                            padding:
                                DesignConstants.cardPadding.copyWith(top: 0),
                            itemCount: items.length,
                            itemBuilder: (_, i) => _buildFoodListItem(items[i]),
                          ),
                      ],
                    ),
                  );
                },
              ),
            ),
          ),
        ],
      );
    }

    // FALL B: Mit Query → zuerst Base-Items, dann OFF/User-Items (Priorisierung)
    final baseHits = _foundFoodItems
        .where((it) => it.source == FoodItemSource.base)
        .toList();
    final otherHits = _foundFoodItems
        .where((it) => it.source != FoodItemSource.base)
        .toList();

    return Column(
      children: [
        const SizedBox(height: 12),
        searchRow,
        const SizedBox(height: 12),
        Expanded(
          child: _isLoadingSearch
              ? const Center(child: CircularProgressIndicator())
              : (baseHits.isEmpty && otherHits.isEmpty)
                  ? Center(
                      child: Text(l10n.searchNoResults,
                          style: textTheme.titleMedium))
                  : ListView(
                      padding: DesignConstants.cardPadding,
                      children: [
                        if (baseHits.isNotEmpty) ...[
                          Text(l10n.searchSectionBase,
                              style: textTheme.titleMedium),
                          const SizedBox(height: 8),
                          ...baseHits.map(_buildFoodListItem),
                          const SizedBox(height: DesignConstants.spacingL),
                        ],
                        if (otherHits.isNotEmpty) ...[
                          Text(l10n.searchSectionOther,
                              style: textTheme.titleMedium),
                          const SizedBox(height: 8),
                          ...otherHits.map(_buildFoodListItem),
                        ],
                        if (otherHits
                            .any((i) => i.source == FoodItemSource.off))
                          const Padding(
                            padding: EdgeInsets.only(top: 12),
                            child: OffAttributionWidget(),
                          ),
                      ],
                    ),
        ),
      ],
    );
  }

  Widget _buildMealsTab(AppLocalizations l10n) {
    if (_isLoadingMeals) {
      return const Center(child: CircularProgressIndicator());
    }

    if (_meals.isEmpty) {
      // Empty State: kein Top-Button mehr – Erstellen läuft über den FAB
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.restaurant_menu,
                  size: 80, color: Colors.grey.shade400),
              const SizedBox(height: DesignConstants.spacingL),
              Text(l10n.mealsEmptyTitle,
                  style: Theme.of(context).textTheme.headlineSmall,
                  textAlign: TextAlign.center),
              const SizedBox(height: DesignConstants.spacingS),
              Text(l10n.mealsEmptyBody,
                  textAlign: TextAlign.center,
                  style: Theme.of(context)
                      .textTheme
                      .bodyLarge
                      ?.copyWith(color: Colors.grey.shade600)),
            ],
          ),
        ),
      );
    }

    return RefreshIndicator(
      onRefresh: _loadMeals,
      child: ListView.builder(
        padding: DesignConstants.cardPadding,
        itemCount: _meals.length,
        itemBuilder: (_, i) {
          final meal = _meals[i];
          return _buildMealCard(meal, l10n); // enthält jetzt Swipe-Actions
        },
      ),
    );
  }

  Widget _buildMealCard(Map<String, dynamic> meal, AppLocalizations l10n) {
    final color = Theme.of(context).colorScheme;

    Future<Map<String, num>> computeMealTotals(int mealId) async {
      final items = await _getMealItems(mealId);
      int kcal = 0;
      double c = 0, f = 0, p = 0;

      for (final it in items) {
        final bc = it['barcode'] as String;
        final qty = (it['quantity_in_grams'] as num?)?.toDouble() ?? 0.0;
        final fi = await ProductDatabaseHelper.instance.getProductByBarcode(bc);
        if (fi == null) continue;

        final factor = qty / 100.0;
        kcal += ((fi.calories ?? 0) * factor).round();
        c += (fi.carbs ?? 0) * factor;
        f += (fi.fat ?? 0) * factor;
        p += (fi.protein ?? 0) * factor;
      }
      return {
        'kcal': kcal,
        'c': c,
        'f': f,
        'p': p,
      };
    }

    return SummaryCard(
      child: ListTile(
        leading: Icon(Icons.restaurant, color: color.primary),
        title: Text(meal['name'] as String),
        subtitle: FutureBuilder<Map<String, num>>(
          future: computeMealTotals(meal['id'] as int),
          builder: (_, snap) {
            // Fallback: nur Anzahl Zutaten, falls noch lädt
            if (!snap.hasData) {
              return FutureBuilder<List<Map<String, dynamic>>>(
                future: _getMealItems(meal['id'] as int),
                builder: (_, s2) {
                  final count = s2.data?.length ?? 0;
                  return Text('${l10n.mealIngredientsTitle}: $count');
                },
              );
            }
            final t = snap.data!;
            final c = (t['c'] ?? 0).toDouble();
            final f = (t['f'] ?? 0).toDouble();
            final p = (t['p'] ?? 0).toDouble();
            final kcal = (t['kcal'] ?? 0).toInt();

            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                FutureBuilder<List<Map<String, dynamic>>>(
                  future: _getMealItems(meal['id'] as int),
                  builder: (_, s2) {
                    final count = s2.data?.length ?? 0;
                    return Text('${l10n.mealIngredientsTitle}: $count');
                  },
                ),
                const SizedBox(height: 2),
                Text(
                  '$kcal kcal   •   C ${c.toStringAsFixed(1)} g   •   F ${f.toStringAsFixed(1)} g   •   P ${p.toStringAsFixed(1)} g',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Colors.grey.shade600,
                      ),
                ),
              ],
            );
          },
        ),
        trailing: Wrap(
          spacing: 4,
          children: [
            IconButton(
              tooltip: l10n.mealsAddToDiary,
              icon: Icon(Icons.add_circle_outline, color: color.primary),
              onPressed: () => _confirmAndLogMeal(meal, l10n),
            ),
            IconButton(
              tooltip: l10n.mealsEdit,
              icon: const Icon(Icons.edit),
              onPressed: () async {
                // Neuer Screen öffnen (View), direkt in Edit wechseln
                await Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (_) => MealScreen(meal: meal, startInEdit: true),
                  ),
                );
                await _loadMeals();
              },
            ),
            IconButton(
              tooltip: l10n.mealsDelete,
              icon: const Icon(Icons.delete_outline),
              onPressed: () => _deleteMeal(meal, l10n),
            ),
          ],
        ),
        onTap: () async {
          // Neuer Detail-Screen (View)
          await Navigator.of(context).push(
            MaterialPageRoute(builder: (_) => MealScreen(meal: meal)),
          );
          await _loadMeals();
        },
      ),
    );
  }

  Future<void> _openMealEditor(AppLocalizations l10n,
      {Map<String, dynamic>? mealToEdit}) async {
    final isEdit = mealToEdit != null;
    final nameCtrl = TextEditingController(
        text: isEdit ? (mealToEdit['name'] as String? ?? '') : '');
    final notesCtrl = TextEditingController(
        text: isEdit ? (mealToEdit['notes'] as String? ?? '') : '');

    List<Map<String, dynamic>> items = isEdit
        ? List<Map<String, dynamic>>.from(
            await _getMealItems(mealToEdit['id'] as int))
        : <Map<String, dynamic>>[];

    setState(() => _suspendFab = true);
    final result = await showModalBottomSheet<bool>(
      context: context,
      useRootNavigator: true, // <- wichtig: über allen Overlays
      isScrollControlled: true,
      backgroundColor: Theme.of(context).colorScheme.surface,
      shape: const RoundedRectangleBorder(
          borderRadius: BorderRadius.vertical(top: Radius.circular(20))),
      builder: (ctx) {
        return StatefulBuilder(builder: (ctx, modalSetState) {
          // verhindert Doppelklicks auf "Speichern"
          bool saving = false;
          Future<void> addIngredient() async {
            final picked = await _pickIngredient(l10n);
            if (picked == null) return;
            final (barcode, grams) = picked;

            // Produkt für den Namen (optional) laden
            final fi = await ProductDatabaseHelper.instance
                .getProductByBarcode(barcode);
            final displayName =
                (fi?.name.isNotEmpty ?? false) ? fi!.name : null;
            modalSetState(() {
              items.add({
                'id': null,
                'meal_id': mealToEdit?['id'],
                'barcode': barcode,
                'quantity_in_grams': grams,
                'display_name': displayName, // nur Anzeige
              });
            });
          }

          return Padding(
            padding: EdgeInsets.only(
              left: 16,
              right: 16,
              top: 16,
              bottom: MediaQuery.of(ctx).viewInsets.bottom + 16,
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                    width: 40,
                    height: 4,
                    decoration: BoxDecoration(
                        color: Colors.grey.shade500,
                        borderRadius: BorderRadius.circular(2))),
                const SizedBox(height: 12),
                Text(isEdit ? l10n.mealsEdit : l10n.mealsCreate,
                    style: Theme.of(ctx)
                        .textTheme
                        .titleLarge
                        ?.copyWith(fontWeight: FontWeight.bold)),
                const SizedBox(height: 12),
                TextField(
                  controller: nameCtrl,
                  decoration: InputDecoration(labelText: l10n.mealNameLabel),
                ),
                const SizedBox(height: 8),
                TextField(
                  controller: notesCtrl,
                  decoration: InputDecoration(labelText: l10n.mealNotesLabel),
                  maxLines: 2,
                ),
                const SizedBox(height: 12),
                Row(
                  children: [
                    // Live-Validierung: Name + mind. 1 Zutat
                    // (keine Listener nötig; wir lesen direkt unten aus nameCtrl/items)
                    // Hinweis: Keine UI-Änderung hier – nur Logik im Save-Handler.
                    // (enabled/disabled steuern wir über onPressed: null)
                    Text(l10n.mealIngredientsTitle,
                        style: Theme.of(ctx).textTheme.titleMedium),
                    const Spacer(),
                    TextButton.icon(
                        onPressed: addIngredient,
                        icon: const Icon(Icons.add),
                        label: Text(l10n.mealAddIngredient)),
                  ],
                ),
                const SizedBox(height: 4),
                Flexible(
                  child: items.isEmpty
                      ? Padding(
                          padding: const EdgeInsets.symmetric(vertical: 16),
                          child: Text(l10n.emptyCategory,
                              textAlign: TextAlign.center),
                        )
                      : ListView.builder(
                          shrinkWrap: true,
                          itemCount: items.length,
                          itemBuilder: (_, i) {
                            final it = items[i];
                            final barcode = it['barcode'] as String;

                            return FutureBuilder<FoodItem?>(
                              future: ProductDatabaseHelper.instance
                                  .getProductByBarcode(barcode),
                              builder: (_, snap) {
                                final fi = snap.data;
                                final displayName =
                                    (fi?.name.isNotEmpty ?? false)
                                        ? fi!.name
                                        : barcode;
                                final isLiquid = (fi?.isLiquid == true);
                                final unit = isLiquid ? 'ml' : 'g';
                                final amount = it['quantity_in_grams'] ?? 0;

                                return ListTile(
                                  dense: true,
                                  leading: const Icon(Icons.drag_indicator,
                                      size: 18),
                                  title: Text(displayName),
                                  subtitle: Text('$amount $unit'),
                                  trailing: IconButton(
                                    icon: const Icon(Icons.close),
                                    onPressed: () => modalSetState(
                                        () => items.removeAt(i)), // <—
                                  ),
                                );
                              },
                            );
                          },
                        ),
                ),
                const SizedBox(height: 12),
                Row(
                  children: [
                    TextButton(
                      onPressed: () => Navigator.of(ctx).pop(),
                      child: Text(l10n.cancel),
                    ),
                    const Spacer(),
                    FilledButton(
                      onPressed: () async {
                        print("save button clicked");
                        final name = nameCtrl.text.trim();
                        if (name.isEmpty) return;
                        try {
                          if (isEdit) {
                            final mealId = mealToEdit['id'] as int;
                            await DatabaseHelper.instance.updateMeal(mealId,
                                name: name, notes: notesCtrl.text.trim());
                            await DatabaseHelper.instance
                                .clearMealItems(mealId);
                            for (final it in items) {
                              await DatabaseHelper.instance.addMealItem(
                                mealId,
                                barcode: it['barcode'] as String,
                                grams: it['quantity_in_grams'] as int,
                              );
                            }
                          } else {
                            final mealId =
                                await DatabaseHelper.instance.insertMeal(
                              name: name,
                              notes: notesCtrl.text.trim(),
                            );
                            for (final it in items) {
                              await DatabaseHelper.instance.addMealItem(
                                mealId,
                                barcode: it['barcode'] as String,
                                grams: it['quantity_in_grams'] as int,
                              );
                            }
                          }
                          _mealItemsCache.clear();
                          await _loadMeals();
                          if (mounted) Navigator.of(ctx).pop();
                          if (mounted) {
                            ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(content: Text(l10n.mealSaved)));
                          }
                        } catch (e) {
                          if (mounted) {
                            ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(content: Text('${l10n.error}: $e')));
                          }
                        }
                      },
                      child: Text(l10n.save),
                    ),
                  ],
                ),
              ],
            ),
          );
        });
      },
    );
    if (mounted) setState(() => _suspendFab = false);
  }

  Future<void> _deleteMeal(
      Map<String, dynamic> meal, AppLocalizations l10n) async {
    final ok = await showDialog<bool>(
          context: context,
          builder: (_) => AlertDialog(
            title: Text(l10n.mealDeleteConfirmTitle),
            content: Text(l10n.mealDeleteConfirmBody(meal['name'] as String)),
            actions: [
              TextButton(
                  onPressed: () => Navigator.pop(context, false),
                  child: Text(l10n.cancel)),
              TextButton(
                  onPressed: () => Navigator.pop(context, true),
                  child: Text(l10n.delete)),
            ],
          ),
        ) ??
        false;
    if (!ok) return;
    await DatabaseHelper.instance.deleteMeal(meal['id'] as int);
    _mealItemsCache.remove(meal['id'] as int);
    await _loadMeals();
    if (mounted) {
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(l10n.mealDeleted)));
    }
  }

  Future<(String, int)?> _pickIngredient(AppLocalizations l10n) async {
    final searchCtrl = TextEditingController();
    List<FoodItem> results = [];
    bool loading = false;

    return showDialog<(String, int)?>(
      context: context,
      builder: (ctx) {
        final qtyCtrl = TextEditingController(text: '100'); // default
        Future<void> runSearch(String q) async {
          if (q.trim().isEmpty) {
            results = [];
            (ctx as Element).markNeedsBuild();
            return;
          }
          loading = true;
          (ctx as Element).markNeedsBuild();
          results =
              await ProductDatabaseHelper.instance.searchProducts(q.trim());
          loading = false;
          (ctx).markNeedsBuild();
        }

        return AlertDialog(
          title: Text(l10n.mealAddIngredient),
          content: SizedBox(
            width: 500,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextField(
                  controller: searchCtrl,
                  decoration: InputDecoration(
                      hintText: l10n.searchHintText,
                      prefixIcon: const Icon(Icons.search)),
                  onChanged: runSearch,
                ),
                const SizedBox(height: 8),
                if (loading) const LinearProgressIndicator(minHeight: 2),
                Flexible(
                  child: results.isEmpty
                      ? Padding(
                          padding: const EdgeInsets.symmetric(vertical: 12),
                          child: Text(l10n.searchInitialHint),
                        )
                      : ListView.builder(
                          shrinkWrap: true,
                          itemCount: results.length,
                          itemBuilder: (_, i) {
                            final fi = results[i];
                            return ListTile(
                              dense: true,
                              title: Text(fi.name),
                              subtitle: Text(fi.brand.isNotEmpty
                                  ? fi.brand
                                  : l10n.noBrand),
                              trailing: IconButton(
                                icon: const Icon(Icons.add),
                                onPressed: () async {
                                  // Nach Menge fragen
                                  final grams = await showDialog<int>(
                                    context: context,
                                    builder: (_) => AlertDialog(
                                      title:
                                          Text(l10n.mealIngredientAmountLabel),
                                      content: TextField(
                                        controller: qtyCtrl,
                                        keyboardType: const TextInputType
                                            .numberWithOptions(decimal: false),
                                        decoration: const InputDecoration(
                                            suffixText: 'g/ml'),
                                      ),
                                      actions: [
                                        TextButton(
                                            onPressed: () =>
                                                Navigator.pop(context, null),
                                            child: Text(l10n.cancel)),
                                        TextButton(
                                            onPressed: () {
                                              final val = int.tryParse(
                                                  qtyCtrl.text.trim());
                                              Navigator.pop(context, val);
                                            },
                                            child: Text(l10n.add_button)),
                                      ],
                                    ),
                                  );
                                  if (grams != null && grams > 0 && mounted) {
                                    Navigator.of(ctx).pop((fi.barcode, grams));
                                  }
                                },
                              ),
                            );
                          },
                        ),
                ),
              ],
            ),
          ),
          actions: [
            TextButton(
                onPressed: () => Navigator.pop(ctx, null),
                child: Text(l10n.cancel)),
          ],
        );
      },
    );
  }

  Future<void> _confirmAndLogMeal(
    Map<String, dynamic> meal,
    AppLocalizations l10n,
  ) async {
    final mealId = meal['id'] as int;
    final rawItems =
        List<Map<String, dynamic>>.from(await _getMealItems(mealId));
    if (rawItems.isEmpty) return;

    // Produkte vorab laden (für Namen, isLiquid, Koffein)
    final Map<String, FoodItem?> products = {};
    for (final it in rawItems) {
      final bc = it['barcode'] as String;
      products[bc] =
          await ProductDatabaseHelper.instance.getProductByBarcode(bc);
    }

    // Editierbare Mengen pro Zutat
    final Map<String, TextEditingController> qtyCtrls = {
      for (final it in rawItems)
        (it['barcode'] as String):
            TextEditingController(text: '${it['quantity_in_grams']}')
    };

    // Interne Keys wie im Diary/Nutrition (WICHTIG: exakt diese Strings)
    const internalTypes = [
      'mealtypeBreakfast',
      'mealtypeLunch',
      'mealtypeDinner',
      'mealtypeSnack',
    ];
    String selectedMealType = internalTypes.first;

    final Map<String, String> mealTypeLabel = {
      'mealtypeBreakfast': l10n.mealtypeBreakfast,
      'mealtypeLunch': l10n.mealtypeLunch,
      'mealtypeDinner': l10n.mealtypeDinner,
      'mealtypeSnack': l10n.mealtypeSnack,
    };

    final ok = await showModalBottomSheet<bool>(
          context: context,
          isScrollControlled: true,
          backgroundColor: Theme.of(context).colorScheme.surface,
          shape: const RoundedRectangleBorder(
            borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
          ),
          builder: (ctx) {
            return StatefulBuilder(
              builder: (ctx, modalSetState) {
                return Padding(
                  padding: EdgeInsets.only(
                    left: 16,
                    right: 16,
                    top: 12,
                    bottom: MediaQuery.of(ctx).viewInsets.bottom + 16,
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Container(
                        width: 40,
                        height: 4,
                        decoration: BoxDecoration(
                          color: Colors.grey.shade500,
                          borderRadius: BorderRadius.circular(2),
                        ),
                      ),
                      const SizedBox(height: 12),
                      Text(
                        l10n.mealsAddToDiary,
                        style: Theme.of(ctx)
                            .textTheme
                            .titleLarge
                            ?.copyWith(fontWeight: FontWeight.bold),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        meal['name'] as String,
                        style: Theme.of(ctx).textTheme.titleMedium,
                      ),
                      const SizedBox(height: 12),

                      // Meal-Type Auswahl
                      DropdownButtonFormField<String>(
                        initialValue: selectedMealType,
                        decoration: InputDecoration(
                          labelText: l10n.mealTypeLabel,
                          border: const OutlineInputBorder(),
                          isDense: true,
                        ),
                        items: internalTypes
                            .map((key) => DropdownMenuItem(
                                  value: key,
                                  child: Text(mealTypeLabel[key] ?? key),
                                ))
                            .toList(),
                        onChanged: (v) {
                          if (v != null) {
                            modalSetState(() => selectedMealType = v);
                          }
                        },
                      ),

                      const SizedBox(height: 12),

                      // Zutatenliste mit editierbaren Mengen
                      Flexible(
                        child: ListView.separated(
                          shrinkWrap: true,
                          itemCount: rawItems.length,
                          separatorBuilder: (_, __) =>
                              const SizedBox(height: 10),
                          itemBuilder: (_, i) {
                            final it = rawItems[i];
                            final bc = it['barcode'] as String;
                            final fi = products[bc];
                            final displayName = (fi?.name.isNotEmpty ?? false)
                                ? fi!.name
                                : bc; // Fallback Barcode, falls Name fehlt
                            final unit = (fi?.isLiquid == true) ? 'ml' : 'g';

                            return Row(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                const Padding(
                                  padding: EdgeInsets.only(top: 14),
                                  child: Icon(Icons.lunch_dining),
                                ),
                                const SizedBox(width: 12),
                                Expanded(
                                  child: TextFormField(
                                    controller: qtyCtrls[bc],
                                    keyboardType:
                                        const TextInputType.numberWithOptions(
                                            decimal: true),
                                    decoration: InputDecoration(
                                      labelText:
                                          displayName, // Name statt Barcode
                                      helperText: l10n.amountLabel,
                                      suffixText: unit,
                                      border: OutlineInputBorder(
                                        borderRadius: BorderRadius.circular(14),
                                      ),
                                    ),
                                  ),
                                ),
                              ],
                            );
                          },
                        ),
                      ),

                      const SizedBox(height: 12),
                      Row(
                        children: [
                          TextButton(
                            onPressed: () => Navigator.of(ctx).pop(false),
                            child: Text(l10n.cancel),
                          ),
                          const Spacer(),
                          FilledButton(
                            onPressed: () => Navigator.of(ctx).pop(true),
                            child: Text(l10n.save),
                          ),
                        ],
                      ),
                    ],
                  ),
                );
              },
            );
          },
        ) ??
        false;

    if (!ok) return;

    // Speichern → pro Zutat ein FoodEntry (inkl. Wasser/Koffein falls zutreffend)
    final ts = DateTime.now();
    for (final it in rawItems) {
      final bc = it['barcode'] as String;
      final ctrl = qtyCtrls[bc]!;
      final qty =
          int.tryParse(ctrl.text.trim()) ?? (it['quantity_in_grams'] as int);

      // 1) FoodEntry (mit korrekt gesetztem Meal-Typ)
      await DatabaseHelper.instance.insertFoodEntry(
        FoodEntry(
          barcode: bc,
          timestamp: ts,
          quantityInGrams: qty,
          mealType: selectedMealType, // <- EXACT dieselben Keys wie im Diary
        ),
      );

      // 2) Wasser/Koffein automatisch buchen (bei Flüssigkeiten)
      final fi = products[bc];
      if (fi != null) {
        if (fi.isLiquid == true) {
          // await DatabaseHelper.instance.insertWaterEntry(qty, ts);
        }
        final c100 = fi.caffeineMgPer100ml;
        if (fi.isLiquid == true && c100 != null && c100 > 0) {
          await _logCaffeineDose(c100 * (qty / 100.0), ts);
        }
      }
    }

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(l10n.mealAddedToDiarySuccess)),
      );
    }
  }

  Future<void> _logCaffeineDose(double doseMg, DateTime timestamp) async {
    if (doseMg <= 0) return;

    // Caffeine-Supplement suchen/anlegen
    final supplements = await DatabaseHelper.instance.getAllSupplements();
    final caffeine = supplements.firstWhere(
      (s) => (s.code == 'caffeine') || s.name.toLowerCase() == 'caffeine',
      orElse: () => Supplement(
        name: 'Caffeine',
        defaultDose: 100,
        unit: 'mg',
        dailyLimit: 400,
        code: 'caffeine',
        isBuiltin: true,
      ),
    );

    final caffeineId = caffeine.id ??
        (await DatabaseHelper.instance.insertSupplement(caffeine)).id!;

    await DatabaseHelper.instance.insertSupplementLog(
      SupplementLog(
        supplementId: caffeineId,
        dose: doseMg,
        unit: 'mg',
        timestamp: timestamp,
        // source_food_entry_id: hier könnten wir verlinken, wenn wir die neue FoodEntry-ID hätten –
        // in diesem Flow buchen wir mehrere; Verlinkung kannst du später erweitern.
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/add_measurement_screen.dart =====

// lib/screens/add_measurement_screen.dart (Final & De-Materialisiert - Korrigiert)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/measurement.dart';
import 'package:lightweight/models/measurement_session.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart'; // HINZUGEFÜGT

class AddMeasurementScreen extends StatefulWidget {
  const AddMeasurementScreen({super.key});

  @override
  State<AddMeasurementScreen> createState() => _AddMeasurementScreenState();
}

class _AddMeasurementScreenState extends State<AddMeasurementScreen> {
  final _formKey = GlobalKey<FormState>();
  final Map<String, TextEditingController> _controllers = {};
  DateTime _selectedDateTime = DateTime.now();

  final Map<String, String> _measurementTypes = {
    'weight': 'kg',
    'fat_percent': '%',
    'waist': 'cm',
    'abdomen': 'cm',
    'hips': 'cm',
    'neck': 'cm',
    'shoulder': 'cm',
    'chest': 'cm',
    'left_bicep': 'cm',
    'right_bicep': 'cm',
    'left_forearm': 'cm',
    'right_forearm': 'cm',
    'left_thigh': 'cm',
    'right_thigh': 'cm',
    'left_calf': 'cm',
    'right_calf': 'cm',
  };

  @override
  void initState() {
    super.initState();
    for (var key in _measurementTypes.keys) {
      _controllers[key] = TextEditingController();
    }
  }

  @override
  void dispose() {
    _controllers.forEach((key, controller) => controller.dispose());
    super.dispose();
  }

  void _saveSession() async {
    final List<Measurement> measurements = [];
    _controllers.forEach((key, controller) {
      if (controller.text.isNotEmpty) {
        final value = double.tryParse(controller.text.replaceAll(',', '.'));
        if (value != null) {
          measurements.add(Measurement(
            sessionId: 0,
            type: key,
            value: value,
            unit: _measurementTypes[key]!,
          ));
        }
      }
    });

    if (measurements.isNotEmpty) {
      final session = MeasurementSession(
          timestamp: _selectedDateTime, measurements: measurements);
      await DatabaseHelper.instance.insertMeasurementSession(session);
      if (mounted) {
        Navigator.of(context).pop(true);
      }
    } else {
      if (mounted) Navigator.of(context).pop(false);
    }
  }

  String _getLocalizedMeasurementName(String key, AppLocalizations l10n) {
    switch (key) {
      case 'weight':
        return l10n.measurementWeight;
      case 'fat_percent':
        return l10n.measurementFatPercent;
      case 'neck':
        return l10n.measurementNeck;
      case 'shoulder':
        return l10n.measurementShoulder;
      case 'chest':
        return l10n.measurementChest;
      case 'left_bicep':
        return l10n.measurementLeftBicep;
      case 'right_bicep':
        return l10n.measurementRightBicep;
      case 'left_forearm':
        return l10n.measurementLeftForearm;
      case 'right_forearm':
        return l10n.measurementRightForearm;
      case 'abdomen':
        return l10n.measurementAbdomen;
      case 'waist':
        return l10n.measurementWaist;
      case 'hips':
        return l10n.measurementHips;
      case 'left_thigh':
        return l10n.measurementLeftThigh;
      case 'right_thigh':
        return l10n.measurementRightThigh;
      case 'left_calf':
        return l10n.measurementLeftCalf;
      case 'right_calf':
        return l10n.measurementRightCalf;
      default:
        return key;
    }
  }

  Future<void> _selectDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDateTime,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (picked != null && picked != _selectedDateTime) {
      setState(() {
        _selectedDateTime = DateTime(picked.year, picked.month, picked.day,
            _selectedDateTime.hour, _selectedDateTime.minute);
      });
    }
  }

  Future<void> _selectTime() async {
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(_selectedDateTime),
    );
    if (picked != null) {
      setState(() {
        _selectedDateTime = DateTime(
            _selectedDateTime.year,
            _selectedDateTime.month,
            _selectedDateTime.day,
            picked.hour,
            picked.minute);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final textTheme = Theme.of(context).textTheme;

    final formattedDate = DateFormat('dd.MM.yyyy').format(_selectedDateTime);
    final formattedTime = DateFormat.Hm().format(_selectedDateTime);

    return Scaffold(
      appBar: AppBar(
        title: Text(
          l10n.addMeasurementDialogTitle, // or whatever your l10n key is
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
        actions: [
          TextButton(
            onPressed: _saveSession,
            style: TextButton.styleFrom(
              foregroundColor: Theme.of(context).appBarTheme.foregroundColor,
            ),
            child: Text(l10n.save),
          ),
        ],
      ),
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: SingleChildScrollView(
        padding: DesignConstants.cardPadding,
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Datum & Uhrzeit Sektion
              Text(l10n.date_and_time_of_measurement,
                  style: textTheme.titleMedium),
              const SizedBox(height: DesignConstants.spacingS),
              SummaryCard(
                // KORREKTUR 2: Datum/Uhrzeit in SummaryCard
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                      horizontal: 16.0, vertical: 8.0),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      InkWell(
                          onTap: _selectDate,
                          child: Row(children: [
                            const Icon(Icons.calendar_today, size: 20),
                            const SizedBox(width: 8),
                            Text(formattedDate,
                                style: const TextStyle(fontSize: 16))
                          ])),
                      InkWell(
                          onTap: _selectTime,
                          child: Row(children: [
                            const Icon(Icons.access_time, size: 20),
                            const SizedBox(width: 8),
                            Text(formattedTime,
                                style: const TextStyle(fontSize: 16))
                          ])),
                    ],
                  ),
                ),
              ),
              const SizedBox(
                  height: DesignConstants
                      .spacingXL), // KORREKTUR 3: Abstand angepasst

              // Messwerte-Sektion
              Text(l10n.drawerMeasurements,
                  style: textTheme.titleMedium), // TODO: Lokalisieren
              const SizedBox(height: DesignConstants.spacingS),
              ..._measurementTypes.keys.map((key) {
                return Padding(
                  padding: const EdgeInsets.only(
                      bottom: 12.0), // KORREKTUR 4: Padding angepasst
                  child: TextFormField(
                    controller: _controllers[key],
                    decoration: InputDecoration(
                      labelText: _getLocalizedMeasurementName(key, l10n),
                      suffixText: _measurementTypes[key],
                    ),
                    keyboardType:
                        const TextInputType.numberWithOptions(decimal: true),
                    validator: (value) {
                      // Nur validieren, wenn etwas eingegeben wurde
                      if (value != null &&
                          value.isNotEmpty &&
                          double.tryParse(value.replaceAll(',', '.')) == null) {
                        return l10n.validatorPleaseEnterNumber;
                      }
                      return null;
                    },
                  ),
                );
              }),
              const SizedBox(
                  height: DesignConstants.spacingL), // Abstand zum Ende
            ],
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/scanner_screen.dart =====

// lib/screens/scanner_screen.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:mobile_scanner/mobile_scanner.dart';

class ScannerScreen extends StatefulWidget {
  const ScannerScreen({super.key});

  @override
  State<ScannerScreen> createState() => _ScannerScreenState();
}

class _ScannerScreenState extends State<ScannerScreen> {
  final MobileScannerController _controller = MobileScannerController(
    detectionSpeed: DetectionSpeed.normal,
    facing: CameraFacing.back,
  );
  bool _isDone = false;

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final textTheme = Theme.of(context).textTheme; // Hier definiert
    final scanWindow = Rect.fromCenter(
      center: MediaQuery.of(context).size.center(Offset.zero),
      width: 250,
      height: 250,
    );

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          l10n.scann_barcode_capslock,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      backgroundColor: Colors.black,
      body: Stack(
        fit: StackFit.expand,
        children: [
          MobileScanner(
            controller: _controller,
            scanWindow: scanWindow,
            onDetect: (capture) {
              if (!_isDone) {
                final String? code = capture.barcodes.first.rawValue;
                if (code != null) {
                  setState(() {
                    _isDone = true;
                  });
                  Navigator.of(context).pop(code);
                }
              }
            },
          ),
          // Visuelles Overlay
          CustomPaint(
            painter: ScannerOverlay(scanWindow: scanWindow),
          ),
        ],
      ),
    );
  }
}

// Helfer-Klasse für das visuelle Overlay
class ScannerOverlay extends CustomPainter {
  final Rect scanWindow;
  ScannerOverlay({required this.scanWindow});

  @override
  void paint(Canvas canvas, Size size) {
    final backgroundPath = Path()..addRect(Rect.largest);
    final cutoutPath = Path()..addRect(scanWindow);
    final backgroundPaint = Paint()
      ..color = Colors.black.withOpacity(0.5)
      ..style = PaintingStyle.fill
      ..blendMode = BlendMode.dstOut;

    final backgroundWithCutout =
        Path.combine(PathOperation.difference, backgroundPath, cutoutPath);
    canvas.drawPath(backgroundWithCutout, backgroundPaint);

    final borderPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2;
    canvas.drawRect(scanWindow, borderPaint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) {
    return false;
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/diary_screen.dart =====

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/dialogs/quantity_dialog_content.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/models/fluid_entry.dart';
import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';
import 'package:lightweight/models/tracked_food_item.dart';
import 'package:lightweight/screens/add_food_screen.dart';
import 'package:lightweight/screens/food_detail_screen.dart';
import 'package:lightweight/screens/supplement_track_screen.dart';
import 'package:lightweight/util/date_util.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/bottom_content_spacer.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
import 'package:lightweight/widgets/measurement_chart_widget.dart';
import 'package:lightweight/widgets/nutrition_summary_widget.dart';
import 'package:lightweight/widgets/supplement_summary_widget.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../models/tracked_supplement.dart';

class DiaryScreen extends StatefulWidget {
  const DiaryScreen({super.key});

  @override
  State<DiaryScreen> createState() => DiaryScreenState();
}

class DiaryScreenState extends State<DiaryScreen> {
  bool _isLoading = true;
  final ValueNotifier<DateTime> selectedDateNotifier =
      ValueNotifier(DateTime.now());
  DateTime get _selectedDate => selectedDateNotifier.value;
  DailyNutrition? _dailyNutrition;
  Map<String, List<TrackedFoodItem>> _entriesByMeal = {};
  List<FluidEntry> _fluidEntries = [];
  List<TrackedSupplement> _trackedSupplements = [];
  String _selectedChartRangeKey = '30D';
  final Map<String, bool> _mealExpanded = {
    "mealtypeBreakfast": false,
    "mealtypeLunch": false,
    "mealtypeDinner": false,
    "mealtypeSnack": false,
    "fluids": false,
  };

  @override
  void initState() {
    super.initState();
    loadDataForDate(_selectedDate);
  }

  @override
  void dispose() {
    selectedDateNotifier.dispose();
    super.dispose();
  }

// lib/screens/diary_screen.dart

// ... (Rest der Datei bleibt unverändert)

// ERSETZEN SIE DIESE METHODE
  Future<void> loadDataForDate(DateTime date) async {
    if (!mounted) return;
    setState(() => _isLoading = true);

    final prefs = await SharedPreferences.getInstance();
    final targetCalories = prefs.getInt('targetCalories') ?? 2500;
    final targetProtein = prefs.getInt('targetProtein') ?? 180;
    final targetCarbs = prefs.getInt('targetCarbs') ?? 250;
    final targetFat = prefs.getInt('targetFat') ?? 80;
    final targetWater = prefs.getInt('targetWater') ?? 3000;
    final targetCaffeine = prefs.getInt('targetCaffeine') ?? 400;

    final foodEntries = await DatabaseHelper.instance.getEntriesForDate(date);
    final fluidEntries = await DatabaseHelper.instance.getFluidEntriesForDate(date);
    final waterIntake = fluidEntries.fold<int>(0, (sum, entry) => sum + entry.quantityInMl);

    final summary = DailyNutrition(
      targetCalories: targetCalories,
      targetProtein: targetProtein,
      targetCarbs: targetCarbs,
      targetFat: targetFat,
      targetWater: targetWater,
      targetCaffeine: targetCaffeine,
    );
    summary.water = waterIntake;

    for (final entry in fluidEntries) {
      summary.calories += entry.kcal ?? 0;
      final factor = entry.quantityInMl / 100.0;
      summary.sugar += (entry.sugarPer100ml ?? 0) * factor;
      summary.carbs += ((entry.carbsPer100ml ?? 0) * factor).round();
    }

    final Map<String, List<TrackedFoodItem>> groupedEntries = {
      'mealtypeBreakfast': [],
      'mealtypeLunch': [],
      'mealtypeDinner': [],
      'mealtypeSnack': []
    };

    for (final entry in foodEntries) {
      final foodItem = await ProductDatabaseHelper.instance
          .getProductByBarcode(entry.barcode);
      if (foodItem != null) {
        summary.calories +=
            (foodItem.calories / 100 * entry.quantityInGrams).round();
        summary.protein +=
            (foodItem.protein / 100 * entry.quantityInGrams).round();
        summary.carbs += (foodItem.carbs / 100 * entry.quantityInGrams).round();
        summary.fat += (foodItem.fat / 100 * entry.quantityInGrams).round();

        final trackedItem = TrackedFoodItem(entry: entry, item: foodItem);
        groupedEntries[entry.mealType]?.add(trackedItem);
      }
    }

    for (var meal in groupedEntries.values) {
      meal.sort((a, b) => b.entry.timestamp.compareTo(a.entry.timestamp));
    }

    final allSupplements = await DatabaseHelper.instance.getAllSupplements();
    final todaysSupplementLogs =
        await DatabaseHelper.instance.getSupplementLogsForDate(date);

    final Map<int, double> todaysDoses = {};
    for (final log in todaysSupplementLogs) {
      todaysDoses.update(log.supplementId, (value) => value + log.dose,
          ifAbsent: () => log.dose);
    }
    
    // *** KORREKTUR HIER ***
    // Wir fangen den Fehler ab, falls das Supplement nicht gefunden wird.
    Supplement? caffeineSupplement;
    try {
      caffeineSupplement = allSupplements.firstWhere((s) => s.code == 'caffeine');
    } catch(e) {
      caffeineSupplement = null; // Sicherstellen, dass es null ist, wenn nicht gefunden
    }

    if (caffeineSupplement != null && caffeineSupplement.id != null) {
        summary.caffeine = todaysDoses[caffeineSupplement.id] ?? 0.0;
    }

    final trackedSupps = allSupplements
        .map((s) => TrackedSupplement(
              supplement: s,
              totalDosedToday: todaysDoses[s.id] ?? 0.0,
            ))
        .toList();

    if (mounted) {
      setState(() {
        selectedDateNotifier.value = date;
        _dailyNutrition = summary;
        _entriesByMeal = groupedEntries;
        _fluidEntries = fluidEntries;
        _trackedSupplements = trackedSupps;
        _isLoading = false;
      });
    }
  }

// ... (Rest der Datei bleibt unverändert)

  Future<void> _deleteFoodEntry(int id) async {
    await DatabaseHelper.instance.deleteFoodEntry(id);
    loadDataForDate(_selectedDate);
  }

  Future<void> _deleteFluidEntry(int id) async {
    await DatabaseHelper.instance.deleteFluidEntry(id);
    loadDataForDate(_selectedDate);
  }

  Future<void> _editFoodEntry(TrackedFoodItem trackedItem) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<QuantityDialogContentState> dialogStateKey = GlobalKey();

    final result = await showDialog<(int, DateTime, String, double?)?>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(trackedItem.item.name,
              maxLines: 2, overflow: TextOverflow.ellipsis),
          content: QuantityDialogContent(
            key: dialogStateKey,
            item: trackedItem.item,
            initialQuantity: trackedItem.entry.quantityInGrams,
            initialTimestamp: trackedItem.entry.timestamp,
            initialMealType: trackedItem.entry.mealType,
          ),
          actions: [
            TextButton(
                child: Text(l10n.cancel),
                onPressed: () => Navigator.of(context).pop()),
            FilledButton(
                child: Text(l10n.save),
                onPressed: () {
                  final state = dialogStateKey.currentState;
                  if (state != null) {
                    final quantity = int.tryParse(state.quantityText);
                    final caffeine = double.tryParse(
                        state.caffeineText.replaceAll(',', '.'));
                    if (quantity != null && quantity > 0) {
                      Navigator.of(context).pop((
                        quantity,
                        state.selectedDateTime,
                        state.selectedMealType,
                        caffeine
                      ));
                    }
                  }
                }),
          ],
        );
      },
    );

    if (result != null) {
      final updatedEntry = FoodEntry(
        id: trackedItem.entry.id,
        barcode: trackedItem.item.barcode,
        quantityInGrams: result.$1,
        timestamp: result.$2,
        mealType: result.$3,
      );
      await DatabaseHelper.instance.updateFoodEntry(updatedEntry);
      loadDataForDate(_selectedDate);
    }
  }

  Future<void> _addFoodToMeal(String mealType) async {
    final FoodItem? selectedFoodItem = await Navigator.of(context)
        .push<FoodItem>(
            MaterialPageRoute(builder: (context) => const AddFoodScreen()));

    if (selectedFoodItem == null || !mounted) return;

    final result = await _showQuantityMenu(selectedFoodItem, mealType);
    if (result == null || !mounted) return;

    final int quantity = result.quantity;
    final DateTime timestamp = result.timestamp;
    final String resultMealType = result.mealType;
    final bool isLiquid = result.isLiquid;
    final double? caffeinePer100 = result.caffeinePer100ml;

    // 1. Immer den FoodEntry mit allen Nährwerten speichern
    final newFoodEntry = FoodEntry(
      barcode: selectedFoodItem.barcode,
      timestamp: timestamp,
      quantityInGrams: quantity,
      mealType: resultMealType,
    );
    final newFoodEntryId = await DatabaseHelper.instance.insertFoodEntry(newFoodEntry);

    // 2. Wenn es eine Flüssigkeit ist, ZUSÄTZLICH einen FluidEntry NUR FÜR WASSER erstellen
    if (isLiquid) {
      final newFluidEntry = FluidEntry(
        timestamp: timestamp,
        quantityInMl: quantity,
        name: selectedFoodItem.name,
        kcal: null,
        sugarPer100ml: null,
        carbsPer100ml: null,
        caffeinePer100ml: null,
        linked_food_entry_id: newFoodEntryId,
      );
      await DatabaseHelper.instance.insertFluidEntry(newFluidEntry);
    }
    
    // 3. Koffein nur loggen, wenn als Flüssigkeit deklariert
    if (isLiquid && caffeinePer100 != null && caffeinePer100 > 0) {
      final totalCaffeine = (caffeinePer100 / 100.0) * quantity;
      await _logCaffeineDose(totalCaffeine, timestamp, foodEntryId: newFoodEntryId);
    }

    loadDataForDate(_selectedDate);
  }


  // FÜGEN SIE DIESE ZWEI NEUEN METHODEN ZUR KLASSE HINZU
  Future<({
    int quantity,
    DateTime timestamp,
    String mealType,
    bool isLiquid,
    double? sugarPer100ml,
    double? caffeinePer100ml
  })?> _showQuantityMenu(FoodItem item, String mealType) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<QuantityDialogContentState> dialogStateKey = GlobalKey();

    return showGlassBottomMenu<({
      int quantity,
      DateTime timestamp,
      String mealType,
      bool isLiquid,
      double? sugarPer100ml,
      double? caffeinePer100ml
    })>(
      context: context,
      title: item.name,
      contentBuilder: (ctx, close) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            QuantityDialogContent(
              key: dialogStateKey, 
              item: item,
              initialMealType: mealType, // WICHTIG: Mahlzeit vorauswählen
              initialTimestamp: _selectedDate,
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () {
                      close();
                      Navigator.of(ctx).pop(null);
                    },
                    child: Text(l10n.cancel),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton(
                    onPressed: () {
                      final state = dialogStateKey.currentState;
                      if (state != null) {
                        final quantity = int.tryParse(state.quantityText);
                        final sugar = double.tryParse(state.sugarText.replaceAll(',', '.'));
                        final caffeine = double.tryParse(state.caffeineText.replaceAll(',', '.'));

                        if (quantity != null && quantity > 0) {
                          close();
                          Navigator.of(ctx).pop((
                            quantity: quantity,
                            timestamp: state.selectedDateTime,
                            mealType: state.selectedMealType,
                            isLiquid: state.isLiquid,
                            sugarPer100ml: sugar,
                            caffeinePer100ml: caffeine
                          ));
                        }
                      }
                    },
                    child: Text(l10n.add_button),
                  ),
                ),
              ],
            ),
          ],
        );
      },
    );
  }

  Future<void> _logCaffeineDose(double doseMg, DateTime timestamp, {int? foodEntryId, int? fluidEntryId}) async {
    if (doseMg <= 0) return;
    
    final supplements = await DatabaseHelper.instance.getAllSupplements();
    Supplement? caffeineSupplement;
    try {
      caffeineSupplement = supplements.firstWhere((s) => s.code == 'caffeine');
    } catch(e) { return; }

    if (caffeineSupplement.id == null) return;

    await DatabaseHelper.instance.insertSupplementLog(
      SupplementLog(
        supplementId: caffeineSupplement.id!,
        dose: doseMg,
        unit: 'mg',
        timestamp: timestamp,
        source_food_entry_id: foodEntryId,
        source_fluid_entry_id: fluidEntryId,
      ),
    );
  }

  Future<void> pickDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2020),
      // Erlaube Auswahl in der Zukunft, z.B. für Vorausplanung
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );
    if (picked != null && picked != _selectedDate) {
      loadDataForDate(picked);
    }
  }

  String _getAppBarTitle(AppLocalizations l10n) {
    final today = DateTime.now();
    final yesterday = today.subtract(const Duration(days: 1));
    final dayBeforeYesterday = today.subtract(const Duration(days: 2));

    if (_selectedDate.isSameDate(today)) {
      return l10n.today;
    } else if (_selectedDate.isSameDate(yesterday)) {
      return l10n.yesterday; // ← NEW
    } else if (_selectedDate.isSameDate(dayBeforeYesterday)) {
      return l10n.dayBeforeYesterday; // ← NEW
    } else {
      return DateFormat.yMMMMd(Localizations.localeOf(context).toString())
          .format(_selectedDate);
    }
  }

  void navigateDay(bool forward) {
    final newDay = _selectedDate.add(Duration(days: forward ? 1 : -1));
    // Im Gegensatz zum NutritionScreen erlauben wir hier die Navigation in die Zukunft
    // if (forward && newDay.isAfter(DateTime.now())) return;

    loadDataForDate(newDay);
  }

  Widget _buildWeightChartCard(
      BuildContext context, ColorScheme colorScheme, AppLocalizations l10n) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(l10n.weightHistoryTitle,
                    style: Theme.of(context)
                        .textTheme
                        .titleMedium
                        ?.copyWith(fontWeight: FontWeight.bold)),
                Expanded(
                  child: Align(
                    alignment: Alignment.centerRight,
                    child: Wrap(
                      spacing: 8.0,
                      alignment: WrapAlignment.end,
                      children: ['30D', '90D', 'All']
                          .map((key) => _buildFilterButton(key, key))
                          .toList(),
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: DesignConstants.spacingL),
            MeasurementChartWidget(
              chartType: 'weight',
              dateRange: _calculateDateRange(),
              unit: "kg",
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFilterButton(String label, String key) {
    final theme = Theme.of(context);
    final isSelected = _selectedChartRangeKey == key;
    return GestureDetector(
      onTap: () {
        setState(() {
          _selectedChartRangeKey = key;
        });
        // Chart wird durch setState im MeasurementChartWidget neu geladen
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10.0, vertical: 6.0),
        decoration: BoxDecoration(
          color: isSelected
              ? theme.colorScheme.primary
              : theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
          borderRadius: BorderRadius.circular(8.0),
        ),
        child: Text(
          label,
          style: theme.textTheme.labelSmall?.copyWith(
            color: isSelected
                ? theme.colorScheme.onPrimary
                : theme.colorScheme.onSurfaceVariant,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  DateTimeRange _calculateDateRange() {
    final now = DateTime.now();
    DateTime start;
    switch (_selectedChartRangeKey) {
      case '90D':
        start = now.subtract(const Duration(days: 89));
        break;
      case 'All':
        // Für "Alle" setzen wir ein sehr frühes Datum,
        // der Chart wird die Daten entsprechend laden
        start = DateTime(2020);
        break;
      case '30D':
      default:
        start = now.subtract(const Duration(days: 29));
    }
    return DateTimeRange(start: start, end: now);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final hasEntries = _entriesByMeal.values.any((list) => list.isNotEmpty);

    return Scaffold(
      // AppBar wird jetzt im MainScreen verwaltet
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : RefreshIndicator(
              onRefresh: () => loadDataForDate(_selectedDate),
              child: ListView(
                padding: DesignConstants.cardPadding,
                children: [
                  // Die Datumsnavigation mit Pfeilen wurde in die AppBar verschoben
                  const SizedBox(height: DesignConstants.spacingL),
                  _buildSectionTitle(context, l10n.today_overview_text),
                  if (_dailyNutrition != null)
                    NutritionSummaryWidget(
                        nutritionData: _dailyNutrition!,
                        l10n: l10n,
                        isExpandedView: false),
                  const SizedBox(height: DesignConstants.spacingXS),
                  SupplementSummaryWidget(
                    trackedSupplements: _trackedSupplements,
                    onTap: () => Navigator.of(context)
                        .push(MaterialPageRoute(
                            builder: (context) =>
                                const SupplementTrackScreen()))
                        .then((_) => loadDataForDate(_selectedDate)),
                  ),
                  const SizedBox(height: DesignConstants.spacingXL),
                  _buildSectionTitle(context, l10n.protocol_today_capslock),
                  _buildTodaysLog(l10n),
                  const SizedBox(height: DesignConstants.spacingXL),
                  _buildSectionTitle(context, l10n.measurementWeightCapslock),
                  _buildWeightChartCard(
                      context, Theme.of(context).colorScheme, l10n),
                  const BottomContentSpacer(),
                ],
              ),
            ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(title,
          style: Theme.of(context)
              .textTheme
              .labelLarge
              ?.copyWith(color: Colors.grey[600], fontWeight: FontWeight.bold)),
    );
  }

  Widget _buildTodaysLog(AppLocalizations l10n) {
    const mealOrder = [
      "mealtypeBreakfast",
      "mealtypeLunch",
      "mealtypeDinner",
      "mealtypeSnack"
    ];

    return Column(
      children: [
        ...mealOrder.map((mealKey) {
          final entries = _entriesByMeal[mealKey] ?? [];
          // Calculate macros for this specific meal
          final mealMacros = _MealMacros();
          for (var item in entries) {
            final factor = item.entry.quantityInGrams / 100.0;
            mealMacros.calories += (item.item.calories * factor).round();
            mealMacros.protein += (item.item.protein * factor).round();
            mealMacros.carbs += (item.item.carbs * factor).round();
            mealMacros.fat += (item.item.fat * factor).round();
          }

          return _buildMealCard(
            _getLocalizedMealName(l10n, mealKey),
            mealKey,
            entries,
            mealMacros,
            l10n,
          );
        }).toList(),
        _buildFluidsCard(l10n),
      ],
    );
  }

  Widget _buildMealCard(
    String title,
    String mealKey,
    List<TrackedFoodItem> items,
    _MealMacros macros,
    AppLocalizations l10n,
  ) {
    final isOpen = _mealExpanded[mealKey] ?? false;
    final theme = Theme.of(context);
    final titleStyle = theme.textTheme.titleLarge; // Inter, fett wie im Rest

    return SummaryCard(
      padding: const EdgeInsets.all(12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // Header (Tippen toggelt)
          InkWell(
            onTap: () => setState(() {
              _mealExpanded[mealKey] = !isOpen;
            }),
            child: Row(
              children: [
                Expanded(child: Text(title, style: titleStyle)),
                Icon(isOpen ? Icons.expand_less : Icons.expand_more),
                const SizedBox(width: 4),
                IconButton(
                  icon: const Icon(Icons.add_circle),
                  color: theme.colorScheme.primary,
                  onPressed: () => _addFoodToMeal(mealKey),
                  tooltip: l10n.addFoodOption,
                ),
              ],
            ),
          ),

          // <<< NEU: Makro-Zeile unter dem Titel (eigene Zeile, linksbündig)
          if (items.isNotEmpty) ...[
            const SizedBox(height: 4),
            Align(
              alignment: Alignment.centerLeft,
              child: Text(
                '${macros.calories} kcal · '
                '${macros.protein}g P · '
                '${macros.carbs}g C · '
                '${macros.fat}g F',
                style: theme.textTheme.bodySmall?.copyWith(
                  color: Colors.grey[600],
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ],

          // Inhalt (animiert ein-/ausklappen)
          AnimatedCrossFade(
            crossFadeState:
                isOpen ? CrossFadeState.showFirst : CrossFadeState.showSecond,
            duration: const Duration(milliseconds: 180),
            firstChild: Column(
              children: [
                if (items.isNotEmpty) const Divider(height: 16),
                ...items.map((item) => _buildFoodEntryTile(l10n, item)),
              ],
            ),
            secondChild: const SizedBox.shrink(),
          ),
        ],
      ),
    );
  }

  Widget _buildFluidsCard(AppLocalizations l10n) {
    final isOpen = _mealExpanded['fluids'] ?? false;
    final theme = Theme.of(context);
    final titleStyle = theme.textTheme.titleLarge;

    return SummaryCard(
      padding: const EdgeInsets.all(12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          InkWell(
            onTap: () => setState(() {
              _mealExpanded['fluids'] = !isOpen;
            }),
            child: Row(
              children: [
                Expanded(child: Text(l10n.water, style: titleStyle)),
                Icon(isOpen ? Icons.expand_less : Icons.expand_more),
                const SizedBox(width: 4),
                IconButton(
                  icon: const Icon(Icons.add_circle),
                  color: theme.colorScheme.primary,
                  onPressed: () {},
                  tooltip: l10n.addLiquidOption,
                ),
              ],
            ),
          ),
          AnimatedCrossFade(
            crossFadeState:
                isOpen ? CrossFadeState.showFirst : CrossFadeState.showSecond,
            duration: const Duration(milliseconds: 180),
            firstChild: Column(
              children: [
                if (_fluidEntries.isNotEmpty) const Divider(height: 16),
                ..._fluidEntries.map((entry) => _buildFluidEntryTile(l10n, entry)),
              ],
            ),
            secondChild: const SizedBox.shrink(),
          ),
        ],
      ),
    );
  }

  Widget _buildFluidEntryTile(AppLocalizations l10n, FluidEntry entry) {
    final totalSugar = (entry.sugarPer100ml != null) ? (entry.sugarPer100ml! / 100 * entry.quantityInMl).toStringAsFixed(1) : '0';
    final totalCaffeine = (entry.caffeinePer100ml != null) ? (entry.caffeinePer100ml! / 100 * entry.quantityInMl).toStringAsFixed(1) : '0';

    return Dismissible(
      key: Key('fluid_entry_${entry.id}'),
      background: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      direction: DismissDirection.endToStart,
      confirmDismiss: (direction) async {
        return await showDialog<bool>(
              context: context,
              builder: (BuildContext context) {
                return AlertDialog(
                  title: Text(l10n.deleteConfirmTitle),
                  content: Text(l10n.deleteConfirmContent),
                  actions: <Widget>[
                    TextButton(
                        onPressed: () => Navigator.of(context).pop(false),
                        child: Text(l10n.cancel)),
                    TextButton(
                        onPressed: () => Navigator.of(context).pop(true),
                        child: Text(l10n.delete)),
                  ],
                );
              },
            ) ??
            false;
      },
      onDismissed: (direction) {
        _deleteFluidEntry(entry.id!);
      },
      child: SummaryCard(
        child: ListTile(
          title: Text(entry.name),
          subtitle: Text("${entry.quantityInMl}ml · Sugar: ${totalSugar}g · Caffeine: ${totalCaffeine}mg"),
          trailing: Text("${entry.kcal ?? 0} kcal"),
        ),
      ),
    );
  }


  Widget _buildMacroText(String text) {
    return Text(
      text,
      style: TextStyle(
        color: Colors.grey[600],
        fontSize: 12,
        fontWeight: FontWeight.w600,
      ),
    );
  }

  Widget _buildFoodEntryTile(
      AppLocalizations l10n, TrackedFoodItem trackedItem) {
    return Dismissible(
      key: Key('food_hub_entry_${trackedItem.entry.id}'),
      background: const SwipeActionBackground(
        color: Colors.blueAccent,
        icon: Icons.edit,
        alignment: Alignment.centerLeft,
      ),
      secondaryBackground: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      confirmDismiss: (direction) async {
        if (direction == DismissDirection.startToEnd) {
          _editFoodEntry(trackedItem);
          return false;
        } else {
          return await showDialog<bool>(
                context: context,
                builder: (BuildContext context) {
                  return AlertDialog(
                    title: Text(l10n.deleteConfirmTitle),
                    content: Text(l10n.deleteConfirmContent),
                    actions: <Widget>[
                      TextButton(
                          onPressed: () => Navigator.of(context).pop(false),
                          child: Text(l10n.cancel)),
                      TextButton(
                          onPressed: () => Navigator.of(context).pop(true),
                          child: Text(l10n.delete)),
                    ],
                  );
                },
              ) ??
              false;
        }
      },
      onDismissed: (direction) {
        if (direction == DismissDirection.endToStart) {
          _deleteFoodEntry(trackedItem.entry.id!);
        }
      },
      child: SummaryCard(
        child: ListTile(
          title: Text(trackedItem.item.name),
          subtitle: Text("${trackedItem.entry.quantityInGrams}g"),
          trailing: Text("${trackedItem.calculatedCalories} kcal"),
          onTap: () {
            Navigator.of(context)
                .push(MaterialPageRoute(
                    builder: (context) =>
                        FoodDetailScreen(trackedItem: trackedItem)))
                .then((_) => loadDataForDate(_selectedDate));
          },
        ),
      ),
    );
  }

  Widget _buildEmptyLogState(AppLocalizations l10n) {
    return SummaryCard(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Text(
          l10n.noEntriesForPeriod,
          textAlign: TextAlign.center,
          style: Theme.of(context).textTheme.bodyLarge,
        ),
      ),
    );
  }

  String _getLocalizedMealName(AppLocalizations l10n, String key) {
    switch (key) {
      case "mealtypeBreakfast":
        return l10n.mealtypeBreakfast;
      case "mealtypeLunch":
        return l10n.mealtypeLunch;
      case "mealtypeDinner":
        return l10n.mealtypeDinner;
      case "mealtypeSnack":
        return l10n.mealtypeSnack;
      default:
        return key;
    }
  }
}

class _MealMacros {
  int calories = 0;
  int protein = 0;
  int carbs = 0;
  int fat = 0;
}

class DiaryAppBar extends StatelessWidget {
  final ValueNotifier<DateTime>? selectedDateNotifier;
  const DiaryAppBar({super.key, required this.selectedDateNotifier});

  String _getAppBarTitle(
      BuildContext context, AppLocalizations l10n, DateTime selectedDate) {
    final today = DateTime.now();
    final yesterday = today.subtract(const Duration(days: 1));
    final dayBeforeYesterday = today.subtract(const Duration(days: 2));

    if (selectedDate.isSameDate(today)) {
      return l10n.today;
    } else if (selectedDate.isSameDate(yesterday)) {
      return l10n.yesterday; // ← NEW
    } else if (selectedDate.isSameDate(dayBeforeYesterday)) {
      return l10n.dayBeforeYesterday; // ← NEW
    } else {
      return DateFormat.yMMMMd(Localizations.localeOf(context).toString())
          .format(selectedDate);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    // Gracefully handle the case where the notifier might be null during the first frame
    if (selectedDateNotifier == null) {
      return Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0),
        child: Text(
          l10n.today, // Default to 'Today'
          style: Theme.of(context)
              .textTheme
              .titleLarge
              ?.copyWith(fontWeight: FontWeight.w900),
        ),
      );
    }

    return ValueListenableBuilder<DateTime>(
      valueListenable: selectedDateNotifier!,
      builder: (context, selectedDate, child) {
        final title = _getAppBarTitle(context, l10n, selectedDate);
        return Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0),
          child: Text(
            title,
            style: Theme.of(context)
                .textTheme
                .titleLarge
                ?.copyWith(fontWeight: FontWeight.w900),
          ),
        );
      },
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/nutrition_hub_screen.dart =====

// lib/screens/nutrition_hub_screen.dart
import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/add_food_screen.dart';
import 'package:lightweight/screens/supplement_track_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/bottom_content_spacer.dart';
import 'package:lightweight/widgets/summary_card.dart';

class NutritionHubScreen extends StatelessWidget {
  const NutritionHubScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: ListView(
        padding: DesignConstants.cardPadding,
        children: [
          _buildNavigationCard(
            context: context,
            icon: Icons.restaurant_menu_outlined,
            title: l10n.tabMeals,
            subtitle: l10n.mealsEmptyBody,
            onTap: () {
              Navigator.of(context).push(
                  MaterialPageRoute(builder: (_) => const AddFoodScreen())); //MaterialPageRoute(builder: (_) => const AddFoodScreen(initialTab: 3)));
            },
          ),
          const SizedBox(height: DesignConstants.spacingM),
          _buildNavigationCard(
            context: context,
            icon: Icons.medication_outlined,
            title: l10n.supplementTrackerTitle,
            subtitle: l10n.supplementTrackerDescription,
            onTap: () {
              Navigator.of(context).push(
                  MaterialPageRoute(builder: (_) => const SupplementTrackScreen()));
            },
          ),
          const SizedBox(height: DesignConstants.spacingM),
          _buildNavigationCard(
            context: context,
            icon: Icons.search,
            title: l10n.drawerFoodExplorer,
            subtitle: "Datenbank durchsuchen und Favoriten verwalten", // TODO: l10n
            onTap: () {
                Navigator.of(context).push(
                  MaterialPageRoute(builder: (_) => const AddFoodScreen()));
            },
          ),
          const SizedBox(height: DesignConstants.spacingXL),
          _buildPlaceholderCard(context, l10n),
          const BottomContentSpacer(),
        ],
      ),
    );
  }

  Widget _buildNavigationCard({
    required BuildContext context,
    required IconData icon,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
  }) {
    return SummaryCard(
      child: ListTile(
        contentPadding:
            const EdgeInsets.symmetric(vertical: 12.0, horizontal: 16.0),
        leading:
            Icon(icon, size: 40, color: Theme.of(context).colorScheme.primary),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Text(subtitle),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
      ),
    );
  }

  Widget _buildPlaceholderCard(BuildContext context, AppLocalizations l10n) {
    final theme = Theme.of(context);
    return SummaryCard(
      child: Padding(
        padding: const EdgeInsets.all(DesignConstants.spacingXL),
        child: Column(
            children: [
              Icon(Icons.rule_folder_outlined,
                  size: 72, color: theme.colorScheme.primary.withOpacity(0.6)),
              const SizedBox(height: DesignConstants.spacingL),
              Text(
                "Ernährungsplan", // TODO: l10n
                style: theme.textTheme.headlineSmall
                    ?.copyWith(fontWeight: FontWeight.bold),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: DesignConstants.spacingS),
              Text(
                "Erstelle und verfolge hier bald detaillierte Ernährungspläne.", // TODO: l10n
                style: theme.textTheme.bodyMedium
                    ?.copyWith(color: Colors.grey.shade500),
                textAlign: TextAlign.center,
              ),
            ],
          ),
      ),
    );
  }
}

===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/settings_screen.dart =====

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/data_management_screen.dart';
import 'package:lightweight/services/profile_service.dart';
import 'package:lightweight/services/theme_service.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:provider/provider.dart';

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  String _appVersion = '';

  @override
  void initState() {
    super.initState();
    _loadAppVersion();
  }

  Future<void> _loadAppVersion() async {
    final packageInfo = await PackageInfo.fromPlatform();
    if (mounted) {
      setState(() {
        _appVersion = "${packageInfo.version} (${packageInfo.buildNumber})";
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final themeService = Provider.of<ThemeService>(context);
    final profileService = Provider.of<ProfileService>(context);

    return Scaffold(
      appBar: AppBar(
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        elevation: 0,
        scrolledUnderElevation: 0,
        title: Text(
          l10n.settingsTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      body: ListView(
        padding: DesignConstants.cardPadding,
        children: [
          _buildSectionTitle(context, l10n.settingsAppearance),
          SummaryCard(
            child: Column(
              children: [
                RadioListTile<ThemeMode>(
                  title: Text(l10n.themeSystem),
                  value: ThemeMode.system,
                  groupValue: themeService.themeMode,
                  onChanged: (value) => themeService.setThemeMode(value!),
                ),
                RadioListTile<ThemeMode>(
                  title: Text(l10n.themeLight),
                  value: ThemeMode.light,
                  groupValue: themeService.themeMode,
                  onChanged: (value) => themeService.setThemeMode(value!),
                ),
                RadioListTile<ThemeMode>(
                  title: Text(l10n.themeDark),
                  value: ThemeMode.dark,
                  groupValue: themeService.themeMode,
                  onChanged: (value) => themeService.setThemeMode(value!),
                ),
              ],
            ),
          ),
          const SizedBox(height: DesignConstants.spacingXL),
          _buildSectionTitle(context, l10n.backup_and_import),
          _buildNavigationCard(
            context: context,
            icon: Icons.import_export_rounded,
            title: l10n.backup_and_import,
            subtitle: l10n.backup_and_import_description,
            onTap: () {
              Navigator.of(context).push(MaterialPageRoute(
                  builder: (context) => const DataManagementScreen()));
            },
          ),
          const SizedBox(height: DesignConstants.spacingXL),
          _buildSectionTitle(context, l10n.about_and_legal_capslock),
          _buildNavigationCard(
            context: context,
            icon: Icons.info_outline_rounded,
            title: l10n.attribution_and_license,
            subtitle: l10n.data_from_off_and_wger,
            onTap: () {
              showDialog(
                  context: context,
                  builder: (context) => AlertDialog(
                        title: Text(l10n.attribution_title),
                        content: SingleChildScrollView(
                          child: Text(l10n.attributionText),
                        ),
                        actions: [
                          TextButton(
                              onPressed: () => Navigator.of(context).pop(),
                              child: Text(l10n.snackbar_button_ok)),
                        ],
                      ));
            },
          ),
          const SizedBox(height: DesignConstants.spacingM),
          SummaryCard(
            child: ListTile(
              leading: const Icon(Icons.code_rounded),
              title: Text(l10n.app_version,
                  style: const TextStyle(fontWeight: FontWeight.bold)),
              subtitle: Text(_appVersion),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title.toUpperCase(),
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildNavigationCard({
    required BuildContext context,
    required IconData icon,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
  }) {
    return SummaryCard(
      child: ListTile(
        contentPadding:
            const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16.0),
        leading:
            Icon(icon, size: 36, color: Theme.of(context).colorScheme.primary),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Text(subtitle),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
        shape:
            RoundedRectangleBorder(borderRadius: BorderRadius.circular(24.0)),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/food_explorer_screen.dart =====

// lib/screens/food_explorer_screen.dart (Final & De-Materialisiert)

import 'package:flutter/material.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/screens/create_food_screen.dart';
import 'package:lightweight/screens/food_detail_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/off_attribution_widget.dart';
import 'package:lightweight/widgets/summary_card.dart'; // HINZUGEFÜGT

class FoodExplorerScreen extends StatefulWidget {
  const FoodExplorerScreen({super.key});

  @override
  State<FoodExplorerScreen> createState() => _FoodExplorerScreenState();
}

class _FoodExplorerScreenState extends State<FoodExplorerScreen>
    with SingleTickerProviderStateMixin {
  List<FoodItem> _foundFoodItems = [];
  bool _isLoadingSearch = false;
  String _searchInitialText = "";
  final _searchController = TextEditingController();

  List<FoodItem> _favoriteFoodItems = [];
  bool _isLoadingFavorites = true;

  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _searchController.addListener(() => setState(() {}));
    _loadFavorites();
  }

  @override
  void dispose() {
    _searchController.dispose();
    _tabController.dispose();
    super.dispose();
  }

  void _runFilter(String enteredKeyword) async {
    final l10n = AppLocalizations.of(context)!;

    if (enteredKeyword.isEmpty) {
      setState(() {
        _foundFoodItems = [];
        _searchInitialText = l10n.searchInitialHint;
      });
      return;
    }
    setState(() {
      _isLoadingSearch = true;
    });
    final results =
        await ProductDatabaseHelper.instance.searchProducts(enteredKeyword);
    if (mounted) {
      setState(() {
        _foundFoodItems = results;
        _isLoadingSearch = false;
        if (results.isEmpty) {
          _searchInitialText = l10n.searchNoResults;
        }
      });
    }
  }

  void _navigateAndCreateFood() {
    Navigator.of(context)
        .push(
      MaterialPageRoute(builder: (context) => const CreateFoodScreen()),
    )
        .then((_) {
      _searchController.clear();
      _runFilter('');
    });
  }

  Future<void> _loadFavorites() async {
    setState(() {
      _isLoadingFavorites = true;
    });
    final results = await ProductDatabaseHelper.instance.getFavoriteProducts();
    if (mounted) {
      setState(() {
        _favoriteFoodItems = results;
        _isLoadingFavorites = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    // KORREKTUR: Direkte Abfrage des Theme-Modus
    final isLightMode = Theme.of(context).brightness == Brightness.light;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: Column(
        children: [
          Padding(
            padding:
                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 24.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(l10n.drawerFoodExplorer,
                    style: textTheme.headlineMedium
                        ?.copyWith(fontWeight: FontWeight.w900, fontSize: 28)),
                const SizedBox(height: DesignConstants.spacingL),
                TabBar(
                  controller: _tabController,
                  isScrollable: false,
                  indicator: const BoxDecoration(),
                  splashFactory: NoSplash.splashFactory,
                  overlayColor: WidgetStateProperty.all(Colors.transparent),
                  dividerColor: Colors.transparent,
                  // KORREKTUR: Dynamische Farbe basierend auf dem Theme-Modus
                  labelColor: isLightMode ? Colors.black : Colors.white,
                  unselectedLabelColor: Colors.grey.shade600,
                  labelStyle: const TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.w900,
                      letterSpacing: 0.0),
                  unselectedLabelStyle: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.w800,
                      letterSpacing: 0.0),
                  tabs: [
                    Tab(text: l10n.tabSearch),
                    Tab(text: l10n.tabFavorites),
                  ],
                ),
              ],
            ),
          ),
          Divider(
              height: 1,
              thickness: 1,
              color: colorScheme.onSurfaceVariant.withOpacity(0.1)),
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildSearchTab(l10n),
                _buildFavoritesTab(l10n),
              ],
            ),
          ),
        ],
      ),
      floatingActionButton: GlassFab(
        onPressed: _navigateAndCreateFood,
        label: l10n.createFoodScreenTitle,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  Widget _buildSearchTab(AppLocalizations l10n) {
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    return Padding(
      padding: DesignConstants.cardPadding,
      child: Column(
        children: [
          // KORREKTUR 4: TextField nutzt globale InputDecorationTheme
          TextField(
              controller: _searchController,
              onChanged: (value) => _runFilter(value),
              decoration: InputDecoration(
                  hintText: l10n.searchHintText,
                  prefixIcon: Icon(Icons.search,
                      color: colorScheme.onSurfaceVariant, size: 20),
                  suffixIcon: _searchController.text.isNotEmpty
                      ? IconButton(
                          icon: Icon(Icons.clear,
                              color: colorScheme.onSurfaceVariant),
                          onPressed: () {
                            _searchController.clear();
                            _runFilter('');
                          })
                      : null)),
          const SizedBox(height: 20),
          Expanded(
            child: _isLoadingSearch
                ? const Center(child: CircularProgressIndicator())
                : _foundFoodItems.isNotEmpty
                    ? ListView.builder(
                        itemCount: _foundFoodItems.length,
                        itemBuilder: (context, index) =>
                            _buildFoodListItem(_foundFoodItems[index]))
                    : Center(
                        child: Text(_searchInitialText,
                            style: textTheme.titleMedium)),
          ),
          if (_foundFoodItems.any((item) => item.source == FoodItemSource.off))
            const OffAttributionWidget(),
        ],
      ),
    );
  }

  Widget _buildFavoritesTab(AppLocalizations l10n) {
    if (_isLoadingFavorites) {
      return const Center(child: CircularProgressIndicator());
    }
    if (_favoriteFoodItems.isEmpty) {
      return Center(
          child: Text(l10n.favoritesEmptyState,
              textAlign: TextAlign.center,
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  color: Theme.of(context)
                      .colorScheme
                      .onSurface
                      .withOpacity(0.6))));
    }
    return Column(children: [
      Expanded(
          child: ListView.builder(
              padding: DesignConstants.cardPadding,
              itemCount: _favoriteFoodItems.length,
              itemBuilder: (context, index) =>
                  _buildFoodListItem(_favoriteFoodItems[index]))),
      if (_favoriteFoodItems.any((item) => item.source == FoodItemSource.off))
        const OffAttributionWidget()
    ]);
  }

  // KORREKTUR 5: _buildFoodListItem verwendet jetzt SummaryCard
  Widget _buildFoodListItem(FoodItem item) {
    final colorScheme = Theme.of(context).colorScheme;
    final l10n = AppLocalizations.of(context)!;

    IconData sourceIcon;
    switch (item.source) {
      case FoodItemSource.base:
        sourceIcon = Icons.star;
        break;
      case FoodItemSource.off:
      case FoodItemSource.user:
        sourceIcon = Icons.inventory_2;
        break;
    }

    return SummaryCard(
      // KORREKTUR: Jetzt mit SummaryCard
      child: ListTile(
        leading: Icon(sourceIcon, color: colorScheme.primary),
        title: Text(item.name.isNotEmpty ? item.name : l10n.unknown,
            style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Text(l10n.foodItemSubtitle(
            item.brand.isNotEmpty ? item.brand : l10n.noBrand, item.calories)),
        trailing: IconButton(
          icon: Icon(Icons.add_circle_outline,
              color: colorScheme.primary, size: 28),
          onPressed: () => Navigator.of(context).pop(item),
        ),
        onTap: () => Navigator.of(context)
            .push(MaterialPageRoute(
                builder: (context) => FoodDetailScreen(foodItem: item)))
            .then((_) {
          _loadFavorites();
        }),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/workout_history_screen.dart =====

// lib/screens/workout_history_screen.dart (Final & De-Materialisiert mit AppBar)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/screens/workout_log_detail_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/util/time_util.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';

class WorkoutHistoryScreen extends StatefulWidget {
  const WorkoutHistoryScreen({super.key});
  @override
  State<WorkoutHistoryScreen> createState() => _WorkoutHistoryScreenState();
}

class _WorkoutHistoryScreenState extends State<WorkoutHistoryScreen> {
  bool _isLoading = true;
  List<WorkoutLog> _logs = [];

  @override
  void initState() {
    super.initState();
    _loadHistory();
  }

  Future<void> _loadHistory() async {
    setState(() => _isLoading = true);
    // KORREKTUR: Wir verwenden getFullWorkoutLogs(), um die Sätze direkt mitzuladen.
    final data = await WorkoutDatabaseHelper.instance.getFullWorkoutLogs();
    if (mounted) {
      setState(() {
        _logs = data;
        _isLoading = false;
      });
    }
  }

  Future<void> _deleteLog(int logId) async {
    await WorkoutDatabaseHelper.instance.deleteWorkoutLog(logId);
    _loadHistory();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).toString();
    final colorScheme = Theme.of(context).colorScheme;

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          l10n.workoutHistoryTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _logs.isEmpty
              // KORREKTUR: Aufgewerteter "Empty State"
              ? Center(
                  child: Padding(
                    padding: const EdgeInsets.all(24.0),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.history_toggle_off_outlined,
                            size: 80, color: Colors.grey.shade400),
                        const SizedBox(height: DesignConstants.spacingL),
                        Text(
                          l10n.workoutHistoryEmptyTitle,
                          style: Theme.of(context).textTheme.headlineSmall,
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: DesignConstants.spacingS),
                        Text(
                          l10n.emptyHistory,
                          textAlign: TextAlign.center,
                          style: Theme.of(context)
                              .textTheme
                              .bodyLarge
                              ?.copyWith(color: Colors.grey.shade600),
                        ),
                      ],
                    ),
                  ),
                )
              : ListView.builder(
                  padding: DesignConstants.cardPadding,
                  itemCount: _logs.length,
                  itemBuilder: (context, index) {
                    final log = _logs[index];
                    final duration = log.endTime?.difference(log.startTime);

                    // NEU: Berechne Volumen und Sätze für diesen Log
                    final totalSets = log.sets.length;
                    final totalVolume = log.sets.fold<double>(
                      0,
                      (sum, set) => sum + (set.weightKg ?? 0) * (set.reps ?? 0),
                    );

                    return Dismissible(
                      key: Key('log_${log.id}'),
                      direction: DismissDirection.endToStart,

                      // KORRIGIERT: Nur `secondaryBackground` wird hier benötigt
                      background: const SwipeActionBackground(
                        color: Colors.redAccent,
                        icon: Icons.delete,
                        alignment: Alignment.centerRight,
                      ),
                      confirmDismiss: (direction) async {
                        return await showDialog<bool>(
                              context: context,
                              builder: (ctx) => AlertDialog(
                                title: Text(l10n.deleteConfirmTitle),
                                content: Text(l10n.deleteWorkoutConfirmContent),
                                actions: [
                                  TextButton(
                                    onPressed: () =>
                                        Navigator.of(ctx).pop(false),
                                    child: Text(l10n.cancel),
                                  ),
                                  TextButton(
                                    onPressed: () =>
                                        Navigator.of(ctx).pop(true),
                                    child: Text(l10n.delete),
                                  ),
                                ],
                              ),
                            ) ??
                            false;
                      },
                      onDismissed: (direction) {
                        _deleteLog(log.id!);
                      },
                      child: SummaryCard(
                        child: ListTile(
                          leading: const Icon(Icons.event_note, size: 40),
                          title: Text(
                            log.routineName ?? l10n.freeWorkoutTitle,
                            style: const TextStyle(fontWeight: FontWeight.bold),
                          ),
                          // KORREKTUR: Das Subtitle wird jetzt ein Column mit mehr Infos
                          subtitle: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              const SizedBox(height: 4),
                              Text(
                                DateFormat.yMMMMd(locale)
                                    .add_Hm()
                                    .format(log.startTime),
                              ),
                              const SizedBox(height: 8),
                              Row(
                                children: [
                                  Icon(Icons.monitor_weight_outlined,
                                      size: 14, color: Colors.grey[600]),
                                  const SizedBox(width: 4),
                                  Text(
                                    '${totalVolume.toStringAsFixed(0)} kg',
                                    style: TextStyle(
                                        color: Colors.grey[600], fontSize: 12),
                                  ),
                                  const SizedBox(width: 12),
                                  Icon(Icons.replay_circle_filled_outlined,
                                      size: 14, color: Colors.grey[600]),
                                  const SizedBox(width: 4),
                                  Text(
                                    l10n.setCount(
                                        totalSets), // Nutzt die Plural-Funktion
                                    style: TextStyle(
                                        color: Colors.grey[600], fontSize: 12),
                                  ),
                                ],
                              ),
                            ],
                          ),
                          trailing: duration != null
                              ? Text(
                                  formatDuration(duration),
                                  style: TextStyle(
                                    color: colorScheme.primary,
                                    fontWeight: FontWeight.w500,
                                  ),
                                )
                              : null,
                          onTap: () => Navigator.of(context)
                              .push(
                                MaterialPageRoute(
                                  builder: (context) =>
                                      WorkoutLogDetailScreen(logId: log.id!),
                                ),
                              )
                              .then((_) => _loadHistory()),
                        ),
                      ),
                    );
                  },
                ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/measurement_session_detail_screen.dart =====

// lib/screens/measurement_session_detail_screen.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/measurement_session.dart';
import 'package:lightweight/util/design_constants.dart';

class MeasurementSessionDetailScreen extends StatelessWidget {
  final MeasurementSession session;

  const MeasurementSessionDetailScreen({super.key, required this.session});

  // Wir kopieren die Helfer-Methode hierher, um die Namen zu übersetzen.
  String _getLocalizedMeasurementName(String key, AppLocalizations l10n) {
    switch (key) {
      case 'weight':
        return l10n.measurementWeight;
      case 'fat_percent':
        return l10n.measurementFatPercent;
      case 'neck':
        return l10n.measurementNeck;
      // ... (füge hier alle anderen 'case' Anweisungen aus dem measurements_screen.dart ein)
      case 'right_calf':
        return l10n.measurementRightCalf;
      default:
        return key;
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true, // zeigt den Zurück-Pfeil
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          DateFormat.yMMMMd('de_DE').format(session.timestamp),
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      body: ListView(
        padding: DesignConstants.cardPadding,
        children: [
          ...session.measurements.map((measurement) {
            return Card(
              elevation: 2,
              margin: const EdgeInsets.symmetric(vertical: 6),
              child: ListTile(
                title:
                    Text(_getLocalizedMeasurementName(measurement.type, l10n)),
                trailing: Text(
                  "${measurement.value.toStringAsFixed(1)} ${measurement.unit}",
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                ),
              ),
            );
          }),
        ],
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/edit_routine_screen.dart =====

// lib/screens/edit_routine_screen.dart (Final & De-Materialisiert - Endgültig)

import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/models/routine_exercise.dart';
import 'package:lightweight/models/set_template.dart';
import 'package:lightweight/screens/exercise_catalog_screen.dart';
import 'package:lightweight/screens/exercise_detail_screen.dart';
import 'package:lightweight/util/design_constants.dart';
// Zum Starten der Routine
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/set_type_chip.dart';
// HINZUGEFÜGT
import 'package:lightweight/widgets/wger_attribution_widget.dart'; // HINZUGEFÜGT
import 'package:lightweight/widgets/workout_card.dart'; // NEUER IMPORT

class EditRoutineScreen extends StatefulWidget {
  final Routine? routine;
  const EditRoutineScreen({super.key, this.routine});

  @override
  State<EditRoutineScreen> createState() => _EditRoutineScreenState();
}

class _EditRoutineScreenState extends State<EditRoutineScreen> {
  final _nameController = TextEditingController();
  List<RoutineExercise> _routineExercises = [];
  bool _isNewRoutine = true;
  int? _routineId;
  String _originalName = '';
  bool _isLoading = false;
  final Map<int, TextEditingController> _repsControllers = {};
  final Map<int, TextEditingController> _weightControllers = {};
  final Map<int, bool> _exerciseExpanded = {};

  @override
  void initState() {
    super.initState();
    if (widget.routine != null) {
      _isNewRoutine = false;
      _routineId = widget.routine!.id;
      _nameController.text = widget.routine!.name;
      _originalName = widget.routine!.name;
      _loadExercisesForRoutine();
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    for (var c in _repsControllers.values) {
      c.dispose();
    }
    for (var c in _weightControllers.values) {
      c.dispose();
    }
    super.dispose();
  }

  Future<void> _loadExercisesForRoutine() async {
    if (_routineId == null) return;
    setState(() => _isLoading = true);
    final routineWithExercises =
        await WorkoutDatabaseHelper.instance.getRoutineById(_routineId!);
    if (mounted && routineWithExercises != null) {
      for (var c in _repsControllers.values) {
        c.dispose();
      }
      for (var c in _weightControllers.values) {
        c.dispose();
      }
      _repsControllers.clear();
      _weightControllers.clear();

      for (var re in routineWithExercises.exercises) {
        for (var st in re.setTemplates) {
          _repsControllers[st.id!] = TextEditingController(text: st.targetReps);
          _weightControllers[st.id!] =
              TextEditingController(text: st.targetWeight?.toString() ?? '');
        }
      }

      setState(() {
        _routineExercises = routineWithExercises.exercises;
        _isLoading = false;
      });
    } else if (mounted) {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _addExercises() async {
    if (_isNewRoutine) {
      final success = await _saveRoutine(isAddingExercise: true);
      if (!success) return;
    }
    if (!mounted) return;
    final selectedExercise = await Navigator.of(context).push<Exercise>(
        MaterialPageRoute(
            builder: (context) =>
                const ExerciseCatalogScreen(isSelectionMode: true)));

    if (selectedExercise != null && _routineId != null) {
      final newRoutineExercise = await WorkoutDatabaseHelper.instance
          .addExerciseToRoutine(_routineId!, selectedExercise.id!);
      if (newRoutineExercise != null) {
        for (var st in newRoutineExercise.setTemplates) {
          _repsControllers[st.id!] = TextEditingController(text: st.targetReps);
          _weightControllers[st.id!] =
              TextEditingController(text: st.targetWeight?.toString() ?? '');
        }
        setState(() {
          _routineExercises.add(newRoutineExercise);
        });
      }
    }
  }

  Future<bool> _saveRoutine({bool isAddingExercise = false}) async {
    final l10n = AppLocalizations.of(context)!;
    FocusScope.of(context).unfocus();

    if (_nameController.text.trim().isEmpty) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(l10n.validatorPleaseEnterRoutineName)));
      }
      return false;
    }

    int? currentRoutineId = _routineId;

    if (_isNewRoutine) {
      final newRoutine = await WorkoutDatabaseHelper.instance
          .createRoutine(_nameController.text.trim());
      currentRoutineId = newRoutine.id;
      if (mounted) {
        setState(() {
          _routineId = newRoutine.id;
          _isNewRoutine = false;
          _originalName = newRoutine.name;
        });
      }
      if (mounted && !isAddingExercise) {
        ScaffoldMessenger.of(context)
            .showSnackBar(SnackBar(content: Text(l10n.snackbarRoutineCreated)));
      }
    } else {
      if (_nameController.text.trim() != _originalName) {
        await WorkoutDatabaseHelper.instance
            .updateRoutineName(currentRoutineId!, _nameController.text.trim());
      }
    }

    final db = WorkoutDatabaseHelper.instance;
    for (var re in _routineExercises) {
      final List<SetTemplate> currentTemplates = [];
      for (var set in re.setTemplates) {
        currentTemplates.add(set.copyWith(
            targetReps: _repsControllers[set.id!]?.text,
            targetWeight: double.tryParse(
                _weightControllers[set.id!]!.text.replaceAll(',', '.'))));
      }
      await db.replaceSetTemplatesForExercise(re.id!, currentTemplates);
    }

    if (mounted && !isAddingExercise) {
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(l10n.snackbarRoutineSaved)));
      Navigator.of(context).pop(true);
    }
    return true;
  }

  void _addSet(RoutineExercise routineExercise) {
    setState(() {
      final newSet = SetTemplate(
          id: DateTime.now().millisecondsSinceEpoch,
          setType: 'normal',
          targetReps: '8-12');
      routineExercise.setTemplates.add(newSet);
      _repsControllers[newSet.id!] =
          TextEditingController(text: newSet.targetReps);
      _weightControllers[newSet.id!] = TextEditingController();
    });
  }

  void _removeSet(
      RoutineExercise routineExercise, int setTemplateId, int index) {
    setState(() {
      routineExercise.setTemplates.removeAt(index);
      _repsControllers.remove(setTemplateId)?.dispose();
      _weightControllers.remove(setTemplateId)?.dispose();
    });
  }

  void _changeSetType(SetTemplate setTemplate, String newType) {
    setState(() {
      final re = _routineExercises
          .firstWhere((re) => re.setTemplates.contains(setTemplate));
      final setIndex = re.setTemplates.indexOf(setTemplate);
      re.setTemplates[setIndex] = setTemplate.copyWith(setType: newType);
    });
    Navigator.pop(context);
  }

  void _showSetTypePicker(SetTemplate setTemplate) {
    showModalBottomSheet(
      context: context,
      builder: (context) {
        return Wrap(
          children: <Widget>[
            ListTile(
                title: const Text('Normal'),
                onTap: () => _changeSetType(setTemplate, 'normal')),
            ListTile(
                title: const Text('Warmup'),
                onTap: () => _changeSetType(setTemplate, 'warmup')),
            ListTile(
                title: const Text('Failure'),
                onTap: () => _changeSetType(setTemplate, 'failure')),
            ListTile(
                title: const Text('Dropset'),
                onTap: () => _changeSetType(setTemplate, 'dropset')),
          ],
        );
      },
    );
  }

  void _editPauseTime(RoutineExercise routineExercise) async {
    final l10n = AppLocalizations.of(context)!;
    final controller = TextEditingController(
        text: routineExercise.pauseSeconds?.toString() ?? '');

    final result = await showDialog<int?>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.editPauseTimeTitle),
        content: TextField(
          controller: controller,
          keyboardType: TextInputType.number,
          decoration: InputDecoration(
            labelText: l10n.pauseInSeconds,
          ),
        ),
        actions: [
          TextButton(
              onPressed: () => Navigator.of(ctx).pop(),
              child: Text(l10n.cancel)),
          FilledButton(
              onPressed: () {
                final seconds = int.tryParse(controller.text);
                Navigator.of(ctx).pop(seconds);
              },
              child: Text(l10n.save)),
        ],
      ),
    );

    if (result != null) {
      await WorkoutDatabaseHelper.instance
          .updatePauseTime(routineExercise.id!, result);
      _loadExercisesForRoutine();
    }
  }

  void _deleteSingleExercise(RoutineExercise exerciseToDelete) async {
    final l10n = AppLocalizations.of(context)!;
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.deleteExerciseConfirmTitle),
        content: Text(l10n.deleteExerciseConfirmContent(
            exerciseToDelete.exercise.getLocalizedName(context))),
        actions: [
          TextButton(
              onPressed: () => Navigator.of(ctx).pop(false),
              child: Text(l10n.cancel)),
          TextButton(
              onPressed: () => Navigator.of(ctx).pop(true),
              child: Text(l10n.delete)),
        ],
      ),
    );

    if (confirmed == true && _routineId != null) {
      await WorkoutDatabaseHelper.instance
          .removeExerciseFromRoutine(exerciseToDelete.id!);
      _loadExercisesForRoutine();
    }
  }

  void _onReorder(int oldIndex, int newIndex) {
    setState(() {
      if (newIndex > oldIndex) {
        newIndex -= 1;
      }
      final RoutineExercise item = _routineExercises.removeAt(oldIndex);
      _routineExercises.insert(newIndex, item);
    });
    if (_routineId != null) {
      WorkoutDatabaseHelper.instance
          .updateExerciseOrder(_routineId!, _routineExercises);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          _isNewRoutine ? l10n.titleNewRoutine : l10n.titleEditRoutine,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
        actions: [
          TextButton(
            onPressed: () => _saveRoutine(),
            child: Text(
              l10n.save,
              style: TextStyle(
                color: Theme.of(context).colorScheme.primary,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      body: Column(
        children: [
          Padding(
            padding: DesignConstants.screenPadding,
            child: TextFormField(
              controller: _nameController,
              decoration: InputDecoration(labelText: l10n.formFieldRoutineName),
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return l10n.validatorPleaseEnterRoutineName;
                }
                return null;
              },
            ),
          ),
          const SizedBox(height: DesignConstants.spacingM),
          Divider(
            height: 1,
            thickness: 1,
            color: colorScheme.onSurfaceVariant.withOpacity(0.1),
          ),
          Expanded(
            child: _isLoading
                ? const Center(child: CircularProgressIndicator())
                : _routineExercises.isEmpty
                    ? Center(
                        child: Text(
                          l10n.emptyStateAddFirstExercise,
                          style: textTheme.titleMedium,
                        ),
                      )
                    : ReorderableListView.builder(
                        padding: EdgeInsets.zero,
                        itemCount: _routineExercises.length,
                        proxyDecorator: (Widget child, int index,
                            Animation<double> animation) {
                          return Material(
                            elevation: 4.0,
                            color: Theme.of(context).scaffoldBackgroundColor,
                            child: child,
                          );
                        },
                        onReorder: _onReorder,
                        itemBuilder: (context, index) {
                          final routineExercise = _routineExercises[index];

                          return WorkoutCard(
                            key: ValueKey(routineExercise.id),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                ListTile(
                                  contentPadding: const EdgeInsets.symmetric(
                                      horizontal: 16.0, vertical: 8.0),
                                  title: InkWell(
                                    onTap: () => Navigator.of(context).push(
                                        MaterialPageRoute(
                                            builder: (context) =>
                                                ExerciseDetailScreen(
                                                    exercise: routineExercise
                                                        .exercise))),
                                    child: Padding(
                                      padding: const EdgeInsets.symmetric(
                                          vertical: 4.0),
                                      child: Text(
                                          routineExercise.exercise
                                              .getLocalizedName(context),
                                          style: textTheme.titleLarge?.copyWith(
                                              fontWeight: FontWeight.bold)),
                                    ),
                                  ),
                                  leading: ReorderableDragStartListener(
                                    index: index,
                                    child: const Icon(Icons.drag_handle),
                                  ),
                                  trailing: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      IconButton(
                                        icon: const Icon(Icons.timer_outlined),
                                        tooltip: l10n.editPauseTime,
                                        onPressed: () =>
                                            _editPauseTime(routineExercise),
                                      ),
                                      IconButton(
                                        icon: const Icon(Icons.delete_outline,
                                            color: Colors.redAccent),
                                        tooltip: l10n.removeExercise,
                                        onPressed: () => _deleteSingleExercise(
                                            routineExercise),
                                      ),
                                    ],
                                  ),
                                ),
                                Padding(
                                  padding: const EdgeInsets.symmetric(
                                      horizontal: 0.0),
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      if (routineExercise.pauseSeconds !=
                                              null &&
                                          routineExercise.pauseSeconds! > 0)
                                        Padding(
                                          padding: const EdgeInsets.fromLTRB(
                                              16, 12, 16, 12),
                                          child: Text(
                                            l10n.pauseDuration(
                                                routineExercise.pauseSeconds!),
                                            style: textTheme.bodyMedium
                                                ?.copyWith(
                                                    color: Colors.grey[600],
                                                    fontStyle:
                                                        FontStyle.italic),
                                          ),
                                        ),
                                      Row(
                                        children: [
                                          _buildHeader(l10n.setLabel, flex: 2),
                                          const Spacer(flex: 3),
                                          _buildHeader(l10n.kgLabel, flex: 2),
                                          const SizedBox(width: 8),
                                          _buildHeader(l10n.repsLabel, flex: 2),
                                          const SizedBox(width: 48),
                                        ],
                                      ),
                                      ...routineExercise.setTemplates
                                          .asMap()
                                          .entries
                                          .map((entry) {
                                        final setIndex = entry.key;
                                        final setTemplate = entry.value;

                                        // HIER IST DIE NEUE LOGIK
                                        int workingSetIndex = 0;
                                        for (int i = 0; i <= setIndex; i++) {
                                          if (routineExercise
                                                  .setTemplates[i].setType !=
                                              'warmup') {
                                            workingSetIndex++;
                                          }
                                        }

                                        return _buildSetTemplateRow(
                                            workingSetIndex,
                                            setIndex,
                                            routineExercise,
                                            setTemplate,
                                            setIndex);
                                      }),
                                      const SizedBox(
                                          height: DesignConstants.spacingS),
                                      Padding(
                                        padding: const EdgeInsets.symmetric(
                                            horizontal: 16.0),
                                        child: TextButton.icon(
                                          onPressed: () =>
                                              _addSet(routineExercise),
                                          icon: const Icon(Icons.add),
                                          label: Text(l10n.addSetButton),
                                        ),
                                      ),
                                    ],
                                  ),
                                )
                              ],
                            ),
                          );
                        },
                      ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 24.0, bottom: 8.0),
            child: WgerAttributionWidget(
              textStyle: textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
            ),
          ),
        ],
      ),
      // KORRIGIERT: label hinzugefügt
      floatingActionButton: GlassFab(
        label: l10n.fabAddExercise,
        onPressed: _addExercises,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  Widget _buildSetTemplateRow(int setIndex, int rowIndex, RoutineExercise re,
      SetTemplate template, int listIndex) {
    final l10n = AppLocalizations.of(context)!;
    final isLightMode = Theme.of(context).brightness == Brightness.light;
    final bool isColoredRow = rowIndex > 0 && rowIndex.isOdd;

    final Color rowColor;
    if (isColoredRow) {
      rowColor = isLightMode
          ? Colors.grey.withOpacity(0.08)
          : Colors.white.withOpacity(0.05);
    } else {
      rowColor = Colors.transparent;
    }

    return Container(
      color: rowColor,
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 4.0),
        child: Row(
          children: [
            Expanded(
              flex: 2,
              child: Center(
                child: SetTypeChip(
                  setType: template.setType,
                  setIndex: (template.setType == 'warmup') ? null : setIndex,
                  onTap: () => _showSetTypePicker(template),
                ),
              ),
            ),
            const Spacer(flex: 3),
            Expanded(
                flex: 2,
                child: TextFormField(
                  controller: _weightControllers[template.id!],
                  textAlign: TextAlign.center,
                  keyboardType:
                      const TextInputType.numberWithOptions(decimal: true),
                  decoration: InputDecoration(
                      border: InputBorder.none,
                      isDense: true,
                      fillColor: Colors.transparent,
                      hintText: l10n.kgLabelShort),
                  validator: (value) {
                    if (value != null &&
                        value.isNotEmpty &&
                        double.tryParse(value.replaceAll(',', '.')) == null) {
                      return "!";
                    }
                    return null;
                  },
                )),
            const SizedBox(width: 8),
            Expanded(
                flex: 2,
                child: TextFormField(
                  controller: _repsControllers[template.id!],
                  textAlign: TextAlign.center,
                  keyboardType: TextInputType.number,
                  decoration: InputDecoration(
                      border: InputBorder.none,
                      isDense: true,
                      fillColor: Colors.transparent,
                      hintText: l10n.set_reps_hint),
                  validator: (value) {
                    if (value != null &&
                        value.isNotEmpty &&
                        int.tryParse(value) == null) {
                      return "!";
                    }
                    return null;
                  },
                )),
            Padding(
              padding: const EdgeInsets.only(right: 8.0),
              child: SizedBox(
                  width: 48,
                  child: IconButton(
                      icon: const Icon(Icons.delete_outline,
                          color: Colors.redAccent),
                      onPressed: () =>
                          _removeSet(re, template.id!, listIndex))),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildHeader(String text, {required int flex}) => Expanded(
      flex: flex,
      child: Text(text,
          textAlign: TextAlign.center,
          style: TextStyle(
              color: Colors.grey[600],
              fontSize: 12,
              fontWeight: FontWeight.bold)));
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/data_management_screen.dart =====

// lib/screens/data_management_screen.dart (Final & Vollständig)

import 'package:flutter/material.dart';
import 'package:file_picker/file_picker.dart';
import 'package:lightweight/data/backup_manager.dart';
import 'package:lightweight/data/import_manager.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/exercise_mapping_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:shared_preferences/shared_preferences.dart'; // NEU
import 'package:flutter/services.dart'; // NEU (Clipboard)

class DataManagementScreen extends StatefulWidget {
  const DataManagementScreen({super.key});

  @override
  State<DataManagementScreen> createState() => _DataManagementScreenState();
}

class _DataManagementScreenState extends State<DataManagementScreen> {
  // Lade-Zustände für die verschiedenen Aktionen
  bool _isFullBackupRunning = false;
  bool _isCsvExportRunning = false;
  bool _isMigrationRunning = false;
  String? _autoBackupDir; // NEU
  @override
  void initState() {
    super.initState();
    _loadAutoBackupDir(); // NEU
  }

  Future<void> _loadAutoBackupDir() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _autoBackupDir = prefs.getString('auto_backup_dir');
    });
  }

  // --- UNVERÄNDERT: Logik für Komplett-Backup ---
  void _performFullExport() async {
    setState(() => _isFullBackupRunning = true);
    final success = await BackupManager().exportFullBackup();
    if (!mounted) return;
    setState(() => _isFullBackupRunning = false);

    final l10n = AppLocalizations.of(context)!;
    if (success) {
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(l10n.snackbarExportSuccess)));
    } else {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: Text(l10n.snackbarExportFailed),
          backgroundColor: Colors.orange));
    }
  }

  void _performFullImport() async {
    final result = await FilePicker.platform
        .pickFiles(type: FileType.custom, allowedExtensions: ['json']);
    if (result == null || result.files.single.path == null) return;

    final filePath = result.files.single.path!;
    final l10n = AppLocalizations.of(context)!;

    final bool? confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.dialogConfirmTitle),
        content: Text(l10n.dialogConfirmImportContent),
        actions: [
          TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: Text(l10n.dialogButtonCancel)),
          FilledButton(
            style: FilledButton.styleFrom(
                backgroundColor: Theme.of(context).colorScheme.error),
            onPressed: () => Navigator.of(context).pop(true),
            child: Text(l10n.dialogButtonOverwrite),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      setState(() => _isFullBackupRunning = true);
      bool success = await BackupManager().importFullBackupAuto(filePath);
      if (!success) {
        // Datei könnte verschlüsselt sein – Passwort abfragen (leer = “kein Passwort” versuchen)
        final pw = await _askPassword(title: l10n.dialogEnterPasswordImport);
        if (pw != null) {
          // <-- wichtig: leer zulassen
          success = await BackupManager()
              .importFullBackupAuto(filePath, passphrase: pw);
        }
      }

      if (!mounted) return;
      setState(() => _isFullBackupRunning = false); // nur einmal

      if (success) {
        // Neu: Unbekannte Übungsnamen ermitteln und ggf. Mapping anbieten
        final unknown =
            await WorkoutDatabaseHelper.instance.findUnknownExerciseNames();
        if (mounted && unknown.isNotEmpty) {
          final bool? changed = await Navigator.of(context).push<bool>(
            MaterialPageRoute(
                builder: (_) => ExerciseMappingScreen(unknownNames: unknown)),
          );
          // Optional: Nach Anwendung erneut prüfen/refreshen, aber keine Pflicht.
        }

        await showDialog(
          context: context,
          barrierDismissible: false,
          builder: (context) => AlertDialog(
            title: Text(l10n.snackbarImportSuccessTitle),
            content: Text(l10n.snackbarImportSuccessContent),
            actions: [
              FilledButton(
                onPressed: () => Navigator.of(context).pop(),
                child: Text(l10n.snackbarButtonOK),
              ),
            ],
          ),
        );
      } else {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(
            content: Text(l10n.snackbarImportError),
            backgroundColor: Colors.red));
      }
    }
  }

  // --- UNVERÄNDERT: Logik für Hevy-Import ---
  void _performHevyImport() async {
    setState(() => _isMigrationRunning = true);
    final count = await ImportManager().importHevyCsv();
    if (!mounted) return;
    setState(() => _isMigrationRunning = false);

    if (count > 0) {
      final unknown =
          await WorkoutDatabaseHelper.instance.findUnknownExerciseNames();
      if (mounted && unknown.isNotEmpty) {
        await Navigator.of(context).push(
          MaterialPageRoute(
              builder: (_) => ExerciseMappingScreen(unknownNames: unknown)),
        );
      }
    }
    final l10n = AppLocalizations.of(context)!;
    if (count > 0) {
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(l10n.hevyImportSuccess(count))));
    } else {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: Text(l10n.hevyImportFailed), backgroundColor: Colors.red));
    }
  }

  // --- NEU: Helfer-Methode für alle CSV-Exporte ---
  void _exportCsv(Future<bool> Function() exportFunction, String successMessage,
      String failureMessage) async {
    setState(() => _isCsvExportRunning = true);
    final success = await exportFunction();
    if (!mounted) return;
    setState(() => _isCsvExportRunning = false);

    if (success) {
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(successMessage)));
    } else {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: Text(failureMessage), backgroundColor: Colors.orange));
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true, // <- zeigt den Zurück-Pfeil
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          "Data Hub",
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: DesignConstants.cardPadding,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // --- bestehender Inhalt bleibt unverändert ---
              _buildFullBackupCard(context, l10n, theme),
              const SizedBox(height: DesignConstants.spacingL),
              _buildAutoBackupCard(context, l10n, theme),
              const SizedBox(height: DesignConstants.spacingL),
              _buildCsvExportCard(context, l10n, theme),
              const SizedBox(height: DesignConstants.spacingL),
              _buildMigrationCard(context, l10n, theme),
              const SizedBox(height: DesignConstants.spacingL),
              _buildExerciseMappingCard(context, l10n, theme),
            ],
          ),
        ),
      ),
    );
  }
  // --- WIDGET BUILDER ---

  Widget _buildFullBackupCard(
      BuildContext context, AppLocalizations l10n, ThemeData theme) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.dataManagementBackupTitle,
                style: theme.textTheme.headlineSmall),
            const SizedBox(height: DesignConstants.spacingS),
            Text(l10n.dataManagementBackupDescription,
                style: theme.textTheme.bodyMedium),
            const SizedBox(height: DesignConstants.spacingL),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    icon: const Icon(Icons.upload_file),
                    label: Text(l10n.data_export_button),
                    onPressed: _isFullBackupRunning ? null : _performFullExport,
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton.icon(
                    icon: const Icon(Icons.download_for_offline),
                    label: Text(l10n.data_import_button),
                    style: FilledButton.styleFrom(
                        backgroundColor: theme.colorScheme.error),
                    onPressed: _isFullBackupRunning ? null : _performFullImport,
                  ),
                ),
              ],
            ),
            const SizedBox(height: DesignConstants.spacingS),
// NEU: Verschlüsselt exportieren
            SizedBox(
              width: double.infinity,
              child: OutlinedButton.icon(
                icon: const Icon(Icons.lock_outline),
                label: Text(l10n.exportEncrypted),
                onPressed: _isFullBackupRunning
                    ? null
                    : () async {
                        final pw = await _askPassword(
                            title: l10n.dialogPasswordForExport);
                        if (pw == null || pw.isEmpty) return;
                        setState(() => _isFullBackupRunning = true);
                        final ok =
                            await BackupManager().exportFullBackupEncrypted(pw);
                        if (!mounted) return;
                        setState(() => _isFullBackupRunning = false);
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                              content: Text(ok
                                  ? l10n.snackbarEncryptedBackupShared
                                  : l10n.exportFailed)),
                        );
                      },
              ),
            ),

            if (_isFullBackupRunning)
              const Padding(
                padding: EdgeInsets.only(top: 16.0),
                child: Center(child: CircularProgressIndicator()),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildCsvExportCard(
      BuildContext context, AppLocalizations l10n, ThemeData theme) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.csvExportTitle, style: theme.textTheme.headlineSmall),
            const SizedBox(height: DesignConstants.spacingS),
            Text(l10n.csvExportDescription, style: theme.textTheme.bodyMedium),
            const SizedBox(height: DesignConstants.spacingS),
            _buildExportTile(
              icon: Icons.restaurant_menu,
              title: l10n.nutritionDiary,
              onTap: _isCsvExportRunning
                  ? null
                  : () => _exportCsv(
                      BackupManager().exportNutritionAsCsv,
                      l10n.snackbarSharingNutrition,
                      l10n.snackbarExportFailedNoEntries),
            ),
            _buildExportTile(
              icon: Icons.monitor_weight_outlined,
              title: l10n.drawerMeasurements,
              onTap: _isCsvExportRunning
                  ? null
                  : () => _exportCsv(
                      BackupManager().exportMeasurementsAsCsv,
                      l10n.snackbarSharingMeasurements,
                      l10n.snackbarExportFailedNoEntries),
            ),
            _buildExportTile(
              icon: Icons.fitness_center,
              title: l10n.workoutHistoryTitle,
              onTap: _isCsvExportRunning
                  ? null
                  : () => _exportCsv(
                      BackupManager().exportWorkoutsAsCsv,
                      l10n.snackbarSharingWorkouts,
                      l10n.snackbarExportFailedNoEntries),
            ),
            if (_isCsvExportRunning)
              const Padding(
                padding: EdgeInsets.only(top: 16.0),
                child: Center(child: CircularProgressIndicator()),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildMigrationCard(
      BuildContext context, AppLocalizations l10n, ThemeData theme) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.hevyImportTitle, style: theme.textTheme.headlineSmall),
            const SizedBox(height: DesignConstants.spacingS),
            Text(l10n.hevyImportDescription, style: theme.textTheme.bodyMedium),
            const SizedBox(height: DesignConstants.spacingL),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                icon: const Icon(Icons.sync_alt),
                label: Text(l10n.hevyImportButton),
                onPressed: _isMigrationRunning ? null : _performHevyImport,
              ),
            ),
            if (_isMigrationRunning)
              const Padding(
                padding: EdgeInsets.only(top: 16.0),
                child: Center(child: CircularProgressIndicator()),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildExportTile(
      {required IconData icon,
      required String title,
      required VoidCallback? onTap}) {
    return ListTile(
      leading: Icon(icon),
      title: Text(title),
      trailing: const Icon(Icons.chevron_right),
      onTap: onTap,
      contentPadding: EdgeInsets.zero,
    );
  }

  Widget _buildExerciseMappingCard(
      BuildContext context, AppLocalizations l10n, ThemeData theme) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.mapExercisesTitle, style: theme.textTheme.headlineSmall),
            const SizedBox(height: DesignConstants.spacingS),
            Text(
              l10n.mapExercisesDescription,
              style: theme.textTheme.bodyMedium,
            ),
            const SizedBox(height: DesignConstants.spacingL),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                icon: const Icon(Icons.rule_folder_outlined),
                label: Text(l10n.mapExercisesButton),
                onPressed: _openExerciseMapping,
              ),
            ),
          ],
        ),
      ),
    );
  }

// lib/screens/data_management_screen.dart – Auszug: neue Card
  Widget _buildAutoBackupCard(
      BuildContext context, AppLocalizations l10n, ThemeData theme) {
    return SummaryCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.autoBackupTitle, style: theme.textTheme.headlineSmall),
            const SizedBox(height: DesignConstants.spacingS),
            Text(
              l10n.autoBackupDescription,
              style: theme.textTheme.bodyMedium,
            ),
            const SizedBox(height: DesignConstants.spacingS),
            SelectableText(
              _autoBackupDir ?? l10n.autoBackupDefaultFolder,
              style: theme.textTheme.bodySmall,
            ),
            const SizedBox(height: DesignConstants.spacingM),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    icon: const Icon(Icons.folder_open),
                    label: Text(l10n.autoBackupChooseFolder),
                    onPressed: _pickAutoBackupDirectory,
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: OutlinedButton.icon(
                    icon: const Icon(Icons.copy),
                    label: Text(l10n.autoBackupCopyPath),
                    onPressed:
                        (_autoBackupDir == null || _autoBackupDir!.isEmpty)
                            ? null
                            : _copyAutoBackupPathToClipboard,
                  ),
                ),
              ],
            ),
            const SizedBox(height: DesignConstants.spacingM),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                icon: const Icon(Icons.backup),
                label: Text(l10n.autoBackupRunNow),
                onPressed: () async {
                  final ok = await BackupManager().runAutoBackupIfDue(
                    interval: const Duration(days: 1),
                    encrypted: false,
                    passphrase: null,
                    retention: 7,
                    dirPath: _autoBackupDir,
                    force: true, // NEU: sofort ausführen
                  );
                  if (!mounted) return;
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                        content: Text(ok
                            ? l10n.snackbarAutoBackupSuccess
                            : l10n.snackbarAutoBackupFailed)),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _openExerciseMapping() async {
    final unknown =
        await WorkoutDatabaseHelper.instance.findUnknownExerciseNames();
    final l10n = AppLocalizations.of(context)!;
    if (!mounted) return;
    if (unknown.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(l10n.noUnknownExercisesFound)),
      );
      return;
    }
    await Navigator.of(context).push(
      MaterialPageRoute(
          builder: (_) => ExerciseMappingScreen(unknownNames: unknown)),
    );
  }

  Future<void> _pickAutoBackupDirectory() async {
    // Directory-Picker (FilePicker unterstützt getDirectoryPath)
    final l10n = AppLocalizations.of(context)!;
    final path = await FilePicker.platform.getDirectoryPath();
    if (path == null) return;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('auto_backup_dir', path);
    setState(() => _autoBackupDir = path);
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(l10n.snackbarAutoBackupFolderSet(path))),
    );
  }

  Future<void> _copyAutoBackupPathToClipboard() async {
    final path = _autoBackupDir;
    final l10n = AppLocalizations.of(context)!;
    if (path == null || path.isEmpty) return;
    await Clipboard.setData(ClipboardData(text: path));
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(l10n.snackbarPathCopied)),
    );
  }

  Future<String?> _askPassword({required String title}) async {
    final controller = TextEditingController();
    bool obscure = true;
    final l10n = AppLocalizations.of(context)!;
    return showDialog<String>(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: Text(title),
          content: TextField(
            controller: controller,
            obscureText: obscure,
            decoration: InputDecoration(
              labelText: l10n.passwordLabel,
              suffixIcon: IconButton(
                icon: Icon(obscure ? Icons.visibility_off : Icons.visibility),
                onPressed: () => setState(() => obscure = !obscure),
              ),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(null),
              child: Text(l10n.dialogButtonCancel),
            ),
            FilledButton(
              onPressed: () =>
                  Navigator.of(context).pop(controller.text.trim()),
              child: Text(l10n.snackbarButtonOK),
            ),
          ],
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/profile_screen.dart =====

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/goals_screen.dart';
import 'package:lightweight/screens/onboarding_screen.dart';
import 'package:lightweight/screens/settings_screen.dart';
import 'package:lightweight/services/profile_service.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/bottom_content_spacer.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:provider/provider.dart';

class ProfileScreen extends StatefulWidget {
  const ProfileScreen({super.key});

  @override
  State<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends State<ProfileScreen> {
  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final profileService = Provider.of<ProfileService>(context);

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          l10n.profileScreenTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      body: ListView(
        padding: DesignConstants.cardPadding,
        children: [
          // Profilbild-Sektion
          //_buildSectionTitle(l10n.profile_capslock),
          SummaryCard(
            child: Padding(
              padding: DesignConstants.cardPadding,
              child: Column(
                children: [
                  GestureDetector(
                    onTap: () async {
                      await profileService.pickAndSaveProfileImage();
                    },
                    child: CircleAvatar(
                      key: ValueKey(
                          '${profileService.profileImagePath ?? ''}${profileService.cacheBuster}'),
                      radius: 50,
                      backgroundColor: Theme.of(context)
                          .colorScheme
                          .primary
                          .withOpacity(0.1),
                      backgroundImage: profileService.profileImagePath != null
                          ? FileImage(File(profileService.profileImagePath!))
                          : null,
                      child: profileService.profileImagePath == null
                          ? Icon(Icons.camera_alt,
                              size: 50,
                              color: Theme.of(context).colorScheme.primary)
                          : null,
                    ),
                  ),
                  if (profileService.profileImagePath != null)
                    TextButton(
                      onPressed: () async {
                        await profileService.deleteProfileImage();
                      },
                      child: Text(l10n.delete_profile_picture_button),
                    ),
                ],
              ),
            ),
          ),
          const SizedBox(height: DesignConstants.spacingM),

          // Sektion für Navigation
          // HINWEIS: Der redundante Titel "EINSTELLUNGEN" wurde entfernt.
          _buildNavigationCard(
            icon: Icons.settings_outlined,
            title: l10n.settingsTitle,
            subtitle:
                "Theme, units, data and more", // TODO: Localize this subtitle
            onTap: () {
              Navigator.of(context).push(MaterialPageRoute(
                  builder: (context) => const SettingsScreen()));
            },
          ),
          const SizedBox(height: DesignConstants.spacingM),
          _buildNavigationCard(
            icon: Icons.flag_outlined,
            title: l10n.my_goals,
            subtitle: l10n.my_goals_description,
            onTap: () {
              Navigator.of(context).push(
                  MaterialPageRoute(builder: (context) => const GoalsScreen()));
            },
          ),
          const SizedBox(height: DesignConstants.spacingM),
          _buildOnboardingCard(l10n),
          const BottomContentSpacer(),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildNavigationCard({
    required IconData icon,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
  }) {
    return SummaryCard(
      child: ListTile(
        contentPadding:
            const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16.0),
        leading:
            Icon(icon, size: 36, color: Theme.of(context).colorScheme.primary),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Text(subtitle),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
        shape:
            RoundedRectangleBorder(borderRadius: BorderRadius.circular(24.0)),
      ),
    );
  }

  Widget _buildOnboardingCard(AppLocalizations l10n) {
    // KORREKTUR: 'theme' wird direkt hier aus dem context geholt.
    final theme = Theme.of(context);

    return SummaryCard(
      child: ListTile(
        leading: Icon(Icons.school_outlined, color: theme.colorScheme.primary),
        title: Text(
          l10n.onbShowTutorialAgain,
          style: theme.textTheme.titleMedium
              ?.copyWith(fontWeight: FontWeight.w700),
        ),
        subtitle: Text(
          l10n.onbFinishBody,
          style: theme.textTheme.bodyMedium,
        ),
        trailing: const Icon(Icons.chevron_right),
        onTap: () {
          Navigator.of(context).push(
            MaterialPageRoute(builder: (_) => const OnboardingScreen()),
          );
        },
        contentPadding:
            const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/supplement_track_screen.dart =====

// lib/screens/supplement_track_screen.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/dialogs/log_supplement_dialog_content.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';
import 'package:lightweight/models/tracked_supplement.dart';
import 'package:lightweight/screens/manage_supplements_screen.dart';
import 'package:lightweight/util/date_util.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/util/supplement_l10n.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';

class SupplementTrackScreen extends StatefulWidget {
  const SupplementTrackScreen({super.key});
  @override
  State<SupplementTrackScreen> createState() => _SupplementTrackScreenState();
}

class _SupplementTrackScreenState extends State<SupplementTrackScreen> {
  bool _isLoading = true;
  DateTime _selectedDate = DateTime.now();

  final Map<int, Supplement> _supplementsById = {};
  List<TrackedSupplement> _tracked = const [];
  List<SupplementLog> _todaysLogs = const [];

  @override
  void initState() {
    super.initState();
    _loadData(_selectedDate);
  }

  Future<void> _loadData(DateTime day) async {
    setState(() => _isLoading = true);
    final db = DatabaseHelper.instance;

    final supplements = await db.getAllSupplements();
    final logs = await db.getSupplementLogsForDate(day);

    final byId = <int, Supplement>{
      for (final s in supplements)
        if (s.id != null) s.id!: s,
    };

    final doses = <int, double>{};
    for (final log in logs) {
      doses.update(log.supplementId, (v) => v + log.dose,
          ifAbsent: () => log.dose);
    }

    final tracked = supplements
        .map((s) => TrackedSupplement(
              supplement: s,
              totalDosedToday: doses[s.id] ?? 0.0,
            ))
        .toList();

    if (!mounted) return;
    setState(() {
      _supplementsById
        ..clear()
        ..addAll(byId);
      _tracked = tracked;
      _todaysLogs = logs;
      _isLoading = false;
    });
  }

  void _navigateDay(bool forward) {
    final newDay = _selectedDate.add(Duration(days: forward ? 1 : -1));
    if (forward && newDay.isAfter(DateTime.now())) return;
    setState(() => _selectedDate = newDay);
    _loadData(_selectedDate);
  }

  Future<void> _pickDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (picked != null && picked != _selectedDate) {
      setState(() => _selectedDate = picked);
      _loadData(_selectedDate);
    }
  }

  Future<void> _logSupplement(Supplement supplement) async {
    final l10n = AppLocalizations.of(context)!;
    final key = GlobalKey<LogSupplementDialogContentState>();

    final result = await showDialog<(double, DateTime)?>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(localizeSupplementName(supplement, l10n)),
        content: LogSupplementDialogContent(key: key, supplement: supplement),
        actions: [
          TextButton(
              onPressed: () => Navigator.pop(context, null),
              child: Text(l10n.cancel)),
          FilledButton(
            onPressed: () {
              final st = key.currentState;
              if (st == null) return;
              final dose = double.tryParse(st.doseText.replaceAll(',', '.'));
              if (dose != null && dose > 0) {
                Navigator.pop(context, (dose, st.selectedDateTime));
              }
            },
            child: Text(l10n.add_button),
          ),
        ],
      ),
    );

    if (result == null) return;

    final log = SupplementLog(
      supplementId: supplement.id!,
      dose: result.$1,
      unit: supplement.unit,
      timestamp: result.$2,
    );
    await DatabaseHelper.instance.insertSupplementLog(log);
    _loadData(_selectedDate);
  }

  Future<void> _editLogEntry(SupplementLog log) async {
    final l10n = AppLocalizations.of(context)!;
    final supplement = _supplementsById[log.supplementId]!;
    final key = GlobalKey<LogSupplementDialogContentState>();

    final result = await showDialog<(double, DateTime)?>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(localizeSupplementName(supplement, l10n)),
        content: LogSupplementDialogContent(
          key: key,
          supplement: supplement,
          initialDose: log.dose,
          initialTimestamp: log.timestamp,
        ),
        actions: [
          TextButton(
              onPressed: () => Navigator.pop(context, null),
              child: Text(l10n.cancel)),
          FilledButton(
            onPressed: () {
              final st = key.currentState;
              if (st == null) return;
              final dose = double.tryParse(st.doseText.replaceAll(',', '.'));
              if (dose != null && dose > 0) {
                Navigator.pop(context, (dose, st.selectedDateTime));
              }
            },
            child: Text(l10n.save),
          ),
        ],
      ),
    );

    if (result == null) return;

    final updated = SupplementLog(
      id: log.id,
      supplementId: supplement.id!,
      dose: result.$1,
      unit: supplement.unit,
      timestamp: result.$2,
    );
    await DatabaseHelper.instance.updateSupplementLog(updated);
    _loadData(_selectedDate);
  }

  Future<void> _deleteLogEntry(int id) async {
    // Log sichern
    final deleted = _todaysLogs.firstWhere((l) => l.id == id);

    await DatabaseHelper.instance.deleteSupplementLog(id);
    await _loadData(_selectedDate);

    final l10n = AppLocalizations.of(context)!;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(l10n.deleted),
        action: SnackBarAction(
          label: l10n.undo,
          onPressed: () async {
            // Gleiche Daten, aber ohne ID (damit es ein neuer Datensatz wird)
            final restored = SupplementLog(
              supplementId: deleted.supplementId,
              dose: deleted.dose,
              unit: deleted.unit,
              timestamp: deleted.timestamp,
            );
            await DatabaseHelper.instance.insertSupplementLog(restored);
            _loadData(_selectedDate);
          },
        ),
      ),
    );
  }

  Widget _sectionTitle(String title) => Padding(
        padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
        child: Text(
          title,
          style: Theme.of(context).textTheme.labelLarge?.copyWith(
                color: Colors.grey[600],
                fontWeight: FontWeight.bold,
              ),
        ),
      );

  Widget _progressCard(TrackedSupplement ts) {
    final s = ts.supplement;
    final isLimit = s.dailyLimit != null;
    final target = (isLimit ? s.dailyLimit : s.dailyGoal) ?? 0.0;
    final overTarget = isLimit && ts.totalDosedToday > target;
    final hasTarget = target > 0;
    final progress =
        hasTarget ? (ts.totalDosedToday / target).clamp(0.0, 1.0) : 0.0;
    final color = overTarget ? Colors.red.shade400 : Colors.green.shade400;
    final l10n = AppLocalizations.of(context)!;

    return Container(
      height: 60,
      margin: const EdgeInsets.symmetric(vertical: 6.0),
      decoration: BoxDecoration(
        color: Theme.of(context)
            .colorScheme
            .surfaceContainerHighest
            .withOpacity(0.3),
        borderRadius: BorderRadius.circular(20),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(20),
        child: Stack(
          fit: StackFit.expand,
          children: [
            Align(
              alignment: Alignment.centerLeft,
              child: FractionallySizedBox(
                  widthFactor: progress, child: Container(color: color)),
            ),
            Padding(
              padding:
                  const EdgeInsets.symmetric(horizontal: 12.0, vertical: 4.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  FittedBox(
                    fit: BoxFit.scaleDown,
                    child: Text(
                      localizeSupplementName(s, l10n),
                      maxLines: 1,
                      style: const TextStyle(
                          fontSize: 16, fontWeight: FontWeight.bold),
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    hasTarget
                        ? '${ts.totalDosedToday.toStringAsFixed(1)} / ${target.toStringAsFixed(1)} ${s.unit}'
                        : '${ts.totalDosedToday.toStringAsFixed(1)} ${s.unit}',
                    style: TextStyle(
                      color: Theme.of(context)
                          .colorScheme
                          .onSurface
                          .withOpacity(0.8),
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _logActionTile(Supplement s) {
    final l10n = AppLocalizations.of(context)!;
    return SummaryCard(
      child: ListTile(
        leading: const Icon(Icons.add_circle_outline),
        title: Text(localizeSupplementName(s, l10n)),
        onTap: () => _logSupplement(s),
      ),
    );
  }

  Widget _logEntryTile(SupplementLog log, AppLocalizations l10n) {
    final s = _supplementsById[log.supplementId];
    final titleText = (s == null) ? 'Unknown' : localizeSupplementName(s, l10n);

    return Dismissible(
      key: Key('log_${log.id}'),
      direction: DismissDirection.horizontal,
      background: const SwipeActionBackground(
        color: Colors.blueAccent,
        icon: Icons.edit,
        alignment: Alignment.centerLeft,
      ),
      secondaryBackground: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      confirmDismiss: (direction) async {
        if (direction == DismissDirection.startToEnd) {
          _editLogEntry(log);
          return false;
        }
        final ok = await showDialog<bool>(
              context: context,
              builder: (_) => AlertDialog(
                title: Text(l10n.deleteConfirmTitle),
                content: Text(l10n.deleteConfirmContent),
                actions: [
                  TextButton(
                      onPressed: () => Navigator.pop(context, false),
                      child: Text(l10n.cancel)),
                  TextButton(
                      onPressed: () => Navigator.pop(context, true),
                      child: Text(l10n.delete)),
                ],
              ),
            ) ??
            false;
        return ok;
      },
      onDismissed: (direction) {
        if (direction == DismissDirection.endToStart) _deleteLogEntry(log.id!);
      },
      child: SummaryCard(
        child: ListTile(
          leading: const Icon(Icons.check_circle, color: Colors.grey),
          title: Text(titleText),
          subtitle: Text(DateFormat.Hm().format(log.timestamp)),
          trailing: Text('${log.dose.toStringAsFixed(1)} ${log.unit}'),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).toString();

    return Scaffold(
      appBar: AppBar(
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        elevation: 0,
        scrolledUnderElevation: 0,
        title: Text(
          l10n.supplementTrackerTitle,
          style: Theme.of(context)
              .textTheme
              .titleLarge
              ?.copyWith(fontWeight: FontWeight.w900),
        ),
        actions: [
          IconButton(
            tooltip: l10n.manageSupplementsTitle,
            icon: const Icon(Icons.tune),
            onPressed: () async {
              final changed = await Navigator.of(context).push<bool>(
                MaterialPageRoute(
                    builder: (_) => const ManageSupplementsScreen()),
              );
              if (changed == true) _loadData(_selectedDate);
            },
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : RefreshIndicator(
              onRefresh: () => _loadData(_selectedDate),
              child: ListView(
                padding: EdgeInsets.only(
                  left: DesignConstants.cardPadding.left,
                  right: DesignConstants.cardPadding.right,
                  bottom: DesignConstants.cardPadding.bottom + 24,
                  top: 8,
                ),
                children: [
                  // Date header
                  Padding(
                    padding: const EdgeInsets.symmetric(
                        horizontal: 16.0, vertical: 8.0),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        IconButton(
                            icon: const Icon(Icons.chevron_left),
                            onPressed: () => _navigateDay(false)),
                        Expanded(
                          child: InkWell(
                            onTap: _pickDate,
                            child: Text(
                              DateFormat.yMMMMd(locale).format(_selectedDate),
                              textAlign: TextAlign.center,
                              overflow: TextOverflow.ellipsis,
                              style: Theme.of(context)
                                  .textTheme
                                  .titleMedium
                                  ?.copyWith(fontWeight: FontWeight.bold),
                            ),
                          ),
                        ),
                        IconButton(
                          icon: const Icon(Icons.chevron_right),
                          onPressed: _selectedDate.isSameDate(DateTime.now())
                              ? null
                              : () => _navigateDay(true),
                        ),
                      ],
                    ),
                  ),
                  Divider(
                    height: 1,
                    thickness: 1,
                    color: Theme.of(context)
                        .colorScheme
                        .onSurfaceVariant
                        .withOpacity(0.1),
                  ),
                  const SizedBox(height: DesignConstants.spacingL),

                  // Progress section
                  _sectionTitle(l10n.dailyProgressTitle),
                  if (_tracked
                      .where((t) =>
                          t.supplement.dailyGoal != null ||
                          t.supplement.dailyLimit != null)
                      .isEmpty)
                    Padding(
                      padding: const EdgeInsets.symmetric(vertical: 8.0),
                      child: Text(l10n.emptySupplementGoals,
                          textAlign: TextAlign.center),
                    ),
                  ..._tracked
                      .where((t) =>
                          t.supplement.dailyGoal != null ||
                          t.supplement.dailyLimit != null)
                      .map(_progressCard),

                  const SizedBox(height: DesignConstants.spacingXL),

                  // Log intake
                  _sectionTitle(l10n.logIntakeTitle),
                  ..._tracked.map((t) => _logActionTile(t.supplement)),

                  const SizedBox(height: DesignConstants.spacingXL),

                  // Today's logs
                  _sectionTitle(l10n.todaysLogTitle),
                  if (_todaysLogs.isEmpty)
                    Padding(
                      padding: const EdgeInsets.symmetric(vertical: 8.0),
                      child: Text(l10n.emptySupplementLogs,
                          textAlign: TextAlign.center),
                    )
                  else
                    ..._todaysLogs.map((log) => _logEntryTile(log, l10n)),
                ],
              ),
            ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/onboarding_screen.dart =====

// lib/screens/onboarding_screen.dart
import 'package:flutter/material.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/generated/app_localizations.dart';

// TODO: Ersetze diese Imports durch deine echten Screens/Routes
import 'package:lightweight/screens/main_screen.dart';
import 'package:lightweight/screens/goals_screen.dart';

class OnboardingScreen extends StatefulWidget {
  const OnboardingScreen({super.key});
  @override
  State<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenState extends State<OnboardingScreen> {
  final PageController _page = PageController();
  int _index = 0;
  bool _goalVisited = false;
  final bool _foodVisited = false;
  final bool _trainVisited = false;

  Future<void> _finish() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool('hasSeenOnboarding', true);
    if (!mounted) return;
    // Zurück ins Haupt-UI
    Navigator.of(context).pushAndRemoveUntil(
      MaterialPageRoute(builder: (_) => const MainScreen()),
      (r) => false,
    );
  }

  void _next(int lastIndex) {
    if (_index < lastIndex) {
      _page.animateToPage(
        _index + 1,
        duration: const Duration(milliseconds: 250),
        curve: Curves.easeOut,
      );
    } else {
      _finish();
    }
  }

  void _skip() => _finish();

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    final pages = <Widget>[
      _Slide(
        icon: Icons.flag,
        title: l10n.onbWelcomeTitle,
        body: l10n.onbWelcomeBody,
        primaryCta: _Cta(
          icon: Icons.edit_outlined,
          label: l10n.onbSetGoalsCta,
          onTap: () async {
            await Navigator.of(context).push(
              MaterialPageRoute(builder: (_) => const GoalsScreen()),
            );
            if (!mounted) return;
            setState(() => _goalVisited = true);
          },
        ),
        footer: _goalVisited
            ? _Badge(text: l10n.onbBadgeDone)
            : _Hint(text: l10n.onbTipSetGoals),
      ),
      // 2) Nutrition (nur Beschreibung, kein Link)
      _Slide(
        icon: Icons.restaurant_menu,
        title: l10n
            .onbTrackTitle, // oder eigener Titel, z. B. l10n.onbNutritionTitle
        body: l10n
            .onbTrackHowBody, // bereits eingefügt: Schrittfolge fürs Essen-Loggen
        primaryCta: null,
        footer: _Hint(text: l10n.onbTipAddEntry),
      ),

// 3) Measurements (neue Folie)
      _Slide(
        icon: Icons.monitor_weight_outlined,
        title: l10n.onbMeasureTitle,
        body: l10n.onbMeasureBody, // Schrittfolge zum Hinzufügen von Messungen
        primaryCta: null,
        footer: _Hint(text: l10n.onbTipMeasureToday),
      ),

// 4) Training: Routine erstellen + Workout starten (neue Folie)
      _Slide(
        icon: Icons.fitness_center,
        title: l10n.onbTrainTitle,
        body: l10n.onbTrainBody, // Kombinierte Anleitung Routine/Workout
        primaryCta: null,
        footer: _Hint(text: l10n.onbTipStartWorkout),
      ),

// 5) Offline & Privacy bleibt
      _Slide(
        icon: Icons.lock_outline,
        title: l10n.onbPrivacyTitle,
        body: l10n.onbPrivacyBody,
        primaryCta: null,
        footer: _Hint(text: l10n.onbTipLocalControl),
      ),

// 6) Finish bleibt
      _FinalSlide(
        title: l10n.onbFinishTitle,
        body: l10n.onbFinishBody,
        onFinish: _finish,
      ),
    ];

    final lastIndex = pages.length - 1;

    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            // Header Controls
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 8, 16, 0),
              child: Row(
                children: [
                  Text(l10n.onbHeaderTitle, style: theme.textTheme.titleMedium),
                  const Spacer(),
                  TextButton(onPressed: _skip, child: Text(l10n.onbHeaderSkip)),
                ],
              ),
            ),
            // Compact guide banner
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 0, 16, 8),
              child: Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: theme.colorScheme.primary.withOpacity(0.06),
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(
                    color: theme.colorScheme.primary.withOpacity(0.25),
                  ),
                ),
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Icon(Icons.swipe, color: theme.colorScheme.primary),
                    const SizedBox(width: 12),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            l10n.onbGuideTitle,
                            style: theme.textTheme.titleSmall?.copyWith(
                              fontWeight: FontWeight.w700,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            l10n.onbGuideBody,
                            style: theme.textTheme.bodySmall,
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
            // Pages
            Expanded(
              child: PageView.builder(
                controller: _page,
                onPageChanged: (i) => setState(() => _index = i),
                itemCount: pages.length,
                itemBuilder: (_, i) => pages[i],
              ),
            ),
            // Dots
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: List.generate(
                pages.length,
                (i) => AnimatedContainer(
                  duration: const Duration(milliseconds: 200),
                  margin: const EdgeInsets.all(6),
                  height: 8,
                  width: _index == i ? 24 : 8,
                  decoration: BoxDecoration(
                    color: _index == i
                        ? theme.colorScheme.primary
                        : theme.disabledColor.withOpacity(0.4),
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
              ),
            ),
            // Bottom bar
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 8, 16, 16),
              child: Row(
                children: [
                  Expanded(
                    child: OutlinedButton.icon(
                      onPressed: _index == 0
                          ? null
                          : () => _page.animateToPage(
                                _index - 1,
                                duration: const Duration(milliseconds: 250),
                                curve: Curves.easeOut,
                              ),
                      icon: const Icon(Icons.chevron_left),
                      label: Text(l10n.onbBack),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton.icon(
                      onPressed: () => _next(lastIndex),
                      icon: Icon(_index < lastIndex
                          ? Icons.chevron_right
                          : Icons.check),
                      label: Text(_index < lastIndex
                          ? l10n.onbNext
                          : l10n.onbFinishCta),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _Slide extends StatelessWidget {
  final IconData icon;
  final String title;
  final String body;
  final _Cta? primaryCta;
  final Widget? footer;
  const _Slide({
    required this.icon,
    required this.title,
    required this.body,
    this.primaryCta,
    this.footer,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 72, color: theme.colorScheme.primary),
          const SizedBox(height: DesignConstants.spacingL),
          Text(title,
              style: theme.textTheme.headlineSmall,
              textAlign: TextAlign.center),
          const SizedBox(height: DesignConstants.spacingS),
          Text(body,
              textAlign: TextAlign.center, style: theme.textTheme.bodyLarge),
          const SizedBox(height: DesignConstants.spacingXL),
          if (primaryCta != null)
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: primaryCta!.onTap,
                icon: Icon(primaryCta!.icon),
                label: Text(primaryCta!.label),
              ),
            ),
          if (footer != null) ...[
            const SizedBox(height: DesignConstants.spacingM),
            footer!,
          ],
        ],
      ),
    );
  }
}

class _FinalSlide extends StatelessWidget {
  final String title;
  final String body;
  final VoidCallback onFinish;
  const _FinalSlide({
    required this.title,
    required this.body,
    required this.onFinish,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.rocket_launch, size: 72, color: theme.colorScheme.primary),
          const SizedBox(height: DesignConstants.spacingL),
          Text(title,
              style: theme.textTheme.headlineSmall,
              textAlign: TextAlign.center),
          const SizedBox(height: DesignConstants.spacingS),
          Text(body,
              textAlign: TextAlign.center, style: theme.textTheme.bodyLarge),
          const SizedBox(height: DesignConstants.spacingXL),
          SizedBox(
            width: double.infinity,
            child: ElevatedButton.icon(
              onPressed: onFinish,
              icon: const Icon(Icons.check),
              label: Text(AppLocalizations.of(context)!.onbFinishCta),
            ),
          ),
        ],
      ),
    );
  }
}

class _Cta {
  final IconData icon;
  final String label;
  final Future<void> Function()? onTap;
  const _Cta({required this.icon, required this.label, this.onTap});
}

class _Badge extends StatelessWidget {
  final String text;
  const _Badge({required this.text});
  @override
  Widget build(BuildContext context) {
    final c = Theme.of(context).colorScheme;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        color: c.primary.withOpacity(0.15),
        borderRadius: BorderRadius.circular(999),
        border: Border.all(color: c.primary.withOpacity(0.35)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.check_circle, size: 16, color: c.primary),
          const SizedBox(width: 6),
          Text(text,
              style: TextStyle(color: c.primary, fontWeight: FontWeight.w600)),
        ],
      ),
    );
  }
}

class _Hint extends StatelessWidget {
  final String text;
  const _Hint({required this.text});
  @override
  Widget build(BuildContext context) {
    return Text(text,
        style: Theme.of(context)
            .textTheme
            .bodySmall
            ?.copyWith(color: Colors.grey));
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/meals_screen.dart =====

import 'package:flutter/material.dart';
import 'meal_editor_screen.dart';

class MealsScreen extends StatelessWidget {
  const MealsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    // Platzhalter-Liste – später mit echten Meals füllen
    final meals = <String>[];

    return Scaffold(
      appBar: AppBar(title: const Text('Meals')),
      body: meals.isEmpty
          ? const Center(
              child: Text(
                'Noch keine Meals.\nTippe auf das +, um eines zu erstellen.',
                textAlign: TextAlign.center,
              ),
            )
          : ListView.separated(
              itemCount: meals.length,
              separatorBuilder: (_, __) => const Divider(height: 1),
              itemBuilder: (context, i) => ListTile(
                title: Text(meals[i]),
                onTap: () async {
                  final result = await Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (_) => MealEditorScreen(initialName: meals[i]),
                    ),
                  );
                  if (result == true && context.mounted) {
                    // TODO: Liste neu laden (später)
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Meal gespeichert')),
                    );
                  }
                },
              ),
            ),
      floatingActionButton: FloatingActionButton(
        onPressed: () async {
          final result = await Navigator.push(
            context,
            MaterialPageRoute(builder: (_) => const MealEditorScreen()),
          );
          if (result == true && context.mounted) {
            // TODO: Liste neu laden (später)
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text('Meal gespeichert')),
            );
          }
        },
        child: const Icon(Icons.add),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/create_food_screen.dart =====

// lib/screens/create_food_screen.dart (Final & De-Materialisiert)

import 'package:flutter/material.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/util/design_constants.dart';

class CreateFoodScreen extends StatefulWidget {
  final FoodItem? foodItemToEdit;
  const CreateFoodScreen({super.key, this.foodItemToEdit});

  @override
  State<CreateFoodScreen> createState() => _CreateFoodScreenState();
}

class _CreateFoodScreenState extends State<CreateFoodScreen> {
  final _formKey = GlobalKey<FormState>();

  final _nameController = TextEditingController();
  final _brandController = TextEditingController();
  final _caloriesController = TextEditingController();
  final _proteinController = TextEditingController();
  final _carbsController = TextEditingController();
  final _fatController = TextEditingController();
  final _sugarController = TextEditingController();
  final _fiberController = TextEditingController();
  final _saltController = TextEditingController();

  bool get _isEditing => widget.foodItemToEdit != null;

  @override
  void initState() {
    super.initState();
    if (_isEditing) {
      final item = widget.foodItemToEdit!;
      _nameController.text = item.name;
      _brandController.text = item.brand;
      _caloriesController.text = item.calories.toString();
      _proteinController.text = item.protein.toString();
      _carbsController.text = item.carbs.toString();
      _fatController.text = item.fat.toString();
      _sugarController.text = item.sugar?.toString() ?? '';
      _fiberController.text = item.fiber?.toString() ?? '';
      _saltController.text = item.salt?.toString() ?? '';
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _brandController.dispose();
    _caloriesController.dispose();
    _proteinController.dispose();
    _carbsController.dispose();
    _fatController.dispose();
    _sugarController.dispose();
    _fiberController.dispose();
    _saltController.dispose();
    super.dispose();
  }

  Future<void> _saveFoodItem() async {
    if (_formKey.currentState?.validate() ?? false) {
      final l10n = AppLocalizations.of(context)!;

      final foodData = FoodItem(
        barcode: _isEditing
            ? widget.foodItemToEdit!.barcode
            : "user_created_${DateTime.now().millisecondsSinceEpoch}",
        name: _nameController.text,
        brand: _brandController.text,
        calories: int.tryParse(_caloriesController.text) ?? 0,
        protein: double.tryParse(_proteinController.text) ?? 0.0,
        carbs: double.tryParse(_carbsController.text) ?? 0.0,
        fat: double.tryParse(_fatController.text) ?? 0.0,
        sugar: double.tryParse(_sugarController.text),
        fiber: double.tryParse(_fiberController.text),
        salt: double.tryParse(_saltController.text),
        source: FoodItemSource.user,
      );

      if (_isEditing) {
        await ProductDatabaseHelper.instance.updateProduct(foodData);
      } else {
        await ProductDatabaseHelper.instance.insertProduct(foodData);
      }

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(l10n.snackbarSaveSuccess(foodData.name))),
        );
        Navigator.of(context).pop(foodData);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      // KORREKTUR: Eine AppBar hinzugefügt, die den Titel und den Speicher-Button enthält

      appBar: AppBar(
        title: Text(l10n.createFoodScreenTitle),
        actions: [
          TextButton(
            onPressed: _saveFoodItem,
            // Hier stellen wir sicher, dass der Text die Primärfarbe nutzt
            style: TextButton.styleFrom(
              foregroundColor: Theme.of(context).colorScheme.primary,
            ),

            child: Text(
              l10n.buttonSave,
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          )
        ],
      ),
      body: SingleChildScrollView(
        padding: DesignConstants.cardPadding,
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // KORREKTUR: Der alte Header wurde aus dem Body entfernt

              // Formularfelder (unverändert)
              _buildFoodInputField(
                  controller: _nameController,
                  label: l10n.formFieldName,
                  isRequired: true),
              _buildFoodInputField(
                  controller: _brandController, label: l10n.formFieldBrand),

              const SizedBox(height: DesignConstants.spacingXL),
              _buildSectionTitle(context, l10n.formSectionMainNutrients),
              const SizedBox(height: DesignConstants.spacingL),
              _buildFoodInputField(
                  controller: _caloriesController,
                  label: l10n.formFieldCalories),
              _buildFoodInputField(
                  controller: _proteinController, label: l10n.formFieldProtein),
              _buildFoodInputField(
                  controller: _carbsController, label: l10n.formFieldCarbs),
              _buildFoodInputField(
                  controller: _fatController, label: l10n.formFieldFat),

              const SizedBox(height: DesignConstants.spacingXL),
              _buildSectionTitle(context, l10n.formSectionOptionalNutrients),
              const SizedBox(height: DesignConstants.spacingL),
              _buildFoodInputField(
                  controller: _sugarController, label: l10n.formFieldSugar),
              _buildFoodInputField(
                  controller: _fiberController, label: l10n.formFieldFiber),
              _buildFoodInputField(
                  controller: _saltController, label: l10n.formFieldSalt),

              const SizedBox(height: 32),
            ],
          ),
        ),
      ),
    );
  }

  // ... (die restlichen _build-Methoden bleiben unverändert hier drin)
  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildFoodInputField({
    required TextEditingController controller,
    required String label,
    bool isRequired = false,
  }) {
    final l10n = AppLocalizations.of(context)!;
    return Padding(
      padding: const EdgeInsets.only(bottom: 12.0),
      child: TextFormField(
        controller: controller,
        decoration: InputDecoration(
          labelText: label,
        ),
        keyboardType: const TextInputType.numberWithOptions(decimal: true),
        validator: (value) {
          if (isRequired && (value == null || value.isEmpty)) {
            return l10n.validatorPleaseEnterName;
          }
          if (value != null &&
              value.isNotEmpty &&
              double.tryParse(value) == null) {
            return l10n.validatorPleaseEnterNumber;
          }
          return null;
        },
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/statistics_hub_screen.dart =====

// lib/screens/statistics_hub_screen.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/measurements_screen.dart';
import 'package:lightweight/screens/nutrition_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/bottom_content_spacer.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:table_calendar/table_calendar.dart';

class StatisticsHubScreen extends StatefulWidget {
  const StatisticsHubScreen({super.key});

  @override
  State<StatisticsHubScreen> createState() => _StatisticsHubScreenState();
}

class _StatisticsHubScreenState extends State<StatisticsHubScreen> {
  late final l10n = AppLocalizations.of(context)!;
  DateTime _focusedDay = DateTime.now();
  DateTime? _selectedDay;
  bool _isLoading = true;
  String _recommendationText = '';

  Set<int> _workoutDays = {};
  Set<int> _nutritionLogDays = {};
  Set<int> _supplementDays = {};

  @override
  void initState() {
    super.initState();
    _selectedDay = _focusedDay;
    _loadAllData();
  }

  Future<void> _loadAllData() async {
    if (!mounted) return;
    setState(() => _isLoading = true);

    await _loadMonthData(_focusedDay);
    final recommendation = await _getRecommendation();

    if (mounted) {
      setState(() {
        _recommendationText = recommendation;
        _isLoading = false;
      });
    }
  }

  Future<void> _loadMonthData(DateTime month) async {
    final workoutDays =
        await WorkoutDatabaseHelper.instance.getWorkoutDaysInMonth(month);
    final nutritionDays =
        await DatabaseHelper.instance.getNutritionLogDaysInMonth(month);
    final supplementDays =
        await DatabaseHelper.instance.getSupplementLogDaysInMonth(month);

    if (mounted) {
      setState(() {
        _workoutDays = workoutDays;
        _nutritionLogDays = nutritionDays;
        _supplementDays = supplementDays;
      });
    }
  }

  Future<String> _getRecommendation() async {
    final prefs = await SharedPreferences.getInstance();
    final targetCalories = prefs.getInt('targetCalories') ?? 2500;
    final today = DateTime.now();
    final sevenDaysAgo = today.subtract(const Duration(days: 6));
    final recentEntries = await DatabaseHelper.instance
        .getEntriesForDateRange(sevenDaysAgo, today);

    if (recentEntries.isEmpty) {
      return l10n.recommendationDefault;
    }

    final uniqueDaysTracked =
        recentEntries.map((e) => DateFormat.yMd().format(e.timestamp)).toSet();
    final numberOfTrackedDays = uniqueDaysTracked.length;
    int totalRecentCalories = 0;
    for (final entry in recentEntries) {
      final foodItem = await ProductDatabaseHelper.instance
          .getProductByBarcode(entry.barcode);
      if (foodItem != null) {
        totalRecentCalories +=
            (foodItem.calories / 100 * entry.quantityInGrams).round();
      }
    }

    final totalTargetCalories = targetCalories * numberOfTrackedDays;
    final difference = totalRecentCalories - totalTargetCalories;
    final tolerance = totalTargetCalories * 0.05;

    if (numberOfTrackedDays > 1) {
      if (difference > tolerance) {
        return l10n.recommendationOverTarget(
            numberOfTrackedDays, difference.round());
      } else if (difference < -tolerance) {
        return l10n.recommendationUnderTarget(
            numberOfTrackedDays, (-difference).round());
      } else {
        return l10n.recommendationOnTarget(numberOfTrackedDays);
      }
    } else {
      return l10n.recommendationFirstEntry;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : RefreshIndicator(
            onRefresh: _loadAllData,
            child: ListView(
                padding: DesignConstants.cardPadding,
                children: [
                  _buildSectionTitle(context, l10n.my_consistency),
                  SummaryCard(
                    child: Padding(
                      padding: const EdgeInsets.all(8.0),
                      child: TableCalendar(
                        locale: Localizations.localeOf(context).toString(),
                        firstDay: DateTime.utc(2020, 1, 1),
                        lastDay: DateTime.now().add(const Duration(days: 365)),
                        focusedDay: _focusedDay,
                        selectedDayPredicate: (day) =>
                            isSameDay(_selectedDay, day),
                        calendarFormat: CalendarFormat.month,
                        headerStyle: HeaderStyle(
                          formatButtonVisible: false,
                          titleCentered: true,
                          titleTextStyle:
                              Theme.of(context).textTheme.titleMedium!,
                        ),
                        onDaySelected: (selectedDay, focusedDay) {
                          setState(() {
                            _selectedDay = selectedDay;
                            _focusedDay = focusedDay;
                          });
                        },
                        onPageChanged: (focusedDay) {
                          setState(() {
                            _focusedDay = focusedDay;
                          });
                          _loadMonthData(focusedDay);
                        },
                        calendarBuilders: CalendarBuilders(
                          markerBuilder: (context, day, events) {
                            final isNutritionDay =
                                _nutritionLogDays.contains(day.day);
                            final isSupplementDay =
                                _supplementDays.contains(day.day);

                            return Positioned(
                              bottom: 4,
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  if (isNutritionDay)
                                    Container(
                                      width: 6,
                                      height: 6,
                                      decoration: const BoxDecoration(
                                          shape: BoxShape.circle,
                                          color: Colors.blueAccent),
                                    ),
                                  if (isNutritionDay && isSupplementDay)
                                    const SizedBox(width: 2),
                                  if (isSupplementDay)
                                    Container(
                                      width: 6,
                                      height: 6,
                                      decoration: const BoxDecoration(
                                          shape: BoxShape.circle,
                                          color: Colors.amber),
                                    ),
                                ],
                              ),
                            );
                          },
                          defaultBuilder: (context, day, focusedDay) {
                            final isWorkoutDay = _workoutDays.contains(day.day);
                            if (isWorkoutDay) {
                              return Center(
                                child: Container(
                                  width: 32,
                                  height: 32,
                                  decoration: BoxDecoration(
                                    shape: BoxShape.circle,
                                    color: Theme.of(context).colorScheme.primary,
                                  ),
                                  child: Center(
                                    child: Text(
                                      '${day.day}',
                                      style: TextStyle(
                                        color: Theme.of(context)
                                            .colorScheme
                                            .onPrimary,
                                      ),
                                    ),
                                  ),
                                ),
                              );
                            }
                            return null;
                          },
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: DesignConstants.spacingS),
                  _buildBannerCard(l10n),
                  const SizedBox(height: DesignConstants.spacingXL),
                  _buildSectionTitle(context, l10n.in_depth_analysis),
                  _buildAnalysisGateway(
                    context: context,
                    icon: Icons.monitor_weight_outlined,
                    title: l10n.body_measurements,
                    subtitle: l10n.measurements_description,
                    onTap: () {
                      Navigator.of(context).push(MaterialPageRoute(
                          builder: (context) => const MeasurementsScreen()));
                    },
                  ),
                  const SizedBox(height: DesignConstants.spacingM),
                  _buildAnalysisGateway(
                    context: context,
                    icon: Icons.pie_chart_outline_rounded,
                    title: l10n.nutritionScreenTitle,
                    subtitle: l10n.nutrition_description,
                    onTap: () {
                      Navigator.of(context).push(MaterialPageRoute(
                          builder: (context) => const NutritionScreen()));
                    },
                  ),
                  const SizedBox(height: DesignConstants.spacingM),
                  _buildAnalysisGateway(
                    context: context,
                    icon: Icons.bar_chart_rounded,
                    title: l10n.training_analysis,
                    subtitle: l10n.training_analysis_description,
                    onTap: () {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text(l10n.soon_available_snackbar)),
                      );
                    },
                  ),
                  const BottomContentSpacer(),
                ],
              ),
          ),
    );
  }

  Widget _buildBannerCard(AppLocalizations l10n) {
    return SummaryCard(
      child: Container(
        height: 100,
        alignment: Alignment.center,
        child: Text(
          _recommendationText.isEmpty ? l10n.load_dots : _recommendationText,
          textAlign: TextAlign.center,
          style: TextStyle(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
              fontSize: 22,
              fontWeight: FontWeight.w500),
        ),
      ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildAnalysisGateway({
    required BuildContext context,
    required IconData icon,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
  }) {
    return SummaryCard(
      child: ListTile(
        contentPadding:
            const EdgeInsets.symmetric(vertical: 12.0, horizontal: 16.0),
        leading:
            Icon(icon, size: 40, color: Theme.of(context).colorScheme.primary),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Text(subtitle),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
      ),
    );
  }
}

===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/workout_hub_screen.dart =====

// lib/screens/workout_hub_screen.dart (Final, mit einheitlichem Design)

import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/screens/edit_routine_screen.dart';
import 'package:lightweight/screens/exercise_catalog_screen.dart';
import 'package:lightweight/screens/live_workout_screen.dart';
import 'package:lightweight/screens/routines_screen.dart';
import 'package:lightweight/screens/workout_history_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/bottom_content_spacer.dart';
import 'package:lightweight/widgets/summary_card.dart';

class WorkoutHubScreen extends StatefulWidget {
  const WorkoutHubScreen({super.key});

  @override
  State<WorkoutHubScreen> createState() => _WorkoutHubScreenState();
}

class _WorkoutHubScreenState extends State<WorkoutHubScreen> {
  bool _isLoading = true;
  List<Routine> _routines = [];
  late final l10n = AppLocalizations.of(context)!;

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  Future<void> _loadData() async {
    setState(() => _isLoading = true);
    final routines = await WorkoutDatabaseHelper.instance.getAllRoutines();
    if (mounted) {
      setState(() {
        _routines = routines;
        _isLoading = false;
      });
    }
  }

  void _startEmptyWorkout() async {
    final newLog = await WorkoutDatabaseHelper.instance
        .startWorkout(routineName: l10n.free_training);
    if (mounted) {
      Navigator.of(context)
          .push(MaterialPageRoute(
            builder: (context) => LiveWorkoutScreen(workoutLog: newLog),
          ))
          .then((_) => _loadData());
    }
  }

  void _startRoutine(Routine routine) async {
    // Wir brauchen die vollen Details der Routine zum Starten
    final detailedRoutine =
        await WorkoutDatabaseHelper.instance.getRoutineById(routine.id!);
    if (detailedRoutine == null) return;

    final newLog = await WorkoutDatabaseHelper.instance
        .startWorkout(routineName: routine.name);
    if (mounted) {
      Navigator.of(context)
          .push(MaterialPageRoute(
            builder: (context) =>
                LiveWorkoutScreen(routine: detailedRoutine, workoutLog: newLog),
          ))
          .then((_) => _loadData());
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    return Scaffold(
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : RefreshIndicator(
              onRefresh: _loadData,
              child: ListView(
                padding: DesignConstants.cardPadding,
                children: [
                  _buildSectionTitle(context, l10n.startCapsLock),
                  SummaryCard(
                    child: InkWell(
                      onTap: _startEmptyWorkout,
                      borderRadius:
                          BorderRadius.circular(DesignConstants.borderRadiusM),
                      child: Padding(
                        padding: const EdgeInsets.all(20.0),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            const Icon(Icons.add_circle_outline, size: 28),
                            const SizedBox(width: 12),
                            Text(l10n.startEmptyWorkoutButton,
                                style: Theme.of(context).textTheme.titleLarge),
                          ],
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: DesignConstants.spacingXL),
                  _buildSectionTitle(context, l10n.my_plans_capslock),
                  _routines.isEmpty
                      ? _buildEmptyRoutinesCard(context, l10n)
                      : SizedBox(
                          height: 150,
                          child: ListView.builder(
                            scrollDirection: Axis.horizontal,
                            clipBehavior: Clip.none,
                            itemCount: _routines.length,
                            itemBuilder: (context, index) {
                              return _buildRoutineCard(
                                  context, _routines[index]);
                            },
                          ),
                        ),
                  const SizedBox(height: DesignConstants.spacingXL),
                  _buildSectionTitle(context, l10n.overview_capslock),
                  _buildNavigationTile(
                    context: context,
                    icon: Icons.history,
                    title: l10n.workoutHistoryButton,
                    onTap: () => Navigator.of(context).push(MaterialPageRoute(
                        builder: (context) => const WorkoutHistoryScreen())),
                  ),
                  const SizedBox(height: DesignConstants.spacingM),
                  _buildNavigationTile(
                    context: context,
                    icon: Icons.list_alt_rounded,
                    title: l10n.manage_all_plans,
                    onTap: () => Navigator.of(context)
                        .push(MaterialPageRoute(
                            builder: (context) => const RoutinesScreen()))
                        .then((_) => _loadData()),
                  ),
                  const SizedBox(height: DesignConstants.spacingM),
                  _buildNavigationTile(
                    context: context,
                    icon: Icons.folder_open_outlined,
                    title: l10n.drawerExerciseCatalog,
                    onTap: () => Navigator.of(context).push(MaterialPageRoute(
                        builder: (context) => const ExerciseCatalogScreen())),
                  ),
                  const BottomContentSpacer(),
                ],
              ),
            ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildRoutineCard(BuildContext context, Routine routine) {
    final screenWidth = MediaQuery.of(context).size.width;
    final cardWidth = (screenWidth - 32 - 12) / 2;

    return SizedBox(
      width: cardWidth,
      // KORREKTUR: Wir fügen den Abstand hier als Padding hinzu, nicht als Margin.
      child: Padding(
        padding: const EdgeInsets.only(right: 12.0),
        child: SummaryCard(
          child: InkWell(
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (_) => EditRoutineScreen(routine: routine),
                ),
              );
            },
            borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM),
            child: Padding(
              padding: DesignConstants.cardPadding,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(routine.name,
                      style: Theme.of(context)
                          .textTheme
                          .titleMedium
                          ?.copyWith(fontWeight: FontWeight.bold),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis),
                  ElevatedButton(
                      onPressed: () => _startRoutine(routine),
                      child: Text(l10n.start_button)),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildEmptyRoutinesCard(BuildContext context, AppLocalizations l10n) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          children: [
            Text(l10n.emptyRoutinesTitle,
                style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: DesignConstants.spacingS),
            Text(l10n.emptyRoutinesSubtitle,
                textAlign: TextAlign.center,
                style: Theme.of(context).textTheme.bodySmall),
            const SizedBox(height: DesignConstants.spacingL),
            TextButton.icon(
              onPressed: () => Navigator.of(context)
                  .push(MaterialPageRoute(
                      builder: (context) => const RoutinesScreen()))
                  .then((_) => _loadData()),
              icon: const Icon(Icons.add),
              label: Text(l10n.createFirstRoutineButton),
            )
          ],
        ),
      ),
    );
  }

  Widget _buildNavigationTile({
    required BuildContext context,
    required IconData icon,
    required String title,
    required VoidCallback onTap,
  }) {
    return SummaryCard(
      child: ListTile(
        leading: Icon(icon, color: Theme.of(context).colorScheme.primary),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
        shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM)),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/exercise_catalog_screen.dart =====

// lib/screens/exercise_catalog_screen.dart (Final & De-Materialisiert)

import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/screens/exercise_detail_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/wger_attribution_widget.dart';
import 'package:lightweight/screens/create_exercise_screen.dart';
import 'package:lightweight/widgets/glass_fab.dart';

class ExerciseCatalogScreen extends StatefulWidget {
  final bool isSelectionMode;
  const ExerciseCatalogScreen({super.key, this.isSelectionMode = false});

  @override
  State<ExerciseCatalogScreen> createState() => _ExerciseCatalogScreenState();
}

class _ExerciseCatalogScreenState extends State<ExerciseCatalogScreen> {
  List<Exercise> _foundExercises = [];
  bool _isLoading = true;
  final _searchController = TextEditingController();
  List<String> _allCategories = [];
  List<String> _selectedCategories = [];

  @override
  void initState() {
    super.initState();
    _searchController.addListener(() => _runFilter(_searchController.text));
    _loadCategories();
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  Future<void> _loadCategories() async {
    final categories = await WorkoutDatabaseHelper.instance.getAllCategories();
    setState(() {
      _allCategories = categories;
      _isLoading = false;
    });
    _runFilter(_searchController.text); // Erste Ladung oder Filter
  }

  void _runFilter(String enteredKeyword) async {
    final results = await WorkoutDatabaseHelper.instance.searchExercises(
      query: enteredKeyword,
      selectedCategories: _selectedCategories,
    );
    if (mounted) {
      setState(() {
        _foundExercises = results;
      });
    }
  }

  void _showFilterDialog(BuildContext context, AppLocalizations l10n) {
    showDialog(
      context: context,
      builder: (context) {
        // Lokaler State für die Auswahl im Dialog
        List<String> tempSelectedCategories = List.from(_selectedCategories);
        return StatefulBuilder(
          builder: (context, setStateSB) {
            return AlertDialog(
              // Nutzt globales DialogTheme
              title: Text(l10n.filterByCategory),
              content: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: _allCategories.map((category) {
                    final isSelected =
                        tempSelectedCategories.contains(category);
                    return ListTile(
                      title: Text(category),
                      leading: Checkbox(
                        value: isSelected,
                        onChanged: (bool? value) {
                          setStateSB(() {
                            // State des Dialogs aktualisieren
                            if (value == true) {
                              tempSelectedCategories.add(category);
                            } else {
                              tempSelectedCategories.remove(category);
                            }
                          });
                        },
                      ),
                    );
                  }).toList(),
                ),
              ),
              actions: [
                TextButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: Text(l10n.cancel)),
                ElevatedButton(
                  // Nutzt globales Theme
                  onPressed: () {
                    setState(() {
                      // State des Haupt-Screens aktualisieren
                      _selectedCategories = tempSelectedCategories;
                    });
                    _runFilter(_searchController.text);
                    Navigator.of(context).pop();
                  },
                  child: Text(l10n.doneButtonLabel),
                ),
              ],
            );
          },
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          l10n.exerciseCatalogTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
        actions: [
          if (widget.isSelectionMode)
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: Text(
                l10n.doneButtonLabel,
                style: TextStyle(
                  color: Theme.of(context).colorScheme.primary,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
        ],
      ),

      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      // KORREKTUR 1: AppBar entfernt, Titel und Aktionen im Body
// Body ohne doppelten Titel
      body: Column(
        children: [
          Padding(
            padding:
                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 24.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const SizedBox(height: DesignConstants.spacingS),
                TextField(
                  controller: _searchController,
                  decoration: InputDecoration(
                    hintText: l10n.searchHintText,
                    prefixIcon: Icon(Icons.search,
                        color: colorScheme.onSurfaceVariant, size: 20),
                    suffixIcon: _searchController.text.isNotEmpty
                        ? IconButton(
                            icon: Icon(Icons.clear,
                                color: colorScheme.onSurfaceVariant),
                            onPressed: () => _searchController.clear(),
                          )
                        : null,
                  ),
                ),
                const SizedBox(height: DesignConstants.spacingL),
                _buildFilterButton(context, l10n),
              ],
            ),
          ),
          Divider(
            height: 1,
            thickness: 1,
            color: colorScheme.onSurfaceVariant.withOpacity(0.1),
          ),
          Expanded(
            child: _isLoading
                ? const Center(child: CircularProgressIndicator())
                : _foundExercises.isEmpty
                    ? Center(
                        child: Text(l10n.noExercisesFound,
                            style: textTheme.titleMedium))
                    : ListView.builder(
                        padding: DesignConstants.cardPadding,
                        itemCount: _foundExercises.length,
                        itemBuilder: (context, index) {
                          final exercise = _foundExercises[index];
                          return SummaryCard(
                            // KORREKTUR 3: Übungs-Card
                            child: ListTile(
                              leading: const Icon(Icons.fitness_center),
                              title: Text(exercise.getLocalizedName(context),
                                  style: const TextStyle(
                                      fontWeight: FontWeight.bold)),
                              subtitle: Text(exercise.categoryName),
                              trailing: widget.isSelectionMode
                                  ? IconButton(
                                      // Auswahl-Modus: Hinzufügen-Icon
                                      icon: Icon(Icons.add_circle_outline,
                                          color: colorScheme.primary),
                                      onPressed: () =>
                                          Navigator.of(context).pop(exercise),
                                    )
                                  : const Icon(Icons
                                      .chevron_right), // Anzeige-Modus: Pfeil
                              onTap: () {
                                if (widget.isSelectionMode) {
                                  // Im Auswahl-Modus: Bei Klick auch auswählen
                                  Navigator.of(context).pop(exercise);
                                } else {
                                  // Im Anzeige-Modus: Detail-Screen öffnen
                                  Navigator.of(context).push(MaterialPageRoute(
                                      builder: (context) =>
                                          ExerciseDetailScreen(
                                              exercise: exercise)));
                                }
                              },
                            ),
                          );
                        },
                      ),
          ),
          // KORREKTUR 4: WgerAttributionWidget am Ende
          Padding(
            padding: const EdgeInsets.only(top: 16.0, bottom: 8.0),
            child: WgerAttributionWidget(
              textStyle: textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
            ),
          ),
        ],
      ),
      floatingActionButton: GlassFab(
        label: l10n.create_exercise_screen_title,
        onPressed: () {
          Navigator.of(context)
              .push(
            MaterialPageRoute(
                builder: (context) => const CreateExerciseScreen()),
          )
              .then((wasCreated) {
            // Wenn der Screen mit 'true' zurückkehrt, wurde eine Übung erstellt.
            // Lade die Liste neu, um die neue Übung anzuzeigen.
            if (wasCreated == true) {
              _runFilter(_searchController.text);
            }
          });
        },
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  // KORREKTUR 5: Helfer-Widget für den Filter-Button
  Widget _buildFilterButton(BuildContext context, AppLocalizations l10n) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final textTheme = theme.textTheme;

    return Padding(
      padding: const EdgeInsets.only(top: 8.0),
      child: GestureDetector(
        onTap: () => _showFilterDialog(context, l10n),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
          decoration: BoxDecoration(
            color: _selectedCategories.isNotEmpty
                ? colorScheme.primary
                : colorScheme.surfaceContainerHighest.withOpacity(0.5),
            borderRadius: BorderRadius.circular(10.0),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.filter_list,
                  size: 20,
                  color: _selectedCategories.isNotEmpty
                      ? colorScheme.onPrimary
                      : colorScheme.onSurfaceVariant),
              const SizedBox(width: 8),
              Text(
                l10n.filterByCategory,
                style: textTheme.labelLarge?.copyWith(
                  color: _selectedCategories.isNotEmpty
                      ? colorScheme.onPrimary
                      : colorScheme.onSurfaceVariant,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/routines_screen.dart =====

// lib/screens/routines_screen.dart (Final & De-Materialisiert - Korrigiert)

import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/screens/edit_routine_screen.dart';
import 'package:lightweight/screens/live_workout_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';

class RoutinesScreen extends StatefulWidget {
  final int? initialRoutineId;
  const RoutinesScreen({super.key, this.initialRoutineId});
  @override
  State<RoutinesScreen> createState() => _RoutinesScreenState();
}

class _RoutinesScreenState extends State<RoutinesScreen> {
  bool _isLoading = true;
  List<Routine> _routines = [];
  // final l10n wurde entfernt, da es in didChangeDependencies instanziiert wird

  @override
  void initState() {
    super.initState();
    // _loadRoutines wird jetzt von didChangeDependencies aufgerufen
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Sicherstellen, dass l10n verfügbar ist, bevor _loadRoutines aufgerufen wird.
    // l10n wird hier instanziiert, wo context sicher verfügbar ist.
    _loadRoutines(AppLocalizations.of(context)!);
  }

  Future<void> _loadRoutines(AppLocalizations l10n) async {
    // l10n als Parameter hinzugefügt
    setState(() => _isLoading = true);
    final data = await WorkoutDatabaseHelper.instance.getAllRoutines();
    if (mounted) {
      setState(() {
        _routines = data;
        _isLoading = false;
      });
      // Wenn eine initialRoutineId übergeben wurde, direkt dorthin navigieren
      if (widget.initialRoutineId != null) {
        final routineToEdit = _routines.firstWhere(
            (r) => r.id == widget.initialRoutineId,
            orElse: () => throw Exception(
                l10n.errorRoutineNotFound)); // l10n hier verwenden
        WidgetsBinding.instance.addPostFrameCallback((_) {
          Navigator.of(context)
              .push(MaterialPageRoute(
                  builder: (context) =>
                      EditRoutineScreen(routine: routineToEdit)))
              .then((_) => _loadRoutines(l10n)); // l10n hier übergeben
        });
      }
    }
  }

  void _startWorkout(Routine routine) async {
    showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => const Center(child: CircularProgressIndicator()));
    final fullRoutine =
        await WorkoutDatabaseHelper.instance.getRoutineById(routine.id!);
    final newWorkoutLog = await WorkoutDatabaseHelper.instance
        .startWorkout(routineName: routine.name);
    if (!mounted) return;
    Navigator.of(context).pop();
    if (fullRoutine != null) {
      final l10n = AppLocalizations.of(context)!; // l10n im Build-Kontext holen
      Navigator.of(context)
          .push(MaterialPageRoute(
            builder: (context) => LiveWorkoutScreen(
                routine: fullRoutine, workoutLog: newWorkoutLog),
          ))
          .then((_) => _loadRoutines(l10n)); // l10n hier übergeben
    }
  }

  void _startEmptyWorkout() async {
    final l10n = AppLocalizations.of(context)!;
    final newWorkoutLog = await WorkoutDatabaseHelper.instance
        .startWorkout(routineName: l10n.freeWorkoutTitle);
    if (!mounted) return;
    Navigator.of(context)
        .push(MaterialPageRoute(
          builder: (context) => LiveWorkoutScreen(workoutLog: newWorkoutLog),
        ))
        .then((_) => _loadRoutines(l10n)); // l10n hier übergeben
  }

  void _createNewRoutine() {
    final l10n = AppLocalizations.of(context)!; // l10n im Build-Kontext holen
    Navigator.of(context)
        .push(
            MaterialPageRoute(builder: (context) => const EditRoutineScreen()))
        .then((_) => _loadRoutines(l10n)); // l10n hier übergeben
  }

// NEUE METHODEN FÜR DAS MENÜ
  void _duplicateRoutine(int routineId) async {
    await WorkoutDatabaseHelper.instance.duplicateRoutine(routineId);
    final l10n = AppLocalizations.of(context)!; // l10n im Build-Kontext holen
    _loadRoutines(l10n); // l10n hier übergeben
  }

  void _deleteRoutine(BuildContext context, Routine routine) async {
    final l10n = AppLocalizations.of(context)!;
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.deleteConfirmTitle),
        content: Text(l10n.deleteRoutineConfirmContent(routine.name)),
        actions: [
          TextButton(
              onPressed: () => Navigator.of(ctx).pop(false),
              child: Text(l10n.cancel)),
          TextButton(
              onPressed: () => Navigator.of(ctx).pop(true),
              child: Text(l10n.delete)),
        ],
      ),
    );

    if (confirmed == true) {
      await WorkoutDatabaseHelper.instance.deleteRoutine(routine.id!);
      _loadRoutines(l10n); // l10n hier übergeben
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final textTheme = Theme.of(context).textTheme; // Hier definiert

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          l10n.workoutRoutinesTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _routines.isEmpty
              ? _buildEmptyState(context, l10n, textTheme)
              : ListView.builder(
                  padding: DesignConstants.cardPadding,
                  itemCount: _routines.length + 1, // statt +2
                  itemBuilder: (context, index) {
                    if (index == 0) {
                      return _buildStartEmptyWorkoutCard(context, l10n);
                    }
                    final routine = _routines[index - 1];
                    return Dismissible(
                      key: Key('routine_${routine.id}'),
                      direction: DismissDirection.endToStart,

                      // gleiche Hintergründe wie im Nutrition Screen
                      background: const SwipeActionBackground(
                        color: Colors.redAccent,
                        icon: Icons.delete,
                        alignment: Alignment.centerRight,
                      ),

                      // Swipe-Logik wie bei Nutrition:
                      // links→rechts = Edit (nicht wirklich dismissen),
                      // rechts→links = Delete (mit Bestätigung)
                      confirmDismiss: (direction) async {
                        final confirmed = await showDialog<bool>(
                              context: context,
                              builder: (ctx) => AlertDialog(
                                title: Text(l10n.deleteConfirmTitle),
                                content: Text(l10n.deleteConfirmContent),
                                actions: [
                                  TextButton(
                                    onPressed: () =>
                                        Navigator.of(ctx).pop(false),
                                    child: Text(l10n.cancel),
                                  ),
                                  TextButton(
                                    onPressed: () =>
                                        Navigator.of(ctx).pop(true),
                                    child: Text(l10n.delete),
                                  ),
                                ],
                              ),
                            ) ??
                            false;
                        return confirmed;
                      },

                      onDismissed: (direction) {
                        if (direction == DismissDirection.endToStart) {
                          _deleteRoutine(context, routine); // wirklich löschen
                        }
                      },

                      child: SummaryCard(
                        child: ListTile(
                          leading: ElevatedButton(
                            onPressed: () => _startWorkout(routine),
                            child: Text(l10n.startButton),
                          ),
                          title: Text(routine.name,
                              style:
                                  const TextStyle(fontWeight: FontWeight.bold)),
                          subtitle: Text(l10n.editRoutineSubtitle),
                          trailing: PopupMenuButton<String>(
                            icon: Icon(Icons.more_vert,
                                color: textTheme.bodyMedium?.color),
                            onSelected: (value) {
                              if (value == 'duplicate') {
                                _duplicateRoutine(routine.id!);
                              } else if (value == 'delete') {
                                _deleteRoutine(context, routine);
                              }
                            },
                            itemBuilder: (BuildContext context) =>
                                <PopupMenuEntry<String>>[
                              PopupMenuItem<String>(
                                  value: 'duplicate',
                                  child: Text(l10n.duplicate)),
                              PopupMenuItem<String>(
                                  value: 'delete', child: Text(l10n.delete)),
                            ],
                          ),
                          onTap: () {
                            Navigator.of(context)
                                .push(MaterialPageRoute(
                                    builder: (context) =>
                                        EditRoutineScreen(routine: routine)))
                                .then((_) =>
                                    _loadRoutines(l10n)); // l10n hier übergeben
                          },
                        ),
                      ),
                    );
                  },
                ),
      floatingActionButton: GlassFab(
        label: l10n.addRoutineButton,
        onPressed: _createNewRoutine,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  // KORREKTUR 5: _buildStartEmptyWorkoutCard als SummaryCard-Button
  Widget _buildStartEmptyWorkoutCard(
      BuildContext context, AppLocalizations l10n) {
    return SummaryCard(
      child: ListTile(
        leading: const Icon(Icons.play_circle_fill),
        title: Text(l10n.startEmptyWorkoutButton,
            style: const TextStyle(fontWeight: FontWeight.bold)),
        onTap: _startEmptyWorkout,
        shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM)),
      ),
    );
  }

// In RoutinesScreen: _buildEmptyState ersetzen/erweitern

  Widget _buildEmptyState(
      BuildContext context, AppLocalizations l10n, TextTheme textTheme) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.list_alt_outlined,
                size: 80, color: Colors.grey.shade400),
            const SizedBox(height: DesignConstants.spacingL),
            Text(
              l10n.emptyRoutinesTitle,
              style: textTheme.headlineSmall,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: DesignConstants.spacingS),
            Text(
              l10n.emptyRoutinesSubtitle,
              textAlign: TextAlign.center,
              style: textTheme.bodyLarge?.copyWith(color: Colors.grey.shade600),
            ),
            const SizedBox(height: DesignConstants.spacingXL),

            // Bestehender Button: Routine erstellen
            ElevatedButton.icon(
              style: ElevatedButton.styleFrom(
                padding:
                    const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
              ),
              onPressed: _createNewRoutine,
              icon: const Icon(Icons.add),
              label: Text(
                l10n.createFirstRoutineButton,
                style: textTheme.titleMedium?.copyWith(
                  color: Theme.of(context).colorScheme.onPrimary,
                ),
              ),
            ),

            const SizedBox(height: DesignConstants.spacingM),

            // NEU: Freies Training starten (sichtbar auch im Empty-State)
            OutlinedButton.icon(
              style: OutlinedButton.styleFrom(
                padding:
                    const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
              ),
              onPressed: _startEmptyWorkout,
              icon: const Icon(Icons.play_circle_fill),
              label: Text(l10n.startEmptyWorkoutButton),
            ),
          ],
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/live_workout_screen.dart =====

/*// lib/screens/live_workout_screen.dart (Final & De-Materialisiert - Endgültig)

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/models/routine_exercise.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/set_template.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/services/workout_session_manager.dart';
import 'package:lightweight/widgets/workout_summary_bar.dart';
import 'exercise_catalog_screen.dart';
import 'exercise_detail_screen.dart';
import 'package:provider/provider.dart';
import 'package:lightweight/screens/workout_summary_screen.dart';
import 'package:lightweight/widgets/workout_card.dart';

class LiveWorkoutScreen extends StatefulWidget {
  final Routine? routine;
  final WorkoutLog workoutLog;

  const LiveWorkoutScreen({super.key, this.routine, required this.workoutLog});

  @override
  State<LiveWorkoutScreen> createState() => _LiveWorkoutScreenState();
}

class _LiveWorkoutScreenState extends State<LiveWorkoutScreen> {
  late List<RoutineExercise> _liveExercises;
  final Map<int, Map<String, dynamic>> _setUIData = {};
  final Map<int, TextEditingController> _weightControllers = {};
  final Map<int, TextEditingController> _repsControllers = {};
  final Map<String, SetLog?> _lastPerformances = {};
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    final manager = Provider.of<WorkoutSessionManager>(context, listen: false);
    final isContinuing =
        manager.isActive && manager.workoutLog?.id == widget.workoutLog.id;

    if (isContinuing) {
      _liveExercises = manager.exercises;
    } else {
      if (widget.routine != null) {
        _liveExercises = widget.routine!.exercises.map((re) {
          return RoutineExercise(
            id: re.id,
            exercise: re.exercise,
            setTemplates: re.setTemplates
                .map((st) => SetTemplate.fromMap(st.toMap()))
                .toList(),
            pauseSeconds: re.pauseSeconds,
          );
        }).toList();
      } else {
        _liveExercises = [];
      }
      WidgetsBinding.instance.addPostFrameCallback((_) {
        manager.startWorkout(widget.workoutLog, _liveExercises);
      });
    }
    _initializeScreen();
  }

  @override
  void dispose() {
    for (var c in _weightControllers.values) {
      c.dispose();
    }
    for (var c in _repsControllers.values) {
      c.dispose();
    }
    super.dispose();
  }

  Future<void> _initializeScreen() async {
    for (var routineExercise in _liveExercises) {
      final lastPerf = await WorkoutDatabaseHelper.instance
          .getLastPerformance(routineExercise.exercise.nameEn);
      if (mounted) {
        setState(() =>
            _lastPerformances[routineExercise.exercise.nameEn] = lastPerf);
      }
      for (final template in routineExercise.setTemplates) {
        final templateId = template.id!;
        String initialReps =
            template.targetReps ?? (lastPerf?.reps?.toString() ?? '');
        String initialWeight = (template.targetWeight ?? lastPerf?.weightKg)
                ?.toStringAsFixed(1)
                .replaceAll('.0', '') ??
            '';
        _setUIData[templateId] = {'setType': template.setType};
        _weightControllers[templateId] =
            TextEditingController(text: initialWeight);
        _repsControllers[templateId] = TextEditingController(text: initialReps);
      }
    }
    if (mounted) setState(() => _isLoading = false);
  }

  void _logSet(int setTemplateId, RoutineExercise re) async {
    final weight = double.tryParse(
            _weightControllers[setTemplateId]!.text.replaceAll(',', '.')) ??
        0.0;
    final reps = int.tryParse(_repsControllers[setTemplateId]!.text) ?? 0;
    final setType = _setUIData[setTemplateId]!['setType'] as String;

    await WorkoutSessionManager()
        .logSet(setTemplateId, re, weight, reps, setType);

    setState(() {}); // UI refresh
  }

  void _unlogSet(int setTemplateId) async {
    await WorkoutSessionManager().unlogSet(setTemplateId);
    setState(() {});
  }

  Future<void> _finishWorkout() async {
    final l10n = AppLocalizations.of(context)!;
    // Frage den Nutzer zuerst, ob er wirklich beenden will.
    final bool? confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.finishWorkoutButton), // Titel: "Beenden"
        content: Text(l10n.dialogFinishWorkoutBody),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text(l10n.cancel),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: Text(l10n.finishWorkoutButton),
          ),
        ],
      ),
    );

    // Nur wenn der Nutzer bestätigt hat (confirmed == true)...
    if (confirmed == true && mounted) {
      final logId = widget.workoutLog.id;
      await WorkoutSessionManager().finishWorkout();

      if (mounted && logId != null) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(
            builder: (context) => WorkoutSummaryScreen(logId: logId),
          ),
        );
      }
    }
  }

  void _addSet(RoutineExercise routineExercise) {
    setState(() {
      final newTemplate = SetTemplate(
          id: DateTime.now().millisecondsSinceEpoch, setType: 'normal');
      routineExercise.setTemplates.add(newTemplate);
      final templateId = newTemplate.id!;
      _setUIData[templateId] = {'setType': 'normal'};
      _weightControllers[templateId] = TextEditingController();
      _repsControllers[templateId] = TextEditingController();
    });
  }

  void _removeSet(RoutineExercise routineExercise, int setTemplateId) {
    setState(() {
      routineExercise.setTemplates.removeWhere((st) => st.id == setTemplateId);
      _setUIData.remove(setTemplateId);
      WorkoutSessionManager().completedSets.remove(setTemplateId);
      _weightControllers.remove(setTemplateId)?.dispose();
      _repsControllers.remove(setTemplateId)?.dispose();
    });
  }

  void _addExercise() async {
    final selectedExercise = await Navigator.of(context).push<Exercise>(
      MaterialPageRoute(
          builder: (context) =>
              const ExerciseCatalogScreen(isSelectionMode: true)),
    );

    if (selectedExercise != null) {
      setState(() {
        final newTemplate = SetTemplate(
          id: DateTime.now().millisecondsSinceEpoch + 1,
          setType: 'normal',
        );

        final newRoutineExercise = RoutineExercise(
          id: DateTime.now().millisecondsSinceEpoch,
          exercise: selectedExercise,
          setTemplates: [newTemplate],
        );

        _liveExercises.add(newRoutineExercise);
        WorkoutSessionManager().pauseTimes[newRoutineExercise.id!] = null;

        final templateId = newTemplate.id!;
        _setUIData[templateId] = {'setType': 'normal'};
        _weightControllers[templateId] = TextEditingController();
        _repsControllers[templateId] = TextEditingController();
      });
    }
  }

 void _changeSetType(int setTemplateId, String newType) {
    setState(() {
      _setUIData[setTemplateId]!['setType'] = newType;
    });
    Navigator.pop(context);
  }

  void _showSetTypePicker(int setTemplateId) { // Akzeptiert jetzt wieder int
    showModalBottomSheet(
      context: context,
      builder: (context) {
        return Wrap(
          children: <Widget>[
            ListTile(
                title: const Text('Normal'),
                onTap: () => _changeSetType(setTemplateId, 'normal')), // Übergibt ID
            ListTile(
                title: const Text('Warmup'),
                onTap: () => _changeSetType(setTemplateId, 'warmup')), // Übergibt ID
            ListTile(
                title: const Text('Failure'),
                onTap: () => _changeSetType(setTemplateId, 'failure')), // Übergibt ID
            ListTile(
                title: const Text('Dropset'),
                onTap: () => _changeSetType(setTemplateId, 'dropset')), // Übergibt ID
          ],
        );
      },
    );
  }


  void _editPauseTime(RoutineExercise routineExercise) async {
    final l10n = AppLocalizations.of(context)!;
    final currentPause = WorkoutSessionManager()
        .exercises
        .firstWhere((ex) => ex.id == routineExercise.id)
        .pauseSeconds;

    final controller =
        TextEditingController(text: currentPause?.toString() ?? '');
    final result = await showDialog<int?>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.editPauseTimeTitle),
        content: TextField(
          controller: controller,
          keyboardType: TextInputType.number,
          decoration: InputDecoration(labelText: l10n.pauseInSeconds),
        ),
        actions: [
          TextButton(
              onPressed: () => Navigator.of(ctx).pop(),
              child: Text(l10n.cancel)),
          FilledButton(
              onPressed: () =>
                  Navigator.of(ctx).pop(int.tryParse(controller.text)),
              child: Text(l10n.save)),
        ],
      ),
    );
    if (result != null) {
      WorkoutSessionManager().updatePauseTime(routineExercise, result);
      setState(() {});
    }
  }

  void _removeExercise(RoutineExercise exerciseToRemove) {
    setState(() {
      for (var template in exerciseToRemove.setTemplates) {
        _setUIData.remove(template.id!);
        WorkoutSessionManager().completedSets.remove(template.id!);
        _weightControllers.remove(template.id!)?.dispose();
        _repsControllers.remove(template.id!)?.dispose();
      }
      WorkoutSessionManager().pauseTimes.remove(exerciseToRemove.id!);
      _liveExercises.remove(exerciseToRemove);
    });
  }

  void _onReorder(int oldIndex, int newIndex) {
    setState(() {
      if (newIndex > oldIndex) {
        newIndex -= 1;
      }
      final RoutineExercise item = _liveExercises.removeAt(oldIndex);
      _liveExercises.insert(newIndex, item);
    });
  }

  Widget _buildHeader(String text) => Expanded(
      child: Text(text,
          textAlign: TextAlign.center,
          style: TextStyle(
              color: Colors.grey[600],
              fontSize: 12,
              fontWeight: FontWeight.bold)));

  /// Gibt den anzuzeigenden Text für den Set zurück
  String _getSetDisplayText(String setType, int setIndex) {
    switch (setType) {
      case 'warmup':
        return 'W';
      case 'failure':
        return 'F';
      case 'dropset':
        return 'D';
      default:
        return '$setIndex';
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    final manager = WorkoutSessionManager();

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          widget.workoutLog.routineName ?? l10n.freeWorkoutTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
        actions: [
          TextButton(
            onPressed: _finishWorkout,
            child: Text(
              l10n.finishWorkoutButton,
              style: TextStyle(
                color: Theme.of(context).colorScheme.primary,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : Column(
              children: [
                AnimatedBuilder(
                  animation: manager,
                  builder: (context, _) {
                    return WorkoutSummaryBar(
                      duration: manager.elapsedDuration,
                      volume: manager.totalVolume,
                      sets: manager.totalSets,
                    );
                  },
                ),
                Divider(
                    height: 1,
                    thickness: 1,
                    color: colorScheme.onSurfaceVariant.withOpacity(0.1)),
                Expanded(
                  child: ReorderableListView.builder(
                    padding: EdgeInsets.zero,
                    proxyDecorator:
                        (Widget child, int index, Animation<double> animation) {
                      return Material(
                        elevation: 4.0,
                        color: Theme.of(context).scaffoldBackgroundColor,
                        child: child,
                      );
                    },
                    onReorder: _onReorder,
                    itemCount: _liveExercises.length,
                    itemBuilder: (context, index) {
                      final routineExercise = _liveExercises[index];
                      return WorkoutCard(
                        key: ValueKey(routineExercise.id),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            ListTile(
                              contentPadding: const EdgeInsets.symmetric(
                                  horizontal: 16.0, vertical: 8.0),
                              title: InkWell(
                                onTap: () => Navigator.of(context).push(
                                    MaterialPageRoute(
                                        builder: (context) =>
                                            ExerciseDetailScreen(
                                                exercise:
                                                    routineExercise.exercise))),
                                child: Padding(
                                  padding:
                                      const EdgeInsets.symmetric(vertical: 4.0),
                                  child: Text(
                                    routineExercise.exercise
                                        .getLocalizedName(context),
                                    style: textTheme.titleLarge
                                        ?.copyWith(fontWeight: FontWeight.bold),
                                  ),
                                ),
                              ),
                              leading: ReorderableDragStartListener(
                                index: index,
                                child: const Icon(Icons.drag_handle),
                              ),
                              trailing: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  if (manager.pauseTimes[routineExercise.id!] !=
                                          null &&
                                      manager.pauseTimes[routineExercise.id!]! >
                                          0)
                                    Padding(
                                      padding:
                                          const EdgeInsets.only(right: 4.0),
                                      child: Text(
                                        "${manager.pauseTimes[routineExercise.id!]}s",
                                        style: textTheme.bodyMedium?.copyWith(
                                            color: colorScheme.primary,
                                            fontWeight: FontWeight.bold),
                                      ),
                                    ),
                                  IconButton(
                                    icon: const Icon(Icons.timer_outlined),
                                    tooltip: l10n.editPauseTime,
                                    onPressed: () =>
                                        _editPauseTime(routineExercise),
                                  ),
                                  IconButton(
                                    icon: const Icon(Icons.delete_outline,
                                        color: Colors.redAccent),
                                    tooltip: l10n.removeExercise,
                                    onPressed: () =>
                                        _removeExercise(routineExercise),
                                  ),
                                ],
                              ),
                            ),
                            Padding(
                              padding:
                                  const EdgeInsets.symmetric(horizontal: 0.0),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Row(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.center,
                                    children: [
                                      Expanded(
                                        flex: 2,
                                        child: Center(
                                            child: Text(
                                          l10n.setLabel,
                                          textAlign: TextAlign.center,
                                          style: TextStyle(
                                            color: Colors.grey[600],
                                            fontSize: 12,
                                            fontWeight: FontWeight.bold,
                                          ),
                                        )),
                                      ),
                                      Expanded(
                                        flex: 3,
                                        child: Center(
                                            child: Text(
                                          l10n.lastTimeLabel,
                                          textAlign: TextAlign.center,
                                          style: TextStyle(
                                            color: Colors.grey[600],
                                            fontSize: 12,
                                            fontWeight: FontWeight.bold,
                                          ),
                                        )),
                                      ),
                                      Expanded(
                                        flex: 2,
                                        child: Center(
                                            child: Text(
                                          l10n.kgLabel,
                                          textAlign: TextAlign.center,
                                          style: TextStyle(
                                            color: Colors.grey[600],
                                            fontSize: 12,
                                            fontWeight: FontWeight.bold,
                                          ),
                                        )),
                                      ),
                                      Expanded(
                                        flex: 2,
                                        child: Center(
                                            child: Text(
                                          l10n.repsLabel,
                                          textAlign: TextAlign.center,
                                          style: TextStyle(
                                            color: Colors.grey[600],
                                            fontSize: 12,
                                            fontWeight: FontWeight.bold,
                                          ),
                                        )),
                                      ),
                                      const SizedBox(width: 48),
                                    ],
                                  ),
                                  ...routineExercise.setTemplates
                                      .asMap()
                                      .entries
                                      .map((setEntry) {
                                    final setTemplate = setEntry.value;
                                    int workingSetIndex = 0;
                                    for (int i = 0; i <= setEntry.key; i++) {
                                      final currentTemplate =
                                          routineExercise.setTemplates[i];
                                      final currentSetType = _setUIData[
                                          currentTemplate.id!]!['setType'];
                                      if (currentSetType != 'warmup') {
                                        workingSetIndex++;
                                      }
                                    }

                                    return _buildSetRow(
                                      workingSetIndex,
                                      setEntry.key, // HIER WIRD DER INDEX ÜBERGEBEN
                                      routineExercise,
                                      setTemplate,
                                      manager.completedSets
                                          .contains(setTemplate.id!),
                                      colorScheme,
                                      _lastPerformances[
                                          routineExercise.exercise.nameEn],
                                    );
                                  }),
                                  const SizedBox(height: DesignConstants.spacingS),
                                  Padding(
                                    padding: const EdgeInsets.symmetric(horizontal: 16.0),
                                    child: TextButton.icon(
                                      onPressed: () => _addSet(routineExercise),
                                      icon: const Icon(Icons.add),
                                      label: Text(l10n.addSetButton),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                ),
              ],
            ),
      floatingActionButton: GlassFab(
        onPressed: _addExercise,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
      bottomNavigationBar: AnimatedBuilder(
        animation: manager,
        builder: (context, _) {
          final bar = _buildRestBottomBar(l10n, colorScheme, manager);
          return bar ?? const SizedBox.shrink();
        },
      ),
    );
  }

  Widget _buildSetRow(
    int setIndex,
    int rowIndex,
    RoutineExercise re,
    SetTemplate template,
    bool isCompleted,
    ColorScheme colorScheme,
    SetLog? lastPerf,
  ) {
    final setType = _setUIData[template.id!]!['setType'];
    final isLightMode = Theme.of(context).brightness == Brightness.light;
    
    final bool isColoredRow = rowIndex > 0 && rowIndex.isOdd;
    final Color rowColor;
    if (isColoredRow) {
      rowColor = isLightMode
          ? Colors.grey.withOpacity(0.08)
          : Colors.white.withOpacity(0.05);
    } else {
      rowColor = Colors.transparent;
    }

    // Der Inhalt der Zeile, der immer gleich aussieht
    final rowContent = Row(
      children: [
        Expanded(
          flex: 2,
          child: Center(
            child: Builder(
              builder: (_) {
                Color textColor;
                switch (setType) {
                  case 'warmup':
                    textColor = Colors.orange;
                    break;
                  case 'dropset':
                    textColor = Colors.blue;
                    break;
                  case 'failure':
                    textColor = Colors.red;
                    break;
                  default:
                    textColor = Colors.grey;
                }
                return GestureDetector(
                  onTap: () {
                    if (!isCompleted) _showSetTypePicker(template.id!);
                  },
                  child: Text(
                    _getSetDisplayText(setType, setIndex),
                    style: TextStyle(
                      color: textColor,
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                );
              },
            ),
          ),
        ),
        Expanded(
          flex: 3,
          child: Text(
            lastPerf != null
                ? "${lastPerf.weightKg?.toStringAsFixed(1).replaceAll('.0', '')}kg × ${lastPerf.reps}"
                : "-",
            textAlign: TextAlign.center,
            style: TextStyle(color: Colors.grey[500], fontSize: 12),
          ),
        ),
        Expanded(
          flex: 2,
          child: TextFormField(
            controller: _weightControllers[template.id!],
            textAlign: TextAlign.center,
            keyboardType:
                const TextInputType.numberWithOptions(decimal: true),
            decoration: const InputDecoration(
                border: InputBorder.none,
                isDense: true,
                fillColor: Colors.transparent),
            enabled: !isCompleted,
          ),
        ),
        const SizedBox(width: 8),
        Expanded(
          flex: 2,
          child: TextFormField(
            controller: _repsControllers[template.id!],
            textAlign: TextAlign.center,
            keyboardType: TextInputType.number,
            decoration: const InputDecoration(
                border: InputBorder.none,
                isDense: true,
                fillColor: Colors.transparent),
            enabled: !isCompleted,
          ),
        ),
        Padding(
          padding: const EdgeInsets.only(right: 8.0),
          child: SizedBox(
            width: 48,
            child: IconButton(
              icon: Icon(
                isCompleted
                    ? Icons.check_circle
                    : Icons.check_circle_outline,
                color: isCompleted ? Colors.green : Colors.grey,
              ),
              onPressed: () {
                if (isCompleted) {
                  _unlogSet(template.id!);
                } else {
                  _logSet(template.id!, re);
                }
              },
            ),
          ),
        ),
      ],
    );

    return Dismissible(
      key: ValueKey(template.id),
      direction:
          isCompleted ? DismissDirection.none : DismissDirection.endToStart,
      onDismissed: (_) => _removeSet(re, template.id!),
      background: Container(
        color: Colors.redAccent,
        alignment: Alignment.centerRight,
        padding: const EdgeInsets.symmetric(horizontal: 20),
        child: const Icon(Icons.delete, color: Colors.white),
      ),
      // HIER IST DIE ÄNDERUNG: Stack statt direktem Container
      child: Stack(
        children: [
          // Ebene 1: Hintergrundfarbe
          Positioned.fill(
            child: Container(
              color: isCompleted ? Colors.green.withOpacity(0.2) : rowColor,
            ),
          ),
          // Ebene 2: Der eigentliche Inhalt
          rowContent,
        ],
      ),
    );
  }

  Widget? _buildRestBottomBar(AppLocalizations l10n, ColorScheme colorScheme, WorkoutSessionManager manager) {
    final isRunning = manager.remainingRestSeconds > 0;
    final isDoneBanner = !isRunning && manager.showRestDone;
    if (!isRunning && !isDoneBanner) return null;

    final theme = Theme.of(context);

    if (isRunning) {
      return BottomAppBar(
        color: colorScheme.surface,
        elevation: 0,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                "${l10n.restTimerLabel}: ${manager.remainingRestSeconds}s",
                style: theme.textTheme.titleLarge?.copyWith(
                  fontSize: 22,
                  fontWeight: FontWeight.w700,
                  color: colorScheme.primary,
                ),
              ),
              ElevatedButton(
                onPressed: () {
                  manager.cancelRest();
                },
                child: Text(l10n.skipButton),
              ),
            ],
          ),
        ),
      );
    }
    return BottomAppBar(
      color: Colors.green.shade600,
      elevation: 0,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            const Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 8),
                Text(
                  "Pause vorbei!",
                  style: TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.w700,
                      fontSize: 18),
                ),
              ],
            ),
            TextButton(
              onPressed: () {
                manager.cancelRest();
              },
              child: Text(l10n.snackbar_button_ok, style: const TextStyle(color: Colors.white)),
            ),
          ],
        ),
      ),
    );
  }
}
*/
// lib/screens/live_workout_screen.dart
// VOLLSTÄNDIGER, FINALER CODE

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/models/routine_exercise.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/services/workout_session_manager.dart';
import 'package:lightweight/widgets/wger_attribution_widget.dart';
import 'package:lightweight/widgets/workout_summary_bar.dart';
import 'exercise_catalog_screen.dart';
import 'exercise_detail_screen.dart';
import 'package:provider/provider.dart';
import 'package:lightweight/screens/workout_summary_screen.dart';
import 'package:lightweight/widgets/workout_card.dart';

class LiveWorkoutScreen extends StatefulWidget {
  final Routine? routine;
  final WorkoutLog workoutLog;

  const LiveWorkoutScreen({super.key, this.routine, required this.workoutLog});

  @override
  State<LiveWorkoutScreen> createState() => _LiveWorkoutScreenState();
}

class _LiveWorkoutScreenState extends State<LiveWorkoutScreen> {
  final Map<int, TextEditingController> _weightControllers = {};
  final Map<int, TextEditingController> _repsControllers = {};
  final Map<String, List<SetLog>> _lastPerformances = {};
  bool _isLoading = true;

  // Definieren wir den Listener hier, damit er im ganzen State bekannt ist
  late final VoidCallback _onManagerUpdateCallback;

  @override
  void initState() {
    super.initState();
    // Der Listener wird jetzt einer Variable zugewiesen
    _onManagerUpdateCallback = () {
      if (mounted) {
        final manager =
            Provider.of<WorkoutSessionManager>(context, listen: false);
        _syncControllersWithManager(manager);
        // setState() wird hier benötigt, um UI-Änderungen zu triggern,
        // die nicht von Controllern abgedeckt sind (z.B. ein neu hinzugefügter Satz)
        setState(() {});
      }
    };

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _initializeScreen();
      // Der Listener wird registriert
      Provider.of<WorkoutSessionManager>(context, listen: false)
          .addListener(_onManagerUpdateCallback);
    });
  }

// NEUE, KORREKTE dispose-Methode
  @override
  void dispose() {
    // Wir greifen direkt auf die Singleton-Instanz zu, ohne den "context" zu nutzen.
    WorkoutSessionManager().removeListener(_onManagerUpdateCallback);
    _clearControllers();
    super.dispose();
  }

  Future<void> _initializeScreen() async {
    final manager = Provider.of<WorkoutSessionManager>(context, listen: false);
    List<RoutineExercise> exercisesToInit = [];

    if (!manager.isActive) {
      exercisesToInit = widget.routine?.exercises ?? [];
      manager.startWorkout(widget.workoutLog, exercisesToInit);
    } else {
      exercisesToInit = manager.exercises;
    }

    // Lade die "Last Time"-Daten für alle Übungen, die bereits im Workout sind
    for (var re in exercisesToInit) {
      final lastSets = await WorkoutDatabaseHelper.instance
          .getLastSetsForExercise(re.exercise.nameEn);
      if (mounted) {
        _lastPerformances[re.exercise.nameEn] = lastSets;
      }
    }

    _syncControllersWithManager(manager);
    if (mounted) {
      //manager.addListener(_onManagerUpdate);
      setState(() => _isLoading = false);
    }
  }

  void _syncControllersWithManager(WorkoutSessionManager manager) {
    manager.setLogs.forEach((templateId, setLog) {
      if (!_weightControllers.containsKey(templateId)) {
        _weightControllers[templateId] = TextEditingController(
            text:
                setLog.weightKg?.toStringAsFixed(1).replaceAll('.0', '') ?? '');
        _repsControllers[templateId] =
            TextEditingController(text: setLog.reps?.toString() ?? '');

        _weightControllers[templateId]!.addListener(() {
          final currentManagerValue = manager.setLogs[templateId]?.weightKg;
          final controllerText = _weightControllers[templateId]!.text;
          final controllerValue =
              double.tryParse(controllerText.replaceAll(',', '.'));

          // Nur updaten, wenn sich der WERT tatsächlich geändert hat, oder das Feld leer ist.
          if (controllerValue != currentManagerValue) {
            // Wenn das Feld leer ist, senden wir 0.0, um den Wert im Manager zurückzusetzen.
            manager.updateSet(templateId, weight: controllerValue ?? 0.0);
          }
        });

        _repsControllers[templateId]!.addListener(() {
          final currentManagerValue = manager.setLogs[templateId]?.reps;
          final controllerText = _repsControllers[templateId]!.text;
          final controllerValue = int.tryParse(controllerText);

          if (controllerValue != currentManagerValue) {
            manager.updateSet(templateId, reps: controllerValue ?? 0);
          }
        });
      } else {
        // Hier ist die entscheidende Änderung:
        // Setze den Controller-Text nur, wenn das Feld NICHT den Fokus hat.
        // Das verhindert, dass der Wert beim Tippen zurückspringt.
        final weightText = setLog.weightKg == 0
            ? ''
            : setLog.weightKg?.toStringAsFixed(1).replaceAll('.0', '') ?? '';
        final repsText = setLog.reps == 0 ? '' : setLog.reps?.toString() ?? '';

        if (_weightControllers[templateId]!.text != weightText) {
          _weightControllers[templateId]!.text = weightText;
        }
        if (_repsControllers[templateId]!.text != repsText) {
          _repsControllers[templateId]!.text = repsText;
        }
      }
    });

    final toRemove = _weightControllers.keys
        .where((id) => !manager.setLogs.containsKey(id))
        .toList();
    for (final id in toRemove) {
      _weightControllers.remove(id)?.dispose();
      _repsControllers.remove(id)?.dispose();
    }
  }

  void _clearControllers() {
    for (var c in _weightControllers.values) {
      c.dispose();
    }
    for (var c in _repsControllers.values) {
      c.dispose();
    }
    _weightControllers.clear();
    _repsControllers.clear();
  }

  Future<void> _finishWorkout() async {
    final l10n = AppLocalizations.of(context)!;
    final manager = Provider.of<WorkoutSessionManager>(context, listen: false);
    final bool? confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.finishWorkoutButton),
        content: Text(l10n.dialogFinishWorkoutBody),
        actions: [
          TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: Text(l10n.cancel)),
          FilledButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: Text(l10n.finishWorkoutButton)),
        ],
      ),
    );

    if (confirmed == true && mounted) {
      final logId = manager.workoutLog?.id;
      await manager.finishWorkout();
      if (mounted && logId != null) {
        Navigator.of(context).pushReplacement(MaterialPageRoute(
            builder: (context) => WorkoutSummaryScreen(logId: logId)));
      }
    }
  }

  void _onReorder(int oldIndex, int newIndex) {
    Provider.of<WorkoutSessionManager>(context, listen: false)
        .reorderExercise(oldIndex, newIndex);
  }

  void _editPauseTime(RoutineExercise routineExercise) async {
    final l10n = AppLocalizations.of(context)!;
    final manager = Provider.of<WorkoutSessionManager>(context, listen: false);
    final currentPause = manager.pauseTimes[routineExercise.id!];

    final controller =
        TextEditingController(text: currentPause?.toString() ?? '');
    final result = await showDialog<int?>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.editPauseTimeTitle),
        content: TextField(
            controller: controller,
            keyboardType: TextInputType.number,
            decoration: InputDecoration(labelText: l10n.pauseInSeconds)),
        actions: [
          TextButton(
              onPressed: () => Navigator.of(ctx).pop(),
              child: Text(l10n.cancel)),
          FilledButton(
              onPressed: () =>
                  Navigator.of(ctx).pop(int.tryParse(controller.text)),
              child: Text(l10n.save)),
        ],
      ),
    );
    if (result != null) {
      manager.updatePauseTime(routineExercise.id!, result);
    }
  }

  void _removeExercise(RoutineExercise exerciseToRemove) {
    Provider.of<WorkoutSessionManager>(context, listen: false)
        .removeExercise(exerciseToRemove.id!);
  }

  void _addExercise() async {
    final manager = Provider.of<WorkoutSessionManager>(context, listen: false);
    final selectedExercise = await Navigator.of(context).push<Exercise>(
      MaterialPageRoute(
          builder: (context) =>
              const ExerciseCatalogScreen(isSelectionMode: true)),
    );

    if (selectedExercise != null) {
      // Lade "Last Time"-Daten für die NEUE Übung
      final lastSets = await WorkoutDatabaseHelper.instance
          .getLastSetsForExercise(selectedExercise.nameEn);
      if (mounted) {
        setState(() {
          _lastPerformances[selectedExercise.nameEn] = lastSets;
        });
      }
      await manager.addExercise(selectedExercise);
    }
  }

  void _addSet(RoutineExercise re) {
    Provider.of<WorkoutSessionManager>(context, listen: false)
        .addSetToExercise(re.id!);
  }

  void _removeSet(int templateId) {
    Provider.of<WorkoutSessionManager>(context, listen: false)
        .removeSet(templateId);
  }

  void _changeSetType(int templateId, String newType) {
    Provider.of<WorkoutSessionManager>(context, listen: false)
        .updateSet(templateId, setType: newType);
    Navigator.pop(context);
  }

  void _showSetTypePicker(int templateId) {
    showModalBottomSheet(
      context: context,
      builder: (context) {
        return Wrap(
          children: <Widget>[
            ListTile(
                title: const Text('Normal'),
                onTap: () => _changeSetType(templateId, 'normal')),
            ListTile(
                title: const Text('Warmup'),
                onTap: () => _changeSetType(templateId, 'warmup')),
            ListTile(
                title: const Text('Failure'),
                onTap: () => _changeSetType(templateId, 'failure')),
            ListTile(
                title: const Text('Dropset'),
                onTap: () => _changeSetType(templateId, 'dropset')),
          ],
        );
      },
    );
  }

  // NEUE HELFER-METHODE für den leeren Zustand
  Widget _buildEmptyState(AppLocalizations l10n) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.add_circle_outline,
                size: 80, color: Colors.grey.shade400),
            const SizedBox(height: DesignConstants.spacingL),
            Text(
              l10n.emptyStateAddFirstExercise,
              style: Theme.of(context).textTheme.headlineSmall,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: DesignConstants.spacingS),
            Text(
              "Füge eine Übung hinzu, um mit dem Protokollieren zu beginnen.", // TODO: l10n
              textAlign: TextAlign.center,
              style: Theme.of(context)
                  .textTheme
                  .bodyLarge
                  ?.copyWith(color: Colors.grey.shade600),
            ),
            const SizedBox(height: DesignConstants.spacingXL),
            ElevatedButton.icon(
              onPressed: _addExercise,
              icon: const Icon(Icons.add),
              label: Text(l10n.fabAddExercise),
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final textTheme = Theme.of(context).textTheme;
    final colorScheme = Theme.of(context).colorScheme;
    final manager = Provider.of<WorkoutSessionManager>(context);
    final mgr = manager;

// geplante/angelegte Sets = Anzahl aller SetLogs (egal ob erledigt)
    final int planned = mgr.setLogs.length;

// erledigte Sets = isCompleted == true
    final int completed =
        mgr.setLogs.values.where((s) => s.isCompleted == true).length;

    final double progress = planned == 0 ? 0.0 : completed / planned;

    // NEU: Synchronisiere die Controller bei jedem Build
    // Das ersetzt den alten Listener und ist sicher.
    if (!_isLoading) {
      _syncControllersWithManager(manager);
    }

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          manager.workoutLog?.routineName ?? l10n.freeWorkoutTitle,
          style: Theme.of(context)
              .textTheme
              .titleLarge
              ?.copyWith(fontWeight: FontWeight.w900),
        ),
        actions: [
          TextButton(
            onPressed: _finishWorkout,
            child: Text(
              l10n.finishWorkoutButton,
              style: TextStyle(
                  color: Theme.of(context).colorScheme.primary,
                  fontWeight: FontWeight.bold),
            ),
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : Column(
              children: [
                WorkoutSummaryBar(
                  duration: mgr.elapsedDuration,
                  volume: mgr.totalVolume,
                  sets:
                      planned, // oder mgr.totalSets, falls das *geplante* Sets sind
                  progress: progress, // LIVE: echter Fortschritt
                ),
                Divider(
                    height: 1,
                    thickness: 1,
                    color: Theme.of(context)
                        .colorScheme
                        .onSurfaceVariant
                        .withOpacity(0.1)),
                Expanded(
                  child: manager.exercises.isEmpty
                      ? _buildEmptyState(l10n)
                      : ReorderableListView.builder(
                          padding: EdgeInsets.zero,
                          onReorder: _onReorder,
                          itemCount: manager.exercises.length,
                          itemBuilder: (context, index) {
                            final routineExercise = manager.exercises[index];
                            return WorkoutCard(
                              key: ValueKey(routineExercise.id),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  ListTile(
                                    contentPadding: const EdgeInsets.symmetric(
                                        horizontal: 16.0, vertical: 8.0),
                                    leading: ReorderableDragStartListener(
                                      index: index,
                                      child: const Icon(Icons.drag_handle),
                                    ),
                                    title: InkWell(
                                      onTap: () => Navigator.of(context).push(
                                          MaterialPageRoute(
                                              builder: (context) =>
                                                  ExerciseDetailScreen(
                                                      exercise: routineExercise
                                                          .exercise))),
                                      child: Padding(
                                        padding: const EdgeInsets.symmetric(
                                            vertical: 4.0),
                                        child: Text(
                                          routineExercise.exercise
                                              .getLocalizedName(context),
                                          style: textTheme.titleLarge?.copyWith(
                                              fontWeight: FontWeight.bold),
                                        ),
                                      ),
                                    ),
// NEUER, KORRIGIERTER trailing-Block
                                    trailing: Row(
                                      mainAxisSize: MainAxisSize.min,
                                      children: [
                                        // Zeigt die eingestellte Pausenzeit an
                                        if (manager.pauseTimes[
                                                    routineExercise.id!] !=
                                                null &&
                                            manager.pauseTimes[
                                                    routineExercise.id!]! >
                                                0)
                                          Padding(
                                            padding: const EdgeInsets.only(
                                                right: 4.0),
                                            child: Text(
                                              "${manager.pauseTimes[routineExercise.id!]}s",
                                              style: textTheme.bodyMedium
                                                  ?.copyWith(
                                                      color:
                                                          colorScheme.primary,
                                                      fontWeight:
                                                          FontWeight.bold),
                                            ),
                                          ),
                                        IconButton(
                                          icon:
                                              const Icon(Icons.timer_outlined),
                                          tooltip: l10n.editPauseTime,
                                          onPressed: () =>
                                              _editPauseTime(routineExercise),
                                        ),
                                        IconButton(
                                          icon: const Icon(Icons.delete_outline,
                                              color: Colors.redAccent),
                                          tooltip: l10n.removeExercise,
                                          onPressed: () =>
                                              _removeExercise(routineExercise),
                                        ),
                                      ],
                                    ),
                                  ),
                                  Padding(
                                    padding: const EdgeInsets.symmetric(
                                        horizontal: 0.0),
                                    child: Column(
                                      crossAxisAlignment:
                                          CrossAxisAlignment.start,
                                      children: [
                                        Row(
                                          crossAxisAlignment:
                                              CrossAxisAlignment.center,
                                          children: [
                                            Expanded(
                                                flex: 2,
                                                child: Center(
                                                    child: Text(l10n.setLabel,
                                                        textAlign:
                                                            TextAlign.center,
                                                        style: TextStyle(
                                                          color:
                                                              Colors.grey[600],
                                                          fontSize: 12,
                                                          fontWeight:
                                                              FontWeight.bold,
                                                        )))),
                                            Expanded(
                                                flex: 3,
                                                child: Center(
                                                    child: Text(
                                                        l10n.lastTimeLabel,
                                                        textAlign:
                                                            TextAlign.center,
                                                        style: TextStyle(
                                                          color:
                                                              Colors.grey[600],
                                                          fontSize: 12,
                                                          fontWeight:
                                                              FontWeight.bold,
                                                        )))),
                                            Expanded(
                                                flex: 2,
                                                child: Center(
                                                    child: Text(l10n.kgLabel,
                                                        textAlign:
                                                            TextAlign.center,
                                                        style: TextStyle(
                                                          color:
                                                              Colors.grey[600],
                                                          fontSize: 12,
                                                          fontWeight:
                                                              FontWeight.bold,
                                                        )))),
                                            Expanded(
                                                flex: 2,
                                                child: Center(
                                                    child: Text(l10n.repsLabel,
                                                        textAlign:
                                                            TextAlign.center,
                                                        style: TextStyle(
                                                          color:
                                                              Colors.grey[600],
                                                          fontSize: 12,
                                                          fontWeight:
                                                              FontWeight.bold,
                                                        )))),
                                            const SizedBox(width: 48),
                                          ],
                                        ),
                                        ...routineExercise.setTemplates
                                            .asMap()
                                            .entries
                                            .map((setEntry) {
                                          final templateId = setEntry.value.id!;
                                          final setLog =
                                              manager.setLogs[templateId];
                                          if (setLog == null) {
                                            return const SizedBox.shrink();
                                          }
                                          int workingSetIndex = 0;
                                          for (int i = 0;
                                              i <= setEntry.key;
                                              i++) {
                                            final currentTemplateId =
                                                routineExercise
                                                    .setTemplates[i].id!;
                                            if (manager
                                                    .setLogs[currentTemplateId]
                                                    ?.setType !=
                                                'warmup') {
                                              workingSetIndex++;
                                            }
                                          }
                                          return _buildSetRow(
                                            workingSetIndex,
                                            setEntry.key,
                                            templateId,
                                            setLog,
                                            _lastPerformances[routineExercise
                                                    .exercise.nameEn] ??
                                                [], // Hier die Liste übergeben
                                          );
                                        }),
                                        Padding(
                                          padding: const EdgeInsets.symmetric(
                                              horizontal: 16.0),
                                          child: TextButton.icon(
                                            onPressed: () =>
                                                _addSet(routineExercise),
                                            icon: const Icon(Icons.add),
                                            label: Text(l10n.addSetButton),
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                                ],
                              ),
                            );
                          },
                        ),
                ),
              ],
            ),
      // KORRIGIERT: label hinzugefügt
      floatingActionButton: GlassFab(
        label: l10n.fabAddExercise,
        onPressed: _addExercise,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
      // NEUER, KORREKTER bottomNavigationBar
      bottomNavigationBar: Column(
        mainAxisSize:
            MainAxisSize.min, // Wichtig: Nimmt nur so viel Höhe wie nötig
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          // 1. Dein bestehender AnimatedBuilder für die Rest-Timer-Bar
          AnimatedBuilder(
            animation: manager,
            builder: (context, _) {
              final bar = _buildRestBottomBar(l10n, colorScheme, manager);
              return bar ?? const SizedBox.shrink();
            },
          ),
          // 2. Das Wger-Widget direkt darunter (nur wenn kein Timer läuft)
          if (manager.remainingRestSeconds <= 0 && !manager.showRestDone)
            Padding(
              padding: const EdgeInsets.only(bottom: 8.0),
              child: WgerAttributionWidget(
                textStyle:
                    textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
              ),
            ),
        ],
      ),
    );
  }

// Ersetze diese Methode im _LiveWorkoutScreenState

  Widget _buildSetRow(
    int setIndex,
    int rowIndex,
    int templateId,
    SetLog setLog,
    List<SetLog> lastPerfSets, // Nimmt jetzt eine Liste entgegen
  ) {
    final manager = Provider.of<WorkoutSessionManager>(context, listen: false);
    final isCompleted = setLog.isCompleted ?? false;
    final isLightMode = Theme.of(context).brightness == Brightness.light;
    final bool isColoredRow = rowIndex > 0 && rowIndex.isOdd;
    final Color rowColor = isColoredRow
        ? (isLightMode
            ? Colors.grey.withOpacity(0.1)
            : Colors.white.withOpacity(0.1))
        : Colors.transparent;

    // Finde den korrespondierenden Satz vom letzten Mal
    SetLog? lastPerf;
    if (rowIndex < lastPerfSets.length) {
      lastPerf = lastPerfSets[rowIndex];
    }

    final rowContent = Row(
      children: [
        Expanded(
          flex: 2,
          child: Center(
            child: GestureDetector(
              onTap: () => isCompleted ? null : _showSetTypePicker(templateId),
              child: Text(
                _getSetDisplayText(setLog.setType, setIndex),
                style: TextStyle(
                    color: _getSetTypeColor(setLog.setType),
                    fontSize: 20,
                    fontWeight: FontWeight.bold),
              ),
            ),
          ),
        ),
        Expanded(
          flex: 3,
          child: Text(
            lastPerf != null
                ? "${lastPerf.weightKg?.toStringAsFixed(1).replaceAll('.0', '')}kg × ${lastPerf.reps}"
                : "-",
            textAlign: TextAlign.center,
            style: TextStyle(color: Colors.grey[500], fontSize: 12),
          ),
        ),
        Expanded(
          flex: 2,
          child: TextFormField(
            controller: _weightControllers[templateId],
            textAlign: TextAlign.center,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            decoration: const InputDecoration(
                border: InputBorder.none,
                isDense: true,
                fillColor: Colors.transparent),
            enabled: !isCompleted,
          ),
        ),
        const SizedBox(width: 8),
        Expanded(
          flex: 2,
          child: TextFormField(
            controller: _repsControllers[templateId],
            textAlign: TextAlign.center,
            keyboardType: TextInputType.number,
            decoration: const InputDecoration(
                border: InputBorder.none,
                isDense: true,
                fillColor: Colors.transparent),
            enabled: !isCompleted,
          ),
        ),
        Padding(
          padding: const EdgeInsets.only(right: 8.0),
          child: SizedBox(
            width: 48,
            child: IconButton(
              icon: Icon(
                  isCompleted ? Icons.check_circle : Icons.check_circle_outline,
                  color: isCompleted ? Colors.green : Colors.grey),
              onPressed: () {
                manager.updateSet(templateId, isCompleted: !isCompleted);
              },
            ),
          ),
        ),
      ],
    );

    return Dismissible(
      key: ValueKey('set_$templateId'),
      direction:
          isCompleted ? DismissDirection.none : DismissDirection.endToStart,
      onDismissed: (_) => _removeSet(templateId),
      background: Container(
        color: Colors.redAccent,
        alignment: Alignment.centerRight,
        padding: const EdgeInsets.symmetric(horizontal: 20),
        child: const Icon(Icons.delete, color: Colors.white),
      ),
      child: Stack(
        children: [
          Positioned.fill(
              child: Container(
                  color:
                      isCompleted ? Colors.green.withOpacity(0.2) : rowColor)),
          rowContent,
        ],
      ),
    );
  }

  Widget? _buildRestBottomBar(AppLocalizations l10n, ColorScheme colorScheme,
      WorkoutSessionManager manager) {
    final isRunning = manager.remainingRestSeconds > 0;
    final isDoneBanner = !isRunning && manager.showRestDone;
    if (!isRunning && !isDoneBanner) return null;
    final theme = Theme.of(context);
    if (isRunning) {
      return BottomAppBar(
        color: colorScheme.surface,
        elevation: 0,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text("${l10n.restTimerLabel}: ${manager.remainingRestSeconds}s",
                  style: theme.textTheme.titleLarge?.copyWith(
                      fontSize: 22,
                      fontWeight: FontWeight.w700,
                      color: colorScheme.primary)),
              ElevatedButton(
                  onPressed: () {
                    manager.cancelRest();
                  },
                  child: Text(l10n.skipButton)),
            ],
          ),
        ),
      );
    }
    return BottomAppBar(
      color: Colors.green.shade600,
      elevation: 0,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            const Row(children: [
              Icon(Icons.check_circle, color: Colors.white),
              SizedBox(width: 8),
              Text("Pause vorbei!",
                  style: TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.w700,
                      fontSize: 18))
            ]),
            TextButton(
                onPressed: () {
                  manager.cancelRest();
                },
                child: Text(l10n.snackbar_button_ok,
                    style: const TextStyle(color: Colors.white))),
          ],
        ),
      ),
    );
  }

  String _getSetDisplayText(String setType, int setIndex) {
    switch (setType) {
      case 'warmup':
        return 'W';
      case 'failure':
        return 'F';
      case 'dropset':
        return 'D';
      default:
        return '$setIndex';
    }
  }

  Color _getSetTypeColor(String setType) {
    switch (setType) {
      case 'warmup':
        return Colors.orange;
      case 'dropset':
        return Colors.blue;
      case 'failure':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/manage_supplements_screen.dart =====

// lib/screens/manage_supplements_screen.dart
import 'package:flutter/material.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/screens/create_supplement_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/util/supplement_l10n.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';

class ManageSupplementsScreen extends StatefulWidget {
  const ManageSupplementsScreen({super.key});

  @override
  State<ManageSupplementsScreen> createState() =>
      _ManageSupplementsScreenState();
}

class _ManageSupplementsScreenState extends State<ManageSupplementsScreen> {
  bool _isLoading = true;
  List<Supplement> _supplements = const [];

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    setState(() => _isLoading = true);
    final list = await DatabaseHelper.instance.getAllSupplements();
    if (!mounted) return;
    setState(() {
      _supplements = list;
      _isLoading = false;
    });
  }

  Future<void> _navigateToEdit(Supplement s) async {
    final changed = await Navigator.of(context).push<bool>(
      MaterialPageRoute(
          builder: (_) => CreateSupplementScreen(supplementToEdit: s)),
    );
    if (changed == true) _load();
  }

  Future<void> _delete(Supplement s) async {
    final l10n = AppLocalizations.of(context)!;
    try {
      final ok = await showDialog<bool>(
            context: context,
            builder: (_) => AlertDialog(
              title: Text(l10n.deleteConfirmTitle),
              content: Text(
                l10n.deleteConfirmContent, // du kannst hier einen spezifischen Text ergänzen
              ),
              actions: [
                TextButton(
                    onPressed: () => Navigator.pop(context, false),
                    child: Text(l10n.cancel)),
                TextButton(
                    onPressed: () => Navigator.pop(context, true),
                    child: Text(l10n.delete)),
              ],
            ),
          ) ??
          false;
      if (!ok) return;

      await DatabaseHelper.instance.deleteSupplement(s.id!);
      if (!mounted) return;
      _load();
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(l10n.deleted)));
    } catch (e) {
      // builtin blockiert -> freundlich erklären
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
            content: Text(
                l10n.operationNotAllowed /* ergänze passenden l10n-Text */)),
      );
    }
  }

  Widget _tile(Supplement s, AppLocalizations l10n) {
    final isBuiltin = s.isBuiltin || s.code == 'caffeine';
    final title = localizeSupplementName(s, l10n);

    final content = SummaryCard(
      child: ListTile(
        leading: const Icon(Icons.set_meal_outlined),
        title: Text(title),
        subtitle: (s.dailyGoal != null || s.dailyLimit != null)
            ? Text([
                if (s.dailyGoal != null)
                  '${l10n.dailyGoalLabel}: ${s.dailyGoal} ${s.unit}',
                if (s.dailyLimit != null)
                  '${l10n.dailyLimitLabel}: ${s.dailyLimit} ${s.unit}',
              ].join('  •  '))
            : null,
        trailing: isBuiltin ? null : const Icon(Icons.chevron_right),
        onTap: () => _navigateToEdit(s),
      ),
    );

    if (isBuiltin) return content;

    return Dismissible(
      key: Key('supp_${s.id}'),
      direction: DismissDirection.horizontal,
      background: const SwipeActionBackground(
        color: Colors.blueAccent,
        icon: Icons.edit,
        alignment: Alignment.centerLeft,
      ),
      secondaryBackground: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      confirmDismiss: (direction) async {
        if (direction == DismissDirection.startToEnd) {
          _navigateToEdit(s);
          return false;
        } else {
          _delete(s);
          return false;
        }
      },
      child: content,
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    return Scaffold(
      appBar: AppBar(
        title: Text(
          l10n.manageSupplementsTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : RefreshIndicator(
              onRefresh: _load,
              child: ListView(
                padding: DesignConstants.cardPadding,
                children: [
                  if (_supplements.isEmpty)
                    Padding(
                      padding: const EdgeInsets.symmetric(vertical: 16.0),
                      child: Text(l10n.emptySupplements,
                          textAlign: TextAlign.center),
                    )
                  else
                    ..._supplements.map((s) => _tile(s, l10n)),
                ],
              ),
            ),
      floatingActionButton: GlassFab(
        label: l10n.createSupplementTitle,
        onPressed: () async {
          final created = await Navigator.of(context).push<bool>(
            MaterialPageRoute(
                builder: (context) => const CreateSupplementScreen()),
          );
          if (created == true) _load();
        },
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/meal_screen.dart =====

import 'package:flutter/material.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';
import 'package:lightweight/screens/food_detail_screen.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';

class MealScreen extends StatefulWidget {
  final Map<String, dynamic> meal; // erwartet: {id, name, notes}
  final bool startInEdit;

  const MealScreen({
    super.key,
    required this.meal,
    this.startInEdit = false,
  });

  @override
  State<MealScreen> createState() => _MealScreenState();
}

class _MealScreenState extends State<MealScreen> {
  late TextEditingController _nameCtrl;
  late TextEditingController _notesCtrl;
  bool _editMode = false;
  bool _saving = false;

  List<Map<String, dynamic>> _items = [];
  bool _loadingItems = true;

  // Totals (werden bei jedem Build aus _items berechnet)
  int _totalKcal = 0;
  double _totalC = 0, _totalF = 0, _totalP = 0;

  @override
  void initState() {
    super.initState();
    _editMode = widget.startInEdit;
    _nameCtrl =
        TextEditingController(text: widget.meal['name'] as String? ?? '');
    _notesCtrl =
        TextEditingController(text: widget.meal['notes'] as String? ?? '');
    _loadItems();
  }

  @override
  void dispose() {
    _nameCtrl.dispose();
    _notesCtrl.dispose();
    super.dispose();
  }

  Future<void> _loadItems() async {
    setState(() => _loadingItems = true);
    final id = widget.meal['id'] as int;
    final rows = await DatabaseHelper.instance.getMealItems(id);
    _items = List<Map<String, dynamic>>.from(rows);
    await _recomputeTotals(); // initiale Totals
    if (mounted) setState(() => _loadingItems = false);
  }

  /// Rechnet die Summen für kcal / C / F / P einmal durch.
  Future<void> _recomputeTotals() async {
    int kcal = 0;
    double c = 0, f = 0, p = 0;

    for (final it in _items) {
      final bc = it['barcode'] as String;
      final qty = (it['quantity_in_grams'] as num?)?.toDouble() ?? 0.0;
      final fi = await ProductDatabaseHelper.instance.getProductByBarcode(bc);
      if (fi == null) continue;

      final factor = qty / 100.0;
      final itemKcal = (fi.calories ?? 0) * factor;
      final itemC = (fi.carbs ?? 0) * factor;
      final itemF = (fi.fat ?? 0) * factor;
      final itemP = (fi.protein ?? 0) * factor;

      kcal += itemKcal.round();
      c += itemC;
      f += itemF;
      p += itemP;
    }

    _totalKcal = kcal;
    _totalC = c;
    _totalF = f;
    _totalP = p;
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    final canSave =
        _nameCtrl.text.trim().isNotEmpty && _items.isNotEmpty && !_saving;

    // Floating Action Button je Modus
    Widget? fab;
    if (_editMode) {
      fab = GlassFab(
        label: l10n.mealAddIngredient, // „Zutat hinzufügen“
        onPressed: _addIngredientFlow,
      );
    } else {
      if (_items.isNotEmpty) {
        fab = GlassFab(
          label: l10n.mealsAddToDiary, // „Zum Tagebuch hinzufügen“
          onPressed: _addMealToDiaryFlow,
        );
      } else {
        fab = null;
      }
    }

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true,
        title: Text(
          _editMode
              ? l10n.mealsEdit // (L10n: du kannst das zu „Bearbeiten“ ändern)
              : (_nameCtrl.text.isNotEmpty
                  ? _nameCtrl.text
                  : l10n.mealsViewTitle),
          style:
              theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w900),
        ),
        actions: [
          if (_editMode)
            TextButton(
              onPressed: canSave ? _save : null,
              child: _saving
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : Text(
                      l10n.save,
                      style: TextStyle(
                        color: canSave
                            ? theme.colorScheme.primary
                            : theme.disabledColor,
                        fontWeight: FontWeight.w700,
                      ),
                    ),
            )
          else
            TextButton(
              onPressed: () => setState(() => _editMode = true),
              child: Text(
                l10n.mealsEdit,
                style: TextStyle(
                  color: theme.colorScheme.primary,
                  fontWeight: FontWeight.w700,
                ),
              ),
            ),
        ],
      ),
      floatingActionButton: fab,
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
      body: _loadingItems
          ? const Center(child: CircularProgressIndicator())
          : ListView(
              padding: const EdgeInsets.fromLTRB(16, 12, 16, 96),
              children: [
                // NAME & NOTIZEN
                SummaryCard(
                  child: Padding(
                    padding: const EdgeInsets.all(12),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        _editMode
                            ? TextField(
                                controller: _nameCtrl,
                                textInputAction: TextInputAction.done,
                                decoration: InputDecoration(
                                    labelText: l10n.mealNameLabel),
                                onChanged: (_) => setState(() {}),
                              )
                            : Text(
                                _nameCtrl.text.isNotEmpty
                                    ? _nameCtrl.text
                                    : l10n.unknown,
                                style: theme.textTheme.titleMedium
                                    ?.copyWith(fontWeight: FontWeight.bold),
                              ),
                        const SizedBox(height: 8),
                        _editMode
                            ? TextField(
                                controller: _notesCtrl,
                                maxLines: 3,
                                decoration: InputDecoration(
                                    labelText: l10n.mealNotesLabel),
                              )
                            : Text(
                                _notesCtrl.text.isNotEmpty
                                    ? _notesCtrl.text
                                    : l10n.noNotes,
                                style: theme.textTheme.bodyMedium
                                    ?.copyWith(color: Colors.grey.shade600),
                              ),
                      ],
                    ),
                  ),
                ),

                const SizedBox(height: 18),

                // === NÄHRWERTE (Gesamtsumme) ===
                _buildSectionTitle(context, l10n.nutritionSectionLabel),
                SummaryCard(
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                        horizontal: 12, vertical: 14),
                    child: FutureBuilder<void>(
                      future: _recomputeTotals(),
                      builder: (_, __) {
                        return Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              _items.isEmpty ? '– kcal' : '$_totalKcal kcal',
                              style: theme.textTheme.headlineSmall?.copyWith(
                                fontWeight: FontWeight.w800,
                              ),
                            ),
                            const SizedBox(height: 6),
                            Wrap(
                              spacing: 16,
                              runSpacing: 6,
                              children: [
                                _MacroChip(
                                    label: 'C',
                                    value: _items.isEmpty
                                        ? '–'
                                        : _format1(_totalC),
                                    unit: 'g'),
                                _MacroChip(
                                    label: 'F',
                                    value: _items.isEmpty
                                        ? '–'
                                        : _format1(_totalF),
                                    unit: 'g'),
                                _MacroChip(
                                    label: 'P',
                                    value: _items.isEmpty
                                        ? '–'
                                        : _format1(_totalP),
                                    unit: 'g'),
                              ],
                            ),
                          ],
                        );
                      },
                    ),
                  ),
                ),

                const SizedBox(height: 18),

                // === ZUTATEN ===
                _buildSectionTitle(context, l10n.ingredientsCapsLock),

                if (_items.isEmpty)
                  Padding(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    child:
                        Text(l10n.emptyCategory, textAlign: TextAlign.center),
                  )
                else
                  Column(
                    children: List.generate(_items.length, (i) {
                      final it = _items[i];
                      return _IngredientCard(
                        key: ValueKey('ing_$i'),
                        item: it,
                        editMode: _editMode,
                        showPerIngredientMacros: !_editMode,
                        onQtyChanged: (val) async {
                          _items[i]['quantity_in_grams'] = val;
                          await _recomputeTotals();
                          if (mounted) setState(() {});
                        },
                        onDelete: () async {
                          final ok = await showDialog<bool>(
                                context: context,
                                builder: (ctx) => AlertDialog(
                                  title: Text(l10n.deleteConfirmTitle),
                                  content: Text(l10n.deleteConfirmContent),
                                  actions: [
                                    TextButton(
                                        onPressed: () =>
                                            Navigator.of(ctx).pop(false),
                                        child: Text(l10n.cancel)),
                                    TextButton(
                                        onPressed: () =>
                                            Navigator.of(ctx).pop(true),
                                        child: Text(l10n.delete)),
                                  ],
                                ),
                              ) ??
                              false;
                          if (ok) {
                            setState(() => _items.removeAt(i));
                            await _recomputeTotals();
                            if (mounted) setState(() {});
                          }
                        },
                      );
                    }),
                  ),
              ],
            ),
    );
  }

  String _format1(double v) => v.toStringAsFixed(1);

  Future<void> _save() async {
    if (_saving) return;
    final name = _nameCtrl.text.trim();
    if (name.isEmpty || _items.isEmpty) return;

    setState(() => _saving = true);
    try {
      final mealId = widget.meal['id'] as int;
      await DatabaseHelper.instance.updateMeal(
        mealId,
        name: name,
        notes: _notesCtrl.text.trim(),
      );
      await DatabaseHelper.instance.clearMealItems(mealId);
      for (final it in _items) {
        final grams = (it['quantity_in_grams'] as int?) ?? 0;
        await DatabaseHelper.instance.addMealItem(
          mealId,
          barcode: it['barcode'] as String,
          grams: grams,
        );
      }
      if (mounted) {
        setState(() => _editMode = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(AppLocalizations.of(context)!.mealSaved)),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('${AppLocalizations.of(context)!.error}: $e')),
        );
      }
    } finally {
      if (mounted) setState(() => _saving = false);
    }
  }

  /// Food auswählen & Menge setzen
  Future<void> _addIngredientFlow() async {
    final l10n = AppLocalizations.of(context)!;
    final searchCtrl = TextEditingController();
    final qtyCtrl = TextEditingController(text: '100');

    final picked = await showDialog<(String, int)?>(
      context: context,
      builder: (ctx) {
        List<FoodItem> results = [];
        bool loading = false;

        return StatefulBuilder(
          builder: (context, setState) {
            Future<void> runSearch(String q) async {
              if (q.trim().isEmpty) {
                setState(() {
                  results = [];
                });
                return;
              }
              setState(() => loading = true);
              results = await ProductDatabaseHelper.instance.searchProducts(q.trim());
              setState(() => loading = false);
            }

            return AlertDialog(
              title: Text(l10n.mealAddIngredient),
              content: SizedBox(
                width: 500,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    TextField(
                      controller: searchCtrl,
                      decoration: InputDecoration(
                        hintText: l10n.searchHintText,
                        prefixIcon: const Icon(Icons.search),
                      ),
                      onChanged: runSearch,
                    ),
                    const SizedBox(height: 8),
                    if (loading) const LinearProgressIndicator(minHeight: 2),
                    Flexible(
                      child: results.isEmpty
                          ? Padding(
                              padding: const EdgeInsets.symmetric(vertical: 12),
                              child: Text(l10n.searchInitialHint),
                            )
                          : ListView.builder(
                              shrinkWrap: true,
                              itemCount: results.length,
                              itemBuilder: (_, i) {
                                final fi = results[i];
                                return ListTile(
                                  dense: true,
                                  title: Text(fi.name),
                                  subtitle: Text(fi.brand.isNotEmpty
                                      ? fi.brand
                                      : l10n.noBrand),
                                  trailing: IconButton(
                                    icon: const Icon(Icons.add),
                                    onPressed: () async {
                                      final grams = await showDialog<int>(
                                        context: context,
                                        builder: (_) => AlertDialog(
                                          title:
                                              Text(l10n.mealIngredientAmountLabel),
                                          content: TextField(
                                            controller: qtyCtrl,
                                            keyboardType: const TextInputType
                                                .numberWithOptions(decimal: false),
                                            decoration: const InputDecoration(
                                                suffixText: 'g/ml'),
                                          ),
                                          actions: [
                                            TextButton(
                                                onPressed: () =>
                                                    Navigator.pop(context, null),
                                                child: Text(l10n.cancel)),
                                            TextButton(
                                                onPressed: () {
                                                  final val = int.tryParse(
                                                      qtyCtrl.text.trim());
                                                  Navigator.pop(context, val);
                                                },
                                                child: Text(l10n.add_button)),
                                          ],
                                        ),
                                      );
                                      if (grams != null && grams > 0) {
                                        Navigator.of(ctx).pop((fi.barcode, grams));
                                      }
                                    },
                                  ),
                                );
                              },
                            ),
                    ),
                  ],
                ),
              ),
              actions: [
                TextButton(
                    onPressed: () => Navigator.pop(ctx, null),
                    child: Text(l10n.cancel)),
              ],
            );
          },
        );
      },
    );

    if (picked != null) {
      final (barcode, grams) = picked;
      setState(() {
        _items.add({'barcode': barcode, 'quantity_in_grams': grams});
      });
      await _recomputeTotals();
      if (mounted) setState(() {});
    }
  }

  /// Aktuelle Mahlzeit als einzelne FoodEntries ins Tagebuch
  Future<void> _addMealToDiaryFlow() async {
    final l10n = AppLocalizations.of(context)!;

    // Produkte laden (Name, Liquid, Koffein)
    final Map<String, FoodItem?> products = {};
    for (final it in _items) {
      final bc = it['barcode'] as String;
      products[bc] =
          await ProductDatabaseHelper.instance.getProductByBarcode(bc);
    }

    // Editierbare Mengen
    final Map<String, TextEditingController> qtyCtrls = {
      for (final it in _items)
        (it['barcode'] as String):
            TextEditingController(text: '${it['quantity_in_grams']}')
    };

    // Meal-Typen (interne Keys müssen mit Diary übereinstimmen)
    const internalTypes = [
      'mealtypeBreakfast',
      'mealtypeLunch',
      'mealtypeDinner',
      'mealtypeSnack',
    ];
    String selectedMealType = internalTypes.first;

    final Map<String, String> mealTypeLabel = {
      'mealtypeBreakfast': l10n.mealtypeBreakfast,
      'mealtypeLunch': l10n.mealtypeLunch,
      'mealtypeDinner': l10n.mealtypeDinner,
      'mealtypeSnack': l10n.mealtypeSnack,
    };

    final ok = await showModalBottomSheet<bool>(
          context: context,
          isScrollControlled: true,
          backgroundColor: Theme.of(context).colorScheme.surface,
          shape: const RoundedRectangleBorder(
            borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
          ),
          builder: (ctx) {
            return StatefulBuilder(
              builder: (ctx, modalSetState) {
                return Padding(
                  padding: EdgeInsets.only(
                    left: 16,
                    right: 16,
                    top: 12,
                    bottom: MediaQuery.of(ctx).viewInsets.bottom + 16,
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Container(
                        width: 40,
                        height: 4,
                        decoration: BoxDecoration(
                          color: Colors.grey.shade500,
                          borderRadius: BorderRadius.circular(2),
                        ),
                      ),
                      const SizedBox(height: 12),
                      Text(
                        l10n.mealsAddToDiary,
                        style: Theme.of(ctx)
                            .textTheme
                            .titleLarge
                            ?.copyWith(fontWeight: FontWeight.bold),
                      ),
                      const SizedBox(height: 4),
                      Text(_nameCtrl.text,
                          style: Theme.of(ctx).textTheme.titleMedium),
                      const SizedBox(height: 12),

                      DropdownButtonFormField<String>(
                        initialValue: selectedMealType,
                        decoration: InputDecoration(
                          labelText: l10n.mealTypeLabel,
                          border: const OutlineInputBorder(),
                          isDense: true,
                        ),
                        items: internalTypes
                            .map((key) => DropdownMenuItem(
                                  value: key,
                                  child: Text(mealTypeLabel[key] ?? key),
                                ))
                            .toList(),
                        onChanged: (v) {
                          if (v != null) {
                            modalSetState(() => selectedMealType = v);
                          }
                        },
                      ),

                      const SizedBox(height: 12),

                      // Mengen anpassen vor dem Buchen
                      Flexible(
                        child: ListView.separated(
                          shrinkWrap: true,
                          itemCount: _items.length,
                          separatorBuilder: (_, __) =>
                              const SizedBox(height: 10),
                          itemBuilder: (_, i) {
                            final it = _items[i];
                            final bc = it['barcode'] as String;
                            final fi = products[bc];
                            final displayName =
                                (fi?.name.isNotEmpty ?? false) ? fi!.name : bc;
                            final unit = (fi?.isLiquid == true) ? 'ml' : 'g';

                            return Row(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                const Padding(
                                  padding: EdgeInsets.only(top: 14),
                                  child: Icon(Icons.lunch_dining),
                                ),
                                const SizedBox(width: 12),
                                Expanded(
                                  child: TextFormField(
                                    controller: qtyCtrls[bc],
                                    keyboardType:
                                        const TextInputType.numberWithOptions(
                                            decimal: true),
                                    decoration: InputDecoration(
                                      labelText: displayName,
                                      helperText: l10n.amountLabel,
                                      suffixText: unit,
                                      border: OutlineInputBorder(
                                        borderRadius: BorderRadius.circular(14),
                                      ),
                                    ),
                                  ),
                                ),
                              ],
                            );
                          },
                        ),
                      ),

                      const SizedBox(height: 12),
                      Row(
                        children: [
                          TextButton(
                            onPressed: () => Navigator.of(ctx).pop(false),
                            child: Text(l10n.cancel),
                          ),
                          const Spacer(),
                          FilledButton(
                            onPressed: () => Navigator.of(ctx).pop(true),
                            child: Text(l10n.save),
                          ),
                        ],
                      ),
                    ],
                  ),
                );
              },
            );
          },
        ) ??
        false;

    if (!ok) return;

    // Buchen
    final ts = DateTime.now();
    for (final it in _items) {
      final bc = it['barcode'] as String;
      final ctrl = qtyCtrls[bc]!;
      final qty =
          int.tryParse(ctrl.text.trim()) ?? (it['quantity_in_grams'] as int);

      await DatabaseHelper.instance.insertFoodEntry(
        FoodEntry(
          barcode: bc,
          timestamp: ts,
          quantityInGrams: qty,
          mealType: selectedMealType,
        ),
      );

      final fi = await ProductDatabaseHelper.instance.getProductByBarcode(bc);
      if (fi != null) {
        if (fi.isLiquid == true) {
          // await DatabaseHelper.instance.insertWaterEntry(qty, ts);
        }
        final c100 = fi.caffeineMgPer100ml;
        if (fi.isLiquid == true && c100 != null && c100 > 0) {
          await _logCaffeineDose(c100 * (qty / 100.0), ts);
        }
      }
    }

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(l10n.mealAddedToDiarySuccess)),
      );
    }
  }

  Future<void> _logCaffeineDose(double doseMg, DateTime timestamp) async {
    if (doseMg <= 0) return;

    final supplements = await DatabaseHelper.instance.getAllSupplements();
    final caffeine = supplements.firstWhere(
      (s) => (s.code == 'caffeine') || s.name.toLowerCase() == 'caffeine',
      orElse: () => Supplement(
        name: 'Caffeine',
        defaultDose: 100,
        unit: 'mg',
        dailyLimit: 400,
        code: 'caffeine',
        isBuiltin: true,
      ),
    );

    final caffeineId = caffeine.id ??
        (await DatabaseHelper.instance.insertSupplement(caffeine)).id!;

    await DatabaseHelper.instance.insertSupplementLog(
      SupplementLog(
        supplementId: caffeineId,
        dose: doseMg,
        unit: 'mg',
        timestamp: timestamp,
      ),
    );
  }
}

/// Kleines “Chip”-Label für C/F/P
class _MacroChip extends StatelessWidget {
  final String label;
  final String value;
  final String unit;
  const _MacroChip({
    required this.label,
    required this.value,
    required this.unit,
  });

  @override
  Widget build(BuildContext context) {
    final text = Theme.of(context).textTheme;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(10),
      ),
      child: Text(
        '$label  $value$unit',
        style: text.labelLarge?.copyWith(fontWeight: FontWeight.w700),
      ),
    );
  }
}

/// Einzelne Zutat als SummaryCard
/// - View-Modus: Name (tappable) + kleine kcal rechts + (darunter) C/F/P
/// - Edit-Modus: rechts Mengenfeld; Swipe nach links = Löschen
class _IngredientCard extends StatelessWidget {
  final Map<String, dynamic> item; // { barcode, quantity_in_grams }
  final bool editMode;
  final bool showPerIngredientMacros;
  final ValueChanged<int> onQtyChanged;
  final VoidCallback onDelete;

  const _IngredientCard({
    super.key,
    required this.item,
    required this.editMode,
    required this.showPerIngredientMacros,
    required this.onQtyChanged,
    required this.onDelete,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final color = theme.colorScheme.primary;
    final bc = item['barcode'] as String;
    final qty = (item['quantity_in_grams'] as num?)?.toDouble() ?? 0.0;

    Widget buildCard(FoodItem? fi) {
      final name = (fi?.name.isNotEmpty ?? false) ? fi!.name : bc;
      final unit = (fi?.isLiquid == true) ? 'ml' : 'g';

      // per-ingredient macros & kcal
      int kcal = 0;
      double c = 0, f = 0, p = 0;
      if (fi != null) {
        final factor = qty / 100.0;
        kcal = ((fi.calories ?? 0) * factor).round();
        c = (fi.carbs ?? 0) * factor;
        f = (fi.fat ?? 0) * factor;
        p = (fi.protein ?? 0) * factor;
      }

      final title = InkWell(
        onTap: () {
          if (fi != null) {
            Navigator.of(context).push(
              MaterialPageRoute(builder: (_) => FoodDetailScreen(foodItem: fi)),
            );
          }
        },
        child: Text(
          name,
          style:
              theme.textTheme.bodyLarge?.copyWith(fontWeight: FontWeight.w600),
        ),
      );

      final trailingView = Text(
        fi == null ? '–' : '$kcal kcal',
        style: theme.textTheme.labelLarge?.copyWith(
          color: theme.colorScheme.onSurfaceVariant,
          fontWeight: FontWeight.w700,
        ),
      );

      final trailingEdit = SizedBox(
        width: 96,
        child: TextFormField(
          initialValue: '${qty.toInt()}',
          textAlign: TextAlign.right,
          keyboardType: const TextInputType.numberWithOptions(decimal: false),
          decoration: InputDecoration(
            isDense: true,
            suffixText: unit,
            border: const OutlineInputBorder(),
          ),
          onChanged: (v) {
            final parsed = int.tryParse(v.trim());
            if (parsed != null && parsed >= 0) onQtyChanged(parsed);
          },
        ),
      );

      return SummaryCard(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  const SizedBox(width: 4),
                  Icon(Icons.local_dining, color: color),
                  const SizedBox(width: 12),
                  Expanded(child: title),
                  if (!editMode) trailingView else trailingEdit,
                ],
              ),
              if (showPerIngredientMacros && fi != null) ...[
                const SizedBox(height: 6),
                Text(
                  'C ${c.toStringAsFixed(1)} g   •   F ${f.toStringAsFixed(1)} g   •   P ${p.toStringAsFixed(1)} g',
                  style: theme.textTheme.bodySmall
                      ?.copyWith(color: Colors.grey.shade600),
                ),
              ],
            ],
          ),
        ),
      );
    }

    final card = FutureBuilder<FoodItem?>(
      future: ProductDatabaseHelper.instance.getProductByBarcode(bc),
      builder: (_, snap) => buildCard(snap.data),
    );

    if (!editMode) return card;

    // Edit-Modus: Swipe links = löschen
    return Dismissible(
      key: ValueKey('ing_${item['barcode']}_${item['quantity_in_grams']}'),
      direction: DismissDirection.endToStart,
      background: const SizedBox.shrink(),
      secondaryBackground: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      confirmDismiss: (direction) async {
        if (direction == DismissDirection.endToStart) {
          onDelete();
        }
        return false;
      },
      child: card,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/exercise_detail_screen.dart =====

// lib/screens/exercise_detail_screen.dart (Final & De-Materialisiert - Korrigiert)

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/wger_attribution_widget.dart';

class ExerciseDetailScreen extends StatelessWidget {
  final Exercise exercise;
  const ExerciseDetailScreen({super.key, required this.exercise});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final textTheme = Theme.of(context).textTheme;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        automaticallyImplyLeading: true, // <-- zeigt den Zurück-Pfeil
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        title: Text(
          exercise.getLocalizedName(context),
          style: textTheme.headlineSmall?.copyWith(
            fontWeight: FontWeight.w900,
          ),
        ),
      ),
      body: SingleChildScrollView(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              exercise.categoryName,
              style: textTheme.titleMedium?.copyWith(color: Colors.grey[600]),
            ),
            const SizedBox(height: DesignConstants.spacingXL),
            SummaryCard(
              child: Padding(
                padding: DesignConstants.cardPadding,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(l10n.descriptionLabel, style: textTheme.titleLarge),
                    const SizedBox(height: DesignConstants.spacingS),
                    Text(
                      exercise.getLocalizedDescription(context).isNotEmpty
                          ? exercise.getLocalizedDescription(context)
                          : l10n.noDescriptionAvailable,
                      style: textTheme.bodyMedium,
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: DesignConstants.spacingM),
            SummaryCard(
              child: Padding(
                padding: DesignConstants.cardPadding,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(l10n.involvedMuscles, style: textTheme.titleLarge),
                    const SizedBox(height: DesignConstants.spacingS),
                    if (exercise.primaryMuscles.isNotEmpty)
                      _buildMuscleRow(l10n.primaryLabel,
                          exercise.primaryMuscles.join(', '), textTheme),
                    if (exercise.secondaryMuscles.isNotEmpty)
                      _buildMuscleRow(l10n.secondaryLabel,
                          exercise.secondaryMuscles.join(', '), textTheme),
                    if (exercise.primaryMuscles.isEmpty &&
                        exercise.secondaryMuscles.isEmpty)
                      Text(l10n.noMusclesSpecified,
                          style: textTheme.bodyMedium
                              ?.copyWith(color: Colors.grey[600])),
                  ],
                ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.only(top: 24.0, bottom: 8.0),
              child: WgerAttributionWidget(
                textStyle:
                    textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMuscleRow(String label, String muscles, TextTheme textTheme) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(label,
                style: textTheme.bodyMedium
                    ?.copyWith(fontWeight: FontWeight.bold)),
          ),
          Expanded(
            child: Text(muscles, style: textTheme.bodyMedium),
          ),
        ],
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/measurements_screen.dart =====

// lib/screens/measurements_screen.dart (Final & De-Materialisiert - mit AppBar)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/measurement_session.dart';
import 'package:lightweight/screens/add_measurement_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/bottom_content_spacer.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/measurement_chart_widget.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/util/l10n_ext.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';

class MeasurementsScreen extends StatefulWidget {
  const MeasurementsScreen({super.key});

  @override
  State<MeasurementsScreen> createState() => _MeasurementsScreenState();
}

class _MeasurementsScreenState extends State<MeasurementsScreen> {
  bool _isLoading = true;
  List<MeasurementSession> _sessions = [];
  String? _selectedChartType;
  List<String> _availableMeasurementTypes = [];

  DateTimeRange _currentChartDateRange = DateTimeRange(
    start: DateTime.now().subtract(const Duration(days: 29)),
    end: DateTime.now(),
  );
  final List<String> _chartDateRangeKeys = ['30D', '90D', '180D', 'All'];
  String _selectedChartRangeKey = '30D';

  @override
  void initState() {
    super.initState();
    _loadMeasurements();
  }

  Future<void> _loadMeasurements() async {
    setState(() => _isLoading = true);
    final sessions = await DatabaseHelper.instance.getMeasurementSessions();

    final Set<String> types = {};
    for (final session in sessions) {
      for (final measurement in session.measurements) {
        types.add(measurement.type);
      }
    }

    if (mounted) {
      setState(() {
        _sessions = sessions;
        _availableMeasurementTypes = types.toList()..sort();
        if (_selectedChartType == null &&
            _availableMeasurementTypes.isNotEmpty) {
          _selectedChartType = _availableMeasurementTypes.first;
        }
        _isLoading = false;
      });
      _loadChartData();
    }
  }

  Future<void> _loadChartData() async {
    if (_selectedChartType == null || _selectedChartType!.isEmpty) return;

    final now = DateTime.now();
    DateTime start;
    DateTime end = DateTime(now.year, now.month, now.day, 23, 59, 59);

    switch (_selectedChartRangeKey) {
      case '90D':
        start = now.subtract(const Duration(days: 89));
        break;
      case '180D':
        start = now.subtract(const Duration(days: 179));
        break;
      case 'All':
        final earliest =
            await DatabaseHelper.instance.getEarliestMeasurementDate();
        start = earliest ?? now;
        break;
      case '30D':
      default:
        start = now.subtract(const Duration(days: 29));
    }

    setState(() {
      _currentChartDateRange = DateTimeRange(start: start, end: end);
    });
  }

  Future<void> _deleteSession(int id) async {
    await DatabaseHelper.instance.deleteMeasurementSession(id);
    _loadMeasurements();
  }

  void _navigateToCreateMeasurement() {
    Navigator.of(context)
        .push(MaterialPageRoute(
            builder: (context) => const AddMeasurementScreen()))
        .then((_) => _loadMeasurements());
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          l10n.measurementsScreenTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _sessions.isEmpty
              ? _buildEmptyState(l10n, context)
              : ListView(
                  padding: DesignConstants.cardPadding,
                  children: [
                    if (_availableMeasurementTypes.isNotEmpty) ...[
                      _buildChartSection(
                          l10n, colorScheme, Theme.of(context).textTheme),
                      const SizedBox(height: DesignConstants.spacingXL),
                    ],
                    _buildSectionTitle(context, l10n.all_measurements),
                    ..._sessions.map((session) => _buildMeasurementSessionCard(
                        l10n, colorScheme, session)),
                    const BottomContentSpacer(),
                  ],
                ),
      floatingActionButton: GlassFab(
        label: l10n.addMeasurement,
        onPressed: _navigateToCreateMeasurement,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  Widget _buildEmptyState(AppLocalizations l10n, BuildContext context) {
    return Center(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(l10n.measurementsEmptyState,
                textAlign: TextAlign.center,
                style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: DesignConstants.spacingXL),
            ElevatedButton.icon(
              onPressed: _navigateToCreateMeasurement,
              icon: const Icon(Icons.add),
              label: Text(l10n.addMeasurement),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildChartSection(
      AppLocalizations l10n, ColorScheme colorScheme, TextTheme textTheme) {
    if (_selectedChartType == null) return const SizedBox.shrink();

    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: DropdownButtonHideUnderline(
                    child: DropdownButton<String>(
                      value: _selectedChartType,
                      isExpanded: true,
                      onChanged: (String? newValue) {
                        if (newValue != null) {
                          setState(() {
                            _selectedChartType = newValue;
                          });
                          _loadChartData();
                        }
                      },
                      items: _availableMeasurementTypes
                          .map<DropdownMenuItem<String>>((String value) {
                        return DropdownMenuItem<String>(
                          value: value,
                          child: Text(l10n.getLocalizedMeasurementName(value)),
                        );
                      }).toList(),
                      style: textTheme.titleMedium
                          ?.copyWith(fontWeight: FontWeight.bold),
                      icon: Icon(Icons.arrow_drop_down,
                          color: colorScheme.onSurfaceVariant),
                    ),
                  ),
                ),
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: _chartDateRangeKeys
                      .map((key) => _buildFilterButton(key, key))
                      .toList(),
                ),
              ],
            ),
            const SizedBox(height: DesignConstants.spacingL),
            MeasurementChartWidget(
              chartType: _selectedChartType!,
              dateRange: _currentChartDateRange,
              // KORREKTUR: Die folgende Zeile wurde entfernt
              // lineColor: colorScheme.primary,
              unit: _getMeasurementUnit(_selectedChartType!),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFilterButton(String label, String key) {
    final theme = Theme.of(context);
    final isSelected = _selectedChartRangeKey == key;
    return GestureDetector(
      onTap: () {
        setState(() {
          _selectedChartRangeKey = key;
        });
        _loadChartData();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10.0, vertical: 6.0),
        decoration: BoxDecoration(
          color: isSelected
              ? theme.colorScheme.primary
              : theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
          borderRadius: BorderRadius.circular(8.0),
        ),
        child: Text(
          label,
          style: theme.textTheme.labelSmall?.copyWith(
            color: isSelected
                ? theme.colorScheme.onPrimary
                : theme.colorScheme.onSurfaceVariant,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  Widget _buildMeasurementSessionCard(AppLocalizations l10n,
      ColorScheme colorScheme, MeasurementSession session) {
    final locale = Localizations.localeOf(context).toString();
    final sortedMeasurements = session.measurements.toList()
      ..sort((a, b) => a.type.compareTo(b.type));

    return Dismissible(
      key: Key('session_${session.id}'),
      direction: DismissDirection.endToStart,
      // gleiche Hintergründe wie im Nutrition Screen
      background: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      confirmDismiss: (direction) async {
        final confirmed = await showDialog<bool>(
              context: context,
              builder: (ctx) => AlertDialog(
                title: Text(l10n.deleteConfirmTitle),
                content: Text(l10n.deleteConfirmContent),
                actions: [
                  TextButton(
                    onPressed: () => Navigator.of(ctx).pop(false),
                    child: Text(l10n.cancel),
                  ),
                  TextButton(
                    onPressed: () => Navigator.of(ctx).pop(true),
                    child: Text(l10n.delete),
                  ),
                ],
              ),
            ) ??
            false;
        return confirmed;
      },
      child: SummaryCard(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            ListTile(
              contentPadding: DesignConstants.screenPadding,
              title: Text(
                  DateFormat.yMMMMEEEEd(locale)
                      .add_Hm()
                      .format(session.timestamp),
                  style: const TextStyle(fontWeight: FontWeight.bold)),
              trailing: const Icon(Icons.chevron_right),
              onTap: () {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text(l10n.measurement_session_detail_view)),
                );
              },
            ),
            Divider(
                height: 1,
                thickness: 1,
                color: colorScheme.onSurfaceVariant.withOpacity(0.1)),
            ...sortedMeasurements.map((measurement) => ListTile(
                  contentPadding: const EdgeInsets.symmetric(
                      horizontal: 16.0, vertical: 4.0),
                  leading: _getMeasurementIcon(measurement.type),
                  title:
                      Text(l10n.getLocalizedMeasurementName(measurement.type)),
                  trailing: Text(
                      "${measurement.value.toStringAsFixed(1)} ${measurement.unit}",
                      style: const TextStyle(fontWeight: FontWeight.bold)),
                )),
          ],
        ),
      ),
    );
  }

  String _getMeasurementUnit(String type) {
    // Hier die Einheiten basierend auf dem Typ zurückgeben
    switch (type) {
      case 'weight':
        return 'kg';
      case 'fat_percent':
        return '%';
      case 'neck':
      case 'shoulder':
      case 'chest':
      case 'left_bicep':
      case 'right_bicep':
      case 'left_forearm':
      case 'right_forearm':
      case 'abdomen':
      case 'waist':
      case 'hips':
      case 'left_thigh':
      case 'right_thigh':
      case 'left_calf':
      case 'right_calf':
        return 'cm';
      default:
        return '';
    }
  }

  Icon _getMeasurementIcon(String type) {
    // Hier Icons basierend auf dem Typ zurückgeben
    switch (type) {
      case 'weight':
        return const Icon(Icons.monitor_weight);
      case 'fat_percent':
        return const Icon(Icons.fitness_center);
      case 'neck':
        return const Icon(Icons.accessibility_new);
      case 'shoulder':
        return const Icon(Icons.accessibility_new);
      case 'chest':
        return const Icon(Icons.accessibility_new);
      case 'left_bicep':
        return const Icon(Icons.accessibility_new);
      case 'right_bicep':
        return const Icon(Icons.accessibility_new);
      case 'abdomen':
        return const Icon(Icons.accessibility_new);
      case 'waist':
        return const Icon(Icons.accessibility_new);
      case 'hips':
        return const Icon(Icons.accessibility_new);
      default:
        return const Icon(Icons.straighten);
    }
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/main_screen.dart =====

import 'dart:io';
import 'dart:ui';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/dialogs/log_supplement_dialog_content.dart';
import 'package:lightweight/dialogs/fluid_dialog_content.dart';
import 'package:lightweight/dialogs/log_supplement_menu.dart';
import 'package:lightweight/dialogs/quantity_dialog_content.dart';
import 'package:lightweight/dialogs/water_dialog_content.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/fluid_entry.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';
import 'package:lightweight/screens/add_food_screen.dart';
import 'package:lightweight/screens/add_measurement_screen.dart';
import 'package:lightweight/screens/diary_screen.dart';
import 'package:lightweight/screens/edit_routine_screen.dart';
import 'package:lightweight/screens/live_workout_screen.dart';
import 'package:lightweight/screens/nutrition_hub_screen.dart';
import 'package:lightweight/screens/profile_screen.dart';
import 'package:lightweight/screens/statistics_hub_screen.dart';
import 'package:lightweight/screens/workout_hub_screen.dart';
import 'package:lightweight/services/profile_service.dart';
import 'package:lightweight/services/workout_session_manager.dart';
import 'package:lightweight/theme/color_constants.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
import 'package:lightweight/widgets/glass_bottom_nav_bar.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/keep_alive_page.dart';
import 'package:provider/provider.dart';

class MainScreen extends StatefulWidget {
  const MainScreen({super.key});
  @override
  State<MainScreen> createState() => _MainScreenState();
}

class _MainScreenState extends State<MainScreen> with TickerProviderStateMixin {
  late PageController _pageController;
  int _currentIndex = 0;
  final GlobalKey<DiaryScreenState> _tagebuchKey =
      GlobalKey<DiaryScreenState>();
  bool _isAddMenuOpen = false;
  late final AnimationController _menuController;
  double kNavBarHeight = 76.0; // aktuelle Höhe deiner GlassBottomNavBar
  double kBarFabGap = 12.0; // Abstand zwischen BottomBar und + Button

  double _safe01(double v) => v.isNaN ? 0.0 : v.clamp(0.0, 1.0).toDouble();

  @override
  void initState() {
    super.initState();
    _pageController = PageController();
    _menuController = AnimationController(
        vsync: this, duration: const Duration(milliseconds: 400));
  }

  @override
  void dispose() {
    _pageController.dispose();
    _menuController.dispose();
    super.dispose();
  }

  void _onPageChanged(int index) {
    if (_isWarping) {
      return; // während Snapshot-Overlay nicht den Index zurückspringen lassen
    }
    setState(() => _currentIndex = index);
  }

  final _pvBoundaryKey = GlobalKey(); // RepaintBoundary um die PageView
  final bool _navAnimating = false;
  final bool _isWarping = false;
  ui.Image? _pvSnapshot; // aktueller Snapshot

  void _onNavigationTapped(int index) {
    if (!_pageController.hasClients) return;
    _pageController.jumpToPage(index);
  }

  void _toggleAddMenu() {
    setState(() {
      _isAddMenuOpen = !_isAddMenuOpen;
      if (_isAddMenuOpen) {
        _menuController.forward();
      } else {
        _menuController.reverse();
      }
    });
  }

  void _executeAddMenuAction(String action) async {
    final l10n = AppLocalizations.of(context)!;
    switch (action) {
      case 'start_workout':
        _showStartWorkoutMenu();
        break;
      case 'add_measurement':
        final success = await Navigator.of(context).push<bool>(
            MaterialPageRoute(
                builder: (context) => const AddMeasurementScreen()));
        if (success == true) _refreshHomeScreen();
        break;
      case 'add_food':
        _handleAddFood();
        break;
      case 'add_liquid':
        await _showAddFluidMenu();
        break;
      case 'log_supplement':
        _showLogSupplementMenu();
        break;
    }
  }

  Future<void> _refreshHomeScreen() async {
    if (_currentIndex == 0) {
      _tagebuchKey.currentState?.loadDataForDate(DateTime.now());
    }
  }

  Future<void> _showLogSupplementMenu() async {
    final l10n = AppLocalizations.of(context)!;
    await showGlassBottomMenu(
      context: context,
      title: l10n.logIntakeTitle,
      contentBuilder: (ctx, close) {
        return LogSupplementMenu(close: close);
      },
    );
    _refreshHomeScreen();
  }

  Future<void> _showStartWorkoutMenu() async {
    final l10n = AppLocalizations.of(context)!;
    final routines = await WorkoutDatabaseHelper.instance.getAllRoutines();
    if (!mounted) return;

    await showGlassBottomMenu(
      context: context,
      title: l10n.startWorkout,
      contentBuilder: (ctx, close) {
        final isDark = Theme.of(ctx).brightness == Brightness.dark;
        Widget glassCard({required Widget child, EdgeInsets? padding}) {
          return Material(
            color: Colors.white.withOpacity(isDark ? 0.06 : 0.08),
            borderRadius: BorderRadius.circular(18),
            child: Padding(
              padding: padding ??
                  const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
              child: child,
            ),
          );
        }

        final freeWorkoutTile = glassCard(
          child: InkWell(
            borderRadius: BorderRadius.circular(16),
            onTap: () async {
              final newWorkoutLog = await WorkoutDatabaseHelper.instance
                  .startWorkout(routineName: l10n.freeWorkoutTitle);
              if (!context.mounted) return;
              close();
              Navigator.of(context)
                  .push(MaterialPageRoute(
                    builder: (_) =>
                        LiveWorkoutScreen(workoutLog: newWorkoutLog),
                  ))
                  .then((_) => _refreshHomeScreen());
            },
            child: Row(
              children: [
                const Icon(Icons.play_arrow_rounded),
                const SizedBox(width: 12),
                Text(
                  l10n.startEmptyWorkoutButton,
                  style: Theme.of(ctx)
                      .textTheme
                      .titleMedium
                      ?.copyWith(fontWeight: FontWeight.w700),
                ),
              ],
            ),
          ),
        );

        final routinesList = ConstrainedBox(
          constraints: const BoxConstraints(maxHeight: 420),
          child: ListView.separated(
            padding: const EdgeInsets.fromLTRB(4, 0, 4, 4),
            shrinkWrap: true,
            itemCount: routines.length,
            separatorBuilder: (_, __) => const SizedBox(height: 10),
            itemBuilder: (ctx, i) {
              final r = routines[i];
              return glassCard(
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    FilledButton(
                      onPressed: () async {
                        showDialog(
                          context: context,
                          barrierDismissible: false,
                          builder: (_) =>
                              const Center(child: CircularProgressIndicator()),
                        );
                        final fullRoutine = await WorkoutDatabaseHelper.instance
                            .getRoutineById(r.id!);
                        final newWorkoutLog = await WorkoutDatabaseHelper
                            .instance
                            .startWorkout(routineName: r.name);
                        if (!context.mounted) return;
                        Navigator.of(context).pop();
                        if (fullRoutine != null) {
                          close();
                          Navigator.of(context)
                              .push(MaterialPageRoute(
                                builder: (_) => LiveWorkoutScreen(
                                  routine: fullRoutine,
                                  workoutLog: newWorkoutLog,
                                ),
                              ))
                              .then((_) => _refreshHomeScreen());
                        }
                      },
                      child: Text(l10n.startButton),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: InkWell(
                        borderRadius: BorderRadius.circular(12),
                        onTap: () {
                          close();
                          Navigator.of(context)
                              .push(MaterialPageRoute(
                                builder: (_) => EditRoutineScreen(routine: r),
                              ))
                              .then((_) => _refreshHomeScreen());
                        },
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              r.name,
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                              style: Theme.of(ctx)
                                  .textTheme
                                  .titleMedium
                                  ?.copyWith(fontWeight: FontWeight.w700),
                            ),
                            const SizedBox(height: 2),
                            Text(
                              l10n.editRoutineSubtitle,
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                              style: Theme.of(ctx).textTheme.bodySmall,
                            ),
                          ],
                        ),
                      ),
                    ),
                    const SizedBox(width: 8),
                    Icon(Icons.more_vert_rounded,
                        color: Theme.of(ctx).textTheme.bodyMedium?.color),
                  ],
                ),
              );
            },
          ),
        );

        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            freeWorkoutTile,
            if (routines.isNotEmpty) ...[
              const SizedBox(height: 12),
              routinesList,
            ],
          ],
        );
      },
    );
  }

  Future<void> _handleAddFood() async {
    final FoodItem? selectedFoodItem = await Navigator.of(context)
        .push<FoodItem>(
            MaterialPageRoute(builder: (context) => const AddFoodScreen()));

    if (selectedFoodItem == null || !mounted) return;

    final result = await _showQuantityMenu(selectedFoodItem);
    if (result == null || !mounted) return;

    final int quantity = result.quantity;
    final DateTime timestamp = result.timestamp;
    final String mealType = result.mealType;
    final bool isLiquid = result.isLiquid;
    final double? caffeinePer100 = result.caffeinePer100ml;

    // 1. Immer den FoodEntry mit allen Nährwerten speichern
    final newFoodEntry = FoodEntry(
      barcode: selectedFoodItem.barcode,
      timestamp: timestamp,
      quantityInGrams: quantity,
      mealType: mealType,
    );
    final newFoodEntryId = await DatabaseHelper.instance.insertFoodEntry(newFoodEntry);

    // 2. Wenn es eine Flüssigkeit ist, ZUSÄTZLICH einen FluidEntry NUR FÜR WASSER erstellen
    if (isLiquid) {
      final newFluidEntry = FluidEntry(
        timestamp: timestamp,
        quantityInMl: quantity,
        name: selectedFoodItem.name,
        // WICHTIG: Keine Nährwerte hier, um Doppelzählung zu vermeiden!
        kcal: null,
        sugarPer100ml: null,
        carbsPer100ml: null,
        caffeinePer100ml: null,
        linked_food_entry_id: newFoodEntryId, // Die neue Verknüpfung
      );
      await DatabaseHelper.instance.insertFluidEntry(newFluidEntry);
    }
    
    // 3. Koffein nur loggen, wenn als Flüssigkeit deklariert, und mit FoodEntry verknüpfen
    if (isLiquid && caffeinePer100 != null && caffeinePer100 > 0) {
      final totalCaffeine = (caffeinePer100 / 100.0) * quantity;
      await _logCaffeineDose(totalCaffeine, timestamp, foodEntryId: newFoodEntryId);
    }

    _refreshHomeScreen();
  }


  Future<void> _showAddFluidMenu() async {
    final l10n = AppLocalizations.of(context)!;
    final key = GlobalKey<FluidDialogContentState>();
    await showGlassBottomMenu(
      context: context,
      title: l10n.add_liquid_title,
      contentBuilder: (ctx, close) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            FluidDialogContent(key: key),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: close,
                    child: Text(l10n.cancel),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton(
                    onPressed: () async {
                      final state = key.currentState;
                      if (state == null) return;
                      final quantity = int.tryParse(state.quantityText);
                      if (quantity == null || quantity <= 0) return;

                      final name = state.nameText;
                      final sugarPer100ml = double.tryParse(state.sugarText.replaceAll(',', '.'));
                      final caffeinePer100ml = double.tryParse(state.caffeineText.replaceAll(',', '.'));
                      final kcal = (sugarPer100ml != null) ? ((sugarPer100ml / 100) * quantity * 4).round() : null;

                      final newEntry = FluidEntry(
                        timestamp: state.selectedDateTime,
                        quantityInMl: quantity,
                        name: name,
                        kcal: kcal,
                        sugarPer100ml: sugarPer100ml,
                        carbsPer100ml: sugarPer100ml, // Spiegeln
                        caffeinePer100ml: caffeinePer100ml,
                      );

                      final newId = await DatabaseHelper.instance.insertFluidEntry(newEntry);
                      
                      if(caffeinePer100ml != null && caffeinePer100ml > 0) {
                        final totalCaffeine = (caffeinePer100ml / 100.0) * quantity;
                        await _logCaffeineDose(totalCaffeine, state.selectedDateTime, fluidEntryId: newId);
                      }

                      close();
                      _refreshHomeScreen();
                    },
                    child: Text(l10n.add_button),
                  ),
                ),
              ],
            ),
          ],
        );
      },
    );
  }

  Future<void> _logCaffeineDose(double doseMg, DateTime timestamp, {int? foodEntryId, int? fluidEntryId}) async {
    if (doseMg <= 0) return;
    
    final supplements = await DatabaseHelper.instance.getAllSupplements();
    Supplement? caffeineSupplement;
    try {
      caffeineSupplement = supplements.firstWhere((s) => s.code == 'caffeine');
    } catch(e) { return; }

    if (caffeineSupplement.id == null) return;

    await DatabaseHelper.instance.insertSupplementLog(
      SupplementLog(
        supplementId: caffeineSupplement.id!,
        dose: doseMg,
        unit: 'mg',
        timestamp: timestamp,
        // EINEN der beiden Fremdschlüssel setzen
        source_food_entry_id: foodEntryId,
        source_fluid_entry_id: fluidEntryId,
      ),
    );
  }

  Future<({int quantity, DateTime timestamp, String mealType, bool isLiquid, double? sugarPer100ml, double? caffeinePer100ml})?>
      _showQuantityMenu(FoodItem item) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<QuantityDialogContentState> dialogStateKey = GlobalKey();

    return showGlassBottomMenu<({
      int quantity,
      DateTime timestamp,
      String mealType,
      bool isLiquid,
      double? sugarPer100ml,
      double? caffeinePer100ml
    })>(
      context: context,
      title: item.name,
      contentBuilder: (ctx, close) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            QuantityDialogContent(key: dialogStateKey, item: item),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () {
                      close();
                      Navigator.of(ctx).pop(null);
                    },
                    child: Text(l10n.cancel),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton(
                    onPressed: () {
                      final state = dialogStateKey.currentState;
                      if (state != null) {
                        final quantity = int.tryParse(state.quantityText);
                        final sugar = double.tryParse(state.sugarText.replaceAll(',', '.'));
                        final caffeine = double.tryParse(state.caffeineText.replaceAll(',', '.'));
                        if (quantity != null && quantity > 0) {
                          close();
                          Navigator.of(ctx).pop((
                            quantity: quantity,
                            timestamp: state.selectedDateTime,
                            mealType: state.selectedMealType,
                            isLiquid: state.isLiquid,
                            sugarPer100ml: sugar,
                            caffeinePer100ml: caffeine
                          ));
                        }
                      }
                    },
                    child: Text(l10n.add_button),
                  ),
                ),
              ],
            ),
          ],
        );
      },
    );
  }


  void _handleCreateRoutine() {
    Navigator.of(context).push(
        MaterialPageRoute(builder: (context) => const EditRoutineScreen()));
  }

  Future<(int, DateTime)?> _openWaterDialog({
    int? initialQuantity,
    DateTime? initialTimestamp,
  }) async {
    final l10n = AppLocalizations.of(context)!;
    final key = GlobalKey<WaterDialogContentState>();

    return showDialog<(int, DateTime)?>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.add_liquid_title),
        content: WaterDialogContent(
          key: key,
          initialQuantity: initialQuantity,
          initialTimestamp: initialTimestamp,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(null),
            child: Text(l10n.cancel),
          ),
          FilledButton(
            onPressed: () {
              final s = key.currentState;
              if (s == null) return;
              final qty = int.tryParse(s.quantityText);
              if (qty != null && qty > 0) {
                Navigator.of(ctx).pop((qty, s.selectedDateTime));
              }
            },
            child: Text(l10n.add_button),
          ),
        ],
      ),
    );
  }
  String localizeSupplementName(Supplement s, AppLocalizations l10n) {
    switch (s.code) {
      case 'caffeine':
        return l10n.supplement_caffeine;
      case 'creatine_monohydrate':
        return l10n.supplement_creatine_monohydrate;
      default:
        // Fallback: benutzerdefinierte Supplements behalten ihren Namen
        return s.name;
    }
  }

  Future<void> _handleSupplementAdd() async {
    final allSupplements = await DatabaseHelper.instance.getAllSupplements();
    if (!mounted || allSupplements.isEmpty) return;
    final l10n = AppLocalizations.of(context)!;

    final Supplement? selectedSupplement = await showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.logIntakeTitle),
        content: SizedBox(
          width: double.maxFinite,
          child: ListView.builder(
            shrinkWrap: true,
            itemCount: allSupplements.length,
            itemBuilder: (context, index) {
              final supplement = allSupplements[index];
              return ListTile(
                title: Text(localizeSupplementName(supplement, l10n)),
                onTap: () => Navigator.of(context).pop(supplement),
              );
            },
          ),
        ),
      ),
    );

    if (selectedSupplement != null && mounted) {
      _logSupplement(selectedSupplement);
    }
  }

  Future<void> _logSupplement(Supplement supplement) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<LogSupplementDialogContentState> dialogStateKey =
        GlobalKey();
    final result = await showDialog<(double, DateTime)?>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(localizeSupplementName(supplement, l10n)),
          content: LogSupplementDialogContent(
              key: dialogStateKey, supplement: supplement),
          actions: [
            TextButton(
                child: Text(l10n.cancel),
                onPressed: () => Navigator.of(context).pop(null)),
            FilledButton(
              child: Text(l10n.add_button),
              onPressed: () {
                final state = dialogStateKey.currentState;
                if (state != null) {
                  final dose =
                      double.tryParse(state.doseText.replaceAll(',', '.'));
                  if (dose != null && dose > 0) {
                    Navigator.of(context).pop((dose, state.selectedDateTime));
                  }
                }
              },
            ),
          ],
        );
      },
    );
    if (result != null) {
      final newLog = SupplementLog(
          supplementId: supplement.id!,
          dose: result.$1,
          unit: supplement.unit,
          timestamp: result.$2);
      await DatabaseHelper.instance.insertSupplementLog(newLog);
      _refreshHomeScreen();
    }
  }

  Future<(int, DateTime)?> _showWaterDialog() async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<WaterDialogContentState> dialogStateKey = GlobalKey();
    return showDialog<(int, DateTime)?>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(l10n.add_liquid_title),
          content: WaterDialogContent(key: dialogStateKey),
          actions: [
            TextButton(
                child: Text(l10n.cancel),
                onPressed: () => Navigator.of(context).pop(null)),
            FilledButton(
              child: Text(l10n.add_button),
              onPressed: () {
                final state = dialogStateKey.currentState;
                if (state != null) {
                  final quantity = int.tryParse(state.quantityText);
                  if (quantity != null && quantity > 0) {
                    Navigator.of(context)
                        .pop((quantity, state.selectedDateTime));
                  }
                }
              },
            ),
          ],
        );
      },
    );
  }

  Future<void> _captureSnapshot() async {
    try {
      final boundary = _pvBoundaryKey.currentContext?.findRenderObject()
          as RenderRepaintBoundary?;
      if (boundary == null) return;
      final img = await boundary.toImage(
          pixelRatio: MediaQuery.of(context).devicePixelRatio);
      setState(() => _pvSnapshot = img);
    } catch (_) {
      // fail silently – wir fallen dann einfach auf den bisherigen Warp zurück
    }
  }

  void _clearSnapshot() {
    setState(() => _pvSnapshot = null);
  }

  AppBar _buildAppBar(BuildContext context, int index, AppLocalizations l10n) {
    String title = '';
    // Handle titles for Train, Stats, and Profile screens
    switch (index) {
      case 1:
        title = 'Workout'; // TODO: l10n
        return AppBar(
          title: Text(
            title,
            style: Theme.of(context)
                .textTheme
                .titleLarge
                ?.copyWith(fontWeight: FontWeight.w900),
          ),
          actions: [
            _profileAppBarButton(context), // ⬅️ NEU
          ],
        );
      case 2:
        return AppBar(
          title: Text(
            l10n.statistics, // ← NEW (or l10n.stats)
            style: Theme.of(context)
                .textTheme
                .titleLarge
                ?.copyWith(fontWeight: FontWeight.w900),
          ),
          actions: [
            _profileAppBarButton(context), // ⬅️ NEU
          ],
        );
      case 3:
        // The profile screen's AppBar is now managed here.
        return AppBar(
          title: Text(
            l10n.nutritionHubTitle,
            style: Theme.of(context)
                .textTheme
                .titleLarge
                ?.copyWith(fontWeight: FontWeight.w900),
          ),
          actions: [
            _profileAppBarButton(context), // ⬅️ NEU
          ],
        );
      case 0:
      default:
        // The Diary Screen has a special, dynamic AppBar
        return AppBar(
          automaticallyImplyLeading: false,
          titleSpacing: 0,
          title: DiaryAppBar(
            // Pass the state's notifier directly IF the state exists
            selectedDateNotifier:
                _tagebuchKey.currentState?.selectedDateNotifier,
          ),
          actions: [
            IconButton(
              icon: const Icon(Icons.chevron_left),
              onPressed: () {
                _tagebuchKey.currentState?.navigateDay(false);
              },
            ),
            IconButton(
              icon: const Icon(Icons.calendar_today),
              onPressed: () {
                _tagebuchKey.currentState?.pickDate();
              },
            ),
            IconButton(
              icon: const Icon(Icons.chevron_right),
              onPressed: () {
                _tagebuchKey.currentState?.navigateDay(true);
              },
            ),
            _profileAppBarButton(context), // ⬅️ NEU
          ],
        );
    }
  }

  List<Map<String, dynamic>> _getSpeedDialActions(AppLocalizations l10n) {
    return [
      {
        'icon': Icons.local_drink,
        'label': l10n.addLiquidOption,
        'action': 'add_liquid'
      },
      {
        'icon': Icons.restaurant_menu,
        'label': l10n.addFoodOption,
        'action': 'add_food'
      },
      {
        'icon': Icons.straighten_outlined,
        'label': l10n.addMeasurement,
        'action': 'add_measurement'
      },
      {
        'icon': Icons.fitness_center,
        'label': l10n.startWorkout,
        'action': 'start_workout'
      },
      {
        'icon': Icons.medication_outlined,
        'label': l10n.logIntakeTitle,
        'action': 'log_supplement'
      },
    ];
  }

  String _formatDuration(Duration d) {
    final h = d.inHours;
    final m = d.inMinutes.remainder(60);
    final s = d.inSeconds.remainder(60);
    if (h > 0) {
      return '${h.toString().padLeft(2, '0')}:${m.toString().padLeft(2, '0')}:${s.toString().padLeft(2, '0')}';
    }
    return '${m.toString().padLeft(2, '0')}:${s.toString().padLeft(2, '0')}';
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final profileService = Provider.of<ProfileService>(context);

    // Workout-Status (nur UI, Logik bleibt)
    final manager = context.watch<WorkoutSessionManager>();
    final bool isWorkoutRunning = manager.isActive; // ✅
    final String elapsed = _formatDuration(manager.elapsedDuration); // ✅
    const basePad = 120.0; // nav bar + FAB visual height
    final runningPad = manager.isActive ? 68.0 : 0.0;

    return Stack(
      children: [
        Scaffold(
          extendBody: true,
          appBar: _buildAppBar(context, _currentIndex, l10n),
          body: PageView(
            controller: _pageController,
            onPageChanged: _onPageChanged,
            children: <Widget>[
              KeepAlivePage(
                storageKey: const PageStorageKey('tab_tagebuch'),
                child: DiaryScreen(key: _tagebuchKey),
              ),
              const KeepAlivePage(
                storageKey: PageStorageKey('tab_workout'),
                child: WorkoutHubScreen(),
              ),
              const KeepAlivePage(
                storageKey: PageStorageKey('tab_stats'),
                child: StatisticsHubScreen(),
              ),
              const KeepAlivePage(
                storageKey: PageStorageKey('tab_nutrition'),
                child: NutritionHubScreen(),
              ),
            ],
          ),
        ),

        // RUNNING WORKOUT BAR (oberhalb der BottomBar)
        if (isWorkoutRunning)
          Positioned(
            bottom: 24 + kNavBarHeight + kBarFabGap,
            // Abstand: BottomBar-Höhe + 8
            left: 16,
            right: 16,
            child: _FrostedBar(
              child: _RunningWorkoutRow(
                timeText: elapsed,
                onContinue: () {
                  final log = context.read<WorkoutSessionManager>().workoutLog;
                  if (log != null) {
                    Navigator.of(context).push(
                      MaterialPageRoute(
                        builder: (_) =>
                            LiveWorkoutScreen(workoutLog: log, routine: null),
                      ),
                    );
                  }
                },
                onDiscard: () async {
                  final l10n = AppLocalizations.of(context)!;
                  final wsm = context.read<WorkoutSessionManager>();
                  final logId = wsm.workoutLog?.id;

                  final bool? confirmed = await showDialog<bool>(
                    context: context,
                    builder: (ctx) => AlertDialog(
                      title: Text(l10n.discard_button),
                      content: Text(l10n.dialogFinishWorkoutBody),
                      actions: [
                        TextButton(
                            onPressed: () => Navigator.pop(ctx, false),
                            child: Text(l10n.cancel)),
                        FilledButton(
                            onPressed: () => Navigator.pop(ctx, true),
                            child: Text(l10n.discard_button)),
                      ],
                    ),
                  );

                  if (confirmed == true) {
                    if (logId != null) {
                      await WorkoutDatabaseHelper.instance
                          .deleteWorkoutLog(logId);
                    }
                    await wsm.finishWorkout();
                  }
                },
                l10n: l10n,
              ),
            ),
          ),

        // GLASS BOTTOM NAV BAR (deine kombinierte Leiste)

        Positioned(
          bottom: 24,
          left: 16,
          right: 16,
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              // Bottom bar takes the remaining width
              Expanded(
                child: GlassBottomNavBar(
                  currentIndex: _currentIndex,
                  onTap: _onNavigationTapped,
                  onFabTap: _toggleAddMenu, // now ignored by the bar
                  items: [
                    BottomNavigationBarItem(
                      icon: const Icon(Icons.book_outlined),
                      label: l10n.diary,
                    ),
                    BottomNavigationBarItem(
                      icon: const Icon(Icons.fitness_center_outlined),
                      label: l10n.workout,
                    ),
                    const BottomNavigationBarItem(
                      icon: Icon(Icons.bar_chart_outlined),
                      label: 'Stats', //l10n.statistics,
                    ),
                    BottomNavigationBarItem(
                      icon: const Icon(Icons.restaurant_menu_rounded),
                      label: l10n.nutrition, // oder einfach "Nutrition"
                    ),
                  ],
                ),
              ),
              SizedBox(width: kBarFabGap),
              // Detached GlassFab (+)
              GlassFab(
                onPressed: _toggleAddMenu,
                icon: Icons.add,
                // label: null, // keep it square; add a label if you want a pill
              ),
            ],
          ),
        ),

        // SPEED-DIAL (unverändert)
        AnimatedBuilder(
          animation: _menuController,
          builder: (context, _) {
            final v = _safe01(_menuController.value);
            return Offstage(
              offstage: v == 0.0,
              child: IgnorePointer(
                ignoring: v == 0.0,
                child: Stack(
                  children: [
                    Opacity(
                      opacity: v,
                      child: GestureDetector(
                        onTap: () {
                          setState(() {
                            _isAddMenuOpen = false;
                            _menuController.reverse();
                          });
                        },
                        child: BackdropFilter(
                          filter: ImageFilter.blur(
                              sigmaX: 6.0 * v, sigmaY: 6.0 * v),
                          child: Container(
                              color: Colors.black.withOpacity(0.4 * v)),
                        ),
                      ),
                    ),
                    Positioned(
                      bottom: 100.0,
                      right: 20.0,
                      child: Material(
                        color: Colors.transparent,
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.end,
                          children: _getSpeedDialActions(l10n)
                              .asMap()
                              .entries
                              .map((entry) {
                            final index = entry.key;
                            final action = entry.value;
                            final curved = CurvedAnimation(
                              parent: _menuController,
                              curve: Interval(
                                  (index * 0.12).clamp(0.0, 0.95), 1.0,
                                  curve: Curves.easeOutBack),
                            );
                            final tv = _safe01(curved.value);
                            final offsetY = 90.0 * (index + 1);
                            return Transform.translate(
                              offset: Offset(0, (1 - tv) * offsetY),
                              child: Opacity(
                                opacity: tv,
                                child: Padding(
                                  padding: const EdgeInsets.symmetric(
                                      vertical: 10.0),
                                  child: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      Text(
                                        action['label'],
                                        style: TextStyle(
                                          color: Theme.of(context).brightness ==
                                                  Brightness.light
                                              ? Colors.black87
                                              : Colors.white,
                                          fontWeight: FontWeight.bold,
                                          fontSize: 18,
                                        ),
                                      ),
                                      const SizedBox(width: 16),
                                      GestureDetector(
                                        behavior: HitTestBehavior.opaque,
                                        onTap: () {
                                          setState(() {
                                            _isAddMenuOpen = false;
                                            _menuController.reverse();
                                          });
                                          _executeAddMenuAction(
                                              action['action']);
                                        },
                                        child: ClipRRect(
                                          borderRadius:
                                              BorderRadius.circular(20),
                                          child: BackdropFilter(
                                            filter: ImageFilter.blur(
                                                sigmaX: 12, sigmaY: 12),
                                            child: Container(
                                              width: 76,
                                              height: 76,
                                              decoration: BoxDecoration(
                                                color: Colors.white
                                                    .withOpacity(0.15),
                                                borderRadius:
                                                    BorderRadius.circular(20),
                                                border: Border.all(
                                                  color: Colors.white
                                                      .withOpacity(0.3),
                                                  width: 1.5,
                                                ),
                                              ),
                                              child: Icon(
                                                action['icon'],
                                                size: 34,
                                                color: Colors.white,
                                              ),
                                            ),
                                          ),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ),
                            );
                          }).toList(),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      ],
    );
  }

  Widget _profileAppBarButton(BuildContext context) {
    final profileService = Provider.of<ProfileService>(context, listen: false);

    return Padding(
      // ⬇️ Abstand analog zu SummaryCard
      padding: const EdgeInsets.only(right: DesignConstants.screenPaddingHorizontal),
      child: InkWell(
        customBorder: const CircleBorder(),
        onTap: () {
          Navigator.of(context).push(
            MaterialPageRoute(builder: (_) => const ProfileScreen()),
          );
        },
        child: CircleAvatar(
          radius: 18,
          backgroundColor: Colors.grey.shade300,
          backgroundImage: (profileService.profileImagePath != null)
              ? FileImage(File(profileService.profileImagePath!))
              : null,
          child: (profileService.profileImagePath == null)
              ? const Icon(Icons.person, size: 20, color: Colors.black54)
              : null,
        ),
      ),
    );
  }
}

class _FrostedBar extends StatelessWidget {
  final Widget child;
  const _FrostedBar({required this.child});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final bg = isDark ? summary_card_dark_mode : summary_card_white_mode;

    return ClipRRect(
      borderRadius: BorderRadius.circular(20),
      child: BackdropFilter(
        filter: ImageFilter.blur(sigmaX: 12, sigmaY: 12),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
          decoration: BoxDecoration(
            color: bg.withOpacity(0.80),
            borderRadius: BorderRadius.circular(20),
            border: Border.all(
              color: isDark
                  ? Colors.white.withOpacity(0.30)
                  : Colors.black.withOpacity(0.10),
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                blurRadius: 12,
                offset: const Offset(0, 6),
                // ignore: deprecated_member_use
                color: Colors.black.withOpacity(0.3),
              ),
            ],
          ),
          child: child,
        ),
      ),
    );
  }
}

class _RunningWorkoutRow extends StatelessWidget {
  final String timeText;
  final VoidCallback onContinue;
  final VoidCallback onDiscard;
  final AppLocalizations l10n;

  const _RunningWorkoutRow({
    required this.timeText,
    required this.onContinue,
    required this.onDiscard,
    required this.l10n,
  });

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;

    return Row(
      children: [
        Expanded(
          child: Row(
            children: [
              const Icon(Icons.timer_outlined, size: 20),
              const SizedBox(width: 6),
              Text(
                timeText,
                style: TextStyle(
                  fontSize: 16,
                  color:
                      Theme.of(context).colorScheme.onSurface.withOpacity(0.9),
                  decoration: TextDecoration.none, // ← remove underline
                  fontFeatures: const [FontFeature.tabularFigures()],
                ),
              ),
            ],
          ),
        ),
        FilledButton(
          onPressed: onContinue,
          style: FilledButton.styleFrom(
            backgroundColor: cs.primary,
            foregroundColor: cs.onPrimary,
            minimumSize: const Size(0, 36),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(10),
            ),
          ),
          child: Text(l10n.continue_workout_button),
        ),
        const SizedBox(width: 8),
        FilledButton(
          onPressed: onDiscard,
          style: FilledButton.styleFrom(
            backgroundColor: cs.error,
            foregroundColor: cs.onError,
            minimumSize: const Size(0, 36),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(10),
            ),
          ),
          child: Text(l10n.discard_button),
        ),
      ],
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/exercise_mapping_screen.dart =====

// lib/screens/exercise_mapping_screen.dart
import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/screens/exercise_catalog_screen.dart';
import 'package:lightweight/util/design_constants.dart';

class ExerciseMappingScreen extends StatefulWidget {
  final List<String> unknownNames;
  const ExerciseMappingScreen({super.key, required this.unknownNames});

  @override
  State<ExerciseMappingScreen> createState() => _ExerciseMappingScreenState();
}

class _ExerciseMappingScreenState extends State<ExerciseMappingScreen> {
  final Map<String, Exercise> _selection = {};
  bool _applying = false;

  Future<void> _pickTarget(String sourceName) async {
    final Exercise? picked = await Navigator.of(context).push(
      MaterialPageRoute(
          builder: (_) => const ExerciseCatalogScreen(isSelectionMode: true)),
    );
    if (picked != null && mounted) {
      setState(() => _selection[sourceName] = picked);
    }
  }

  Future<void> _apply() async {
    if (_selection.isEmpty) {
      Navigator.of(context).pop(false);
      return;
    }
    setState(() => _applying = true);
    final mapping = <String, String>{
      for (final e in _selection.entries)
        e.key: e.value.nameDe.isNotEmpty ? e.value.nameDe : e.value.nameEn,
    };
    await WorkoutDatabaseHelper.instance.applyExerciseNameMapping(mapping);
    if (mounted) {
      setState(() => _applying = false);
      Navigator.of(context).pop(true);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    return Scaffold(
      appBar: AppBar(title: Text(l10n.mapExercisesTitle)),
      body: Column(
        children: [
          const SizedBox(height: DesignConstants.spacingS),
          Expanded(
            child: ListView.builder(
              itemCount: widget.unknownNames.length,
              itemBuilder: (context, index) {
                final src = widget.unknownNames[index];
                final picked = _selection[src];
                return ListTile(
                  title: Text(src),
                  subtitle: picked == null
                      ? Text(l10n.noSelection)
                      : Text('→ ${picked.nameDe} / ${picked.nameEn}'),
                  trailing: TextButton.icon(
                    icon: const Icon(Icons.search),
                    label: Text(l10n.selectButton),
                    onPressed: () => _pickTarget(src),
                  ),
                );
              },
            ),
          ),
          SafeArea(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                  onPressed: _applying ? null : _apply,
                  icon: _applying
                      ? const SizedBox(
                          width: 16,
                          height: 16,
                          child: CircularProgressIndicator(strokeWidth: 2))
                      : const Icon(Icons.check),
                  label: Text(
                      _applying ? l10n.applyingChanges : l10n.applyMapping),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/goals_screen.dart =====

// lib/screens/goals_screen.dart

import 'package:flutter/material.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/generated/app_localizations.dart';

class GoalsScreen extends StatefulWidget {
  const GoalsScreen({super.key});

  @override
  State<GoalsScreen> createState() => _GoalsScreenState();
}

class _GoalsScreenState extends State<GoalsScreen> {
  final _formKey = GlobalKey<FormState>();
  bool _isLoading = true;

  final _caloriesController = TextEditingController();
  final _proteinController = TextEditingController();
  final _carbsController = TextEditingController();
  final _fatController = TextEditingController();
  final _waterController = TextEditingController();
  final _heightController = TextEditingController();
  final _sugarController = TextEditingController();
  final _fiberController = TextEditingController();
  final _saltController = TextEditingController();

  double _proteinPercent = 40;
  double _carbsPercent = 40;
  double _fatPercent = 20;

  // KORREKTUR: Farben zentral definieren, passend zum NutritionSummaryWidget
  final Map<String, Color> _macroColors = {
    'protein': Colors.red.shade400,
    'carbs': Colors.green.shade400,
    'fat': Colors.purple.shade300,
  };

  @override
  void initState() {
    super.initState();
    _loadSettings();
    _caloriesController.addListener(_recalculateGramsFromSliders);
  }

  @override
  void dispose() {
    _caloriesController.removeListener(_recalculateGramsFromSliders);
    _caloriesController.dispose();
    _proteinController.dispose();
    _carbsController.dispose();
    _fatController.dispose();
    _waterController.dispose();
    _heightController.dispose();
    _sugarController.dispose();
    _fiberController.dispose();
    _saltController.dispose();
    super.dispose();
  }

  Future<void> _loadSettings() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _heightController.text = (prefs.getInt('userHeight') ?? 180).toString();
      _caloriesController.text =
          (prefs.getInt('targetCalories') ?? 2500).toString();
      _proteinController.text =
          (prefs.getInt('targetProtein') ?? 180).toString();
      _carbsController.text = (prefs.getInt('targetCarbs') ?? 250).toString();
      _fatController.text = (prefs.getInt('targetFat') ?? 80).toString();
      _waterController.text = (prefs.getInt('targetWater') ?? 3000).toString();
      _sugarController.text = (prefs.getInt('targetSugar') ?? 50).toString();
      _fiberController.text = (prefs.getInt('targetFiber') ?? 30).toString();
      _saltController.text = (prefs.getInt('targetSalt') ?? 6).toString();
      _isLoading = false;
    });
  }

  Future<void> _saveSettings() async {
    final isValid = _formKey.currentState?.validate() ?? false;
    if (!isValid) return;
    final prefs = await SharedPreferences.getInstance();

    await prefs.setInt('userHeight', int.parse(_heightController.text));
    await prefs.setInt('targetCalories', int.parse(_caloriesController.text));
    await prefs.setInt('targetProtein', int.parse(_proteinController.text));
    await prefs.setInt('targetCarbs', int.parse(_carbsController.text));
    await prefs.setInt('targetFat', int.parse(_fatController.text));
    await prefs.setInt('targetWater', int.parse(_waterController.text));
    await prefs.setInt('targetSugar', int.parse(_sugarController.text));
    await prefs.setInt('targetFiber', int.parse(_fiberController.text));
    await prefs.setInt('targetSalt', int.parse(_saltController.text));

    if (mounted) {
      final l10n = AppLocalizations.of(context)!;
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(l10n.snackbarGoalsSaved)));
      Navigator.of(context).pop();
    }
  }

  void _recalculateGramsFromSliders() {
    final totalCalories = int.tryParse(_caloriesController.text) ?? 0;
    if (totalCalories <= 0) return;

    final proteinGrams = (totalCalories * (_proteinPercent / 100)) / 4;
    final carbsGrams = (totalCalories * (_carbsPercent / 100)) / 4;
    final fatGrams = (totalCalories * (_fatPercent / 100)) / 9;

    _proteinController.text = proteinGrams.round().toString();
    _carbsController.text = carbsGrams.round().toString();
    _fatController.text = fatGrams.round().toString();
  }

  Widget _buildMacroCalculator() {
    final l10n = AppLocalizations.of(context)!;
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context)
            .colorScheme
            .surfaceContainerHighest
            .withOpacity(0.3),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        children: [
          Text(l10n.macroDistribution,
              style: Theme.of(context).textTheme.titleMedium),
          _buildMacroSliderRow(
              l10n.protein, _proteinPercent, _macroColors['protein']!),
          _buildMacroSliderRow(
              l10n.carbs, _carbsPercent, _macroColors['carbs']!),
          _buildMacroSliderRow(l10n.fat, _fatPercent, _macroColors['fat']!),
        ],
      ),
    );
  }

  void _updateSliderValues(String changedMacro, double value) {
    setState(() {
      if (changedMacro == 'protein') {
        _proteinPercent = value;
      } else if (changedMacro == 'carbs') {
        _carbsPercent = value;
      } else if (changedMacro == 'fat') {
        _fatPercent = value;
      }

      double sum = _proteinPercent + _carbsPercent + _fatPercent;
      if (sum.round() != 100) {
        double diff = 100 - sum;
        if (changedMacro == 'protein') {
          _carbsPercent += diff / 2;
          _fatPercent += diff / 2;
        } else if (changedMacro == 'carbs') {
          _proteinPercent += diff / 2;
          _fatPercent += diff / 2;
        } else {
          _proteinPercent += diff / 2;
          _carbsPercent += diff / 2;
        }
      }

      // Clamp values between 0 and 100
      _proteinPercent = _proteinPercent.clamp(0, 100);
      _carbsPercent = _carbsPercent.clamp(0, 100);
      _fatPercent = _fatPercent.clamp(0, 100);
    });
    _recalculateGramsFromSliders();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(
        title: Text(
          l10n.my_goals,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
        // KORREKTUR: Save-Button in die AppBar verschoben
        actions: [
          TextButton(
            onPressed: _saveSettings,
            child: Text(
              l10n.buttonSave,
              style: TextStyle(
                color: Theme.of(context).colorScheme.primary,
                fontWeight: FontWeight.bold,
              ),
            ),
          )
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
              padding: DesignConstants.cardPadding,
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Text(l10n.personalData,
                        style: Theme.of(context).textTheme.headlineSmall),
                    const SizedBox(height: DesignConstants.spacingL),
                    _buildSettingsField(
                        controller: _heightController,
                        label: l10n.profileUserHeight),
                    const SizedBox(height: DesignConstants.spacingXL),
                    Text(l10n.profileDailyGoals,
                        style: Theme.of(context).textTheme.headlineSmall),
                    const SizedBox(height: DesignConstants.spacingL),
                    _buildSettingsField(
                        controller: _caloriesController, label: l10n.calories),
                    const SizedBox(height: DesignConstants.spacingL),
                    _buildMacroCalculator(),
                    const SizedBox(height: DesignConstants.spacingL),
                    _buildSettingsField(
                        controller: _proteinController, label: l10n.protein),
                    _buildSettingsField(
                        controller: _carbsController, label: l10n.carbs),
                    _buildSettingsField(
                        controller: _fatController, label: l10n.fat),
                    _buildSettingsField(
                        controller: _waterController, label: l10n.water),
                    const SizedBox(height: DesignConstants.spacingXL),
                    Text(l10n.detailedNutrientGoals, // HIER DIE ÄNDERUNG
                        style: Theme.of(context).textTheme.headlineSmall),
                    const SizedBox(height: DesignConstants.spacingL),
                    _buildSettingsField(
                        controller: _sugarController, label: l10n.sugar),
                    _buildSettingsField(
                        controller: _fiberController, label: l10n.fiber),
                    _buildSettingsField(
                        controller: _saltController, label: l10n.salt),

                    // KORREKTUR: Der untere Button wurde entfernt
                  ],
                ),
              ),
            ),
    );
  }

  // KORREKTUR: Das ist die neue Methode zum Stylen der Slider
  Widget _buildMacroSliderRow(String macro, double value, Color color) {
    return Row(
      children: [
        SizedBox(width: 70, child: Text("${macro.capitalize()}:")),
        Expanded(
          child: SliderTheme(
            data: SliderTheme.of(context).copyWith(
              trackHeight: 12.0, // Dicke des Sliders
              thumbShape: const RoundSliderThumbShape(
                  enabledThumbRadius: 8.0), // Kleinerer Kreis
              overlayShape: const RoundSliderOverlayShape(overlayRadius: 16.0),
              activeTrackColor: color, // Farbe für den aktiven Teil
              inactiveTrackColor: color.withOpacity(0.2), // Hintergrundfarbe
              thumbColor: color, // Farbe des Kreises
              trackShape:
                  const RoundedRectSliderTrackShape(), // Abgerundete Ecken
            ),
            child: Slider(
              value: value,
              min: 0,
              max: 100,
              label: '${value.round()}%',
              onChanged: (newValue) {
                _updateSliderValues(macro, newValue);
              },
            ),
          ),
        ),
        SizedBox(
            width: 50,
            child: Text("${value.round()}%", textAlign: TextAlign.right)),
      ],
    );
  }

  Widget _buildSettingsField(
      {required TextEditingController controller, required String label}) {
    final l10n = AppLocalizations.of(context)!;
    return Padding(
      padding: const EdgeInsets.only(bottom: 12.0),
      child: TextFormField(
        controller: controller,
        decoration: InputDecoration(labelText: label),
        keyboardType: TextInputType.number,
        validator: (value) {
          if (value == null || value.isEmpty || num.tryParse(value) == null) {
            return l10n.validatorPleaseEnterNumber;
          }
          return null;
        },
      ),
    );
  }
}

extension StringExtension on String {
  String capitalize() {
    if (isEmpty) return this;
    return "${this[0].toUpperCase()}${substring(1)}";
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/create_supplement_screen.dart =====

// lib/screens/create_supplement_screen.dart
import 'package:flutter/material.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/util/util_convert.dart';

class CreateSupplementScreen extends StatefulWidget {
  final Supplement? supplementToEdit;
  const CreateSupplementScreen({super.key, this.supplementToEdit});

  @override
  State<CreateSupplementScreen> createState() => _CreateSupplementScreenState();
}

class _CreateSupplementScreenState extends State<CreateSupplementScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _doseController = TextEditingController();
  final _unitController = TextEditingController();
  final _goalController = TextEditingController();
  final _limitController = TextEditingController();
  final _notesController = TextEditingController();

  late final l10n = AppLocalizations.of(context)!;

  bool get _isEditing => widget.supplementToEdit != null;

  late String _unit; // NEU

  @override
  void initState() {
    super.initState();
    if (_isEditing) {
      final s = widget.supplementToEdit!;
      _nameController.text = s.name;
      _doseController.text = s.defaultDose.toString();
      _goalController.text = s.dailyGoal?.toString() ?? '';
      _limitController.text = s.dailyLimit?.toString() ?? '';
      _notesController.text = s.notes ?? '';
      _unit = s.unit; // NEU: verlässlich aus dem Datensatz
    } else {
      _unit = 'mg'; // Default bei Neuanlage
    }
  }

  Future<void> _saveSupplement() async {
    if (!_formKey.currentState!.validate()) return;

    final editing = _isEditing ? widget.supplementToEdit : null;
    final bool isBuiltinCaffeine =
        (editing?.isBuiltin == true) && (editing?.code == 'caffeine');

    // Einheit festlegen/absichern
    String unitToSave = isBuiltinCaffeine ? 'mg' : _unit;

    final newSupplement = Supplement(
      id: editing?.id,
      code: editing?.code, // bei Edit beibehalten; bei New null
      name: _nameController.text.trim(),
      defaultDose:
          double.tryParse(_doseController.text.replaceAll(',', '.')) ?? 0.0,
      unit: unitToSave,
      dailyGoal: _goalController.text.trim().isEmpty
          ? null
          : double.tryParse(_goalController.text.replaceAll(',', '.')),
      dailyLimit: _limitController.text.trim().isEmpty
          ? null
          : double.tryParse(_limitController.text.replaceAll(',', '.')),
      notes: _notesController.text.trim().isEmpty
          ? null
          : _notesController.text.trim(),
      isBuiltin: editing?.isBuiltin ?? false,
    );

    if (_isEditing) {
      await DatabaseHelper.instance.updateSupplement(newSupplement);
    } else {
      await DatabaseHelper.instance.insertSupplement(newSupplement);
    }

    if (!mounted) return;
    Navigator.of(context).pop(true);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    // NEU: Caffeine-Lock bestimmen
    final s = widget.supplementToEdit;
    final bool isBuiltinCaffeine =
        (s?.isBuiltin == true) && (s?.code == 'caffeine');

    return Scaffold(
      appBar: AppBar(
        title: Text(
          _isEditing ? l10n.edit : l10n.createSupplementTitle,
          style: Theme.of(context)
              .textTheme
              .titleLarge
              ?.copyWith(fontWeight: FontWeight.w900),
        ),
        actions: [
          TextButton(
            onPressed: _saveSupplement,
            child: Text(
              l10n.save,
              style: TextStyle(
                color: Theme.of(context).colorScheme.primary,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: DesignConstants.cardPadding,
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              _buildTextField(_nameController, l10n.supplementNameLabel,
                  isRequired: true),
              const SizedBox(height: DesignConstants.spacingL),
              Row(
                children: [
                  Expanded(
                    child: _buildTextField(
                      _doseController,
                      l10n.defaultDoseLabel,
                      isNumeric: true,
                    ),
                  ),
                  const SizedBox(width: DesignConstants.spacingM),

                  // <- Wichtig: begrenzen!
                  Expanded(
                    child: DropdownButtonFormField<String>(
                      initialValue: _unit,
                      items: allowedUnits
                          .map((u) => DropdownMenuItem<String>(
                              value: u, child: Text(u)))
                          .toList(),
                      onChanged: isBuiltinCaffeine
                          ? null
                          : (val) {
                              if (val == null) return;
                              setState(() => _unit = val);
                            },
                      decoration: InputDecoration(
                        labelText: l10n.unitLabel,
                        isDense: true, // optional, macht's kompakter
                        helperText:
                            isBuiltinCaffeine ? l10n.caffeineUnitLocked : null,
                      ),
                      validator: (val) {
                        if (val == null || val.isEmpty) {
                          return l10n.fieldRequired;
                        }
                        if (!allowedUnits.contains(val)) {
                          return l10n.unitNotSupported;
                        }
                        return null;
                      },
                    ),
                  ),
                ],
              ),
              const SizedBox(height: DesignConstants.spacingXL),
              _buildTextField(_goalController, l10n.dailyGoalLabel,
                  isNumeric: true),
              const SizedBox(height: DesignConstants.spacingL),
              _buildTextField(_limitController, l10n.dailyLimitLabel,
                  isNumeric: true),
              const SizedBox(height: DesignConstants.spacingL),
              _buildTextField(_notesController, l10n.notesLabel, maxLines: 3),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTextField(
    TextEditingController controller,
    String label, {
    bool isRequired = false,
    bool isNumeric = false,
    int? maxLines = 1,
  }) {
    return TextFormField(
      controller: controller,
      decoration: InputDecoration(labelText: label),
      keyboardType: isNumeric
          ? const TextInputType.numberWithOptions(decimal: true)
          : TextInputType.text,
      maxLines: maxLines,
      validator: (value) {
        if (isRequired && (value == null || value.trim().isEmpty)) {
          return l10n.validatorPleaseEnterName;
        }
        if (isNumeric &&
            value != null &&
            value.isNotEmpty &&
            double.tryParse(value.replaceAll(',', '.')) == null) {
          return l10n.validatorPleaseEnterNumber;
        }
        return null;
      },
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/meal_editor_screen.dart =====

import 'package:flutter/material.dart';

enum MealType { breakfast, lunch, dinner, snack }

class MealEditorScreen extends StatefulWidget {
  final String? initialName;
  final MealType initialType;

  const MealEditorScreen({
    super.key,
    this.initialName,
    this.initialType = MealType.lunch,
  });

  @override
  State<MealEditorScreen> createState() => _MealEditorScreenState();
}

class _MealEditorScreenState extends State<MealEditorScreen> {
  late final TextEditingController _nameCtrl;
  late MealType _type;
  bool _saving = false;

  bool get _canSave =>
      !_saving && _nameCtrl.text.trim().isNotEmpty; // simpel & robust

  @override
  void initState() {
    super.initState();
    _nameCtrl = TextEditingController(text: widget.initialName ?? '');
    _type = widget.initialType;
    _nameCtrl.addListener(() => setState(() {})); // Button-State aktualisieren
  }

  @override
  void dispose() {
    _nameCtrl.dispose();
    super.dispose();
  }

  Future<void> _onSave() async {
    if (!_canSave) return;
    setState(() => _saving = true);

    try {
      // 🔗 HIER später: Repo/DB call (insert/update).
      // Für jetzt: einfach Erfolg simulieren und zurück.
      await Future.delayed(const Duration(milliseconds: 150));
      if (mounted) Navigator.pop(context, true);
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Fehler beim Speichern: $e')),
      );
      setState(() => _saving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Meal bearbeiten'),
        actions: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
            child: ElevatedButton(
              onPressed: _canSave ? _onSave : null,
              child: _saving
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Text('Speichern'),
            ),
          ),
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          TextField(
            controller: _nameCtrl,
            textInputAction: TextInputAction.done,
            decoration: const InputDecoration(
              labelText: 'Meal-Name',
              hintText: 'z. B. Hähnchen Bowl',
            ),
            onSubmitted: (_) => _onSave(),
          ),
          const SizedBox(height: 12),
          DropdownButtonFormField<MealType>(
            initialValue: _type,
            onChanged: (v) => setState(() => _type = v ?? _type),
            decoration: const InputDecoration(labelText: 'Meal-Typ'),
            items: MealType.values
                .map((t) => DropdownMenuItem(
                      value: t,
                      child: Text(_label(t)),
                    ))
                .toList(),
          ),
          const SizedBox(height: 24),
          // Platzhalter: später Zutaten/Per-Ingredient Anzeige
          Card(
            child: ListTile(
              title: const Text('Zutaten'),
              subtitle: const Text('Noch keine – kommt später'),
              trailing: IconButton(
                icon: const Icon(Icons.add),
                onPressed: () {
                  // später: Produktpicker öffnen
                },
              ),
            ),
          ),
        ],
      ),
    );
  }
}

String _label(MealType t) {
  switch (t) {
    case MealType.breakfast:
      return 'Frühstück';
    case MealType.lunch:
      return 'Mittag';
    case MealType.dinner:
      return 'Abend';
    case MealType.snack:
      return 'Snack';
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/create_exercise_screen.dart =====

// lib/screens/create_exercise_screen.dart
import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/design_constants.dart';

class CreateExerciseScreen extends StatefulWidget {
  const CreateExerciseScreen({super.key});
  @override
  State<CreateExerciseScreen> createState() => _CreateExerciseScreenState();
}

class _CreateExerciseScreenState extends State<CreateExerciseScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _categoryController = TextEditingController();

  // State-Variablen für die getrennten Logiken
  List<String> _allCategories = []; // Für das Autocomplete-Feld
  List<String> _allMuscleGroups = []; // Für die Chip-Auswahl
  final List<String> _selectedPrimaryMuscles = [];
  final List<String> _selectedSecondaryMuscles = [];
  bool _isLoading = true;

  late final l10n = AppLocalizations.of(context)!;

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  @override
  void dispose() {
    _nameController.dispose();
    _descriptionController.dispose();
    _categoryController.dispose();
    super.dispose();
  }

  // Lädt BEIDE Listen: Kategorien und alle einzelnen Muskeln
  Future<void> _loadData() async {
    final db = WorkoutDatabaseHelper.instance;
    final categories = await db.getAllCategories();
    final muscles = await db.getAllMuscleGroups();
    if (mounted) {
      setState(() {
        _allCategories = categories;
        _allMuscleGroups = muscles;
        _isLoading = false;
      });
    }
  }

  void _saveExercise() async {
    if (_formKey.currentState!.validate()) {
      final newExercise = Exercise(
        nameDe: _nameController.text.trim(),
        nameEn: _nameController.text.trim(),
        descriptionDe: _descriptionController.text.trim(),
        descriptionEn: _descriptionController.text.trim(),
        // Getrennte Zuweisung der Daten
        categoryName: _categoryController.text.trim(),
        primaryMuscles: _selectedPrimaryMuscles,
        secondaryMuscles: _selectedSecondaryMuscles,
      );

      await WorkoutDatabaseHelper.instance.insertExercise(newExercise);
      if (mounted) Navigator.of(context).pop(true);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.create_exercise_screen_title),
        actions: [
          TextButton(
            onPressed: _saveExercise,
            child: Text(
              l10n.save,
              style: TextStyle(
                color: Theme.of(context).colorScheme.primary,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
              padding: DesignConstants.cardPadding,
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    TextFormField(
                      controller: _nameController,
                      decoration:
                          InputDecoration(labelText: l10n.exercise_name_label),
                      validator: (value) =>
                          value == null || value.trim().isEmpty
                              ? l10n.validatorPleaseEnterName
                              : null,
                    ),
                    const SizedBox(height: DesignConstants.spacingL),

                    // Feld für die Kategorie (z.B. "Chest")
                    Autocomplete<String>(
                      optionsBuilder: (TextEditingValue textEditingValue) {
                        if (textEditingValue.text == '') {
                          return const Iterable<String>.empty();
                        }
                        return _allCategories.where((String option) {
                          return option
                              .toLowerCase()
                              .contains(textEditingValue.text.toLowerCase());
                        });
                      },
                      onSelected: (String selection) {
                        _categoryController.text = selection;
                      },
                      fieldViewBuilder: (context, textEditingController,
                          focusNode, onFieldSubmitted) {
                        _categoryController.value = textEditingController.value;
                        return TextFormField(
                          controller: textEditingController,
                          focusNode: focusNode,
                          decoration: InputDecoration(
                            labelText: l10n.category_label,
                            hintText: l10n.categoryHint,
                          ),
                          validator: (value) {
                            if (value == null || value.trim().isEmpty) {
                              return l10n.validatorPleaseEnterCategory;
                            }
                            return null;
                          },
                        );
                      },
                    ),

                    const SizedBox(height: DesignConstants.spacingL),
                    TextFormField(
                      controller: _descriptionController,
                      decoration: InputDecoration(
                          labelText: l10n.description_optional_label),
                      maxLines: 3,
                    ),
                    const SizedBox(height: DesignConstants.spacingXL),

                    // Auswahl für primäre Muskeln (z.B. "Pectoralis Major")
                    _buildMuscleSelection(
                      title: l10n.primary_muscles_label,
                      allMuscles: _allMuscleGroups,
                      selectedMuscles: _selectedPrimaryMuscles,
                    ),
                    const SizedBox(height: DesignConstants.spacingXL),

                    // Auswahl für sekundäre Muskeln
                    _buildMuscleSelection(
                      title: l10n.secondary_muscles_label,
                      allMuscles: _allMuscleGroups,
                      selectedMuscles: _selectedSecondaryMuscles,
                    ),
                  ],
                ),
              ),
            ),
    );
  }

  Widget _buildMuscleSelection({
    required String title,
    required List<String> allMuscles,
    required List<String> selectedMuscles,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title, style: Theme.of(context).textTheme.titleMedium),
        const SizedBox(height: DesignConstants.spacingS),
        Wrap(
          spacing: 8.0,
          runSpacing: 4.0,
          children: allMuscles.map((muscle) {
            final isSelected = selectedMuscles.contains(muscle);
            return FilterChip(
              label: Text(muscle),
              selected: isSelected,
              onSelected: (bool selected) {
                setState(() {
                  if (selected) {
                    selectedMuscles.add(muscle);
                  } else {
                    selectedMuscles.remove(muscle);
                  }
                });
              },
            );
          }).toList(),
        ),
      ],
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/workout_summary_screen.dart =====

// lib/screens/workout_summary_screen.dart

import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/workout_summary_bar.dart';

class WorkoutSummaryScreen extends StatefulWidget {
  final int logId;

  const WorkoutSummaryScreen({super.key, required this.logId});

  @override
  State<WorkoutSummaryScreen> createState() => _WorkoutSummaryScreenState();
}

class _WorkoutSummaryScreenState extends State<WorkoutSummaryScreen> {
  bool _isLoading = true;
  WorkoutLog? _log;
  Map<String, double> _volumePerExercise = {};

  @override
  void initState() {
    super.initState();
    _loadWorkoutDetails();
  }

  Future<void> _loadWorkoutDetails() async {
    final data =
        await WorkoutDatabaseHelper.instance.getWorkoutLogById(widget.logId);

    if (data != null) {
      final Map<String, double> volumeMap = {};
      for (var set in data.sets) {
        final volume = (set.weightKg ?? 0) * (set.reps ?? 0);
        volumeMap.update(set.exerciseName, (value) => value + volume,
            ifAbsent: () => volume);
      }

      if (mounted) {
        setState(() {
          _log = data;
          _volumePerExercise = volumeMap;
          _isLoading = false;
        });
      }
    } else {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final textTheme = Theme.of(context).textTheme;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        automaticallyImplyLeading: false, // Verhindert den Zurück-Pfeil
        title: Text(l10n.workoutSummaryTitle,
            style: textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w900)),
        elevation: 0,
        backgroundColor: Colors.transparent,
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _log == null
              ? Center(child: Text(l10n.workoutNotFound))
              : Padding(
                  padding: DesignConstants.cardPadding,
                  child: Column(
                    children: [
                      // Gesamt-Statistiken
                      WorkoutSummaryBar(
                        duration: _log!.endTime?.difference(_log!.startTime),
                        volume:
                            _volumePerExercise.values.fold(0, (a, b) => a + b),
                        sets: _log!.sets.length,
                        progress: null,
                      ),
                      const SizedBox(height: DesignConstants.spacingXL),

                      // Liste der Übungen
                      Expanded(
                        child: ListView(
                          children: [
                            Text(l10n.workoutSummaryExerciseOverview,
                                style: textTheme.titleMedium),
                            const SizedBox(height: DesignConstants.spacingS),
                            ..._volumePerExercise.entries.map((entry) {
                              return SummaryCard(
                                child: ListTile(
                                  title: Text(entry.key,
                                      style: const TextStyle(
                                          fontWeight: FontWeight.bold)),
                                  trailing: Text(
                                      "${entry.value.toStringAsFixed(0)} kg",
                                      style: textTheme.bodyLarge),
                                ),
                              );
                            }),
                          ],
                        ),
                      ),
                      const SizedBox(height: DesignConstants.spacingXL),

                      // Fertig-Button
                      SizedBox(
                        width: double.infinity,
                        child: ElevatedButton(
                          style: ElevatedButton.styleFrom(
                            padding: const EdgeInsets.symmetric(vertical: 16),
                          ),
                          onPressed: () {
                            // Schließt den Summary-Screen und kehrt zum vorherigen Screen zurück
                            // (vermutlich der Routines- oder Home-Screen)
                            Navigator.of(context).pop();
                          },
                          child: Text(l10n.doneButtonLabel,
                              style: const TextStyle(fontSize: 18)),
                        ),
                      ),
                    ],
                  ),
                ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/theme/app_colors.dart =====

import 'package:flutter/material.dart';

@immutable
class AppSurfaces extends ThemeExtension<AppSurfaces> {
  final Color summaryCard;
  const AppSurfaces({required this.summaryCard});

  @override
  AppSurfaces copyWith({Color? summaryCard}) =>
      AppSurfaces(summaryCard: summaryCard ?? this.summaryCard);

  @override
  AppSurfaces lerp(ThemeExtension<AppSurfaces>? other, double t) {
    if (other is! AppSurfaces) return this;
    return AppSurfaces(
      summaryCard: Color.lerp(summaryCard, other.summaryCard, t)!,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/theme/color_constants.dart =====

// lib/theme/color_constants.dart

import 'package:flutter/material.dart';

const Color summary_card_dark_mode =
    Color.fromARGB(255, 40, 40, 40); // tiefes Grau für Dark Mode
const Color summary_card_white_mode =
    Color.fromARGB(255, 235, 235, 235); // sehr helles Grau für Light Mode


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/dialogs/fluid_dialog_content.dart =====

// lib/dialogs/fluid_dialog_content.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/design_constants.dart';

class FluidDialogContent extends StatefulWidget {
  final int? initialQuantity;
  final DateTime? initialTimestamp;

  const FluidDialogContent({
    super.key,
    this.initialQuantity,
    this.initialTimestamp,
  });

  @override
  FluidDialogContentState createState() => FluidDialogContentState();
}

class FluidDialogContentState extends State<FluidDialogContent> {
  late final TextEditingController _nameController;
  late final TextEditingController _quantityController;
  late final TextEditingController _caffeineController;
  late final TextEditingController _sugarController;
  late DateTime _selectedDateTime;

  String get nameText => _nameController.text;
  String get quantityText => _quantityController.text;
  String get caffeineText => _caffeineController.text;
  String get sugarText => _sugarController.text;
  DateTime get selectedDateTime => _selectedDateTime;

  @override
  void initState() {
    super.initState();
    _nameController = TextEditingController(text: 'Water');
    _quantityController =
        TextEditingController(text: widget.initialQuantity?.toString() ?? '');
    _caffeineController = TextEditingController();
    _sugarController = TextEditingController();
    _selectedDateTime = widget.initialTimestamp ?? DateTime.now();
  }

  @override
  void dispose() {
    _nameController.dispose();
    _quantityController.dispose();
    _caffeineController.dispose();
    _sugarController.dispose();
    super.dispose();
  }

  Future<void> _selectDate() async {
    final locale = Localizations.localeOf(context);
    final DateTime? picked = await showDatePicker(
        context: context,
        initialDate: _selectedDateTime,
        firstDate: DateTime(2020),
        lastDate: DateTime.now().add(const Duration(days: 365)),
        locale: locale);
    if (picked != null && picked != _selectedDateTime) {
      setState(() {
        _selectedDateTime = DateTime(picked.year, picked.month, picked.day,
            _selectedDateTime.hour, _selectedDateTime.minute);
      });
    }
  }

  Future<void> _selectTime() async {
    final TimeOfDay? picked = await showTimePicker(
        context: context,
        initialTime: TimeOfDay.fromDateTime(_selectedDateTime));
    if (picked != null) {
      setState(() {
        _selectedDateTime = DateTime(
            _selectedDateTime.year,
            _selectedDateTime.month,
            _selectedDateTime.day,
            picked.hour,
            picked.minute);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).toString();
    final formattedDate = DateFormat.yMd(locale).format(_selectedDateTime);
    final formattedTime = DateFormat.Hm(locale).format(_selectedDateTime);

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        TextField(
            controller: _nameController,
            decoration: const InputDecoration(labelText: 'Name'),
            autofocus: true),
        const SizedBox(height: DesignConstants.spacingL),
        TextField(
            controller: _quantityController,
            keyboardType: TextInputType.number,
            decoration: InputDecoration(
                labelText: l10n.amount_in_milliliters, suffixText: 'ml'),
            autofocus: true),
        const SizedBox(height: DesignConstants.spacingL),
        TextField(
          controller: _sugarController,
          keyboardType:
              const TextInputType.numberWithOptions(decimal: true),
          decoration: InputDecoration(
              labelText: '${l10n.sugar} (g / 100ml)',
              suffixText: 'g'),
        ),
        const SizedBox(height: DesignConstants.spacingL),
        TextField(
          controller: _caffeineController,
          keyboardType:
              const TextInputType.numberWithOptions(decimal: true),
          decoration: InputDecoration(
              labelText: l10n.caffeinePrompt,
              suffixText: 'mg / 100ml'),
        ),
        const SizedBox(height: DesignConstants.spacingL),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            TextButton.icon(
              icon: const Icon(Icons.calendar_today, size: 20),
              label: Text(formattedDate, style: const TextStyle(fontSize: 16)),
              onPressed: _selectDate,
            ),
            TextButton.icon(
              icon: const Icon(Icons.access_time, size: 20),
              label: Text(formattedTime, style: const TextStyle(fontSize: 16)),
              onPressed: _selectTime,
            ),
          ],
        ),
      ],
    );
  }
}

===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/dialogs/water_dialog_content.dart =====

// lib/dialogs/water_dialog_content.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/design_constants.dart';

class WaterDialogContent extends StatefulWidget {
  final int? initialQuantity;
  final DateTime? initialTimestamp;

  const WaterDialogContent(
      {super.key, this.initialQuantity, this.initialTimestamp});
  @override
  WaterDialogContentState createState() => WaterDialogContentState();
}

class WaterDialogContentState extends State<WaterDialogContent> {
  late final TextEditingController _textController;
  late DateTime _selectedDateTime;
  late final l10n = AppLocalizations.of(context)!;

  String get quantityText => _textController.text;
  DateTime get selectedDateTime => _selectedDateTime;

  @override
  void initState() {
    super.initState();
    _textController =
        TextEditingController(text: widget.initialQuantity?.toString() ?? '');
    _selectedDateTime = widget.initialTimestamp ?? DateTime.now();
  }

  @override
  void dispose() {
    _textController.dispose();
    super.dispose();
  }

  Future<void> _selectDate() async {
    final DateTime? picked = await showDatePicker(
        context: context,
        initialDate: _selectedDateTime,
        firstDate: DateTime(2020),
        lastDate: DateTime.now());
    if (picked != null && picked != _selectedDateTime) {
      setState(() {
        _selectedDateTime = DateTime(picked.year, picked.month, picked.day,
            _selectedDateTime.hour, _selectedDateTime.minute);
      });
    }
  }

  Future<void> _selectTime() async {
    final TimeOfDay? picked = await showTimePicker(
        context: context,
        initialTime: TimeOfDay.fromDateTime(_selectedDateTime));
    if (picked != null) {
      setState(() {
        _selectedDateTime = DateTime(
            _selectedDateTime.year,
            _selectedDateTime.month,
            _selectedDateTime.day,
            picked.hour,
            picked.minute);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final formattedDate = DateFormat('dd.MM.yyyy').format(_selectedDateTime);
    final formattedTime = DateFormat.Hm().format(_selectedDateTime);
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        TextField(
            controller: _textController,
            keyboardType: TextInputType.number,
            decoration: InputDecoration(
                labelText: l10n.amount_in_milliliters, suffixText: 'ml'),
            autofocus: true),
        const SizedBox(height: DesignConstants.spacingL),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            InkWell(
                onTap: _selectDate,
                child: Padding(
                    padding: DesignConstants.cardMargin,
                    child: Row(children: [
                      const Icon(Icons.calendar_today, size: 20),
                      const SizedBox(width: 8),
                      Text(formattedDate, style: const TextStyle(fontSize: 16))
                    ]))),
            InkWell(
                onTap: _selectTime,
                child: Padding(
                    padding: DesignConstants.cardMargin,
                    child: Row(children: [
                      const Icon(Icons.access_time, size: 20),
                      const SizedBox(width: 8),
                      Text(formattedTime, style: const TextStyle(fontSize: 16))
                    ]))),
          ],
        ),
      ],
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/dialogs/log_supplement_dialog_content.dart =====

// lib/dialogs/log_supplement_dialog_content.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/util/design_constants.dart';

class LogSupplementDialogContent extends StatefulWidget {
  final Supplement supplement;
  final double? initialDose;
  final DateTime? initialTimestamp;

  const LogSupplementDialogContent(
      {super.key,
      required this.supplement,
      this.initialDose,
      this.initialTimestamp});

  @override
  LogSupplementDialogContentState createState() =>
      LogSupplementDialogContentState();
}

class LogSupplementDialogContentState
    extends State<LogSupplementDialogContent> {
  late final TextEditingController _doseController;
  late DateTime _selectedDateTime;

  // Getter für den Zugriff von außen
  String get doseText => _doseController.text;
  DateTime get selectedDateTime => _selectedDateTime;

  @override
  void initState() {
    super.initState();
    _doseController = TextEditingController(
        text: widget.initialDose?.toStringAsFixed(1).replaceAll('.0', '') ??
            widget.supplement.defaultDose
                .toStringAsFixed(1)
                .replaceAll('.0', ''));
    _selectedDateTime = widget.initialTimestamp ?? DateTime.now();
  }

  @override
  void dispose() {
    _doseController.dispose();
    super.dispose();
  }

  Future<void> _selectDate() async {
    final DateTime? picked = await showDatePicker(
        context: context,
        initialDate: _selectedDateTime,
        firstDate: DateTime(2020),
        lastDate: DateTime.now());
    if (picked != null && picked != _selectedDateTime) {
      setState(() {
        _selectedDateTime = DateTime(picked.year, picked.month, picked.day,
            _selectedDateTime.hour, _selectedDateTime.minute);
      });
    }
  }

  Future<void> _selectTime() async {
    final TimeOfDay? picked = await showTimePicker(
        context: context,
        initialTime: TimeOfDay.fromDateTime(_selectedDateTime));
    if (picked != null) {
      setState(() {
        _selectedDateTime = DateTime(
            _selectedDateTime.year,
            _selectedDateTime.month,
            _selectedDateTime.day,
            picked.hour,
            picked.minute);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!; // Holen der l10n Instanz
    final formattedDate = DateFormat('dd.MM.yyyy').format(_selectedDateTime);
    final formattedTime = DateFormat.Hm().format(_selectedDateTime);
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        TextFormField(
            controller: _doseController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            decoration: InputDecoration(
                labelText: l10n.doseLabel, // LOKALISIERT
                suffixText: widget.supplement.unit),
            autofocus: true),
        const SizedBox(height: DesignConstants.spacingL),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            InkWell(
                onTap: _selectDate,
                child: Padding(
                    padding: DesignConstants.cardMargin,
                    child: Row(children: [
                      const Icon(Icons.calendar_today, size: 20),
                      const SizedBox(width: 8),
                      Text(formattedDate, style: const TextStyle(fontSize: 16))
                    ]))),
            InkWell(
                onTap: _selectTime,
                child: Padding(
                    padding: DesignConstants.cardMargin,
                    child: Row(children: [
                      const Icon(Icons.access_time, size: 20),
                      const SizedBox(width: 8),
                      Text(formattedTime, style: const TextStyle(fontSize: 16))
                    ]))),
          ],
        ),
      ],
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/dialogs/log_supplement_menu.dart =====


import 'package:flutter/material.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/dialogs/log_supplement_dialog_content.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';

class LogSupplementMenu extends StatefulWidget {
  const LogSupplementMenu({super.key, required this.close});

  final VoidCallback close;

  @override
  State<LogSupplementMenu> createState() => _LogSupplementMenuState();
}

class _LogSupplementMenuState extends State<LogSupplementMenu> {
  Supplement? _selected;
  List<Supplement> _supplements = [];
  final _doseKey = GlobalKey<LogSupplementDialogContentState>();

  @override
  void initState() {
    super.initState();
    _loadSupplements();
  }

  Future<void> _loadSupplements() async {
    final supplements = await DatabaseHelper.instance.getAllSupplements();
    if (mounted) {
      setState(() {
        _supplements = supplements;
      });
    }
  }

  String localizeSupplementName(Supplement s, AppLocalizations l10n) {
    switch (s.code) {
      case 'caffeine':
        return l10n.supplement_caffeine;
      case 'creatine_monohydrate':
        return l10n.supplement_creatine_monohydrate;
      default:
        return s.name;
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    if (_selected == null) {
      return _buildSupplementList(l10n);
    } else {
      return _buildDoseView(l10n);
    }
  }

  Widget _buildSupplementList(AppLocalizations l10n) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        ..._supplements.map((s) => Padding(
              padding: const EdgeInsets.symmetric(vertical: 6, horizontal: 4),
              child: Material(
                color: Colors.white.withOpacity(
                  Theme.of(context).brightness == Brightness.dark ? 0.06 : 0.08,
                ),
                borderRadius: BorderRadius.circular(16),
                child: InkWell(
                  borderRadius: BorderRadius.circular(16),
                  onTap: () => setState(() => _selected = s),
                  child: Padding(
                    padding:
                        const EdgeInsets.symmetric(horizontal: 14, vertical: 12),
                    child: Row(
                      children: [
                        const Icon(Icons.medication_outlined),
                        const SizedBox(width: 12),
                        Expanded(child: Text(localizeSupplementName(s, l10n))),
                        const Icon(Icons.chevron_right_rounded),
                      ],
                    ),
                  ),
                ),
              ),
            )),
        const SizedBox(height: 12),
        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: widget.close,
                child: Text(l10n.cancel),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildDoseView(AppLocalizations l10n) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Align(
          alignment: Alignment.centerLeft,
          child: Text(
            localizeSupplementName(_selected!, l10n),
            style: Theme.of(context)
                .textTheme
                .titleMedium
                ?.copyWith(fontWeight: FontWeight.w700),
          ),
        ),
        const SizedBox(height: 8),
        LogSupplementDialogContent(
          key: _doseKey,
          supplement: _selected!,
        ),
        const SizedBox(height: 12),
        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: () => setState(() => _selected = null),
                child: Text(l10n.onbBack),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: FilledButton(
                onPressed: () async {
                  final st = _doseKey.currentState;
                  if (st == null) return;
                  final dose =
                      double.tryParse(st.doseText.replaceAll(',', '.'));
                  if (dose == null || dose <= 0) return;

                  final log = SupplementLog(
                    supplementId: _selected!.id!,
                    dose: dose,
                    unit: _selected!.unit,
                    timestamp: st.selectedDateTime,
                  );
                  await DatabaseHelper.instance.insertSupplementLog(log);
                  widget.close();
                  // This is a bit of a hack, but it's the easiest way to refresh the home screen
                  // without a more complex state management solution.
                  // Consider using a provider or riverpod to manage the state of the home screen.
                  // _refreshHomeScreen(); 
                },
                child: Text(l10n.add_button),
              ),
            ),
          ],
        ),
      ],
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/dialogs/quantity_dialog_content.dart =====

// lib/dialogs/quantity_dialog_content.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/util/design_constants.dart';

class QuantityDialogContent extends StatefulWidget {
  final FoodItem item;
  final int? initialQuantity;
  final DateTime? initialTimestamp;
  final String? initialMealType;

  const QuantityDialogContent({
    super.key,
    required this.item,
    this.initialQuantity,
    this.initialTimestamp,
    this.initialMealType,
  });

  @override
  QuantityDialogContentState createState() => QuantityDialogContentState();
}

class QuantityDialogContentState extends State<QuantityDialogContent> {
  late final TextEditingController _quantityController;
  late final TextEditingController _caffeineController;
  late final TextEditingController _sugarController;
  late DateTime _selectedDateTime;
  final List<String> _mealTypes = [
    "mealtypeBreakfast",
    "mealtypeLunch",
    "mealtypeDinner",
    "mealtypeSnack"
  ];
  late String _selectedMealType;
  late bool _isLiquid;

  // Public Getters
  String get quantityText => _quantityController.text;
  String get caffeineText => _caffeineController.text;
  String get sugarText => _sugarController.text;
  DateTime get selectedDateTime => _selectedDateTime;
  String get selectedMealType => _selectedMealType;
  bool get isLiquid => _isLiquid;

  @override
  void initState() {
    super.initState();
    _quantityController =
        TextEditingController(text: widget.initialQuantity?.toString() ?? '100');
    _sugarController = TextEditingController(
        text: widget.item.sugar?.toStringAsFixed(1).replaceAll('.0', '') ?? '');
    _caffeineController = TextEditingController(
        text: widget.item.caffeineMgPer100ml
                ?.toStringAsFixed(1)
                .replaceAll('.0', '') ??
            '');
    _selectedDateTime = widget.initialTimestamp ?? DateTime.now();
    _selectedMealType = widget.initialMealType ?? "mealtypeSnack";
    _isLiquid = widget.item.isLiquid ?? false;
  }

  @override
  void dispose() {
    _quantityController.dispose();
    _caffeineController.dispose();
    _sugarController.dispose();
    super.dispose();
  }

  Future<void> _selectDate() async {
    final locale = Localizations.localeOf(context);
    final DateTime? picked = await showDatePicker(
        context: context,
        initialDate: _selectedDateTime,
        firstDate: DateTime(2020),
        lastDate: DateTime.now().add(const Duration(days: 365)),
        locale: locale);
    if (picked != null && picked != _selectedDateTime) {
      setState(() {
        _selectedDateTime = DateTime(picked.year, picked.month, picked.day,
            _selectedDateTime.hour, _selectedDateTime.minute);
      });
    }
  }

  Future<void> _selectTime() async {
    final TimeOfDay? picked = await showTimePicker(
        context: context,
        initialTime: TimeOfDay.fromDateTime(_selectedDateTime));
    if (picked != null) {
      setState(() {
        _selectedDateTime = DateTime(
            _selectedDateTime.year,
            _selectedDateTime.month,
            _selectedDateTime.day,
            picked.hour,
            picked.minute);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).toString();
    final formattedDate = DateFormat.yMd(locale).format(_selectedDateTime);
    final formattedTime = DateFormat.Hm(locale).format(_selectedDateTime);
    final unit = _isLiquid ? 'ml' : 'g';

    String getLocalizedMealName(String key) {
      switch (key) {
        case "mealtypeBreakfast": return l10n.mealtypeBreakfast;
        case "mealtypeLunch": return l10n.mealtypeLunch;
        case "mealtypeDinner": return l10n.mealtypeDinner;
        case "mealtypeSnack": return l10n.mealtypeSnack;
        default: return "Snack";
      }
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        TextField(
            controller: _quantityController,
            keyboardType: TextInputType.number,
            decoration: InputDecoration(
                labelText: _isLiquid ? l10n.amount_in_milliliters : l10n.amount_in_grams,
                suffixText: unit),
            autofocus: true),
        const SizedBox(height: DesignConstants.spacingL),
        DropdownButtonFormField<String>(
          value: _selectedMealType,
          decoration: InputDecoration(labelText: l10n.meal_label),
          items: _mealTypes.map((String key) {
            return DropdownMenuItem<String>(
              value: key,
              child: Text(getLocalizedMealName(key)),
            );
          }).toList(),
          onChanged: (String? newValue) {
            if (newValue != null) setState(() => _selectedMealType = newValue);
          },
        ),
        const SizedBox(height: DesignConstants.spacingL),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            TextButton.icon(
              icon: const Icon(Icons.calendar_today, size: 20),
              label: Text(formattedDate, style: const TextStyle(fontSize: 16)),
              onPressed: _selectDate,
            ),
            TextButton.icon(
              icon: const Icon(Icons.access_time, size: 20),
              label: Text(formattedTime, style: const TextStyle(fontSize: 16)),
              onPressed: _selectTime,
            ),
          ],
        ),
        const Divider(height: 24),
        SwitchListTile(
          title: Text(l10n.add_to_water_intake),
          value: _isLiquid,
          onChanged: (bool value) => setState(() => _isLiquid = value),
          contentPadding: EdgeInsets.zero,
        ),
        if (_isLiquid) ...[
          const SizedBox(height: DesignConstants.spacingS),
          TextFormField(
            controller: _sugarController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            decoration: InputDecoration(
              labelText: '${l10n.sugar} (g / 100ml)',
              suffixText: 'g',
            ),
          ),
          const SizedBox(height: DesignConstants.spacingL),
          TextFormField(
            controller: _caffeineController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            decoration: InputDecoration(
              labelText: l10n.caffeinePrompt,
              suffixText: 'mg / 100ml',
            ),
          ),
        ]
      ],
    );
  }
}

===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/data/database_helper.dart =====

// lib/data/database_helper.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:lightweight/models/fluid_entry.dart';
import 'package:lightweight/models/measurement.dart';
import 'package:lightweight/models/measurement_session.dart';
import '../models/food_entry.dart';
import '../models/chart_data_point.dart';
import '../models/supplement.dart';
import '../models/supplement_log.dart';

class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._init();
  static Database? _database;
  DatabaseHelper._init();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB('vita_user.db');
    return _database!;
  }

  Future<Database> _initDB(String fileName) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, fileName);
    return await openDatabase(
      path,
      version: 19,
      onConfigure: (db) async {
        await db.execute('PRAGMA foreign_keys = ON');
      },
      onCreate: _createDB,
      onUpgrade: _upgradeDB,
    );
  }

  Future<void> _createDB(Database db, int version) async {
    // --- Kern-Tabellen ---
    await db.execute('''
    CREATE TABLE IF NOT EXISTS food_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      barcode TEXT NOT NULL,
      timestamp TEXT NOT NULL,
      quantity_in_grams INTEGER NOT NULL,
      meal_type TEXT NOT NULL DEFAULT "mealtypeSnack",
      sugar_in_grams REAL
    )
  ''');

    // *** KORRIGIERTER BLOCK FÜR fluid_entries ***
    await db.execute('''
    CREATE TABLE IF NOT EXISTS fluid_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      timestamp TEXT NOT NULL,
      quantity_in_ml INTEGER NOT NULL,
      name TEXT NOT NULL,
      kcal INTEGER,
      sugar_per_100ml REAL,
      carbs_per_100ml REAL,
      caffeine_per_100ml REAL,
      linked_food_entry_id INTEGER -- DIESE ZEILE WURDE HINZUGEFÜGT
    )
  ''');
    // *** ENDE DES KORRIGIERTEN BLOCKS ***

    await db.execute('''
    CREATE TABLE IF NOT EXISTS favorites (
      barcode TEXT PRIMARY KEY
    )
  ''');

    await db.execute('''
    CREATE TABLE IF NOT EXISTS measurement_sessions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      timestamp TEXT NOT NULL
    )
  ''');

    await db.execute('''
    CREATE TABLE IF NOT EXISTS measurements (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      session_id INTEGER NOT NULL,
      type TEXT NOT NULL,
      value REAL NOT NULL,
      unit TEXT NOT NULL,
      FOREIGN KEY (session_id) REFERENCES measurement_sessions(id) ON DELETE CASCADE
    )
  ''');

    await db.execute('''
    CREATE TABLE IF NOT EXISTS supplements (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      code TEXT,
      name TEXT NOT NULL,
      default_dose REAL NOT NULL,
      unit TEXT NOT NULL,
      daily_goal REAL,
      daily_limit REAL,
      notes TEXT,
      is_builtin INTEGER NOT NULL DEFAULT 0
    )
  ''');
    
    // *** KORRIGIERTER BLOCK FÜR supplement_logs ***
    await db.execute('''
    CREATE TABLE IF NOT EXISTS supplement_logs (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      supplement_id INTEGER NOT NULL,
      dose REAL NOT NULL,
      unit TEXT NOT NULL,
      timestamp TEXT NOT NULL,
      source_food_entry_id INTEGER,
      source_fluid_entry_id INTEGER, -- DIESE ZEILE WURDE HINZUGEFÜGT
      FOREIGN KEY (supplement_id) REFERENCES supplements(id) ON DELETE CASCADE,
      FOREIGN KEY (source_food_entry_id) REFERENCES food_entries(id) ON DELETE SET NULL,
      FOREIGN KEY (source_fluid_entry_id) REFERENCES fluid_entries(id) ON DELETE CASCADE
    )
  ''');
    // *** ENDE DES KORRIGIERTEN BLOCKS ***

    await db.execute('''
    CREATE TABLE IF NOT EXISTS meals (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      notes TEXT,
      updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
    )
  ''');

    await db.execute('''
    CREATE TABLE IF NOT EXISTS meal_items (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      meal_id INTEGER NOT NULL,
      barcode TEXT NOT NULL,
      quantity_in_grams INTEGER NOT NULL,
      FOREIGN KEY (meal_id) REFERENCES meals(id) ON DELETE CASCADE
    )
  ''');

    // --- Indizes (NACH den Tabellen) ---
    await db.execute(
        'CREATE UNIQUE INDEX IF NOT EXISTS idx_supplements_code ON supplements(code)');
    await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_food_entries_timestamp ON food_entries(timestamp)');
    await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_food_entries_mealtype_ts ON food_entries(meal_type, timestamp)');
    await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_fluid_entries_timestamp ON fluid_entries(timestamp)');
    await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_supplement_logs_timestamp ON supplement_logs(timestamp)');
    await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_supplement_logs_supplement ON supplement_logs(supplement_id)');

    // --- Built-ins einmalig einfüllen (idempotent) ---
    final caffeRows = await db.query(
      'supplements',
      where: 'code = ?',
      whereArgs: ['caffeine'],
      limit: 1,
    );
    if (caffeRows.isEmpty) {
      await db.insert('supplements', {
        'code': 'caffeine',
        'name': 'Caffeine',
        'default_dose': 100,
        'unit': 'mg',
        'daily_limit': 400,
        'is_builtin': 1,
      });
    }

    final creaRows = await db.query(
      'supplements',
      where: 'code = ?',
      whereArgs: ['creatine_monohydrate'],
      limit: 1,
    );
    if (creaRows.isEmpty) {
      await db.insert('supplements', {
        'code': 'creatine_monohydrate',
        'name': 'Creatine Monohydrate',
        'default_dose': 5,
        'unit': 'g',
        'daily_goal': 5,
        'is_builtin': 0,
      });
    }

    print('Benutzer-DB (v$version) neu erstellt: Tabellen & Indizes angelegt.');
  }
  Future<void> _upgradeDB(Database db, int oldVersion, int newVersion) async {
    // Dieser Block bringt alte Versionen Schritt für Schritt auf den neuesten Stand.
    if (oldVersion < 2) {
      await db.execute('''
      CREATE TABLE IF NOT EXISTS fluid_entries (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp TEXT NOT NULL,
        quantity_in_ml INTEGER NOT NULL,
        name TEXT NOT NULL,
        kcal INTEGER,
        sugar_per_100ml REAL,
        carbs_per_100ml REAL,
        caffeine_per_100ml REAL
      )
    ''');
    }
    if (oldVersion < 4) {
      await db.execute('CREATE TABLE favorites (barcode TEXT PRIMARY KEY)');
    }
    if (oldVersion < 5) {
      await db.execute(
          'ALTER TABLE food_entries ADD COLUMN meal_type TEXT NOT NULL DEFAULT "Snack"');
    }

    // Upgrade von jedem Zustand vor v9 auf v9 (bereinigt alle alten Measurement-Tabellen)
    if (oldVersion < 9) {
      // Lösche alle möglichen alten Versionen der Tabellen, um sicherzugehen.
      await db.execute('DROP TABLE IF EXISTS measurements');
      await db.execute('DROP TABLE IF EXISTS measurement_sessions');
      // Erstelle die Tabellen in der korrekten, finalen Struktur.
      await db.execute(
          'CREATE TABLE measurement_sessions (id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp TEXT NOT NULL)');
      await db.execute(
          'CREATE TABLE measurements (id INTEGER PRIMARY KEY AUTOINCREMENT, session_id INTEGER NOT NULL, type TEXT NOT NULL, value REAL NOT NULL, unit TEXT NOT NULL, FOREIGN KEY (session_id) REFERENCES measurement_sessions(id) ON DELETE CASCADE)');
      print(
          "Datenbank auf Version 9 aktualisiert: Measurement-Tabellen sauber erstellt.");
    }
    // NEU: Upgrade auf Version 10
    if (oldVersion < 10) {
      await db.execute(
          'CREATE TABLE supplements (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, default_dose REAL NOT NULL, unit TEXT NOT NULL, daily_goal REAL, daily_limit REAL, notes TEXT)');
      await db.execute(
          'CREATE TABLE supplement_logs (id INTEGER PRIMARY KEY AUTOINCREMENT, supplement_id INTEGER NOT NULL, dose REAL NOT NULL, unit TEXT NOT NULL, timestamp TEXT NOT NULL, FOREIGN KEY (supplement_id) REFERENCES supplements(id) ON DELETE CASCADE)');

      await db.insert('supplements', {
        'name': 'Caffeine',
        'default_dose': 100,
        'unit': 'mg',
        'daily_limit': 400
      });
      await db.insert('supplements', {
        'name': 'Creatine Monohydrate',
        'default_dose': 5,
        'unit': 'g',
        'daily_goal': 5
      });
      print(
          "Datenbank auf Version 10 aktualisiert: Supplement-Tabellen hinzugefügt.");
    }
    // Upgrade auf Version 11
    if (oldVersion < 11) {
      // 1) Spalten ergänzen (ALTER kann fehlschlagen, falls bereits vorhanden – deshalb try/catch)
      try {
        await db.execute(
            'ALTER TABLE supplements ADD COLUMN is_builtin INTEGER NOT NULL DEFAULT 0');
      } catch (_) {}
      try {
        await db.execute(
            'ALTER TABLE supplement_logs ADD COLUMN source_food_entry_id INTEGER');
      } catch (_) {}

      // 2) Caffeine absichern/vereinheitlichen
      final rows = await db.query('supplements',
          where: 'name = ?', whereArgs: ['Caffeine'], limit: 1);
      if (rows.isEmpty) {
        await db.insert('supplements', {
          'name': 'Caffeine',
          'default_dose': 100,
          'unit': 'mg',
          'daily_limit': 400,
          'is_builtin': 1,
        });
      } else {
        await db.update(
            'supplements',
            {
              'unit': 'mg',
              'is_builtin': 1,
            },
            where: 'name = ?',
            whereArgs: ['Caffeine']);
      }

      print(
          "Datenbank auf Version 11 aktualisiert: builtin-Flag & FoodEntry-Link für Supplements.");
    }
// Upgrade auf Version 12
    if (oldVersion < 12) {
      try {
        await db.execute('ALTER TABLE supplements ADD COLUMN code TEXT');
      } catch (_) {}
      try {
        await db.execute(
            'CREATE UNIQUE INDEX IF NOT EXISTS idx_supplements_code ON supplements(code)');
      } catch (_) {}

      // Backfill Codes für bestehende Einträge
      // Caffeine
      final caff = await db.query('supplements',
          where: 'name = ?', whereArgs: ['Caffeine'], limit: 1);
      if (caff.isNotEmpty) {
        await db.update(
            'supplements', {'code': 'caffeine', 'is_builtin': 1, 'unit': 'mg'},
            where: 'id = ?', whereArgs: [caff.first['id']]);
      }
      // Creatine
      final crea = await db.query('supplements',
          where: 'name LIKE ?', whereArgs: ['Creatine%'], limit: 1);
      if (crea.isNotEmpty) {
        await db.update('supplements', {'code': 'creatine_monohydrate'},
            where: 'id = ?', whereArgs: [crea.first['id']]);
      }

      print("DB v12: supplements.code hinzugefügt & befüllt.");
    }
// Upgrade auf Version 13: Indizes nachziehen
    if (oldVersion < 13) {
      await db.execute(
          'CREATE UNIQUE INDEX IF NOT EXISTS idx_supplements_code ON supplements(code)');
      await db.execute(
          'CREATE INDEX IF NOT EXISTS idx_food_entries_timestamp ON food_entries(timestamp)');
      await db.execute(
          'CREATE INDEX IF NOT EXISTS idx_fluid_entries_timestamp ON fluid_entries(timestamp)');
      await db.execute(
          'CREATE INDEX IF NOT EXISTS idx_supp_logs_ts ON supplement_logs(timestamp)');
      await db.execute(
          'CREATE INDEX IF NOT EXISTS idx_supp_logs_supp ON supplement_logs(supplement_id)');
      print("DB v13: Performance-Indizes erstellt.");
    }
    // Upgrade auf Version 14: Mahlzeiten
    if (oldVersion < 14) {
      // food_entries
      await db.execute('''
      CREATE TABLE IF NOT EXISTS food_entries (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        barcode TEXT NOT NULL,
        timestamp TEXT NOT NULL,
        quantity_in_grams INTEGER NOT NULL,
        meal_type TEXT NOT NULL DEFAULT "mealtypeSnack"
      )
    ''');

      // fluid_entries
      await db.execute('''
      CREATE TABLE IF NOT EXISTS fluid_entries (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp TEXT NOT NULL,
        quantity_in_ml INTEGER NOT NULL,
        name TEXT NOT NULL,
        kcal INTEGER,
        sugar_per_100ml REAL,
        carbs_per_100ml REAL,
        caffeine_per_100ml REAL
      )
    ''');

      // favorites
      await db.execute('''
      CREATE TABLE IF NOT EXISTS favorites (
        barcode TEXT PRIMARY KEY
      )
    ''');

      // measurements
      await db.execute('''
      CREATE TABLE IF NOT EXISTS measurement_sessions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp TEXT NOT NULL
      )
    ''');
      await db.execute('''
      CREATE TABLE IF NOT EXISTS measurements (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id INTEGER NOT NULL,
        type TEXT NOT NULL,
        value REAL NOT NULL,
        unit TEXT NOT NULL,
        FOREIGN KEY (session_id) REFERENCES measurement_sessions(id) ON DELETE CASCADE
      )
    ''');

      // supplements
      await db.execute('''
      CREATE TABLE IF NOT EXISTS supplements (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        code TEXT,
        name TEXT NOT NULL,
        default_dose REAL NOT NULL,
        unit TEXT NOT NULL,
        daily_goal REAL,
        daily_limit REAL,
        notes TEXT,
        is_builtin INTEGER NOT NULL DEFAULT 0
      )
    ''');

      await db.execute('''
      CREATE TABLE IF NOT EXISTS supplement_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        supplement_id INTEGER NOT NULL,
        dose REAL NOT NULL,
        unit TEXT NOT NULL,
        timestamp TEXT NOT NULL,
        source_food_entry_id INTEGER,
        FOREIGN KEY (supplement_id) REFERENCES supplements(id) ON DELETE CASCADE,
        FOREIGN KEY (source_food_entry_id) REFERENCES food_entries(id) ON DELETE CASCADE
      )
    ''');

      // meals
      await db.execute('''
      CREATE TABLE IF NOT EXISTS meals (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        notes TEXT,
        updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
      )
    ''');
      await db.execute('''
      CREATE TABLE IF NOT EXISTS meal_items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        meal_id INTEGER NOT NULL,
        barcode TEXT NOT NULL,
        quantity_in_grams INTEGER NOT NULL,
        FOREIGN KEY (meal_id) REFERENCES meals(id) ON DELETE CASCADE
      )
    ''');

      // Indizes
      await db.execute(
          'CREATE UNIQUE INDEX IF NOT EXISTS idx_supplements_code ON supplements(code)');
      await db.execute(
          'CREATE INDEX IF NOT EXISTS idx_food_entries_timestamp ON food_entries(timestamp)');
      await db.execute(
          'CREATE INDEX IF NOT EXISTS idx_food_entries_mealtype_ts ON food_entries(meal_type, timestamp)');
      await db.execute(
          'CREATE INDEX IF NOT EXISTS idx_fluid_entries_timestamp ON fluid_entries(timestamp)');
      await db.execute(
          'CREATE INDEX IF NOT EXISTS idx_supplement_logs_timestamp ON supplement_logs(timestamp)');
      await db.execute(
          'CREATE INDEX IF NOT EXISTS idx_supplement_logs_supplement ON supplement_logs(supplement_id)');

            debugPrint('Catch-up: Tabellen + Indizes bis v14 sichergestellt.');

          }

    if (oldVersion < 15) {
      try {
        await db.execute('ALTER TABLE food_entries ADD COLUMN sugar_in_grams REAL');
      } catch (_) {}
      debugPrint("DB v15: food_entries.sugar_in_grams added.");
    }
    if (oldVersion < 16) {
      try {
        await db.execute('ALTER TABLE fluid_entries ADD COLUMN carbs_per_100ml REAL');
      } catch (_) {}
      debugPrint("DB v16: fluid_entries.carbs_per_100ml added.");
    }
        if (oldVersion < 17) {
      try {
        await db.execute('ALTER TABLE supplement_logs ADD COLUMN source_fluid_entry_id INTEGER');
      } catch (_) {}
      debugPrint("DB v17: supplement_logs.source_fluid_entry_id added.");
    }
    if (oldVersion < 18) {
      try {
        await db.execute('ALTER TABLE supplement_logs ADD COLUMN source_fluid_entry_id INTEGER');
        // Füge die Fremdschlüsselbeziehung hinzu, falls sie nicht existiert
        // HINWEIS: Das Hinzufügen von Foreign Keys zu einer bestehenden Tabelle ist in SQLite komplex.
        // Für Einfachheit verlassen wir uns auf die Löschlogik in der App.
        // Aber für Neuinstallationen ist der Foreign Key in _createDB korrekt.
      } catch (_) {}
      
      // Korrigiere auch den Foreign Key für food_entries, falls er falsch war
      try {
        await db.execute('DROP INDEX IF EXISTS idx_supp_logs_food_entry'); // Beispiel, falls alter Index existierte
        await db.execute('''
          -- Rekonstruktion der Tabelle, um Foreign Key hinzuzufügen, ist aufwändig.
          -- Stattdessen stellen wir sicher, dass die Logik in der App stimmt.
          -- Die Löschung erfolgt jetzt in der App-Logik (deleteFoodEntry, deleteFluidEntry)
        ''');
      } catch (_) {}
      
      debugPrint("DB v18: supplement_logs.source_fluid_entry_id hinzugefügt und Foreign Keys sichergestellt.");
    }
  
      if (oldVersion < 19) {
      try {
        await db.execute('ALTER TABLE fluid_entries ADD COLUMN linked_food_entry_id INTEGER');
      } catch (_) {}
      debugPrint("DB v19: fluid_entries.linked_food_entry_id added.");
    }
  }
  
  // --- FOOD ENTRIES ---
  Future<int> insertFoodEntry(FoodEntry entry) async {
    final db = await database;
    final id = await db.insert('food_entries', entry.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace);
    print(
        "Neuer FoodEntry erfolgreich in der Benutzer-DB gespeichert (id=$id).");
    return id;
  }

  // Diese Methode ist für den Home Screen. Wir aktualisieren sie auch gleich.
  Future<List<FoodEntry>> getEntriesForDate(DateTime date) async {
    final db = await database;
    final dateString = date.toIso8601String().substring(0, 10);
    final List<Map<String, dynamic>> maps = await db.query(
      'food_entries',
      where: 'timestamp LIKE ?',
      whereArgs: ['$dateString%'],
    );
    return List.generate(maps.length, (i) {
      return FoodEntry(
        id: maps[i]['id'],
        barcode: maps[i]['barcode'],
        timestamp: DateTime.parse(maps[i]['timestamp']),
        quantityInGrams: maps[i]['quantity_in_grams'],
        mealType: maps[i]['meal_type'] ?? 'Snack', // Neues Feld auslesen
      );
    });
  }

  Future<List<FoodEntry>> getEntriesForDateRange(
      DateTime start, DateTime end) async {
    final db = await database;
    final startDateString = DateFormat('yyyy-MM-dd').format(start);
    final endDate = DateTime(end.year, end.month, end.day, 23, 59, 59);
    final endDateString = endDate.toIso8601String();
    final List<Map<String, dynamic>> maps = await db.query(
      'food_entries',
      where: 'timestamp BETWEEN ? AND ?',
      whereArgs: [startDateString, endDateString],
    );
    return List.generate(maps.length, (i) {
      return FoodEntry(
        id: maps[i]['id'],
        barcode: maps[i]['barcode'],
        timestamp: DateTime.parse(maps[i]['timestamp']),
        quantityInGrams: maps[i]['quantity_in_grams'],
        mealType: maps[i]['meal_type'] ?? 'Snack', // Neues Feld auslesen
      );
    });
  }
  Future<void> deleteFoodEntry(int id) async {
    final db = await database;
    await db.transaction((txn) async {
      // Lösche zuerst verknüpfte Supplement-Logs (z.B. Koffein)
      await txn.delete('supplement_logs', where: 'source_food_entry_id = ?', whereArgs: [id]);
      // Lösche dann den verknüpften Fluid-Eintrag (falls vorhanden)
      await txn.delete('fluid_entries', where: 'linked_food_entry_id = ?', whereArgs: [id]);
      // Lösche zuletzt den Food-Eintrag selbst
      await txn.delete('food_entries', where: 'id = ?', whereArgs: [id]);
    });
    print("Eintrag mit ID $id und alle verknüpften Daten erfolgreich gelöscht.");
  }


  // --- FLUID ENTRIES ---
  Future<int> insertFluidEntry(FluidEntry entry) async {
    final db = await database;
    final id = await db.insert('fluid_entries', entry.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace);
    print(
        "Neuer FluidEntry erfolgreich in der Benutzer-DB gespeichert (id=$id).");
    return id;
  }

  Future<List<FluidEntry>> getFluidEntriesForDate(DateTime date) async {
    final db = await database;
    final dateString = date.toIso8601String().substring(0, 10);
    final List<Map<String, dynamic>> maps = await db.query(
      'fluid_entries',
      where: 'timestamp LIKE ?',
      whereArgs: ['$dateString%'],
    );
    return List.generate(maps.length, (i) {
      return FluidEntry.fromMap(maps[i]);
    });
  }

Future<void> deleteFluidEntry(int id) async {
    final db = await database;
    
    // Finde zuerst den Eintrag, um die verknüpfte FoodEntry-ID zu bekommen
    final List<Map<String, dynamic>> maps = await db.query(
      'fluid_entries',
      where: 'id = ?',
      whereArgs: [id],
      limit: 1,
    );

    if (maps.isNotEmpty) {
      final linkedFoodEntryId = maps.first['linked_food_entry_id'] as int?;
      
      if (linkedFoodEntryId != null) {
        // *** DAS IST DER FIX ***
        // Wenn es einen verknüpften FoodEntry gibt, rufen wir dessen Löschmethode auf.
        // Diese kümmert sich um das Löschen von ALLEM (FoodEntry, FluidEntry und SupplementLog).
        await deleteFoodEntry(linkedFoodEntryId);

      } else {
        // Dies ist ein eigenständiger FluidEntry (z.B. "Wasser" oder manueller Proteinshake).
        // Er hat möglicherweise einen eigenen Koffein-Log.
        await db.transaction((txn) async {
          await txn.delete('supplement_logs', where: 'source_fluid_entry_id = ?', whereArgs: [id]);
          await txn.delete('fluid_entries', where: 'id = ?', whereArgs: [id]);
        });
      }
      print("Fluid-Eintrag mit ID $id und alle verknüpften Daten erfolgreich gelöscht.");
    }
  }

  Future<List<FluidEntry>> getFluidEntriesForDateRange(
      DateTime start, DateTime end) async {
    final db = await database;
    final startDateString = DateFormat('yyyy-MM-dd').format(start);
    final endDate = DateTime(end.year, end.month, end.day, 23, 59, 59);
    final endDateString = endDate.toIso8601String();
    final List<Map<String, dynamic>> maps = await db.query(
      'fluid_entries',
      where: 'timestamp BETWEEN ? AND ?',
      whereArgs: [startDateString, endDateString],
    );
    return List.generate(maps.length, (i) {
      return FluidEntry.fromMap(maps[i]);
    });
  }

  Future<void> updateFluidEntry(FluidEntry entry) async {
    final db = await database;
    await db.update(
      'fluid_entries',
      entry.toMap(),
      where: 'id = ?',
      whereArgs: [entry.id],
    );
    print("Fluid-Eintrag mit ID ${entry.id} erfolgreich aktualisiert.");
  }
      // --- FAVORITES ---
  Future<void> addFavorite(String barcode) async {
    final db = await database;
    await db.insert('favorites', {'barcode': barcode});
    print("Favorit $barcode hinzugefügt.");
  }

  Future<void> removeFavorite(String barcode) async {
    final db = await database;
    await db.delete('favorites', where: 'barcode = ?', whereArgs: [barcode]);
    print("Favorit $barcode entfernt.");
  }

  Future<bool> isFavorite(String barcode) async {
    final db = await database;
    final List<Map<String, dynamic>> maps =
        await db.query('favorites', where: 'barcode = ?', whereArgs: [barcode]);
    return maps.isNotEmpty;
  }

  Future<List<String>> getFavoriteBarcodes() async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query('favorites');
    return List.generate(maps.length, (i) => maps[i]['barcode'] as String);
  }

  // DOC: NEUE METHODE für die "Zuletzt verwendet"-Liste
  Future<List<String>> getRecentlyUsedBarcodes() async {
    final db = await database;
    // Dieses SQL-Statement ist etwas komplexer:
    // 1. SELECT DISTINCT barcode: Wähle jeden Barcode nur einmal aus.
    // 2. FROM food_entries: Aus der Tabelle der Einträge.
    // 3. ORDER BY timestamp DESC: Sortiere sie absteigend nach dem Zeitstempel (die neuesten zuerst).
    // 4. LIMIT 20: Gib uns nur die Top 20 zurück.
    final List<Map<String, dynamic>> maps = await db.query(
      'food_entries',
      distinct: true,
      columns: ['barcode'],
      orderBy: 'timestamp DESC',
      limit: 20,
    );
    return List.generate(maps.length, (i) => maps[i]['barcode'] as String);
  }

  // --- MEASUREMENTS (SESSION-BASED) ---
  Future<void> insertMeasurementSession(MeasurementSession session) async {
    final db = await database;
    await db.transaction((txn) async {
      final sessionId = await txn.insert(
        'measurement_sessions',
        {'timestamp': session.timestamp.toIso8601String()},
      );

      for (final measurement in session.measurements) {
        // WICHTIG: Wir erstellen hier eine NEUE Map aus dem Measurement-Objekt,
        // das KEINEN Timestamp mehr hat, und fügen die session_id hinzu.
        final measurementMap = {
          'session_id': sessionId,
          'type': measurement.type,
          'value': measurement.value,
          'unit': measurement.unit,
        };
        await txn.insert('measurements', measurementMap);
      }
    });
    print("Neue Measurement-Session erfolgreich gespeichert.");
  }

  Future<List<MeasurementSession>> getMeasurementSessions() async {
    final db = await database;
    final List<Map<String, dynamic>> sessionMaps = await db.query(
      'measurement_sessions',
      orderBy: 'timestamp DESC',
    );

    if (sessionMaps.isEmpty) return [];

    final List<MeasurementSession> sessions = [];
    for (final sessionMap in sessionMaps) {
      final sessionId = sessionMap['id'] as int;
      final List<Map<String, dynamic>> measurementMaps = await db.query(
        'measurements',
        where: 'session_id = ?',
        whereArgs: [sessionId],
      );

      // Die fromMap-Methode im korrigierten Measurement-Modell wird hier verwendet.
      final measurements =
          measurementMaps.map((map) => Measurement.fromMap(map)).toList();

      sessions.add(MeasurementSession(
        id: sessionId,
        timestamp: DateTime.parse(sessionMap['timestamp'] as String),
        measurements: measurements,
      ));
    }
    return sessions;
  }

  Future<void> deleteMeasurementSession(int id) async {
    final db = await database;
    await db.delete('measurement_sessions', where: 'id = ?', whereArgs: [id]);
    print(
        "Measurement-Session mit ID $id (und zugehörige Messwerte) gelöscht.");
  }

  // --- CHART DATA HELPERS ---

  /// Ruft alle Messwerte eines bestimmten Typs ab und gibt sie als
  /// eine Liste von Datenpunkten für einen Graphen zurück.
  Future<List<ChartDataPoint>> getChartDataForType(String type) async {
    final db = await database;

    // Dies ist eine komplexere SQL-Abfrage. Sie verbindet die beiden Tabellen:
    // Sie holt den 'value' aus der 'measurements'-Tabelle und den zugehörigen
    // 'timestamp' aus der 'measurement_sessions'-Tabelle, filtert nach dem
    // gewünschten Typ und sortiert nach Datum.
    final List<Map<String, dynamic>> maps = await db.rawQuery('''
      SELECT
        s.timestamp,
        m.value
      FROM measurements m
      INNER JOIN measurement_sessions s ON m.session_id = s.id
      WHERE m.type = ?
      ORDER BY s.timestamp ASC 
    ''', [type]);

    if (maps.isEmpty) {
      return [];
    }

    // Wandle das Ergebnis der Datenbankabfrage in unsere saubere ChartDataPoint-Liste um.
    return maps.map((map) {
      return ChartDataPoint(
        date: DateTime.parse(map['timestamp'] as String),
        value: map['value'] as double,
      );
    }).toList();
  }

  Future<List<ChartDataPoint>> getChartDataForTypeAndRange(
      String type, DateTimeRange range) async {
    final db = await database;

    final List<Map<String, dynamic>> maps = await db.rawQuery('''
      SELECT
        s.timestamp,
        m.value
      FROM measurements m
      INNER JOIN measurement_sessions s ON m.session_id = s.id
      WHERE m.type = ? AND s.timestamp BETWEEN ? AND ?
      ORDER BY s.timestamp ASC 
    ''', [
      type,
      range.start.toIso8601String(),
      range.end.toIso8601String(),
    ]);

    if (maps.isEmpty) {
      return [];
    }

    return maps.map((map) {
      return ChartDataPoint(
        date: DateTime.parse(map['timestamp'] as String),
        value: map['value'] as double,
      );
    }).toList();
  }

  Future<void> updateFoodEntry(FoodEntry entry) async {
    final db = await database;
    await db.update(
      'food_entries',
      entry.toMap(),
      where: 'id = ?',
      whereArgs: [entry.id],
    );
    print("Eintrag mit ID ${entry.id} erfolgreich aktualisiert.");
  }

  Future<DateTime?> getEarliestMeasurementDate() async {
    final db = await database;
    final maps = await db.query('measurement_sessions',
        orderBy: 'timestamp ASC', limit: 1);
    if (maps.isNotEmpty) {
      return DateTime.parse(maps.first['timestamp'] as String);
    }
    return null;
  }

  Future<DateTime?> getEarliestFoodEntryDate() async {
    final db = await database;
    final maps =
        await db.query('food_entries', orderBy: 'timestamp ASC', limit: 1);
    if (maps.isNotEmpty) {
      return DateTime.parse(maps.first['timestamp'] as String);
    }
    return null;
  }

  Future<List<FoodEntry>> getAllFoodEntries() async {
    final db = await database;
    final maps = await db.query('food_entries');
    return maps
        .map((map) => FoodEntry(
              id: map['id'] as int?,
              barcode: map['barcode'] as String,
              timestamp: DateTime.parse(map['timestamp'] as String),
              quantityInGrams: map['quantity_in_grams'] as int,
              mealType: map['meal_type'] as String,
            ))
        .toList();
  }

  Future<List<FluidEntry>> getAllFluidEntries() async {
    final db = await database;
    final maps = await db.query('fluid_entries');
    return maps.map((map) => FluidEntry.fromMap(map)).toList();
  }



  Future<void> importUserData({
    required List<FoodEntry> foodEntries,
    required List<FluidEntry> fluidEntries,
    required List<String> favoriteBarcodes,
    required List<MeasurementSession> measurementSessions,
    required List<Supplement> supplements, // NEU
    required List<SupplementLog> supplementLogs, // NEU
  }) async {
    final db = await database;
    await db.transaction((txn) async {
      for (final entry in foodEntries) {
        await txn.insert('food_entries', entry.toMap());
      }
      for (final entry in fluidEntries) {
        await txn.insert('fluid_entries', entry.toMap());
      }
      for (final barcode in favoriteBarcodes) {
        await txn.insert('favorites', {'barcode': barcode});
      }
      for (final session in measurementSessions) {
        // KORREKTUR: Erstellt die Map für die Session direkt hier.
        final sessionId = await txn.insert('measurement_sessions',
            {'timestamp': session.timestamp.toIso8601String()});
        for (final measurement in session.measurements) {
          // KORREKTUR: Erstellt die Map für das Measurement hier und fügt die NEUE sessionId hinzu.
          await txn.insert('measurements', {
            ...measurement.toMap(), // Nutzt die existierende toMap()
            'session_id': sessionId, // Überschreibt mit der neuen ID
          });
        }
      }
    });
  }

  /// Gibt ein Set von Tagen (1-31) zurück, an denen im gegebenen Monat Ernährungseinträge existieren.
  Future<Set<int>> getNutritionLogDaysInMonth(DateTime month) async {
    final db = await database;
    final firstDayOfMonth = DateTime(month.year, month.month, 1);
    final lastDayOfMonth = DateTime(month.year, month.month + 1, 0, 23, 59, 59);

    final maps = await db.query(
      'food_entries',
      columns: ['timestamp'],
      where: 'timestamp BETWEEN ? AND ?',
      whereArgs: [
        firstDayOfMonth.toIso8601String(),
        lastDayOfMonth.toIso8601String()
      ],
    );

    if (maps.isEmpty) return {};

    // Extrahiere den Tag aus jedem Timestamp und füge ihn einem Set hinzu, um Duplikate zu vermeiden.
    return maps
        .map((map) => DateTime.parse(map['timestamp'] as String).day)
        .toSet();
  }

  // --- NEUE METHODEN FÜR SUPPLEMENTS ---

  Future<Supplement> insertSupplement(Supplement supplement) async {
    final db = await database;
    final id = await db.insert('supplements', supplement.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace);
    // Erstelle eine neue Instanz mit der zurückgegebenen ID
    return Supplement(
        id: id,
        name: supplement.name,
        defaultDose: supplement.defaultDose,
        unit: supplement.unit,
        dailyGoal: supplement.dailyGoal,
        dailyLimit: supplement.dailyLimit,
        notes: supplement.notes);
  }

  Future<List<Supplement>> getAllSupplements() async {
    final db = await database;
    final maps = await db.query('supplements', orderBy: 'name ASC');
    return maps.map((map) => Supplement.fromMap(map)).toList();
  }

  Future<void> deleteSupplement(int id) async {
    final db = await database;

    // Built-in blockieren
    final check = await db.query('supplements',
        where: 'id = ?', whereArgs: [id], limit: 1);
    if (check.isNotEmpty && (check.first['is_builtin'] as int? ?? 0) == 1) {
      throw Exception("Built-in supplement can't be deleted.");
    }

    // Logs + Supplement löschen
    await db.transaction((txn) async {
      await txn.delete('supplement_logs',
          where: 'supplement_id = ?', whereArgs: [id]);
      await txn.delete('supplements', where: 'id = ?', whereArgs: [id]);
    });
  }

  Future<SupplementLog> insertSupplementLog(SupplementLog log) async {
    final db = await database;
    final id = await db.insert('supplement_logs', log.toMap());
    return SupplementLog(
        id: id,
        supplementId: log.supplementId,
        dose: log.dose,
        unit: log.unit,
        timestamp: log.timestamp);
  }

  Future<void> updateSupplement(Supplement supplement) async {
    if ((supplement.code == 'caffeine') && supplement.unit != 'mg') {
      throw Exception('Caffeine must be in mg.');
    }
    if (supplement.isBuiltin &&
        supplement.code != null &&
        supplement.code!.isNotEmpty) {
      // Name darf lokalisiert sein, code bleibt
    }
    final db = await database;
    await db.update(
      'supplements',
      supplement.toMap(),
      where: 'id = ?',
      whereArgs: [supplement.id],
    );
  }

  Future<void> updateSupplementLog(SupplementLog log) async {
    final db = await database;
    await db.update(
      'supplement_logs',
      log.toMap(),
      where: 'id = ?',
      whereArgs: [log.id],
    );
    print("Supplement-Log mit ID ${log.id} erfolgreich aktualisiert.");
  }

  Future<List<SupplementLog>> getSupplementLogsForDate(DateTime date) async {
    final db = await database;
    final dateString = date.toIso8601String().substring(0, 10);
    final List<Map<String, dynamic>> maps = await db.query(
      'supplement_logs',
      where: 'timestamp LIKE ?',
      whereArgs: ['$dateString%'],
      orderBy: 'timestamp DESC',
    );
    return maps.map((map) => SupplementLog.fromMap(map)).toList();
  }

  Future<void> deleteSupplementLog(int id) async {
    final db = await database;
    await db.delete('supplement_logs', where: 'id = ?', whereArgs: [id]);
  }

  // FÜR BACKUP
  Future<List<SupplementLog>> getAllSupplementLogs() async {
    final db = await database;
    final maps = await db.query('supplement_logs');
    return maps.map((map) => SupplementLog.fromMap(map)).toList();
  }

  // --- CAFFEINE HELPERS (für Getränke-Autologging) ---

  Future<int> _getCaffeineSupplementId() async {
    final db = await database;
    final r = await db.query('supplements',
        columns: ['id'], where: 'code = ?', whereArgs: ['caffeine'], limit: 1);
    if (r.isEmpty) {
      throw Exception('Caffeine supplement missing');
    }
    return r.first['id'] as int;
  }

  /// Upsert eines Koffein-Logs, verknüpft mit einem FoodEntry.
  /// - caffeinePer100ml: mg pro 100 ml (null => entfernen)
  /// - quantityInMl: Menge des Getränks in ml
  Future<void> upsertCaffeineForFoodEntry({
    required int foodEntryId,
    required DateTime timestamp,
    required double? caffeinePer100ml,
    required double quantityInMl,
  }) async {
    final db = await database;

    // Vorherige (falls vorhanden) löschen
    await db.delete('supplement_logs',
        where: 'source_food_entry_id = ?', whereArgs: [foodEntryId]);

    if (caffeinePer100ml == null) return;

    final caffeineId = await _getCaffeineSupplementId();

    // mg = (mg / 100 ml) * (ml / 100)
    final double doseMg = caffeinePer100ml * (quantityInMl / 100.0);

    await db.insert(
        'supplement_logs',
        {
          'supplement_id': caffeineId,
          'dose': doseMg,
          'unit': 'mg',
          'timestamp': timestamp.toIso8601String(),
          'source_food_entry_id': foodEntryId,
        },
        conflictAlgorithm: ConflictAlgorithm.replace);
  }

  @override
  Future<void> clearAllUserData() async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('food_entries');
      await txn.delete('fluid_entries');
      await txn.delete('favorites');
      await txn.delete('measurements');
      await txn.delete('measurement_sessions');
      await txn.delete('supplement_logs');
      await txn.delete('supplements');
      // Built-ins wiederherstellen
      await txn.insert('supplements', {
        'code': 'caffeine',
        'name': 'Caffeine',
        'default_dose': 100,
        'unit': 'mg',
        'daily_limit': 400,
        'is_builtin': 1,
      });
      await txn.insert('supplements', {
        'code': 'creatine_monohydrate',
        'name': 'Creatine Monohydrate',
        'default_dose': 5,
        'unit': 'g',
        'daily_goal': 5,
        'is_builtin': 0,
      });
    });
  }

  // NEUE METHODE
  Future<Set<int>> getSupplementLogDaysInMonth(DateTime month) async {
    final db = await database;
    final firstDayOfMonth = DateTime(month.year, month.month, 1);
    final lastDayOfMonth = DateTime(month.year, month.month + 1, 0, 23, 59, 59);

    final maps = await db.query(
      'supplement_logs',
      columns: ['timestamp'],
      where: 'timestamp BETWEEN ? AND ?',
      whereArgs: [
        firstDayOfMonth.toIso8601String(),
        lastDayOfMonth.toIso8601String()
      ],
    );

    if (maps.isEmpty) return {};

    return maps
        .map((map) => DateTime.parse(map['timestamp'] as String).day)
        .toSet();
  }
  // --- MEALS API ---

  Future<int> insertMeal({required String name, String? notes}) async {
    final db = await database;
    final now = DateTime.now().toIso8601String();
    return await db.insert('meals', {
      'name': name.trim(),
      'notes': (notes ?? '').trim().isEmpty ? null : notes!.trim(),
      //'created_at': now,
      'updated_at': now,
    });
  }

  Future<void> updateMeal(int id, {required String name, String? notes}) async {
    final db = await database;
    final now = DateTime.now().toIso8601String();
    await db.update(
      'meals',
      {
        'name': name.trim(),
        'notes': (notes ?? '').trim().isEmpty ? null : notes!.trim(),
        'updated_at': now,
      },
      where: 'id = ?',
      whereArgs: [id],
    );
  }

  Future<void> deleteMeal(int id) async {
    final db = await database;
    await db.delete('meals', where: 'id = ?', whereArgs: [id]);
  }

  Future<List<Map<String, dynamic>>> getMeals() async {
    final db = await database;
    return await db.query('meals', orderBy: 'updated_at DESC');
  }

  Future<List<Map<String, dynamic>>> getMealItems(int mealId) async {
    final db = await database;
    return await db
        .query('meal_items', where: 'meal_id = ?', whereArgs: [mealId]);
  }

  Future<int> addMealItem(int mealId,
      {required String barcode, required int grams}) async {
    final db = await database;
    return await db.insert('meal_items', {
      'meal_id': mealId,
      'barcode': barcode,
      'quantity_in_grams': grams,
    });
  }

  Future<void> removeMealItem(int itemId) async {
    final db = await database;
    await db.delete('meal_items', where: 'id = ?', whereArgs: [itemId]);
  }

  Future<void> clearMealItems(int mealId) async {
    final db = await database;
    await db.delete('meal_items', where: 'meal_id = ?', whereArgs: [mealId]);
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/data/base_db_exporter.dart =====

// lib/data/base_db_exporter.dart
import 'package:share_plus/share_plus.dart';
import 'package:mime/mime.dart';
import 'package:path/path.dart';
import 'product_database_helper.dart';

class BaseDbExporter {
  static Future<void> shareBaseDb({String? subject}) async {
    final path = await ProductDatabaseHelper.instance.getBaseDbPath();
    final file = XFile(
      path,
      mimeType: lookupMimeType(path) ?? 'application/octet-stream',
      name: basename(path),
    );
    await Share.shareXFiles([file], subject: subject ?? 'vita_base_foods.db');
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/data/workout_database_helper.dart =====

// lib/data/workout_database_helper.dart
// VOLLSTÄNDIGER CODE

import 'dart:convert';
import 'dart:io';
import 'package:flutter/services.dart';
import 'package:lightweight/util/mapping_prefs.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/models/routine_exercise.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/set_template.dart';
import 'package:lightweight/models/workout_log.dart';

class WorkoutDatabaseHelper {
  static final WorkoutDatabaseHelper instance = WorkoutDatabaseHelper._init();
  static Database? _database;
  WorkoutDatabaseHelper._init();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB('vita_training.db');
    return _database!;
  }

  Future<Database> _initDB(String fileName) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, fileName);

    final exists = await databaseExists(path);
    if (!exists) {
      try {
        await Directory(dirname(path)).create(recursive: true);
        ByteData data = await rootBundle.load(join('assets/db', fileName));
        List<int> bytes =
            data.buffer.asUint8List(data.offsetInBytes, data.lengthInBytes);
        await File(path).writeAsBytes(bytes, flush: true);
      } catch (e) {
        rethrow;
      }
    }

    return await openDatabase(
      path,
      version: 9,
      onUpgrade: _upgradeDB,
    );
  }

  Future<void> _upgradeDB(Database db, int oldVersion, int newVersion) async {
    print("Führe DB-Upgrade von v$oldVersion auf v$newVersion aus...");
    if (oldVersion < 2) {
      await db
          .execute('ALTER TABLE set_logs ADD COLUMN rest_time_seconds INTEGER')
          .catchError((_) {});
      await db
          .execute('ALTER TABLE set_logs ADD COLUMN is_completed INTEGER')
          .catchError((_) {});
    }
    if (oldVersion < 3) {
      await db
          .execute(
              "ALTER TABLE workout_logs ADD COLUMN status TEXT NOT NULL DEFAULT 'completed'")
          .catchError((_) {});
    }
    if (oldVersion < 4) {
      await db
          .execute(
              "ALTER TABLE routine_exercises ADD COLUMN pause_seconds INTEGER")
          .catchError((_) {});
    }
    if (oldVersion < 5) {
      await db
          .execute("ALTER TABLE set_logs ADD COLUMN log_order INTEGER")
          .catchError((_) {});
    }
    if (oldVersion < 6) {
      print("Upgrade DB auf v6: Entferne set_index aus set_logs...");
      await db.transaction((txn) async {
        await txn.execute('ALTER TABLE set_logs RENAME TO set_logs_old');
        await txn.execute('''
          CREATE TABLE set_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            workout_log_id INTEGER,
            exercise_name TEXT,
            set_type TEXT,
            weight_kg REAL,
            reps INTEGER,
            rest_time_seconds INTEGER,
            is_completed INTEGER,
            log_order INTEGER
          )
        ''');
        await txn.execute('''
          INSERT INTO set_logs (id, workout_log_id, exercise_name, set_type, weight_kg, reps, rest_time_seconds, is_completed, log_order)
          SELECT id, workout_log_id, exercise_name, set_type, weight_kg, reps, rest_time_seconds, is_completed, log_order FROM set_logs_old
        ''');
        await txn.execute('DROP TABLE set_logs_old');
      });
    }
    if (oldVersion < 7) {
      print("Upgrade DB auf v7: Füge Detail-Spalten zu set_logs hinzu...");
      await db
          .execute("ALTER TABLE set_logs ADD COLUMN notes TEXT")
          .catchError((_) {});
      await db
          .execute("ALTER TABLE set_logs ADD COLUMN distance_km REAL")
          .catchError((_) {});
      await db
          .execute("ALTER TABLE set_logs ADD COLUMN duration_seconds INTEGER")
          .catchError((_) {});
      await db
          .execute("ALTER TABLE set_logs ADD COLUMN rpe INTEGER")
          .catchError((_) {});
    }
    if (oldVersion < 8) {
      print("Upgrade DB auf v8: Füge superset_id zu set_logs hinzu...");
      await db
          .execute("ALTER TABLE set_logs ADD COLUMN superset_id INTEGER")
          .catchError((_) {});
    }
    if (oldVersion < 9) {
      print("Upgrade DB auf v9: Erstelle exercise_mapping Tabelle...");
      await db.execute('''
        CREATE TABLE exercise_mapping (
          external_name TEXT PRIMARY KEY COLLATE NOCASE,
          target_name TEXT NOT NULL
        )
      ''');
      final oldMappings = await MappingPrefs.load();
      if (oldMappings.isNotEmpty) {
        print("Migriere ${oldMappings.length} bestehende Mappings...");
        final batch = db.batch();
        for (final entry in oldMappings.entries) {
          batch.insert(
            'exercise_mapping',
            {'external_name': entry.key, 'target_name': entry.value},
            conflictAlgorithm: ConflictAlgorithm.replace,
          );
        }
        await batch.commit(noResult: true);
        print("Migration abgeschlossen.");
      }
    }
    print("DB-Upgrade auf v$newVersion erfolgreich abgeschlossen.");
  }

  // HINZUGEFÜGT: Neue Methode zur Wiederherstellung
  /// Sucht nach einem laufenden Workout in der DB. Es sollte immer nur eines geben.
  Future<WorkoutLog?> getOngoingWorkout() async {
    final db = await database;
    final maps = await db.query(
      'workout_logs',
      where: "status = 'ongoing'",
      orderBy: 'start_time DESC',
      limit: 1,
    );

    if (maps.isNotEmpty) {
      // Wenn ein laufendes Workout gefunden wird, holen wir auch alle zugehörigen Sätze.
      final logId = maps.first['id'] as int;
      return getWorkoutLogById(logId);
    }

    return null;
  }

  Future<Map<String, String>> getExerciseMappings() async {
    final db = await database;
    final maps = await db.query('exercise_mapping');
    return {
      for (var map in maps)
        (map['external_name'] as String): (map['target_name'] as String)
    };
  }

  // --- EXERCISE MANAGEMENT ---
  Future<List<String>> getAllCategories() async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query('exercises',
        columns: ['category_name'],
        distinct: true,
        orderBy: 'category_name ASC');
    return maps
        .map((map) => map['category_name'] as String?)
        .where((category) => category != null && category.isNotEmpty)
        .cast<String>()
        .toList();
  }

  Future<List<Exercise>> searchExercises(
      {String query = '', List<String> selectedCategories = const []}) async {
    final db = await database;
    List<String> whereClauses = [];
    List<dynamic> whereArgs = [];
    if (query.isNotEmpty) {
      whereClauses.add('(name_de LIKE ? OR name_en LIKE ?)');
      whereArgs.addAll(['%$query%', '%$query%']);
    }
    if (selectedCategories.isNotEmpty) {
      String placeholders =
          List.filled(selectedCategories.length, '?').join(', ');
      whereClauses.add('category_name IN ($placeholders)');
      whereArgs.addAll(selectedCategories);
    }
    String finalWhere =
        whereClauses.isNotEmpty ? whereClauses.join(' AND ') : '';
    final String sql = '''
      SELECT e.*, CASE WHEN sl.id IS NOT NULL THEN 0 ELSE 1 END as sort_priority
      FROM exercises e
      LEFT JOIN (SELECT exercise_name, MAX(id) as id FROM set_logs GROUP BY exercise_name) sl
      ON e.name_de = sl.exercise_name OR e.name_en = sl.exercise_name
      ${finalWhere.isNotEmpty ? 'WHERE $finalWhere' : ''}
      ORDER BY sort_priority ASC, e.name_de ASC
    ''';
    final List<Map<String, dynamic>> maps = await db.rawQuery(sql, whereArgs);
    return List.generate(maps.length, (i) => Exercise.fromMap(maps[i]));
  }

  Future<Exercise> insertExercise(Exercise exercise) async {
    final db = await database;
    final id = await db.insert('exercises', exercise.toMap());
    return exercise.copyWith(id: id);
  }

  Future<Exercise?> getExerciseByName(String name) async {
    final db = await database;
    final maps = await db.query('exercises',
        where: 'name_de = ? OR name_en = ?', whereArgs: [name, name], limit: 1);
    if (maps.isNotEmpty) {
      return Exercise.fromMap(maps.first);
    }
    return null;
  }

  // --- ROUTINE MANAGEMENT ---
  Future<Routine> createRoutine(String name) async {
    final db = await database;
    final id = await db.insert('routines', {'name': name},
        conflictAlgorithm: ConflictAlgorithm.replace);
    return Routine(id: id, name: name);
  }

  Future<void> updateRoutineName(int routineId, String newName) async {
    final db = await database;
    await db.update('routines', {'name': newName},
        where: 'id = ?', whereArgs: [routineId]);
  }

  Future<RoutineExercise?> addExerciseToRoutine(
      int routineId, int exerciseId) async {
    final db = await database;
    final exerciseMaps =
        await db.query('exercises', where: 'id = ?', whereArgs: [exerciseId]);
    if (exerciseMaps.isEmpty) return null;
    final result = await db.rawQuery(
        'SELECT MAX(exercise_order) as max_order FROM routine_exercises WHERE routine_id = ?',
        [routineId]);
    final maxOrder = (result.first['max_order'] as int?) ?? -1;
    final routineExerciseId = await db.insert('routine_exercises', {
      'routine_id': routineId,
      'exercise_id': exerciseId,
      'exercise_order': maxOrder + 1
    });
    final List<SetTemplate> newTemplates = [];
    for (int i = 0; i < 3; i++) {
      final setId = await db.insert('routine_set_templates', {
        'routine_exercise_id': routineExerciseId,
        'set_index': i,
        'set_type': 'normal'
      });
      newTemplates
          .add(SetTemplate(id: setId, setType: 'normal', targetReps: '8-12'));
    }
    return RoutineExercise(
        id: routineExerciseId,
        exercise: Exercise.fromMap(exerciseMaps.first),
        setTemplates: newTemplates);
  }

  Future<void> removeExerciseFromRoutine(int routineExerciseId) async {
    final db = await database;
    await db.delete('routine_exercises',
        where: 'id = ?', whereArgs: [routineExerciseId]);
  }

  Future<void> updateExerciseOrder(
      int routineId, List<RoutineExercise> orderedExercises) async {
    final db = await database;
    final batch = db.batch();
    for (int i = 0; i < orderedExercises.length; i++) {
      final routineExercise = orderedExercises[i];
      batch.update('routine_exercises', {'exercise_order': i},
          where: 'id = ?', whereArgs: [routineExercise.id]);
    }
    await batch.commit(noResult: true);
  }

  Future<List<Routine>> getAllRoutines() async {
    final db = await database;
    final List<Map<String, dynamic>> maps =
        await db.query('routines', orderBy: 'name ASC');
    return List.generate(
        maps.length, (i) => Routine(id: maps[i]['id'], name: maps[i]['name']));
  }

  Future<Routine?> getRoutineById(int id) async {
    final db = await database;
    final routineMaps =
        await db.query('routines', where: 'id = ?', whereArgs: [id]);
    if (routineMaps.isEmpty) return null;
    final routineExerciseMaps = await db.query('routine_exercises',
        where: 'routine_id = ?',
        whereArgs: [id],
        orderBy: 'exercise_order ASC');
    final List<RoutineExercise> routineExercises = [];
    for (final reMap in routineExerciseMaps) {
      final routineExerciseId = reMap['id'] as int;
      final exerciseId = reMap['exercise_id'] as int;
      final exerciseMaps =
          await db.query('exercises', where: 'id = ?', whereArgs: [exerciseId]);
      if (exerciseMaps.isEmpty) continue;
      final setTemplateMaps = await db.query('routine_set_templates',
          where: 'routine_exercise_id = ?',
          whereArgs: [routineExerciseId],
          orderBy: 'set_index ASC');
      final setTemplates =
          setTemplateMaps.map((stMap) => SetTemplate.fromMap(stMap)).toList();
      routineExercises.add(RoutineExercise(
          id: routineExerciseId,
          exercise: Exercise.fromMap(exerciseMaps.first),
          setTemplates: setTemplates,
          pauseSeconds: reMap['pause_seconds'] as int?));
    }
    return Routine(
        id: id,
        name: routineMaps.first['name'] as String,
        exercises: routineExercises);
  }

  Future<void> updateSetTemplate(SetTemplate setTemplate) async {
    final db = await database;
    await db.update(
        'routine_set_templates',
        {
          'set_type': setTemplate.setType,
          'target_reps': setTemplate.targetReps,
          'target_weight': setTemplate.targetWeight
        },
        where: 'id = ?',
        whereArgs: [setTemplate.id]);
  }

  Future<void> replaceSetTemplatesForExercise(
      int routineExerciseId, List<SetTemplate> newTemplates) async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('routine_set_templates',
          where: 'routine_exercise_id = ?', whereArgs: [routineExerciseId]);
      for (int i = 0; i < newTemplates.length; i++) {
        final set = newTemplates[i];
        await txn.insert('routine_set_templates', {
          'routine_exercise_id': routineExerciseId,
          'set_index': i,
          'set_type': set.setType,
          'target_reps': set.targetReps,
          'target_weight': set.targetWeight
        });
      }
    });
  }

  Future<void> deleteRoutine(int routineId) async {
    final db = await database;
    await db.transaction((txn) async {
      final reMaps = await txn.query('routine_exercises',
          where: 'routine_id = ?', whereArgs: [routineId]);
      for (var reMap in reMaps) {
        await txn.delete('routine_set_templates',
            where: 'routine_exercise_id = ?', whereArgs: [reMap['id']]);
      }
      await txn.delete('routine_exercises',
          where: 'routine_id = ?', whereArgs: [routineId]);
      await txn.delete('routines', where: 'id = ?', whereArgs: [routineId]);
    });
  }

  Future<void> duplicateRoutine(int routineId) async {
    final db = await database;
    final originalRoutine = await getRoutineById(routineId);
    if (originalRoutine == null) return;
    await db.transaction((txn) async {
      final newRoutineId = await txn
          .insert('routines', {'name': '${originalRoutine.name} (Kopie)'});
      for (var re in originalRoutine.exercises) {
        final newRoutineExerciseId = await txn.insert('routine_exercises', {
          'routine_id': newRoutineId,
          'exercise_id': re.exercise.id,
          'exercise_order': originalRoutine.exercises.indexOf(re),
          'pause_seconds': re.pauseSeconds
        });
        for (var st in re.setTemplates) {
          await txn.insert('routine_set_templates', {
            'routine_exercise_id': newRoutineExerciseId,
            'set_index': re.setTemplates.indexOf(st),
            'set_type': st.setType,
            'target_reps': st.targetReps,
            'target_weight': st.targetWeight
          });
        }
      }
    });
  }

  Future<void> updatePauseTime(int routineExerciseId, int? seconds) async {
    final db = await database;
    await db.update('routine_exercises', {'pause_seconds': seconds},
        where: 'id = ?', whereArgs: [routineExerciseId]);
  }

  // --- WORKOUT LOGGING ---
  Future<WorkoutLog> startWorkout({String? routineName}) async {
    final db = await database;
    final now = DateTime.now();
    final id = await db.insert('workout_logs', {
      'routine_name': routineName,
      'start_time': now.toIso8601String(),
      'status': 'ongoing'
    });
    return WorkoutLog(id: id, routineName: routineName, startTime: now);
  }

  Future<int> insertSetLog(SetLog setLog) async {
    final db = await database;

    if (setLog.id != null) {
      print("--- DEBUG: Update SetLog ID=${setLog.id} ---");
      return await db.update(
        'set_logs',
        setLog.toMap(),
        where: 'id = ?',
        whereArgs: [setLog.id],
      );
    }

    final id = await db.insert(
      'set_logs',
      setLog.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
    print(
        "--- DEBUG: Insert SetLog (${setLog.exerciseName}, ${setLog.weightKg}kg x ${setLog.reps}) → ID=$id ---");
    return id;
  }

  Future<void> finishWorkout(int workoutLogId) async {
    final db = await database;
    await db.update('workout_logs',
        {'end_time': DateTime.now().toIso8601String(), 'status': 'completed'},
        where: 'id = ?', whereArgs: [workoutLogId]);
  }

  Future<SetLog?> getLastPerformance(String exerciseName) async {
    final db = await database;
    final maps = await db.rawQuery('''
      SELECT * FROM set_logs
      WHERE exercise_name = ? AND set_type != 'warmup' AND reps IS NOT NULL AND weight_kg IS NOT NULL
      ORDER BY id DESC LIMIT 1
    ''', [exerciseName]);
    if (maps.isNotEmpty) return SetLog.fromMap(maps.first);
    return null;
  }

  // --- WORKOUT HISTORY ---
  Future<void> deleteWorkoutLog(int logId) async {
    final db = await database;
    await db.transaction((txn) async {
      await txn
          .delete('set_logs', where: 'workout_log_id = ?', whereArgs: [logId]);
      await txn.delete('workout_logs', where: 'id = ?', whereArgs: [logId]);
    });
  }

  Future<List<WorkoutLog>> getWorkoutLogs() async {
    final db = await database;
    final maps = await db.query('workout_logs',
        where: "status = 'completed'", orderBy: 'start_time DESC');
    return maps.map((map) => WorkoutLog.fromMap(map)).toList();
  }

  Future<WorkoutLog?> getWorkoutLogById(int id) async {
    final db = await database;
    print("--- DEBUG: getWorkoutLogById gestartet für ID: $id ---");

    final logMaps =
        await db.query('workout_logs', where: 'id = ?', whereArgs: [id]);
    if (logMaps.isEmpty) {
      print("--- DEBUG: KEINEN WorkoutLog für ID $id gefunden. Breche ab.");
      return null;
    }
    print("--- DEBUG: WorkoutLog gefunden: ${logMaps.first}");

    final setMaps = await db.query('set_logs',
        where: 'workout_log_id = ?', whereArgs: [id], orderBy: 'id ASC');

    print(
        "--- DEBUG: Für workout_log_id $id wurden ${setMaps.length} Sätze in der DB gefunden.");
    if (setMaps.isNotEmpty) {
      print("--- DEBUG: Erster gefundener Satz: ${setMaps.first}");
    }

    final sets = setMaps.map((map) => SetLog.fromMap(map)).toList();

    return WorkoutLog.fromMap(logMaps.first, sets: sets);
  }

  Future<WorkoutLog?> getLatestWorkoutLog() async {
    final db = await database;
    final maps =
        await db.query('workout_logs', orderBy: 'start_time DESC', limit: 1);
    if (maps.isNotEmpty) {
      return WorkoutLog.fromMap(maps.first);
    }
    return null;
  }

  Future<List<WorkoutLog>> getWorkoutLogsForDateRange(
      DateTime start, DateTime end) async {
    final db = await database;
    final maps = await db.query(
      'workout_logs',
      where: 'start_time >= ? AND start_time <= ?',
      whereArgs: [start.toIso8601String(), end.toIso8601String()],
      orderBy: 'start_time DESC',
    );

    List<WorkoutLog> logs = [];
    for (final map in maps) {
      final sets = await getSetLogsForWorkout(map['id'] as int);
      logs.add(WorkoutLog.fromMap(map, sets: sets));
    }
    return logs;
  }

  Future<Routine?> getRoutineByName(String name) async {
    final db = await database;
    final maps = await db.query('routines',
        where: 'name = ?', whereArgs: [name], limit: 1);
    if (maps.isNotEmpty) {
      return getRoutineById(maps.first['id'] as int);
    }
    return null;
  }

  Future<void> updateWorkoutLogDetails(
      int logId, DateTime startTime, String? notes) async {
    final db = await database;
    await db.update('workout_logs',
        {'start_time': startTime.toIso8601String(), 'notes': notes},
        where: 'id = ?', whereArgs: [logId]);
  }

  Future<void> updateSetLogs(List<SetLog> updatedSets) async {
    if (updatedSets.isEmpty) return;
    final db = await database;
    final batch = db.batch();
    for (final setLog in updatedSets) {
      batch.update('set_logs', setLog.toMap(),
          where: 'id = ?', whereArgs: [setLog.id]);
    }
    await batch.commit(noResult: true);
  }

  Future<void> deleteSetLogs(List<int> idsToDelete) async {
    if (idsToDelete.isEmpty) return;
    final db = await database;
    final batch = db.batch();
    for (final id in idsToDelete) {
      batch.delete('set_logs', where: 'id = ?', whereArgs: [id]);
    }
    await batch.commit(noResult: true);
  }

  Future<List<SetLog>> getSetLogsForWorkout(int workoutLogId) async {
    final db = await database;
    final maps = await db.query(
      'set_logs',
      where: 'workout_log_id = ?',
      whereArgs: [workoutLogId],
      orderBy: 'log_order ASC',
    );

    return maps.map((map) => SetLog.fromMap(map)).toList();
  }
// --- NEUE METHODEN FÜR BACKUP & RESTORE ---

  Future<List<Routine>> getAllRoutinesWithDetails() async {
    final routines = await getAllRoutines();
    final detailedRoutines = <Routine>[];
    for (final routine in routines) {
      if (routine.id != null) {
        final detailedRoutine = await getRoutineById(routine.id!);
        if (detailedRoutine != null) {
          detailedRoutines.add(detailedRoutine);
        }
      }
    }
    return detailedRoutines;
  }

  Future<List<WorkoutLog>> getFullWorkoutLogs() async {
    final db = await database;
    final maps = await db.query('workout_logs', orderBy: 'start_time DESC');
    final logs = <WorkoutLog>[];
    for (final map in maps) {
      final log = await getWorkoutLogById(map['id'] as int);
      if (log != null) {
        logs.add(log);
      }
    }
    return logs;
  }

  Future<void> clearAllWorkoutData() async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('set_logs');
      await txn.delete('workout_logs');
      await txn.delete('routine_set_templates');
      await txn.delete('routine_exercises');
      await txn.delete('routines');
    });
  }

  Future<void> importWorkoutData({
    required List<Routine> routines,
    required List<WorkoutLog> workoutLogs,
  }) async {
    final db = await database;
    await db.transaction((txn) async {
      // Routinen importieren
      for (final routine in routines) {
        final newRoutineId =
            await txn.insert('routines', {'name': routine.name});
        for (final re in routine.exercises) {
          final newReId = await txn.insert('routine_exercises', {
            'routine_id': newRoutineId,
            'exercise_id': re.exercise.id,
            'exercise_order': routine.exercises.indexOf(re),
            'pause_seconds': re.pauseSeconds,
          });
          for (final st in re.setTemplates) {
            final stMap = st.toMap();
            stMap.remove('id');
            stMap['routine_exercise_id'] = newReId;
            stMap['set_index'] = re.setTemplates.indexOf(st);
            await txn.insert('routine_set_templates', stMap);
          }
        }
      }

      // Workout Logs importieren
      for (final log in workoutLogs) {
        final logMap = log.toMap();
        logMap.remove('id');
        logMap['status'] = 'completed';
        final newLogId = await txn.insert('workout_logs', logMap);

        for (final setLog in log.sets) {
          final setMap = setLog.toMap();
          setMap.remove('id');
          setMap['workout_log_id'] = newLogId;
          await txn.insert('set_logs', setMap);
        }
      }
    });
  }

  Future<List<String>> findUnknownExerciseNames() async {
    final db = await database;
    final rows = await db.rawQuery('''
    SELECT DISTINCT sl.exercise_name
    FROM set_logs sl
    LEFT JOIN exercises e
      ON e.name_de = sl.exercise_name OR e.name_en = sl.exercise_name
    WHERE e.id IS NULL
    ORDER BY sl.exercise_name COLLATE NOCASE ASC
  ''');
    return rows
        .map((r) => (r['exercise_name'] as String?) ?? '')
        .where((s) => s.isNotEmpty)
        .toList();
  }

  Future<void> applyExerciseNameMapping(Map<String, String> map) async {
    if (map.isEmpty) return;
    final db = await database;
    await db.transaction((txn) async {
      final batch = txn.batch();
      for (final e in map.entries) {
        batch.insert(
          'exercise_mapping',
          {'external_name': e.key, 'target_name': e.value},
          conflictAlgorithm: ConflictAlgorithm.replace,
        );
      }
      await batch.commit(noResult: true);

      for (final e in map.entries) {
        await txn.update(
          'set_logs',
          {'exercise_name': e.value},
          where: 'exercise_name = ?',
          whereArgs: [e.key],
        );
      }
    });
  }

  Future<List<String>> getAllMuscleGroups() async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query(
      'exercises',
      columns: ['primaryMuscles', 'secondaryMuscles'],
      distinct: true,
    );

    final Set<String> allMuscles = {};

    List<String> parseMuscles(String? jsonString) {
      if (jsonString == null || jsonString.isEmpty) return [];
      try {
        return (jsonDecode(jsonString) as List)
            .map((item) => item.toString())
            .toList();
      } catch (e) {
        return [];
      }
    }

    for (final map in maps) {
      final primary = parseMuscles(map['primaryMuscles'] as String?);
      final secondary = parseMuscles(map['secondaryMuscles'] as String?);
      allMuscles.addAll(primary);
      allMuscles.addAll(secondary);
    }

    final sortedList = allMuscles.toList()..sort();
    return sortedList;
  }

  Future<Set<int>> getWorkoutDaysInMonth(DateTime month) async {
    final db = await database;
    final firstDayOfMonth = DateTime(month.year, month.month, 1);
    final lastDayOfMonth = DateTime(month.year, month.month + 1, 0, 23, 59, 59);

    final maps = await db.query(
      'workout_logs',
      columns: ['start_time'],
      where: 'start_time BETWEEN ? AND ?',
      whereArgs: [
        firstDayOfMonth.toIso8601String(),
        lastDayOfMonth.toIso8601String()
      ],
    );

    if (maps.isEmpty) return {};

    return maps
        .map((map) => DateTime.parse(map['start_time'] as String).day)
        .toSet();
  }

  /// Findet das letzte Workout, das eine bestimmte Übung enthielt,
  /// und gibt alle Sätze dieser Übung aus jenem Workout zurück.
  Future<List<SetLog>> getLastSetsForExercise(String exerciseName) async {
    final db = await database;

    // Schritt 1: Finde die ID des letzten Workout-Logs, das diese Übung enthält.
    final latestLogResult = await db.rawQuery('''
      SELECT l.id
      FROM workout_logs l
      INNER JOIN set_logs s ON l.id = s.workout_log_id
      WHERE s.exercise_name = ? AND l.status = 'completed'
      ORDER BY l.start_time DESC
      LIMIT 1
    ''', [exerciseName]);

    if (latestLogResult.isEmpty) {
      return []; // Kein vorheriges Workout mit dieser Übung gefunden.
    }

    final logId = latestLogResult.first['id'] as int;

    // Schritt 2: Hole alle Sätze für diese Übung aus genau diesem Workout-Log.
    final setMaps = await db.query(
      'set_logs',
      where: 'workout_log_id = ? AND exercise_name = ?',
      whereArgs: [logId, exerciseName],
      orderBy: 'id ASC', // Sortiert nach der Reihenfolge der Erstellung
    );

    return setMaps.map((map) => SetLog.fromMap(map)).toList();
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/data/backup_manager.dart =====

// lib/data/backup_manager.dart (Finale Version)

import 'dart:convert';
import 'dart:io';
import 'package:csv/csv.dart';
import 'package:flutter/services.dart';
import 'package:intl/intl.dart';
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/lightweight_backup.dart';
import 'package:sqflite/sqflite.dart'; // KORREKTUR: Importiert das neue Modell
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/util/encryption_util.dart';
import 'package:path/path.dart' as p;
import 'dart:typed_data';
import 'package:archive/archive.dart'; // for GZipDecoder (add to pubspec if not present)

class BackupManager {
  final _userDb = DatabaseHelper.instance;
  final _productDb = ProductDatabaseHelper.instance;
  final _workoutDb = WorkoutDatabaseHelper.instance;

  static const int currentSchemaVersion = 1;

  Future<bool> exportFullBackup() async {
    try {
      final foodEntries = await _userDb.getAllFoodEntries();
      final fluidEntries = await _userDb.getAllFluidEntries();
      final favoriteBarcodes = await _userDb.getFavoriteBarcodes();
      final measurementSessions = await _userDb.getMeasurementSessions();
      final productDb = await _productDb.offDatabase;
      final customFoodMaps = await productDb?.query('products',
              where: 'barcode LIKE ?', whereArgs: ['user_created_%']) ??
          [];
      final customFoodItems = customFoodMaps
          .map((map) => FoodItem.fromMap(map, source: FoodItemSource.user))
          .toList();
      final routines = await _workoutDb.getAllRoutinesWithDetails();
      final workoutLogs = await _workoutDb.getFullWorkoutLogs();
      // --- HINZUGEFÜGT: Benutzereinstellungen auslesen ---
      final prefs = await SharedPreferences.getInstance();
      final userPrefs = <String, dynamic>{};
      final keys = prefs.getKeys();
      for (String key in keys) {
        userPrefs[key] = prefs.get(key);
      }
      final supplements = await _userDb.getAllSupplements();
      final supplementLogs = await _userDb.getAllSupplementLogs();
      final backup = LightweightBackup(
        // KORREKTUR: Nutzt das neue Modell
        schemaVersion: currentSchemaVersion,
        foodEntries: foodEntries,
        fluidEntries: fluidEntries,
        favoriteBarcodes: favoriteBarcodes,
        customFoodItems: customFoodItems,
        measurementSessions: measurementSessions,
        routines: routines,
        workoutLogs: workoutLogs,
        userPreferences: userPrefs,
        supplements: supplements,
        supplementLogs: supplementLogs,
      );
      final jsonString = jsonEncode(backup.toJson());

      // ... (Logik zum Speichern und Teilen der Datei bleibt identisch)
      final tempDir = await getTemporaryDirectory();
      final timestamp = DateFormat('yyyy-MM-dd_HH-mm').format(DateTime.now());
      final tempFile = File(
          '${tempDir.path}/lightweight_backup_v$currentSchemaVersion-[$timestamp].json');
      await tempFile.writeAsString(jsonString);
      final result = await Share.shareXFiles(
          [XFile(tempFile.path, mimeType: 'application/json')],
          subject: 'Lightweight App Backup - $timestamp');
      await tempFile.delete();
      return result.status == ShareResultStatus.success;
    } catch (e) {
      print("Fehler beim Exportieren der Daten: $e");
      return false;
    }
  }

  Future<bool> importFullBackup(String filePath) async {
    try {
      final file = File(filePath);
      final jsonString = await file.readAsString();
      final jsonMap = jsonDecode(jsonString);

      final backup = LightweightBackup.fromJson(
          jsonMap); // KORREKTUR: Nutzt das neue Modell

      if (backup.schemaVersion > currentSchemaVersion) {
        print(
            "Backup-Version (${backup.schemaVersion}) ist neuer als die App-Version ($currentSchemaVersion). Import abgebrochen.");
        return false;
      }

      // ... (Logik zum Löschen und Einfügen der Daten bleibt identisch)
      // HINZUGEFÜGT: Alte Einstellungen löschen
      final prefs = await SharedPreferences.getInstance();
      await prefs.clear();

      await _userDb.clearAllUserData();
      await _workoutDb.clearAllWorkoutData();
      final productDb = await _productDb.offDatabase;
      await productDb?.delete('products',
          where: 'barcode LIKE ?', whereArgs: ['user_created_%']);
      // HINZUGEFÜGT: Neue Einstellungen wiederherstellen
      for (final entry in backup.userPreferences.entries) {
        final key = entry.key;
        final value = entry.value;
        if (value is bool) {
          await prefs.setBool(key, value);
        } else if (value is int) {
          await prefs.setInt(key, value);
        } else if (value is double) {
          await prefs.setDouble(key, value);
        } else if (value is String) {
          await prefs.setString(key, value);
        } else if (value is List<String>) {
          await prefs.setStringList(key, value);
        }
      }
      final supplements = await _userDb.getAllSupplements();
      final supplementLogs = await _userDb.getAllSupplementLogs();
      await _userDb.importUserData(
        foodEntries: backup.foodEntries,
        fluidEntries: backup.fluidEntries,
        favoriteBarcodes: backup.favoriteBarcodes,
        measurementSessions: backup.measurementSessions,
        supplements: supplements,
        supplementLogs: supplementLogs,
      );
      if (productDb != null) {
        final cols = await _getTableColumns(productDb, 'products'); // <-- neu
        final batch = productDb.batch();
        for (final item in backup.customFoodItems) {
          final raw = item.toMap();
          final filtered = _filterMapForColumns(raw, cols); // <-- neu
          batch.insert(
            'products',
            filtered,
            conflictAlgorithm: ConflictAlgorithm.replace,
          );
        }
        await batch.commit(noResult: true);
      }
      await _workoutDb.importWorkoutData(
        routines: backup.routines,
        workoutLogs: backup.workoutLogs,
      );

      print("Import erfolgreich abgeschlossen.");
      return true;
    } catch (e) {
      print("Fehler beim Importieren der Daten: $e");
      return false;
    }
  }
  // --- NEUE METHODEN FÜR CSV-EXPORT ---

  /// Exportiert das gesamte Ernährungstagebuch als CSV-Datei.
  Future<bool> exportNutritionAsCsv() async {
    try {
      final entries = await _userDb.getAllFoodEntries();
      if (entries.isEmpty) return false; // Nichts zu exportieren

      // Performance-Optimierung: Alle benötigten Produkte auf einmal laden
      final uniqueBarcodes = entries.map((e) => e.barcode).toSet().toList();
      final products = await _productDb.getProductsByBarcodes(uniqueBarcodes);
      final productMap = {for (var p in products) p.barcode: p};

      List<List<dynamic>> rows = [];
      // Header-Zeile
      rows.add([
        'date',
        'time',
        'meal_type',
        'food_name',
        'brand',
        'quantity_grams',
        'calories_kcal',
        'protein_g',
        'carbs_g',
        'fat_g',
        'barcode'
      ]);

      for (final entry in entries) {
        final product = productMap[entry.barcode];
        if (product == null) continue;

        final factor = entry.quantityInGrams / 100.0;
        rows.add([
          DateFormat('yyyy-MM-dd').format(entry.timestamp),
          DateFormat('HH:mm').format(entry.timestamp),
          entry.mealType,
          product.name,
          product.brand,
          entry.quantityInGrams,
          (product.calories * factor).round(),
          (product.protein * factor).toStringAsFixed(1),
          (product.carbs * factor).toStringAsFixed(1),
          (product.fat * factor).toStringAsFixed(1),
          entry.barcode,
        ]);
      }
      return await _createAndShareCsv(rows, 'lightweight_nutrition_export');
    } catch (e) {
      print("Fehler beim CSV-Export der Ernährung: $e");
      return false;
    }
  }

  /// Exportiert alle Messwerte als CSV-Datei.
  Future<bool> exportMeasurementsAsCsv() async {
    try {
      final sessions = await _userDb.getMeasurementSessions();
      if (sessions.isEmpty) return false;

      List<List<dynamic>> rows = [];
      rows.add(['date', 'time', 'measurement_type', 'value', 'unit']);

      for (final session in sessions) {
        for (final measurement in session.measurements) {
          rows.add([
            DateFormat('yyyy-MM-dd').format(session.timestamp),
            DateFormat('HH:mm').format(session.timestamp),
            measurement.type,
            measurement.value,
            measurement.unit,
          ]);
        }
      }
      return await _createAndShareCsv(rows, 'lightweight_measurements_export');
    } catch (e) {
      print("Fehler beim CSV-Export der Messwerte: $e");
      return false;
    }
  }

  /// Exportiert den gesamten Trainingsverlauf als CSV-Datei.
  Future<bool> exportWorkoutsAsCsv() async {
    try {
      final logs = await _workoutDb.getFullWorkoutLogs();
      if (logs.isEmpty) return false;

      List<List<dynamic>> rows = [];
      rows.add([
        'workout_start_time',
        'workout_end_time',
        'routine_name',
        'exercise_name',
        'set_order',
        'set_type',
        'weight_kg',
        'reps',
        'rest_seconds',
        'notes'
      ]);

      for (final log in logs) {
        int setOrder = 1;
        for (final set in log.sets) {
          rows.add([
            log.startTime.toIso8601String(),
            log.endTime?.toIso8601String() ?? '',
            log.routineName ?? 'Freies Training',
            set.exerciseName,
            setOrder++,
            set.setType,
            set.weightKg ?? 0,
            set.reps ?? 0,
            set.restTimeSeconds ?? 0,
            log.notes ?? '',
          ]);
        }
      }
      return await _createAndShareCsv(rows, 'lightweight_workouts_export');
    } catch (e) {
      print("Fehler beim CSV-Export der Workouts: $e");
      return false;
    }
  }

  /// Private Helfer-Methode zum Erstellen, Speichern und Teilen einer CSV-Datei.
  Future<bool> _createAndShareCsv(
      List<List<dynamic>> rows, String baseFileName) async {
    final String csvData = const ListToCsvConverter().convert(rows);
    final tempDir = await getTemporaryDirectory();
    final timestamp = DateFormat('yyyy-MM-dd').format(DateTime.now());
    final tempFile = File('${tempDir.path}/$baseFileName-$timestamp.csv');
    await tempFile.writeAsString(csvData);

    final result = await Share.shareXFiles(
      [XFile(tempFile.path, mimeType: 'text/csv')],
      subject: baseFileName,
    );

    await tempFile.delete();
    return result.status == ShareResultStatus.success;
  }

  Future<bool> exportFullBackupEncrypted(String passphrase) async {
    try {
      // Daten sammeln (wie in exportFullBackup)
      final foodEntries = await _userDb.getAllFoodEntries();
      final fluidEntries = await _userDb.getAllFluidEntries();
      final favoriteBarcodes = await _userDb.getFavoriteBarcodes();
      final measurementSessions = await _userDb.getMeasurementSessions();
      final productDb = await _productDb.offDatabase;
      final customFoodMaps = await productDb?.query(
            'products',
            where: 'barcode LIKE ?',
            whereArgs: ['user_created_%'],
          ) ??
          [];
      final customFoodItems = customFoodMaps
          .map((m) => FoodItem.fromMap(m, source: FoodItemSource.user))
          .toList();
      final routines = await _workoutDb.getAllRoutinesWithDetails();
      final workoutLogs = await _workoutDb.getFullWorkoutLogs();
      final prefs = await SharedPreferences.getInstance();
      final userPrefs = <String, dynamic>{};
      for (final k in prefs.getKeys()) {
        userPrefs[k] = prefs.get(k);
      }
      final supplements = await _userDb.getAllSupplements();
      final supplementLogs = await _userDb.getAllSupplementLogs();
      final backup = LightweightBackup(
        schemaVersion: currentSchemaVersion,
        foodEntries: foodEntries,
        fluidEntries: fluidEntries,
        favoriteBarcodes: favoriteBarcodes,
        customFoodItems: customFoodItems,
        measurementSessions: measurementSessions,
        routines: routines,
        workoutLogs: workoutLogs,
        userPreferences: userPrefs,
        supplements: supplements,
        supplementLogs: supplementLogs,
      );
      final jsonString = jsonEncode(backup.toJson());

      // Verschlüsseln
      final wrapper =
          await EncryptionUtil.encryptString(jsonString, passphrase);
      final wrappedJson = jsonEncode(wrapper);

      final tempDir = await getTemporaryDirectory();
      final ts = DateFormat('yyyy-MM-dd_HH-mm').format(DateTime.now());
      final tempFile = File(
        p.join(tempDir.path,
            'lightweight_backup_enc_v$currentSchemaVersion-[$ts].json'),
      );
      await tempFile.writeAsString(wrappedJson);
      final result = await Share.shareXFiles(
        [XFile(tempFile.path, mimeType: 'application/json')],
        subject: 'Lightweight Encrypted Backup - $ts',
      );
      await tempFile.delete();
      return result.status == ShareResultStatus.success;
    } catch (e) {
      print('Fehler beim verschlüsselten Export: $e');
      return false;
    }
  }

  Future<bool> importFullBackupAuto(String filePath,
      {String? passphrase}) async {
    try {
      final file = File(filePath);
      final raw = await file.readAsString();
      final top = jsonDecode(raw);

      Map<String, dynamic> payload;
      if (top is Map && top['enc'] == EncryptionUtil.wrapperVersion) {
        // Leeres Passwort zulassen (Legacy-Cases) – EncryptionUtil sollte "" akzeptieren
        final effectivePw = (passphrase ?? "");
        try {
          final clear = await EncryptionUtil.decryptToString(
            Map<String, dynamic>.from(top),
            effectivePw,
          );
          payload = jsonDecode(clear) as Map<String, dynamic>;
        } catch (e) {
          // Falsches/fehlendes Passwort → sauber false zurückgeben,
          // damit der UI-Flow den Dialog zeigen/erneut versuchen kann.
          print('Decrypt failed: $e');
          return false;
        }
      } else {
        // Unverschlüsselt (plain JSON)
        payload = (top as Map).cast<String, dynamic>();
      }

      final backup = LightweightBackup.fromJson(payload);
      if (backup.schemaVersion > currentSchemaVersion) {
        print(
            'Backup-Version (${backup.schemaVersion}) ist neuer als App-Version ($currentSchemaVersion).');
        return false;
      }

      final prefs = await SharedPreferences.getInstance();
      await prefs.clear();
      await _userDb.clearAllUserData();
      await _workoutDb.clearAllWorkoutData();

      final productDb = await _productDb.offDatabase;
      await productDb?.delete('products',
          where: 'barcode LIKE ?', whereArgs: ['user_created_%']);

      for (final e in backup.userPreferences.entries) {
        final k = e.key;
        final v = e.value;
        if (v is bool) {
          await prefs.setBool(k, v);
        } else if (v is int)
          await prefs.setInt(k, v);
        else if (v is double)
          await prefs.setDouble(k, v);
        else if (v is String)
          await prefs.setString(k, v);
        else if (v is List<String>) await prefs.setStringList(k, v);
      }

      await _userDb.importUserData(
        foodEntries: backup.foodEntries,
        fluidEntries: backup.fluidEntries,
        favoriteBarcodes: backup.favoriteBarcodes,
        measurementSessions: backup.measurementSessions,
        supplements: backup.supplements, // NEU
        supplementLogs: backup.supplementLogs, // NEU
      );

      if (productDb != null) {
        final cols = await _getTableColumns(productDb, 'products'); // <-- neu
        final batch = productDb.batch();
        for (final item in backup.customFoodItems) {
          final raw = item.toMap();
          final filtered = _filterMapForColumns(raw, cols); // <-- neu
          batch.insert(
            'products',
            filtered,
            conflictAlgorithm: ConflictAlgorithm.replace,
          );
        }
        await batch.commit(noResult: true);
      }

      await _workoutDb.importWorkoutData(
        routines: backup.routines,
        workoutLogs: backup.workoutLogs,
      );

      print('Import erfolgreich (auto).');
      return true;
    } catch (e) {
      print('Fehler beim Auto-Import: $e');
      return false;
    }
  }

// lib/data/backup_manager.dart

  Future<bool> runAutoBackupIfDue({
    Duration interval = const Duration(days: 1),
    bool encrypted = false,
    String? passphrase,
    int retention = 7,
    String? dirPath,
    bool force = false, // NEU
  }) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final lastMs = prefs.getInt('auto_backup_last_ms') ?? 0;
      final nowMs = DateTime.now().millisecondsSinceEpoch;
      if (!force && (nowMs - lastMs < interval.inMilliseconds)) {
        print('Auto-Backup: nicht fällig (force=false)'); // Hinweis
        return false;
      }

      // 1) Daten sammeln (wie schon implementiert)
      final foodEntries = await _userDb.getAllFoodEntries();
      final fluidEntries = await _userDb.getAllFluidEntries();
      final favoriteBarcodes = await _userDb.getFavoriteBarcodes();
      final measurementSessions = await _userDb.getMeasurementSessions();
      final productDb = await _productDb.offDatabase;
      final customFoodMaps = await productDb?.query(
            'products',
            where: 'barcode LIKE ?',
            whereArgs: ['user_created_%'],
          ) ??
          [];
      final customFoodItems = customFoodMaps
          .map((m) => FoodItem.fromMap(m, source: FoodItemSource.user))
          .toList();
      final routines = await _workoutDb.getAllRoutinesWithDetails();
      final workoutLogs = await _workoutDb.getFullWorkoutLogs();
      final userPrefs = <String, dynamic>{};
      for (final k in prefs.getKeys()) {
        userPrefs[k] = prefs.get(k);
      }
      final supplements = await _userDb.getAllSupplements();
      final supplementLogs = await _userDb.getAllSupplementLogs();
      final backup = LightweightBackup(
        schemaVersion: currentSchemaVersion,
        foodEntries: foodEntries,
        fluidEntries: fluidEntries,
        favoriteBarcodes: favoriteBarcodes,
        customFoodItems: customFoodItems,
        measurementSessions: measurementSessions,
        routines: routines,
        workoutLogs: workoutLogs,
        userPreferences: userPrefs,
        supplements: supplements,
        supplementLogs: supplementLogs,
      );
      final jsonString = jsonEncode(backup.toJson());

      // 2) Zielordner auflösen
      final docs = await getApplicationDocumentsDirectory();
      final saved = prefs.getString('auto_backup_dir');
      Directory baseDir = (dirPath != null && dirPath.trim().isNotEmpty)
          ? Directory(dirPath)
          : ((saved != null && saved.trim().isNotEmpty)
              ? Directory(saved)
              : Directory(p.join(docs.path, 'Backups')));
      await baseDir.create(recursive: true);
      final ts = DateFormat('yyyy-MM-dd_HH-mm').format(DateTime.now());

      // 3) Klar/verschlüsselt vorbereiten
      late final String content;
      late final String name;
      if (encrypted) {
        if (passphrase == null || passphrase.isEmpty) {
          print('Auto-Backup ENC: Passwort fehlt');
          return false;
        }
        final wrapper =
            await EncryptionUtil.encryptString(jsonString, passphrase);
        content = jsonEncode(wrapper);
        name = 'lightweight_auto_enc_v$currentSchemaVersion-[$ts].json';
      } else {
        content = jsonString;
        name = 'lightweight_auto_v$currentSchemaVersion-[$ts].json';
      }

      // 4) Schreiben mit Fallback bei Fehler
      File outFile = File(p.join(baseDir.path, name));
      try {
        await outFile.writeAsString(content);
      } on FileSystemException catch (e) {
        print(
            'Auto-Backup: Schreiben in $baseDir fehlgeschlagen, Fallback → App-Ordner ($e)');
        baseDir = Directory(p.join(docs.path, 'Backups'));
        await baseDir.create(recursive: true);
        outFile = File(p.join(baseDir.path, name));
        await outFile.writeAsString(content);
      }

      print('Auto-Backup geschrieben: ${outFile.path}');

      // 5) Retention
      final files = baseDir
          .listSync()
          .whereType<File>()
          .where((f) => p.basename(f.path).startsWith('lightweight_auto'))
          .toList()
        ..sort((a, b) => b.lastModifiedSync().compareTo(a.lastModifiedSync()));
      for (var i = retention; i < files.length; i++) {
        try {
          files[i].deleteSync();
        } catch (_) {}
      }

      await prefs.setInt('auto_backup_last_ms', nowMs);
      return true;
    } catch (e) {
      print('Auto-Backup fehlgeschlagen: $e');
      return false;
    }
  }

  Future<Set<String>> _getTableColumns(Database db, String table) async {
    final rows = await db.rawQuery('PRAGMA table_info($table)');
    return rows.map((r) => (r['name'] as String)).toSet();
  }

  Map<String, Object?> _filterMapForColumns(
    Map<String, Object?> src,
    Set<String> allowedCols,
  ) {
    final out = <String, Object?>{};
    src.forEach((k, v) {
      if (allowedCols.contains(k)) out[k] = v;
    });
    return out;
  }
}

class ProbeResult {
  final bool encrypted;
  final bool gzipped;
  ProbeResult({required this.encrypted, required this.gzipped});
}

ProbeResult _probeBackup(Uint8List bytes) {
  // 1) Quick JSON sniff
  if (bytes.isNotEmpty &&
      (bytes.first == 0x7B /* '{' */ || bytes.first == 0x5B /* '[' */)) {
    // Looks like plain JSON (very common for unencrypted exports)
    return ProbeResult(encrypted: false, gzipped: false);
  }

  // 2) GZIP magic: 1F 8B
  if (bytes.length >= 2 && bytes[0] == 0x1F && bytes[1] == 0x8B) {
    // Might be gzipped JSON (unencrypted) or gzipped+encrypted (rare)
    // We'll try inflate first; if it fails later we can still treat as encrypted
    return ProbeResult(encrypted: false, gzipped: true);
  }

  // 3) Optional custom magic headers you may have used
  // e.g., "VITA1" or "ENC1"... adapt if your exporter wrote a header.
  const encHeader = [0x45, 0x4E, 0x43, 0x31]; // "ENC1"
  if (bytes.length >= 4 &&
      bytes[0] == encHeader[0] &&
      bytes[1] == encHeader[1] &&
      bytes[2] == encHeader[2] &&
      bytes[3] == encHeader[3]) {
    return ProbeResult(encrypted: true, gzipped: false);
  }

  // 4) Default: treat as encrypted blob (e.g., {salt|iv|ciphertext} container)
  return ProbeResult(encrypted: true, gzipped: false);
}

class BackupPasswordError implements Exception {}

Future<void> importBackupBytes(Uint8List bytes, {String? password}) async {
  final probe = _probeBackup(bytes);

  Uint8List plainBytes;

  if (!probe.encrypted) {
    // Try direct JSON first
    try {
      final sourceBytes = probe.gzipped
          ? Uint8List.fromList(const GZipDecoder().decodeBytes(bytes))
          : bytes;
      // Basic JSON sanity check
      jsonDecode(utf8.decode(sourceBytes));
      plainBytes = sourceBytes;
    } catch (_) {
      // If JSON/gzip decode failed, fall back to encrypted flow
      plainBytes = await _tryDecryptWithCandidates(bytes,
          passwordCandidates: [password, "", null]);
    }
  } else {
    // Encrypted flow straight away
    plainBytes = await _tryDecryptWithCandidates(bytes,
        passwordCandidates: [password, "", null]);
  }

  final jsonStr = utf8.decode(plainBytes);
  final Map<String, dynamic> payload =
      jsonDecode(jsonStr) as Map<String, dynamic>;

  // ✅ Apply payload to DB (your current restore routine)
  await _applyBackupPayload(payload);
}

/// Tries multiple password candidates in order.
/// If all fail, throws BackupPasswordError.
Future<Uint8List> _tryDecryptWithCandidates(Uint8List encrypted,
    {required List<String?> passwordCandidates}) async {
  for (final cand in passwordCandidates) {
    try {
      final plain = await _decryptPayload(encrypted, cand);
      // Quick sanity check to ensure we actually decrypted JSON
      final s = utf8.decode(plain);
      jsonDecode(s);
      return plain;
    } catch (_) {
      // continue
    }
  }
  throw BackupPasswordError();
}

/// Replace with your real decryption (AES-GCM, etc.)
/// Contract: when `password` is `null` or `""`, handle legacy “no password” backups
Future<Uint8List> _decryptPayload(Uint8List encrypted, String? password) async {
  // Example structure assumption (adjust to your format):
  // [salt(16) | iv(12) | ciphertext(...) | tag(16)]
  // Or if you stored a JSON envelope with base64 fields, parse that here.

  // PSEUDO:
  // final salt = encrypted.sublist(0, 16);
  // final iv = encrypted.sublist(16, 28);
  // final ct = encrypted.sublist(28);
  // final key = await _deriveKey(password ?? "", salt); // treat null == empty string
  // final plain = aesGcmDecrypt(key, iv, ct);
  // return plain;

  // For now we throw to force you to wire this to your actual crypto util:
  throw UnimplementedError(
      "Wire _decryptPayload to your existing AES-GCM routine");
}

/// Your existing apply logic (truncate & insert or merge)
Future<void> _applyBackupPayload(Map<String, dynamic> payload) async {
  // e.g. payload['food_entries'], payload['water_entries'], etc.
  // Make sure to wrap in a transaction & validate shapes.
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/data/product_database_helper.dart =====

// lib/data/product_database_helper.dart

import 'dart:async';
import 'dart:io';
import 'package:flutter/services.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import '../models/food_item.dart';
import './database_helper.dart';

class ProductDatabaseHelper {
  static final ProductDatabaseHelper instance = ProductDatabaseHelper._init();
  ProductDatabaseHelper._init();

  static Database? _offDatabase;
  static Database? _baseDatabase;

  // Ein einfacher Sperrmechanismus, um doppelte Initialisierung zu verhindern.
  static bool _isInitializing = false;
// --- NEU: kleine Helpers ganz oben in der Klasse ---
  bool _isOpen(Database? db) => db != null && db.isOpen;

  Future<void> _ensureDatabasesAlive() async {
    if (_offDatabase != null && !_offDatabase!.isOpen) {
      _offDatabase = await _initDB('vita_prep_de.db');
    }
    if (_baseDatabase != null && !_baseDatabase!.isOpen) {
      _baseDatabase = await _initDB('vita_base_foods.db');
    }
  }

  Future<void> reloadBaseDb() async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, 'vita_base_foods.db');
    try {
      await _baseDatabase?.close();
    } catch (_) {}
    _baseDatabase = await openDatabase(path);
  }

  // Stellt sicher, dass die Datenbanken geladen sind, bevor eine Abfrage erfolgt.
  Future<void> _ensureDatabasesInitialized() async {
    // Wenn die DBs schon da sind, ist alles gut.
    if (_offDatabase != null) {
      return;
    }

    // Wenn die Initialisierung bereits läuft, warte kurz.
    // Dies ist eine einfache Absicherung, keine komplexe Sperre.
    if (_isInitializing) {
      await Future.delayed(const Duration(milliseconds: 50));
      return _ensureDatabasesInitialized();
    }

    _isInitializing = true;

    // EINFACHE, SEQUENZIELLE INITIALISIERUNG - KEIN Future.wait
    try {
      _offDatabase = await _initDB('vita_prep_de.db');
    } catch (e) {
      print(
          "KRITISCHER FEHLER: Die Haupt-Produktdatenbank konnte nicht geladen werden: $e");
    }

    try {
      _baseDatabase = await _initDB('vita_base_foods.db');
    } catch (e) {
      print(
          "INFO: Die optionale Grundnahrungsmittel-DB wurde nicht gefunden. Das ist normal, wenn sie noch nicht hinzugefügt wurde. Fehler: $e");
    }

    _isInitializing = false;
  }

  Future<Database> _initDB(String fileName) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, fileName);
    final exists = await databaseExists(path);

    if (!exists) {
      print(
          "Datenbank '$fileName' existiert nicht, kopiere sie aus den Assets...");
      try {
        await Directory(dirname(path)).create(recursive: true);
        ByteData data = await rootBundle.load(join('assets/db', fileName));
        List<int> bytes =
            data.buffer.asUint8List(data.offsetInBytes, data.lengthInBytes);
        await File(path).writeAsBytes(bytes, flush: true);
        print("Datenbank '$fileName' erfolgreich kopiert.");
      } catch (e) {
        print("Fehler beim Kopieren der Datenbank '$fileName': $e");
        if (await File(path).exists()) await File(path).delete();
        throw Exception(
            "Konnte Datenbank '$fileName' nicht aus den Assets laden.");
      }
    } else {
      print("Bestehende Datenbank '$fileName' gefunden.");
    }
    return await openDatabase(path);
  }

  // ÖFFENTLICHER GETTER FÜR DEN BACKUP-MANAGER
  Future<Database?> get offDatabase async {
    await _ensureDatabasesInitialized();
    return _offDatabase;
  }

  Future<List<FoodItem>> searchProducts(String query) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    final List<FoodItem> combinedResults = [];

    if (_baseDatabase != null) {
      final List<Map<String, dynamic>> baseMaps = await _baseDatabase!.query(
          'products',
          where: 'name LIKE ?',
          whereArgs: ['%$query%'],
          limit: 25);
      combinedResults.addAll(baseMaps
          .map((map) => FoodItem.fromMap(map, source: FoodItemSource.base)));
    }

    // Die Haupt-DB muss existieren, sonst stürzt die App hier ab, was korrekt ist.
    if (_offDatabase != null) {
      final List<Map<String, dynamic>> offMaps = await _offDatabase!.query(
          'products',
          where: 'name LIKE ? OR brand LIKE ?',
          whereArgs: ['%$query%', '%$query%'],
          limit: 50);
      combinedResults.addAll(offMaps
          .map((map) => FoodItem.fromMap(map, source: FoodItemSource.off)));
    }

    final uniqueResults = <String, FoodItem>{};
    for (var item in combinedResults) {
      uniqueResults.putIfAbsent(item.barcode, () => item);
    }
    return uniqueResults.values.toList();
  }

  Future<FoodItem?> getProductByBarcode(String barcode) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();

    // Lokaler Helper mit anderem Namen als das Keyword "try"
    Future<FoodItem?> attempt() async {
      if (_baseDatabase != null) {
        final baseMaps = await _baseDatabase!.query(
          'products',
          where: 'barcode = ?',
          whereArgs: [barcode],
          limit: 1,
        );
        if (baseMaps.isNotEmpty) {
          return FoodItem.fromMap(baseMaps.first, source: FoodItemSource.base);
        }
      }

      if (_offDatabase != null) {
        final offMaps = await _offDatabase!.query(
          'products',
          where: 'barcode = ?',
          whereArgs: [barcode],
          limit: 1,
        );
        if (offMaps.isNotEmpty) {
          return FoodItem.fromMap(offMaps.first, source: FoodItemSource.off);
        }
      }

      return null;
    }

    try {
      return await attempt();
    } on DatabaseException catch (e) {
      // Falls eine der DBs zwischenzeitlich geschlossen wurde → wiederbeleben & einmalig erneut versuchen
      final msg = e.toString().toLowerCase();
      if (msg.contains('database_closed') ||
          msg.contains('attempt to reopen')) {
        await _ensureDatabasesAlive();
        return await attempt();
      }
      rethrow;
    }
  }

  Future<void> insertProduct(FoodItem item) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    if (_offDatabase == null) return;
    await _offDatabase!.insert('products', item.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace);
  }

  Future<List<FoodItem>> _getProductsByBarcodes(List<String> barcodes) async {
    if (barcodes.isEmpty) return [];
    final results = <FoodItem>[];
    for (final barcode in barcodes) {
      final product = await getProductByBarcode(barcode);
      if (product != null) results.add(product);
    }
    return results;
  }

  Future<List<FoodItem>> getFavoriteProducts() async {
    final favoriteBarcodes =
        await DatabaseHelper.instance.getFavoriteBarcodes();
    return await _getProductsByBarcodes(favoriteBarcodes);
  }

  Future<List<FoodItem>> getRecentProducts() async {
    final recentBarcodes =
        await DatabaseHelper.instance.getRecentlyUsedBarcodes();
    return await _getProductsByBarcodes(recentBarcodes);
  }

  Future<List<FoodItem>> getProductsByBarcodes(List<String> barcodes) async {
    if (barcodes.isEmpty) return [];
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();

    final db = _offDatabase;
    if (db == null) return [];

    // Erstellt eine Kette von '?' für die IN-Klausel
    final placeholders = List.filled(barcodes.length, '?').join(',');
    final maps = await db.query(
      'products',
      where: 'barcode IN ($placeholders)',
      whereArgs: barcodes,
    );
    return maps
        .map((map) => FoodItem.fromMap(map, source: FoodItemSource.off))
        .toList();
  }

  Future<void> updateProduct(FoodItem item) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    if (_offDatabase == null) return;
    await _offDatabase!.update(
      'products',
      item.toMap(),
      where: 'barcode = ?',
      whereArgs: [item.barcode],
    );
  }

  // === NEU: Grundnahrungsmittel lesen (optional mit Kategorie) ===
  Future<List<FoodItem>> getBaseFoods({
    String? categoryKey,
    int limit = 200,
    int offset = 0,
    String? search,
  }) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    if (_baseDatabase == null) return [];

    final whereParts = <String>[];
    final whereArgs = <Object?>[];

    if (categoryKey != null && categoryKey.isNotEmpty) {
      whereParts.add('category_key = ?');
      whereArgs.add(categoryKey);
    }

    if (search != null && search.trim().isNotEmpty) {
      // Suche über name/name_de/name_en
      whereParts.add('(name LIKE ? OR name_de LIKE ? OR name_en LIKE ?)');
      final q = '%${search.trim()}%';
      whereArgs.addAll([q, q, q]);
    }

    final rows = await _baseDatabase!.query(
      'products',
      where: whereParts.isEmpty ? null : whereParts.join(' AND '),
      whereArgs: whereArgs.isEmpty ? null : whereArgs,
      orderBy: 'name COLLATE NOCASE',
      limit: limit,
      offset: offset,
    );

    return rows
        .map((m) => FoodItem.fromMap(m, source: FoodItemSource.base))
        .toList();
  }

// === NEU: Kategorien (für späteren Filter / Anzeige) ===
  Future<List<Map<String, dynamic>>> getBaseCategories() async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    if (_baseDatabase == null) return [];
    return _baseDatabase!.query(
      'categories',
      columns: ['key', 'name_de', 'name_en', 'emoji'],
      orderBy: 'name_de COLLATE NOCASE',
    );
  }

// === DEV: Felder eines Basis-Eintrags aktualisieren (barcode bleibt) ===
  Future<void> updateBaseProductFields({
    required String barcode,
    required Map<String, Object?> fields, // nur Spalten, die du ändern willst
  }) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    if (_baseDatabase == null) {
      throw Exception('Basis-DB nicht geladen');
    }
    if (fields.isEmpty) return;

    // Safety: Barcode niemals überschreiben
    final safe = Map<String, Object?>.from(fields)..remove('barcode');

    await _baseDatabase!.update(
      'products',
      safe,
      where: 'barcode = ?',
      whereArgs: [barcode],
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

// === DEV: Pfad der Basis-DB ermitteln (für Export/Share) ===
  Future<String> getBaseDbPath() async {
    final dbPath = await getDatabasesPath();
    return join(dbPath, 'vita_base_foods.db');
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/data/import_manager.dart =====

// lib/data/import_manager.dart (Final, mit Deutsch-Support)

import 'dart:io';
import 'package:csv/csv.dart';
import 'package:file_picker/file_picker.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/models/set_log.dart';

class ImportManager {
  Future<int> importHevyCsv() async {
    try {
      final result = await FilePicker.platform
          .pickFiles(type: FileType.custom, allowedExtensions: ['csv']);
      if (result == null || result.files.single.path == null) return 0;
      final filePath = result.files.single.path!;
      final file = File(filePath);
      final content = await file.readAsString();
      final List<List<dynamic>> rows =
          const CsvToListConverter(shouldParseNumbers: false, eol: '\n')
              .convert(content);

      if (rows.length < 2) return 0;

      final workoutGroups = <String, List<Map<String, dynamic>>>{};
      final header = rows.first.map((e) => e.toString().trim()).toList();

      for (var i = 1; i < rows.length; i++) {
        final row = rows[i];
        if (row.length != header.length) continue;
        final rowMap = Map<String, dynamic>.fromIterables(header, row);

        if (rowMap['start_time'] == null ||
            rowMap['start_time'].toString().trim().isEmpty) {
          continue;
        }

        final key = "${rowMap['title']}_${rowMap['start_time']}";
        if (workoutGroups.containsKey(key)) {
          workoutGroups[key]!.add(rowMap);
        } else {
          workoutGroups[key] = [rowMap];
        }
      }

      final db = WorkoutDatabaseHelper.instance;
      int importedWorkouts = 0;
      final knownMap = await db.getExerciseMappings();
      for (var group in workoutGroups.values) {
        final firstRow = group.first;
        final newLog = await db.startWorkout(routineName: firstRow['title']);

        final dbInstance = await db.database;
        await dbInstance.update(
            'workout_logs',
            {
              'start_time':
                  _parseHevyDate(firstRow['start_time']).toIso8601String(),
              'end_time':
                  _parseHevyDate(firstRow['end_time']).toIso8601String(),
              'notes': firstRow['description'],
              'status': 'completed',
            },
            where: 'id = ?',
            whereArgs: [newLog.id]);

        int setOrder = 0;
        for (var row in group) {
          final rawName = row['exercise_title']?.toString() ?? '';
          final mappedName = knownMap[rawName.trim().toLowerCase()] ?? rawName;

          final setLog = SetLog(
            workoutLogId: newLog.id!,
            exerciseName: mappedName, // <— statt rawName
            setType: row['set_type'] ?? 'normal',
            weightKg: double.tryParse(row['weight_kg']?.toString() ?? ''),
            reps: int.tryParse(row['reps']?.toString() ?? ''),
            log_order: setOrder++,
            notes: row['exercise_notes'],
            distanceKm: double.tryParse(row['distance_km']?.toString() ?? ''),
            durationSeconds:
                int.tryParse(row['duration_seconds']?.toString() ?? ''),
            rpe: int.tryParse(row['rpe']?.toString() ?? ''),
            supersetId: int.tryParse(row['superset_id']?.toString() ?? ''),
          );
          await db.insertSetLog(setLog);
        }
        importedWorkouts++;
      }
      return importedWorkouts;
    } catch (e) {
      print("Hevy Import Error: $e");
      return -1;
    }
  }

  /// KORREKTUR: Die Parser-Funktion unterstützt jetzt explizit deutsche Monatsnamen.
  DateTime _parseHevyDate(dynamic rawDateString) {
    final dateString = rawDateString?.toString().trim();
    if (dateString == null || dateString.isEmpty) {
      print(
          "Leere oder null Datumszeichenfolge erhalten. Fallback auf DateTime.now()");
      return DateTime.now();
    }

    // Die Liste der Formate wurde um das deutsche Locale erweitert.
    final List<DateFormat> formats = [
      DateFormat("dd MMM yyyy, HH:mm",
          "en_US"), // Probiert zuerst Englisch (Jan, Feb, Apr...)
      DateFormat(
          "dd MMM yyyy, HH:mm", "de_DE"), // Dann Deutsch (März, Mai, Juni...)
      DateFormat("yyyy-MM-dd HH:mm:ss"),
      DateFormat("dd.MM.yyyy, HH:mm"),
    ];

    for (final format in formats) {
      try {
        return format.parse(dateString);
      } catch (e) {
        continue;
      }
    }

    print("Konnte Datum nicht mit bekannten Formaten parsen: '$dateString'");
    return DateTime.now();
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/services/ui_state_service.dart =====

// lib/services/ui_state_service.dart

class UiStateService {
  // Statische Instanz, die beim ersten Zugriff erstellt wird (Singleton-Pattern)
  static final UiStateService instance = UiStateService._internal();

  // Privater Konstruktor
  UiStateService._internal();

  // Der Zustand, den wir speichern wollen
  bool isNutritionSummaryExpanded = true; // Standardmäßig AN, wie gewünscht
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/services/profile_service.dart =====

// lib/services/profile_service.dart
// VEREINFACHTE UND KORRIGIERTE VERSION

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';

class ProfileService extends ChangeNotifier {
  static final ProfileService _instance = ProfileService._internal();
  factory ProfileService() => _instance;
  ProfileService._internal();

  String? _profileImagePath;
  String? get profileImagePath => _profileImagePath;
  int cacheBuster = 0;

  bool _isPickerActive = false;
  static const String _profileImageKey = 'profileImagePath';

  Future<void> initialize() async {
    final prefs = await SharedPreferences.getInstance();
    _profileImagePath = prefs.getString(_profileImageKey);
    notifyListeners();
  }

  Future<void> pickAndSaveProfileImage() async {
    if (_isPickerActive) return;
    _isPickerActive = true;

    try {
      final picker = ImagePicker();
      final pickedFile = await picker.pickImage(source: ImageSource.gallery);

      if (pickedFile != null) {
        final appDir = await getApplicationDocumentsDirectory();
        const fileName = 'profile_image.jpg';
        final localPath = '${appDir.path}/$fileName';

        final newImage = await File(pickedFile.path).copy(localPath);
        final prefs = await SharedPreferences.getInstance();
        await prefs.setString(_profileImageKey, newImage.path);
        _profileImagePath = newImage.path;

        // Erhöhe den Cache-Buster, um einen Rebuild zu erzwingen
        cacheBuster++;
        notifyListeners();
      }
    } finally {
      _isPickerActive = false;
    }
  }

  Future<void> deleteProfileImage() async {
    final prefs = await SharedPreferences.getInstance();
    final currentPath = prefs.getString(_profileImageKey);

    if (currentPath != null) {
      // 1. Immediately remove the reference from persistent storage.
      await prefs.remove(_profileImageKey);

      // 2. Immediately update the internal state and notify the UI.
      _profileImagePath = null;
      cacheBuster++;
      notifyListeners();

      // 3. Try to delete the actual file from disk in the background.
      try {
        final imageFile = File(currentPath);
        if (await imageFile.exists()) {
          await imageFile.delete();
        }
      } catch (e) {
        // Log the error, but the app's state is already corrected.
        debugPrint('Failed to delete profile image file: $e');
      }
    }
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/services/theme_service.dart =====

import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

class ThemeService extends ChangeNotifier {
  static const _themeKey = 'theme_mode';
  ThemeMode _themeMode = ThemeMode.system;

  ThemeMode get themeMode => _themeMode;

  ThemeService() {
    _loadThemeMode();
  }

  Future<void> _loadThemeMode() async {
    final prefs = await SharedPreferences.getInstance();
    // Default to system if no preference is saved
    final themeIndex = prefs.getInt(_themeKey) ?? ThemeMode.system.index;
    _themeMode = ThemeMode.values[themeIndex];
    notifyListeners();
  }

  Future<void> setThemeMode(ThemeMode mode) async {
    if (mode == _themeMode) return;
    _themeMode = mode;
    notifyListeners();
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt(_themeKey, mode.index);
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/services/workout_session_manager.dart =====

// lib/services/workout_session_manager.dart
// VOLLSTÄNDIGER CODE (FINAL)

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:vibration/vibration.dart';
import 'package:lightweight/models/routine_exercise.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/models/set_template.dart';

class WorkoutSessionManager extends ChangeNotifier {
  static final WorkoutSessionManager _instance =
      WorkoutSessionManager._internal();
  factory WorkoutSessionManager() => _instance;
  WorkoutSessionManager._internal();

  WorkoutLog? _workoutLog;
  List<RoutineExercise> _exercises = [];
  final Map<int, SetLog> _setLogs = {};

  final Map<int, int?> pauseTimes = {};

  Timer? _restTimer;
  int _remainingRestSeconds = 0;
  Timer? _restDoneBannerTimer;
  bool _showRestDone = false;

  Timer? _workoutDurationTimer;
  Duration _elapsedDuration = Duration.zero;
  double _totalVolume = 0.0;
  int _totalSets = 0;

  double get totalVolume => _totalVolume;
  int get totalSets => _totalSets;
  WorkoutLog? get workoutLog => _workoutLog;
  List<RoutineExercise> get exercises => _exercises;
  int get remainingRestSeconds => _remainingRestSeconds;
  bool get isActive => _workoutLog != null && _workoutLog!.endTime == null;
  bool get showRestDone => _showRestDone;
  Duration get elapsedDuration => _elapsedDuration;
  Map<int, SetLog> get setLogs => _setLogs;

// Ersetze diese Methode in lib/services/workout_session_manager.dart

// Ersetze diese Methode in lib/services/workout_session_manager.dart

  Future<void> restoreWorkoutSession(WorkoutLog logToRestore) async {
    final db = WorkoutDatabaseHelper.instance;
    _workoutLog = logToRestore;
    _exercises = [];
    pauseTimes.clear();
    _setLogs.clear();

    // 1. Hole alle einzigartigen Übungen, sortiert nach ihrem ersten Auftreten (log_order)
    final sortedSets = logToRestore.sets
      ..sort((a, b) => (a.log_order ?? 999).compareTo(b.log_order ?? 999));
    final orderedUniqueExerciseNames =
        sortedSets.map((s) => s.exerciseName).toSet().toList();

    // 2. Baue die _exercises-Liste in der korrekten Reihenfolge auf
    for (final name in orderedUniqueExerciseNames) {
      final exerciseDetail = await db.getExerciseByName(name);
      if (exerciseDetail != null) {
        final setsForThisExercise =
            sortedSets.where((s) => s.exerciseName == name).toList();

        final routineExercise = RoutineExercise(
          id: DateTime.now().millisecondsSinceEpoch + _exercises.length,
          exercise: exerciseDetail,
          setTemplates: setsForThisExercise
              .map((s) => SetTemplate(id: s.id!, setType: s.setType))
              .toList(),
        );
        _exercises.add(routineExercise);

        // Fülle die _setLogs Map und die Pausenzeiten
        for (final setLog in setsForThisExercise) {
          _setLogs[setLog.id!] = setLog;
        }
        if (setsForThisExercise.isNotEmpty) {
          pauseTimes[routineExercise.id!] =
              setsForThisExercise.first.restTimeSeconds;
        }
      }
    }

    _recalculateStats();
    _startWorkoutTimer();
    notifyListeners();
  }

  Future<void> startWorkout(
      WorkoutLog log, List<RoutineExercise> routineExercises) async {
    _workoutLog = log;
    _exercises = routineExercises;
    _setLogs.clear();
    pauseTimes.clear();

    final db = WorkoutDatabaseHelper.instance;

    for (var re in routineExercises) {
      pauseTimes[re.id!] = re.pauseSeconds;
      final exerciseIndex = routineExercises.indexOf(re);

      for (final template in re.setTemplates) {
        final placeholder = SetLog(
          workoutLogId: _workoutLog!.id!,
          exerciseName: re.exercise.nameEn,
          setType: template.setType,
          isCompleted: false,
          log_order: exerciseIndex,
        );
        final newId = await db.insertSetLog(placeholder);
        _setLogs[template.id!] = placeholder.copyWith(id: newId);
      }
    }

    _recalculateStats();
    _startWorkoutTimer();
    notifyListeners();
  }

// Ersetze diese Methode in lib/services/workout_session_manager.dart

  Future<void> updateSet(int templateId,
      {double? weight, int? reps, String? setType, bool? isCompleted}) async {
    if (_workoutLog == null || !_setLogs.containsKey(templateId)) return;

    SetLog currentLog = _setLogs[templateId]!;
    final exerciseIndex = _exercises
        .indexWhere((e) => e.setTemplates.any((t) => t.id == templateId));

    // Hole die aktuelle Pausenzeit für diese Übung
    int? currentRestTime;
    if (exerciseIndex != -1) {
      currentRestTime = pauseTimes[_exercises[exerciseIndex].id!];
    }

    _setLogs[templateId] = currentLog.copyWith(
      weightKg: weight,
      reps: reps,
      setType: setType,
      isCompleted: isCompleted,
      log_order: exerciseIndex,
      restTimeSeconds:
          currentRestTime, // KORREKTUR: Speichere die Pause immer mit
    );

    final db = WorkoutDatabaseHelper.instance;
    final logToSave = _setLogs[templateId]!;

    if (logToSave.id != null && logToSave.id! > 0) {
      await db.insertSetLog(logToSave);
    } else {
      final newId = await db.insertSetLog(logToSave);
      _setLogs[templateId] = logToSave.copyWith(id: newId);
    }

    if (isCompleted != null) {
      _recalculateStats();
      if (isCompleted) {
        if (exerciseIndex != -1) {
          final re = _exercises[exerciseIndex];
          final restTime = pauseTimes[re.id!];
          if (restTime != null && restTime > 0) {
            _startRestTimer(restTime);
          }
        }
      }
    }
    notifyListeners();
  }

// Ersetze diese Methode in lib/services/workout_session_manager.dart

  void reorderExercise(int oldIndex, int newIndex) {
    if (newIndex > oldIndex) {
      newIndex -= 1;
    }
    final item = _exercises.removeAt(oldIndex);
    _exercises.insert(newIndex, item);

    // Aktualisiere den log_order für alle Sätze basierend auf der neuen Reihenfolge der Übungen
    for (int i = 0; i < _exercises.length; i++) {
      final re = _exercises[i];
      for (final template in re.setTemplates) {
        if (_setLogs.containsKey(template.id!)) {
          // Hier rufen wir direkt updateSet auf, um die Änderung auch in die DB zu schreiben
          updateSet(template.id!,
              isCompleted: _setLogs[template.id!]!.isCompleted);
        }
      }
    }
    notifyListeners();
  }

  void updatePauseTime(int routineExerciseId, int newSeconds) {
    pauseTimes[routineExerciseId] = newSeconds;
    // Finde die zugehörigen Sätze und speichere die neue Pausezeit in der DB
    final exercise = _exercises.firstWhere((e) => e.id == routineExerciseId);
    for (final template in exercise.setTemplates) {
      if (_setLogs.containsKey(template.id!)) {
        updateSet(template.id!,
            isCompleted: _setLogs[template.id!]!.isCompleted);
      }
    }
    notifyListeners();
  }

  Future<void> removeExercise(int routineExerciseId) async {
    final exerciseToRemove =
        _exercises.firstWhere((e) => e.id == routineExerciseId);

    final idsToDelete = <int>[];
    for (final template in exerciseToRemove.setTemplates) {
      final log = _setLogs[template.id!];
      if (log?.id != null) idsToDelete.add(log!.id!);
      _setLogs.remove(template.id!);
    }
    if (idsToDelete.isNotEmpty) {
      await WorkoutDatabaseHelper.instance.deleteSetLogs(idsToDelete);
    }

    _exercises.removeWhere((e) => e.id == routineExerciseId);
    pauseTimes.remove(routineExerciseId);
    _recalculateStats();
    notifyListeners();
  }

// Ersetze diese Methode in lib/services/workout_session_manager.dart

  Future<RoutineExercise?> addExercise(Exercise exercise) async {
    if (_workoutLog == null) return null;

    final newRoutineExercise = RoutineExercise(
      id: DateTime.now().millisecondsSinceEpoch,
      exercise: exercise,
      setTemplates: [
        SetTemplate(
            id: DateTime.now().millisecondsSinceEpoch + 1, setType: 'normal'),
      ],
    );
    _exercises.add(newRoutineExercise);
    pauseTimes[newRoutineExercise.id!] = null;

    final newTemplate = newRoutineExercise.setTemplates.first;
    final db = WorkoutDatabaseHelper.instance;
    final placeholder = SetLog(
      workoutLogId: _workoutLog!.id!,
      exerciseName: exercise.nameEn,
      setType: newTemplate.setType,
      isCompleted: false,
      log_order: _exercises.length - 1,
    );
    final newId = await db.insertSetLog(placeholder);
    _setLogs[newTemplate.id!] = placeholder.copyWith(id: newId);

    notifyListeners();
    return newRoutineExercise;
  }

  Future<SetTemplate?> addSetToExercise(int routineExerciseId) async {
    final exerciseIndex =
        _exercises.indexWhere((e) => e.id == routineExerciseId);
    if (exerciseIndex == -1) return null;

    final newTemplate = SetTemplate(
      id: DateTime.now().millisecondsSinceEpoch,
      setType: 'normal',
    );
    _exercises[exerciseIndex].setTemplates.add(newTemplate);

    final db = WorkoutDatabaseHelper.instance;
    final placeholder = SetLog(
      workoutLogId: _workoutLog!.id!,
      exerciseName: _exercises[exerciseIndex].exercise.nameEn,
      setType: newTemplate.setType,
      isCompleted: false,
      log_order: exerciseIndex,
    );
    final newId = await db.insertSetLog(placeholder);
    _setLogs[newTemplate.id!] = placeholder.copyWith(id: newId);

    notifyListeners();
    return newTemplate;
  }

  Future<void> removeSet(int templateId) async {
    final existing = _setLogs[templateId];
    if (existing?.id != null) {
      await WorkoutDatabaseHelper.instance.deleteSetLogs([existing!.id!]);
    }
    for (final re in _exercises) {
      re.setTemplates.removeWhere((t) => t.id == templateId);
    }
    _setLogs.remove(templateId);
    _recalculateStats();
    notifyListeners();
  }

  Future<void> finishWorkout() async {
    if (_workoutLog == null) return;
    final db = WorkoutDatabaseHelper.instance;
    final emptySetIds = _setLogs.values
        .where((sl) => sl.isCompleted != true && sl.id != null)
        .map((sl) => sl.id!)
        .toList();

    if (emptySetIds.isNotEmpty) {
      await db.deleteSetLogs(emptySetIds);
    }
    await db.finishWorkout(_workoutLog!.id!);
    _stopWorkoutTimer();
    _restTimer?.cancel();
    _workoutLog = null;
    _exercises = [];
    _setLogs.clear();
    _recalculateStats();
    notifyListeners();
  }

  void _recalculateStats() {
    double newVolume = 0.0;
    int newSets = 0;
    for (final setLog in _setLogs.values) {
      if (setLog.isCompleted == true) {
        newVolume += (setLog.weightKg ?? 0.0) * (setLog.reps ?? 0);
        newSets++;
      }
    }
    _totalVolume = newVolume;
    _totalSets = newSets;
    notifyListeners();
  }

  void cancelRest() {
    _restTimer?.cancel();
    _restDoneBannerTimer?.cancel();
    _remainingRestSeconds = 0;
    _showRestDone = false;
    notifyListeners();
  }

  void _startRestTimer(int seconds) {
    _restTimer?.cancel();
    _restDoneBannerTimer?.cancel();
    _remainingRestSeconds = seconds;
    _showRestDone = false;
    notifyListeners();
    _restTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_remainingRestSeconds > 0) {
        _remainingRestSeconds--;
        notifyListeners();
      } else {
        timer.cancel();
        Vibration.vibrate(duration: 500);
        _showRestDone = true;
        notifyListeners();
        _restDoneBannerTimer = Timer(const Duration(seconds: 10), () {
          _showRestDone = false;
          notifyListeners();
        });
      }
    });
  }

  void skipRestTimer() {
    _restTimer?.cancel();
    _remainingRestSeconds = 0;
    notifyListeners();
  }

  void _startWorkoutTimer() {
    _workoutDurationTimer?.cancel();
    _elapsedDuration = Duration.zero;
    if (_workoutLog != null) {
      _elapsedDuration = DateTime.now().difference(_workoutLog!.startTime);
    }
    _workoutDurationTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_workoutLog != null) {
        _elapsedDuration = DateTime.now().difference(_workoutLog!.startTime);
        notifyListeners();
      } else {
        timer.cancel();
      }
    });
  }

  void _stopWorkoutTimer() {
    _workoutDurationTimer?.cancel();
  }

  Future<void> tryRestoreSession() async {
    final db = WorkoutDatabaseHelper.instance;
    final WorkoutLog? ongoingWorkout = await db.getOngoingWorkout();

    if (ongoingWorkout != null) {
      print(
          "Laufendes Workout gefunden (ID: ${ongoingWorkout.id}). Stelle Session wieder her...");
      await restoreWorkoutSession(ongoingWorkout);
      print("Session erfolgreich wiederhergestellt.");
    } else {
      print("Kein laufendes Workout gefunden. Starte normal.");
    }
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/compact_nutrition_bar.dart =====

// lib/widgets/compact_nutrition_bar.dart

import 'package:flutter/material.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/util/design_constants.dart';

class CompactNutritionBar extends StatelessWidget {
  final DailyNutrition nutritionData;
  const CompactNutritionBar({super.key, required this.nutritionData});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: DesignConstants.cardMargin,
      child: Column(
        children: [
          _buildProgressBar(
            context: context,
            label: 'Kalorien',
            value: nutritionData.calories.toDouble(),
            target: nutritionData.targetCalories.toDouble(),
            unit: 'kcal',
            color: Colors.orange,
          ),
          const SizedBox(height: DesignConstants.spacingM),
          _buildProgressBar(
            context: context,
            label: 'Protein',
            value: nutritionData.protein.toDouble(),
            target: nutritionData.targetProtein.toDouble(),
            unit: 'g',
            color: Colors.red.shade400,
          ),
          const SizedBox(height: DesignConstants.spacingM),
          _buildProgressBar(
              context: context,
              label: 'Wasser',
              value: nutritionData.water.toDouble(),
              target: nutritionData.targetWater.toDouble(),
              unit: 'L',
              isWater: true,
              color: Colors.blue),
        ],
      ),
    );
  }

  Widget _buildProgressBar({
    required BuildContext context,
    required String label,
    required double value,
    required double target,
    required String unit,
    required Color color,
    bool isWater = false,
  }) {
    final progress = target > 0 ? (value / target).clamp(0.0, 1.0) : 0.0;
    final displayValue =
        isWater ? (value / 1000).toStringAsFixed(1) : value.toStringAsFixed(0);
    final displayTarget = isWater
        ? (target / 1000).toStringAsFixed(0)
        : target.toStringAsFixed(0);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(label,
                style: Theme.of(context)
                    .textTheme
                    .bodyMedium
                    ?.copyWith(fontWeight: FontWeight.bold)),
            Text('$displayValue / $displayTarget $unit',
                style: Theme.of(context).textTheme.bodySmall),
          ],
        ),
        const SizedBox(height: 4),
        LinearProgressIndicator(
          value: progress,
          backgroundColor: color.withOpacity(0.2),
          color: color,
          minHeight: 8,
          borderRadius: BorderRadius.circular(4),
        ),
      ],
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/workout_summary_bar.dart =====

// lib/widgets/workout_summary_bar.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/time_util.dart'; // Wir erstellen diese Hilfsdatei gleich

class WorkoutSummaryBar extends StatelessWidget {
  const WorkoutSummaryBar({
    super.key,
    this.duration,
    required this.volume,
    required this.sets,
    this.progress, // NULL => Spacer-Modus
  });

  final Duration? duration;
  final double volume;
  final int sets;
  final double? progress; // 0..1 oder null

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        // Header ohne grauen Kasten
        Container(
          margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: [
              _buildStatColumn(
                context: context,
                label: l10n.durationLabel,
                value: formatDuration(duration ?? Duration.zero),
                highlight: true,
              ),
              _buildStatColumn(
                context: context,
                label: l10n.volumeLabel,
                value: "${volume.toStringAsFixed(0)} kg",
              ),
              _buildStatColumn(
                context: context,
                label: l10n.setsLabel,
                value: sets.toString(),
              ),
            ],
          ),
        ),

        // Progress / Spacer: volle Breite, kein Padding
        SizedBox(
          width: double.infinity,
          child: _WorkoutProgressBar(value: progress),
        ),
      ],
    );
  }

  /// Ein kleines Helfer-Widget für eine einzelne Statistik-Spalte.
  Widget _buildStatColumn({
    required BuildContext context,
    required String label,
    required String value,
    bool highlight = false,
  }) {
    final theme = Theme.of(context);
    final valueStyle = theme.textTheme.titleMedium?.copyWith(
      fontWeight: highlight ? FontWeight.bold : FontWeight.normal,
      color: highlight
          ? theme.colorScheme.primary
          : theme.textTheme.titleMedium?.color,
    );

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          label.toUpperCase(),
          style: theme.textTheme.labelSmall?.copyWith(
            color: Colors.grey[600],
            letterSpacing: 0.8,
          ),
        ),
        const SizedBox(height: 4),
        Text(value, style: valueStyle),
      ],
    );
  }
}

class _WorkoutProgressBar extends StatelessWidget {
  const _WorkoutProgressBar({required this.value});
  final double? value; // null => Spacer

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    final bg = Colors.white.withOpacity(0.10); // dezentes Grau
    final fg = cs.primary;

    final bar = ClipRRect(
      borderRadius: BorderRadius.circular(999),
      child: LayoutBuilder(
        builder: (context, c) {
          final v = (value ?? 0).clamp(0.0, 1.0);
          final w = c.maxWidth * v;
          return Stack(
            children: [
              Container(height: 6, color: bg),
              if (value != null)
                AnimatedContainer(
                  duration: const Duration(milliseconds: 250),
                  curve: Curves.easeOut,
                  width: w,
                  height: 6,
                  color: fg,
                ),
            ],
          );
        },
      ),
    );

    // kein Außenabstand → wirklich von ganz links bis ganz rechts
    return bar;
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/set_type_chip.dart =====

// lib/widgets/set_type_chip.dart

import 'package:flutter/material.dart';

class SetTypeChip extends StatelessWidget {
  final String setType;
  final int? setIndex;
  final bool isCompleted;
  final VoidCallback? onTap;

  const SetTypeChip({
    super.key,
    required this.setType,
    this.setIndex, // setIndex ist jetzt optional
    this.isCompleted = false,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final Map<String, dynamic> typeInfo = {
      'normal': {'char': setIndex.toString(), 'color': Colors.grey},
      'warmup': {'char': 'W', 'color': Colors.orange},
      'failure': {'char': 'F', 'color': Colors.red},
      'dropset': {'char': 'D', 'color': Colors.blue},
    };
    final type = typeInfo[setType] ?? typeInfo['normal']!;
    final Color textColor = type['color'];

    return GestureDetector(
      onTap: isCompleted ? null : onTap,
      child: SizedBox(
        width: 40, // Feste Breite für die Spalte
        height: 40, // Feste Höhe
        child: Center(
          child: Text(
            type['char'],
            style: TextStyle(
              color: textColor,
              fontSize: 20, // Größere Schriftart
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/measurement_chart_widget.dart =====

import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/models/chart_data_point.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:flutter/services.dart';

class MeasurementChartWidget extends StatefulWidget {
  final String chartType;
  final DateTimeRange dateRange;
  final String unit;

  const MeasurementChartWidget({
    super.key,
    required this.chartType,
    required this.dateRange,
    required this.unit,
  });

  @override
  State<MeasurementChartWidget> createState() => _MeasurementChartWidgetState();
}

class _MeasurementChartWidgetState extends State<MeasurementChartWidget> {
  List<ChartDataPoint> _dataPoints = [];
  bool _isLoadingChart = true;
  int? _touchedIndex;

  @override
  void initState() {
    super.initState();
    _loadChartData();
  }

  @override
  void didUpdateWidget(covariant MeasurementChartWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.chartType != widget.chartType ||
        oldWidget.dateRange != widget.dateRange) {
      _loadChartData();
    }
  }

  Future<void> _loadChartData() async {
    setState(() {
      _isLoadingChart = true;
      _touchedIndex = null;
    });
    final data = await DatabaseHelper.instance
        .getChartDataForTypeAndRange(widget.chartType, widget.dateRange);
    if (mounted) {
      setState(() {
        _dataPoints = data;
        _isLoadingChart = false;
      });
    }
  }

  void _setTouchedIndexWithHaptics(int? newIndex) {
    if (newIndex == _touchedIndex) return; // nur bei echter Änderung vibrieren
    _touchedIndex = newIndex;
    if (newIndex != null) {
      HapticFeedback.selectionClick(); // dezentes Tock beim Punkt-Wechsel
    }
    if (mounted) setState(() {});
  }

  void _handleTouchCallback(FlTouchEvent event, LineTouchResponse? response) {
    if (event is FlPanEndEvent || event is FlTapUpEvent) {
      // Finger losgelassen: Auswahl zurücksetzen (ohne Haptik)
      _touchedIndex = null;
      if (mounted) setState(() {});
      return;
    }

    final spots = response?.lineBarSpots;
    if (spots != null && spots.isNotEmpty) {
      // Index des aktuell getroffenen Punktes
      final idx = spots.first.spotIndex;
      _setTouchedIndexWithHaptics(idx);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    if (_isLoadingChart) {
      return const SizedBox(
        height: 250,
        child: Center(child: CircularProgressIndicator()),
      );
    }
    if (_dataPoints.isEmpty) {
      return SizedBox(
        height: 250,
        child: Center(child: Text(l10n.chart_no_data_for_period)),
      );
    }

    // Punkt zur Anzeige (entweder getouched oder letzter)
    final int lastIdx = _dataPoints.length - 1;
    final int shownIdx = (_touchedIndex != null &&
            _touchedIndex! >= 0 &&
            _touchedIndex! < _dataPoints.length)
        ? _touchedIndex!
        : lastIdx;

// 2) Anzeigezeile oben (unverändert)
    final ChartDataPoint displayPoint = _dataPoints[shownIdx];
    final String displayValue =
        '${displayPoint.value.toStringAsFixed(1)} ${widget.unit}';
    final String displayDate = DateFormat.yMMMd().format(displayPoint.date);

    final Color lineColor = Theme.of(context).colorScheme.primary;
    final DateTime baseDate = _dataPoints.first.date;
    final int totalDays = widget.dateRange.end
        .difference(widget.dateRange.start)
        .inDays
        .clamp(1, 100000); // Schutz

// 1) Basisdaten: auf Tagesgrenzen normalisieren und SPAN berechnen
    final DateTime firstDate = DateTime(_dataPoints.first.date.year,
        _dataPoints.first.date.month, _dataPoints.first.date.day);
    final DateTime lastDate = DateTime(_dataPoints.last.date.year,
        _dataPoints.last.date.month, _dataPoints.last.date.day);

    final int spanDays = lastDate.difference(firstDate).inDays;
    final double lastX = spanDays.toDouble();

// ~6 Labels anpeilen (mind. 1)
    const int desiredLabels = 6;
    final int labelEvery = (spanDays / desiredLabels).ceil().clamp(1, 100000);

// Kompaktes Datumsformat abhängig von der Spannweite
    String labelFor(DateTime d) {
      if (spanDays > 365 * 2) return DateFormat('yyyy').format(d);
      if (spanDays > 365) return DateFormat('MMM yyyy').format(d);
      if (spanDays > 31) return DateFormat('MMM d').format(d);
      return DateFormat.MMMd().format(d);
    }

    return SizedBox(
      height: 250,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // LINKS bündig: Gewicht groß + Datum rechts daneben
          Row(
            mainAxisAlignment: MainAxisAlignment.start,
            children: [
              Text(
                displayValue,
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
              ),
              const SizedBox(width: 8),
              Text(
                displayDate,
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      color: Theme.of(context)
                          .colorScheme
                          .onSurface
                          .withOpacity(0.6),
                    ),
              ),
            ],
          ),
          const SizedBox(height: DesignConstants.spacingS),

          Expanded(
            child: LineChart(
              LineChartData(
                minX: 0,
                maxX: lastX == 0 ? 1 : lastX, // bei nur einem Punkt min Breite
                clipData: const FlClipData
                    .none(), // vermeidet Clipping am rechten Rand
                lineTouchData: LineTouchData(
                  handleBuiltInTouches: true,
                  touchTooltipData: LineTouchTooltipData(
                    //tooltipBgColor: Colors.transparent,
                    getTooltipItems: (touchedSpots) =>
                        List<LineTooltipItem?>.filled(touchedSpots.length, null,
                            growable: false),
                  ),
                  touchCallback: _handleTouchCallback,
                ),

                extraLinesData: ExtraLinesData(
                  horizontalLines: [
                    HorizontalLine(
                      y: _dataPoints.first.value,
                      color: Colors.grey.withOpacity(0.5),
                      strokeWidth: 1,
                      dashArray: [3, 4],
                    ),
                  ],
                ),
                gridData: const FlGridData(show: false),
                borderData: FlBorderData(show: false),

                titlesData: FlTitlesData(
                  leftTitles: const AxisTitles(
                    sideTitles: SideTitles(showTitles: false),
                  ),
                  topTitles: const AxisTitles(
                    sideTitles: SideTitles(showTitles: false),
                  ),
                  rightTitles: AxisTitles(
                    sideTitles: SideTitles(
                      showTitles: true,
                      reservedSize: 40,
                      getTitlesWidget: (value, meta) => Text(
                        value.toStringAsFixed(0),
                        style: Theme.of(context).textTheme.bodySmall,
                        textAlign: TextAlign.right,
                      ),
                    ),
                  ),
                  bottomTitles: AxisTitles(
                    sideTitles: SideTitles(
                      showTitles: true,
                      reservedSize: 30,
                      // WIR benutzen zusätzlich eine Guard im Builder, damit niemals zu viele Labels erscheinen:
                      interval: 1, // technisch 1, aber wir filtern im Builder
                      getTitlesWidget: (value, meta) {
                        final int v = value.round();

                        // Immer erstes und letztes Label zeigen …
                        final bool isEdge = (v == 0) || (v == spanDays);
                        // … und sonst nur jeden 'labelEvery'-ten Tag
                        final bool show = isEdge || (v % labelEvery == 0);

                        if (!show) return const SizedBox.shrink();

                        final date = firstDate.add(Duration(days: v));
                        return SideTitleWidget(
                          meta: meta,
                          space: 8,
                          child: Text(
                            labelFor(date),
                            style: Theme.of(context).textTheme.bodySmall,
                          ),
                        );
                      },
                    ),
                  ),
                ),
                lineBarsData: [
                  LineChartBarData(
                    spots: _dataPoints.map((p) {
                      final x = DateTime(p.date.year, p.date.month, p.date.day)
                          .difference(firstDate)
                          .inDays
                          .toDouble();
                      return FlSpot(x, p.value);
                    }).toList(),
                    isCurved: false, // gerade Linien
                    color: Theme.of(context).colorScheme.primary,
                    barWidth: 3,
                    isStrokeCapRound: true,
                    // Dot nur beim getouchten Punkt:
                    dotData: FlDotData(
                      show: true,
                      checkToShowDot: (spot, bar) {
                        if (_touchedIndex == null) return false;
                        final idx = bar.spots.indexOf(spot);
                        return idx == _touchedIndex;
                      },
                      getDotPainter: (spot, percent, bar, index) =>
                          FlDotCirclePainter(
                        radius: 6,
                        color: Theme.of(context).colorScheme.primary,
                        strokeWidth: 2,
                        strokeColor: Theme.of(context).scaffoldBackgroundColor,
                      ),
                    ),
                    belowBarData: BarAreaData(
                      show: true,
                      gradient: LinearGradient(
                        colors: [
                          Theme.of(context)
                              .colorScheme
                              .primary
                              .withOpacity(0.3),
                          Theme.of(context)
                              .colorScheme
                              .primary
                              .withOpacity(0.0),
                        ],
                        begin: Alignment.topCenter,
                        end: Alignment.bottomCenter,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/frosted_container.dart =====

//lib/widgets/frosted_container.dart
import 'dart:ui';
import 'package:flutter/material.dart';

class FrostedContainer extends StatelessWidget {
  final Widget child;
  final EdgeInsetsGeometry margin;
  final EdgeInsetsGeometry padding;
  final double radius;
  final double blurSigma;

  const FrostedContainer({
    super.key,
    required this.child,
    this.margin = const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
    this.padding = const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
    this.radius = 20,
    this.blurSigma = 14,
  });

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Padding(
      padding: margin,
      child: ClipRRect(
        borderRadius: BorderRadius.circular(radius),
        child: BackdropFilter(
          filter: ImageFilter.blur(sigmaX: blurSigma, sigmaY: blurSigma),
          child: Container(
            padding: padding,
            decoration: BoxDecoration(
              color: Theme.of(context).brightness == Brightness.dark
                  ? Colors.black.withOpacity(0.6)
                  : Colors.white.withOpacity(0.7),
              borderRadius: BorderRadius.circular(radius),
              border: Border.all(
                color: cs.onSurface.withOpacity(0.08),
                width: 1,
              ),
              boxShadow: const [
                BoxShadow(
                    blurRadius: 18,
                    offset: Offset(0, 6),
                    color: Colors.black26),
              ],
            ),
            child: child,
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/glass_bottom_nav_bar.dart =====

import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:lightweight/theme/color_constants.dart';

class GlassBottomNavBar extends StatelessWidget {
  final int currentIndex;
  final ValueChanged<int> onTap;
  final VoidCallback onFabTap;
  final List<BottomNavigationBarItem> items;

  const GlassBottomNavBar({
    super.key,
    required this.currentIndex,
    required this.onTap,
    required this.onFabTap,
    required this.items,
  });
// Add inside class GlassBottomNavBar
  Widget _buildNavItem(
    BuildContext context,
    BottomNavigationBarItem item,
    bool isSelected,
    VoidCallback onTap,
  ) {
    final cs = Theme.of(context).colorScheme;
    final color = isSelected ? cs.primary : cs.onSurface.withOpacity(0.60);

    return Expanded(
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.circular(16),
          child: Stack(
            alignment: Alignment.center,
            children: [
              Padding(
                padding: const EdgeInsets.symmetric(vertical: 10),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    IconTheme(
                      data: IconThemeData(color: color, size: 24),
                      child: item.icon,
                    ),
                    const SizedBox(height: 4),
                    Text(
                      item.label ?? '',
                      maxLines: 2,
                      overflow: TextOverflow.fade,
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: color,
                        fontSize: 12,
                        fontWeight:
                            isSelected ? FontWeight.w400 : FontWeight.w400,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final bg = isDark ? summary_card_dark_mode : summary_card_white_mode;
    final backgroundColor =
        isDark ? summary_card_dark_mode : summary_card_white_mode;

    return ClipRRect(
      borderRadius: BorderRadius.circular(20),
      child: BackdropFilter(
        filter: ImageFilter.blur(sigmaX: 12, sigmaY: 12),
        child: Container(
          height: 76,
          padding: const EdgeInsets.symmetric(horizontal: 12),
          decoration: BoxDecoration(
            color: bg.withOpacity(0.80),
            borderRadius: BorderRadius.circular(20),
            border: Border.all(
              color: isDark
                  ? Colors.white.withOpacity(0.30)
                  : Colors.black.withOpacity(0.10),
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.3),
                blurRadius: 12,
                offset: const Offset(0, 6),
              ),
            ],
          ),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              // Only the 4 nav items now
              ...List.generate(items.length, (index) {
                final item = items[index];
                final isSelected = index == currentIndex;
                return _buildNavItem(
                  context,
                  item,
                  isSelected,
                  () => onTap(index),
                );
              }),
            ],
          ),
        ),
      ),
    );
  }
}

class _SquareFab extends StatelessWidget {
  final VoidCallback onTap;
  const _SquareFab({required this.onTap});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    final isDark = Theme.of(context).brightness == Brightness.dark;

    return Padding(
      // tiny inset so it doesn’t kiss the bar’s edge
      padding: const EdgeInsets.only(right: 4),
      child: SizedBox(
        width: 68, // a bit chunkier
        height: 68,
        child: Material(
          color: cs.primary, // accent
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(20), // closer to the bar’s 24
            side: BorderSide(
              color: isDark
                  ? Colors.white.withOpacity(0.20)
                  : Colors.black.withOpacity(0.10),
              width: 1, // same outline weight as the glass card
            ),
          ),
          elevation: 0, // we’ll use a soft drop shadow via DecoratedBox
          child: InkWell(
            onTap: onTap,
            borderRadius: BorderRadius.circular(20),
            child: DecoratedBox(
              decoration: const BoxDecoration(
                // soft drop shadow so it feels detached
                boxShadow: [
                  BoxShadow(
                    blurRadius: 24,
                    offset: Offset(0, 8),
                    color: Colors.black26,
                  ),
                ],
              ),
              child: Center(
                child: Icon(Icons.add, size: 30, color: cs.onPrimary),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _NavItem extends StatelessWidget {
  final BottomNavigationBarItem item;
  final bool isSelected;
  final VoidCallback onTap;

  const _NavItem({
    required this.item,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    final Color color =
        isSelected ? cs.primary : cs.onSurface.withOpacity(0.60);

    return Expanded(
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.circular(16),
          child: Stack(
            alignment: Alignment.center,
            children: [
              // content
              Padding(
                padding: const EdgeInsets.symmetric(vertical: 10),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    IconTheme(
                      data: IconThemeData(color: color, size: 24),
                      child: item.icon,
                    ),
                    const SizedBox(height: 4),
                    Text(
                      item.label ?? '',
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: color,
                        fontSize: 12,
                        fontWeight:
                            isSelected ? FontWeight.w600 : FontWeight.w400,
                      ),
                    ),
                  ],
                ),
              ),

              // tiny top indicator (2px)
              if (isSelected)
                Positioned(
                  top: 0,
                  child: Container(
                    width: 24,
                    height: 2,
                    decoration: BoxDecoration(
                      color: cs.primary,
                      borderRadius: BorderRadius.circular(2),
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/workout_card.dart =====

// lib/widgets/workout_card.dart
import 'package:flutter/material.dart';

class WorkoutCard extends StatelessWidget {
  final EdgeInsetsGeometry padding;
  final EdgeInsetsGeometry margin;
  final Widget child;

  const WorkoutCard({
    super.key,
    required this.child,
    this.padding = EdgeInsets.zero,
    this.margin = EdgeInsets.zero,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      key: key, // Key an den Container weitergeben
      margin: margin,
      padding: padding,
      decoration: BoxDecoration(
        color: Colors.transparent, // Komplett transparent
        borderRadius: BorderRadius.circular(20),
      ),
      child: ClipRRect(
        // Stellt sicher, dass die Ecken der Kinder abgerundet sind
        borderRadius: BorderRadius.circular(20),
        child: child,
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/wger_attribution_widget.dart =====

// lib/widgets/wger_attribution_widget.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:url_launcher/url_launcher.dart';

class WgerAttributionWidget extends StatelessWidget {
  final TextStyle? textStyle;

  const WgerAttributionWidget({super.key, this.textStyle});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final currentTextStyle = textStyle ??
        theme.textTheme.bodySmall?.copyWith(color: Colors.grey[600]);

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(8.0),
        child: GestureDetector(
          // Macht den Text klickbar
          onTap: () async {
            final uri = Uri.parse("https://wger.de/"); // <-- Geänderte URL
            try {
              if (await canLaunchUrl(uri)) {
                await launchUrl(uri);
              } else {
                throw 'Could not launch $uri';
              }
            } catch (e) {
              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                      content: Text(l10n.snackbar_could_not_open_open_link)),
                );
              }
            }
          },
          child: Text(
            l10n.exerciseDataAttribution, // <-- Geänderter Text
            style: currentTextStyle,
            textAlign: TextAlign.center,
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/supplement_summary_widget.dart =====

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/tracked_supplement.dart';
import 'package:lightweight/widgets/glass_progress_bar.dart';
import 'package:lightweight/theme/color_constants.dart';

class SupplementSummaryWidget extends StatelessWidget {
  final List<TrackedSupplement> trackedSupplements;
  final VoidCallback onTap;

  const SupplementSummaryWidget({
    super.key,
    required this.trackedSupplements,
    required this.onTap,
  });
  String localizeSupplementName(Supplement s, AppLocalizations l10n) {
    switch (s.code) {
      case 'caffeine':
        return l10n.supplement_caffeine;
      case 'creatine_monohydrate':
        return l10n.supplement_creatine_monohydrate;
      default:
        // Fallback: benutzerdefinierte Supplements behalten ihren Namen
        return s.name;
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final goalOnlySupplements = trackedSupplements
        .where((ts) =>
            ts.supplement.dailyGoal != null && ts.supplement.dailyLimit == null)
        .toList();

    final progressSupplements = trackedSupplements
        .where((ts) => ts.supplement.dailyLimit != null)
        .toList();

    if (goalOnlySupplements.isEmpty && progressSupplements.isEmpty) {
      return const SizedBox.shrink();
    }

    return Column(
      children: [
        ...goalOnlySupplements.map((ts) => GestureDetector(
              onTap: onTap,
              child: _CheckmarkCard(trackedSupplement: ts),
            )),
        ...progressSupplements.map((ts) {
          final supplement = ts.supplement;
          return GestureDetector(
            onTap: onTap,
            child: Padding(
              padding: const EdgeInsets.symmetric(vertical: 4.0),
              child: GlassProgressBar(
                label: localizeSupplementName(supplement, l10n),
                unit: supplement.unit,
                value: ts.totalDosedToday,
                target: supplement.dailyLimit!,
                color: Colors.amber.shade600,
                height: 50,
                borderRadius: 16,
              ),
            ),
          );
        }),
      ],
    );
  }
}

class _CheckmarkCard extends StatelessWidget {
  final TrackedSupplement trackedSupplement;
  const _CheckmarkCard({required this.trackedSupplement});

  String localizeSupplementName(Supplement s, AppLocalizations l10n) {
    switch (s.code) {
      case 'caffeine':
        return l10n.supplement_caffeine;
      case 'creatine_monohydrate':
        return l10n.supplement_creatine_monohydrate;
      default:
        // Fallback: benutzerdefinierte Supplements behalten ihren Namen
        return s.name;
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final brightness = theme.brightness;
    final supplement = trackedSupplement.supplement;
    final doseTaken = trackedSupplement.totalDosedToday;
    final isDone = doseTaken > 0;
    final l10n = AppLocalizations.of(context)!;

    final String displayText;
    if (isDone) {
      displayText =
          '${doseTaken.toStringAsFixed(1).replaceAll('.0', '')} ${supplement.unit}';
    } else {
      displayText =
          '${supplement.dailyGoal?.toStringAsFixed(1).replaceAll('.0', '') ?? ''} ${supplement.unit}';
    }

    final backgroundColor = brightness == Brightness.dark
        ? summary_card_dark_mode
        : summary_card_white_mode;

    return Container(
      height: 50,
      margin: const EdgeInsets.symmetric(vertical: 4.0),
      padding: const EdgeInsets.symmetric(horizontal: 12.0),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(16),
      ),
      child: Row(
        children: [
          Icon(
            isDone ? Icons.check_circle : Icons.radio_button_unchecked,
            color: isDone ? Colors.green.shade400 : Colors.grey.shade600,
            size: 20,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              localizeSupplementName(supplement, l10n),
              style: TextStyle(
                color: theme.colorScheme.onSurface,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          Text(
            displayText,
            style: TextStyle(
              color: theme.colorScheme.onSurface.withOpacity(0.8),
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/add_menu_sheet.dart =====

// lib/widgets/add_menu_sheet.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/design_constants.dart';

class AddMenuSheet extends StatelessWidget {
  const AddMenuSheet({super.key});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;

    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Text(
              l10n.addMenuTitle,
              style: Theme.of(context).textTheme.titleLarge,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: DesignConstants.spacingXL),
            _buildMenuOption(
              context: context,
              colorScheme: colorScheme,
              icon: Icons.fitness_center,
              title: l10n.startWorkout,
              onTap: () => Navigator.of(context).pop('start_workout'),
            ),
            const SizedBox(height: DesignConstants.spacingM),
            _buildMenuOption(
              context: context,
              colorScheme: colorScheme,
              icon: Icons.straighten_outlined,
              title: l10n.addMeasurement,
              onTap: () => Navigator.of(context).pop('add_measurement'),
            ),
            const Divider(height: 24, indent: 16, endIndent: 16),
            _buildMenuOption(
              context: context,
              colorScheme: colorScheme,
              icon: Icons.restaurant_menu,
              title: l10n.addFoodOption,
              onTap: () => Navigator.of(context).pop('add_food'),
            ),
            const SizedBox(height: DesignConstants.spacingM),
            _buildMenuOption(
              context: context,
              colorScheme: colorScheme,
              icon: Icons.local_drink,
              title: l10n.addLiquidOption,
              onTap: () => Navigator.of(context).pop('add_liquid'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMenuOption({
    required BuildContext context,
    required ColorScheme colorScheme,
    required IconData icon,
    required String title,
    required VoidCallback onTap,
  }) {
    return ListTile(
      leading: Icon(icon, color: colorScheme.primary),
      title: Text(
        title,
        style:
            TextStyle(color: colorScheme.primary, fontWeight: FontWeight.w500),
      ),
      tileColor: colorScheme.surfaceContainerHighest.withOpacity(0.5),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      onTap: onTap,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/editable_set_row.dart =====

// lib/widgets/editable_set_row.dart

import 'package:flutter/material.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/widgets/set_type_chip.dart';
import 'package:lightweight/generated/app_localizations.dart';

class EditableSetRow extends StatefulWidget {
  const EditableSetRow({
    super.key,
    required this.setLog,
    required this.setIndex,
    required this.onWeightChanged,
    required this.onRepsChanged,
    required this.onDelete,
  });

  final SetLog setLog;
  final int setIndex;
  final ValueChanged<String> onWeightChanged;
  final ValueChanged<String> onRepsChanged;
  final VoidCallback onDelete;

  @override
  State<EditableSetRow> createState() => _EditableSetRowState();
}

class _EditableSetRowState extends State<EditableSetRow> {
  late final TextEditingController _weightController;
  late final TextEditingController _repsController;

  @override
  void initState() {
    super.initState();
    _weightController = TextEditingController(
        text:
            widget.setLog.weightKg?.toStringAsFixed(2).replaceAll('.00', '') ??
                '');
    _repsController =
        TextEditingController(text: widget.setLog.reps?.toString() ?? '');

    // Melde Änderungen an den Parent-Screen
    _weightController.addListener(() {
      widget.onWeightChanged(_weightController.text);
    });
    _repsController.addListener(() {
      widget.onRepsChanged(_repsController.text);
    });
  }

  @override
  void dispose() {
    _weightController.dispose();
    _repsController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          SetTypeChip(
              setType: widget.setLog.setType, setIndex: widget.setIndex),
          const SizedBox(width: 16),
          Expanded(
            child: TextFormField(
              controller: _weightController,
              decoration:
                  InputDecoration(labelText: l10n.kgLabel, isDense: true),
              keyboardType:
                  const TextInputType.numberWithOptions(decimal: true),
              validator: (value) => (value == null ||
                      value.trim().isEmpty ||
                      double.tryParse(value.replaceAll(',', '.')) == null)
                  ? "!"
                  : null,
            ),
          ),
          const SizedBox(width: 8),
          const Text("x"),
          const SizedBox(width: 8),
          Expanded(
            child: TextFormField(
              controller: _repsController,
              decoration:
                  InputDecoration(labelText: l10n.repsLabel, isDense: true),
              keyboardType: TextInputType.number,
              validator: (value) => (value == null ||
                      value.trim().isEmpty ||
                      int.tryParse(value) == null)
                  ? "!"
                  : null,
            ),
          ),
          IconButton(
            icon: const Icon(Icons.delete_outline, color: Colors.redAccent),
            tooltip: l10n.delete,
            onPressed: widget.onDelete,
          ),
        ],
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/glass_menu.dart =====

import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:lightweight/util/design_constants.dart';

class GlassMenuItem {
  final IconData icon;
  final String label;
  final VoidCallback onTap;

  GlassMenuItem({required this.icon, required this.label, required this.onTap});
}

class GlassMenu extends StatefulWidget {
  final List<GlassMenuItem> items;
  final VoidCallback onDismiss;

  const GlassMenu({
    super.key,
    required this.items,
    required this.onDismiss,
  });

  @override
  State<GlassMenu> createState() => _GlassMenuState();
}

class _GlassMenuState extends State<GlassMenu>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 400),
    )..forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: widget.onDismiss,
      child: Scaffold(
        backgroundColor: Colors.black.withOpacity(0.4),
        body: Center(
          child: Wrap(
            spacing: 24,
            runSpacing: 24,
            children: List.generate(widget.items.length, (index) {
              final item = widget.items[index];
              final intervalStart = index * 0.1;
              final intervalEnd = intervalStart + 0.5;

              final animation = CurvedAnimation(
                parent: _controller,
                curve: Interval(intervalStart, intervalEnd,
                    curve: Curves.easeOutBack),
              );

              return ScaleTransition(
                scale: animation,
                child: FadeTransition(
                  opacity: animation,
                  child: GestureDetector(
                    onTap: () {
                      item.onTap();
                      widget.onDismiss();
                    },
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        _buildGlassIcon(item.icon),
                        const SizedBox(height: DesignConstants.spacingM),
                        Text(
                          item.label,
                          style:
                              Theme.of(context).textTheme.titleLarge?.copyWith(
                                    color: Colors.white,
                                    fontWeight: FontWeight.bold,
                                  ),
                        ),
                      ],
                    ),
                  ),
                ),
              );
            }),
          ),
        ),
      ),
    );
  }

  Widget _buildGlassIcon(IconData icon) {
    return ClipRRect(
      borderRadius: BorderRadius.circular(20),
      child: BackdropFilter(
        filter: ImageFilter.blur(sigmaX: 12, sigmaY: 12),
        child: Container(
          width: 76,
          height: 76,
          decoration: BoxDecoration(
            color: Colors.white.withOpacity(0.15),
            borderRadius: BorderRadius.circular(20),
            border: Border.all(
              color: Colors.white.withOpacity(0.3),
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.3),
                blurRadius: 12,
                offset: const Offset(0, 6),
              ),
            ],
          ),
          child: Icon(icon, size: 34, color: Colors.white),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/summary_card.dart =====

import 'package:flutter/material.dart';
import 'package:lightweight/theme/color_constants.dart';

class SummaryCard extends StatelessWidget {
  final Widget child;
  final EdgeInsetsGeometry padding;

  const SummaryCard({
    super.key,
    required this.child,
    this.padding = const EdgeInsets.all(12.0),
  });

  ///*
  @override
  Widget build(BuildContext context) {
    final brightness = Theme.of(context).brightness;

    final background = brightness == Brightness.dark
        ? summary_card_dark_mode
        : summary_card_white_mode;

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 6.0),
      padding: padding,
      decoration: BoxDecoration(
        color: background,
        borderRadius: BorderRadius.circular(20),
        /*
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.25),
            blurRadius: 6,
            offset: const Offset(0, 2),
          ),
        ],
        */
      ),
      child: child,
    );
  }
}
//*/
/*
  @override
  Widget build(BuildContext context) {
    final brightness = Theme.of(context).brightness;

    // KORREKTUR: Hintergrund im Light Mode weniger transparent für besseren Kontrast
    final backgroundColor = brightness == Brightness.dark
        ? Colors.white.withOpacity(0.10)
        : Colors.white.withOpacity(0.65); // War 0.40, jetzt weniger durchsichtig

    // KORREKTUR: Randfarbe im Light Mode ist jetzt ein dunkles Grau statt Weiß
    final borderColor = brightness == Brightness.dark
        ? Colors.white.withOpacity(0.20)
        : Colors.black.withOpacity(0.12); // War Weiß, jetzt dunkles Grau mit Transparenz

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 6.0),
      // WICHTIG: Kein Padding mehr direkt hier, wird jetzt vom Child gesteuert
      // padding: padding, // Diese Zeile entfernen oder auskommentieren
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
          color: borderColor,
          width: 1.5,
        ),
        boxShadow: const [],
      ),
      // WICHTIG: ClipRRect, damit der Blur-Effekt die Ecken respektiert
      child: ClipRRect(
        borderRadius: BorderRadius.circular(20),
        child: BackdropFilter(
          // Der eigentliche "Frostglas"-Effekt
          filter: ImageFilter.blur(sigmaX: 10.0, sigmaY: 10.0),
          child: Padding(
            // Das Padding wird jetzt innerhalb des Blur-Effekts angewendet
            padding: padding,
            child: child,
          ),
        ),
      ),
    );
  }
}
*/


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/running_workout_bar.dart =====

// lib/widgets/running_workout_bar.dart

import 'package:flutter/material.dart';

class RunningWorkoutBar extends StatelessWidget {
  final String timeText; // z.B. "13:12"
  final VoidCallback onResume;
  final VoidCallback onDiscard;

  const RunningWorkoutBar({
    super.key,
    required this.timeText,
    required this.onResume,
    required this.onDiscard,
  });

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Row(
      children: [
        // Zeit (links)
        Expanded(
          child: Row(
            children: [
              const Icon(Icons.timer_outlined, size: 20),
              const SizedBox(width: 6),
              Text(
                timeText,
                style: const TextStyle(
                    fontFeatures: [FontFeature.tabularFigures()]),
              ),
            ],
          ),
        ),
        // Fortsetzen (Accent)
        FilledButton(
          onPressed: onResume,
          style: FilledButton.styleFrom(
            backgroundColor: cs.primary,
            foregroundColor: cs.onPrimary,
            minimumSize: const Size(0, 36),
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
          ),
          child: const Text('Fortsetzen'),
        ),
        const SizedBox(width: 8),
        // Verwerfen (Rot)
        FilledButton(
          onPressed: onDiscard,
          style: FilledButton.styleFrom(
            backgroundColor: cs.error,
            foregroundColor: cs.onError,
            minimumSize: const Size(0, 36),
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
          ),
          child: const Text('Verwerfen'),
        ),
      ],
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/bottom_content_spacer.dart =====

//bottom_content_spacer.dart

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:lightweight/services/workout_session_manager.dart';

/// Visual overlay heights (your glass bar + detached FAB)
const double kOverlayBaseHeight = 120.0; // bottom bar + FAB + margins
const double kOverlayRunningExtra = 68.0; // extra when workout bar is shown

/// Use in ListView/Column: adds a scrollable spacer at the end.
class BottomContentSpacer extends StatelessWidget {
  final double extra; // if a screen needs a bit more room
  const BottomContentSpacer({super.key, this.extra = 0});

  @override
  Widget build(BuildContext context) {
    final bool isRunning =
        context.select<WorkoutSessionManager, bool>((m) => m.isActive);
    final double safe = MediaQuery.of(context).padding.bottom;
    final double h = kOverlayBaseHeight +
        (isRunning ? kOverlayRunningExtra : 0) +
        safe +
        extra;
    return SizedBox(height: h);
  }
}

/// Use in CustomScrollView: sliver variant.
class SliverBottomContentSpacer extends StatelessWidget {
  final double extra;
  const SliverBottomContentSpacer({super.key, this.extra = 0});

  @override
  Widget build(BuildContext context) {
    return SliverToBoxAdapter(child: BottomContentSpacer(extra: extra));
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/swipe_action_background.dart =====

import 'package:flutter/material.dart';

class SwipeActionBackground extends StatelessWidget {
  final Color color;
  final IconData icon;
  final Alignment alignment;

  const SwipeActionBackground({
    super.key,
    required this.color,
    required this.icon,
    required this.alignment,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.symmetric(
          vertical: 6.0), // Selber Margin wie SummaryCard
      decoration: BoxDecoration(
        color: color,
        borderRadius:
            BorderRadius.circular(20), // Selber Radius wie SummaryCard
      ),
      child: Align(
        alignment: alignment,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 20.0),
          child: Icon(
            icon,
            color: Colors.white,
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/shadow_container.dart =====

// lib/widgets/shadow_container.dart

import 'package:flutter/material.dart';

class ShadowContainer extends StatelessWidget {
  final Widget child;
  final BorderRadiusGeometry borderRadius;
  final List<BoxShadow>? boxShadow;
  final EdgeInsetsGeometry? margin; // Optionaler externer Margin

  const ShadowContainer({
    super.key,
    required this.child,
    this.borderRadius = const BorderRadius.all(Radius.circular(16.0)),
    this.boxShadow,
    this.margin,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: margin,
      decoration: BoxDecoration(
        borderRadius: borderRadius,
        boxShadow: boxShadow ??
            [
              // Standard-Schatten, wenn keiner angegeben ist
              BoxShadow(
                color: Colors.black.withOpacity(0.08),
                blurRadius: 15,
                spreadRadius: 0,
                offset: const Offset(0, 8),
              ),
            ],
      ),
      child: ClipRRect(
        // ClipRRect, um den Inhalt innerhalb der Ecken zu halten
        borderRadius: borderRadius,
        child: child,
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/glass_fab.dart =====

import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:lightweight/theme/color_constants.dart';

class GlassFab extends StatefulWidget {
  final VoidCallback onPressed;
  final IconData icon;
  final String? label; // KORREKTUR: Label ist jetzt optional (kann null sein)

  const GlassFab({
    super.key,
    required this.onPressed,
    this.label, // KORREKTUR: Nicht mehr 'required'
    this.icon = Icons.add,
  });

  @override
  State<GlassFab> createState() => _GlassFabState();
}

class _GlassFabState extends State<GlassFab>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 150),
      lowerBound: 0.0,
      upperBound: 0.1,
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _onTapDown(TapDownDetails details) => _controller.forward();
  void _onTapUp(TapUpDetails details) {
    _controller.reverse();
    // leichtes, kurzes Haptik-Feedback
    HapticFeedback.selectionClick();
    widget.onPressed();
  }

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final bg = isDark ? summary_card_dark_mode : summary_card_white_mode;
    return GestureDetector(
      onTapDown: _onTapDown,
      onTapUp: _onTapUp,
      onTapCancel: () => _controller.reverse(),
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, child) {
          final scale = 1 - _controller.value;
          return Transform.scale(
            scale: scale,
            child: child,
          );
        },
        child: ClipRRect(
          borderRadius: BorderRadius.circular(20),
          child: BackdropFilter(
            filter: ImageFilter.blur(sigmaX: 12, sigmaY: 12),
            child: Container(
              // KORREKTUR: Höhe und Breite sind jetzt dynamisch
              height: 76,
              width: widget.label != null
                  ? null
                  : 76, // Quadratisch, wenn kein Label
              decoration: BoxDecoration(
                color: bg.withOpacity(0.80),
                borderRadius: BorderRadius.circular(20),
                border: Border.all(
                  color: isDark
                      ? Colors.white.withOpacity(0.30)
                      : Colors.black.withOpacity(0.10),
                  width: 1.5,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.3),
                    blurRadius: 12,
                    offset: const Offset(0, 6),
                  ),
                ],
              ),
              // KORREKTUR: Inhalt hängt davon ab, ob ein Label existiert
              child: Padding(
                padding: widget.label != null
                    ? const EdgeInsets.symmetric(horizontal: 24.0)
                    : EdgeInsets.zero,
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      widget.icon,
                      size: 30,
                      color: isDark ? Colors.white : Colors.black,
                    ),
                    if (widget.label != null) ...[
                      const SizedBox(width: 12),
                      Text(
                        widget.label!,
                        style: TextStyle(
                          color: isDark ? Colors.white : Colors.black,
                          fontWeight: FontWeight.bold,
                          fontSize: 18,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/nutrition_summary_widget.dart =====

/*// lib/widgets/nutrition_summary_widget.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'dart:ui'; // Für den ImageFilter.blur

class _NutrientSpec {
  final String label;
  final String unit;
  final double value;
  final double target;
  final Color color;

  _NutrientSpec({
    required this.label,
    required this.unit,
    required this.value,
    required this.target,
    required this.color,
  });
}

class NutritionSummaryWidget extends StatelessWidget {
  final DailyNutrition nutritionData;
  final bool isExpandedView;
  final AppLocalizations l10n;

  const NutritionSummaryWidget({
    super.key,
    required this.nutritionData,
    this.isExpandedView = false,
    required this.l10n,
  });

  @override
  Widget build(BuildContext context) {
    final specs = <String, _NutrientSpec>{
      'calories': _NutrientSpec(
          label: l10n.calories,
          unit: 'kcal',
          value: nutritionData.calories.toDouble(),
          target: nutritionData.targetCalories.toDouble(),
          color: Colors.orange),
      'water': _NutrientSpec(
          label: l10n.water,
          unit: 'ml',
          value: nutritionData.water.toDouble(),
          target: nutritionData.targetWater.toDouble(),
          color: Colors.blue),
      'protein': _NutrientSpec(
          label: l10n.protein,
          unit: 'g',
          value: nutritionData.protein.toDouble(),
          target: nutritionData.targetProtein.toDouble(),
          color: Colors.red.shade400),
      'carbs': _NutrientSpec(
          label: l10n.carbs,
          unit: 'g',
          value: nutritionData.carbs.toDouble(),
          target: nutritionData.targetCarbs.toDouble(),
          color: Colors.green.shade400),
      'fat': _NutrientSpec(
          label: l10n.fat,
          unit: 'g',
          value: nutritionData.fat.toDouble(),
          target: nutritionData.targetFat.toDouble(),
          color: Colors.purple.shade300),
      'sugar': _NutrientSpec(
          label: l10n.sugar,
          unit: 'g',
          value: nutritionData.sugar,
          target: nutritionData.targetSugar.toDouble(),
          color: Colors.pink.shade200),
      'fiber': _NutrientSpec(
          label: l10n.fiber,
          unit: 'g',
          value: nutritionData.fiber,
          target: nutritionData.targetFiber.toDouble(),
          color: Colors.brown.shade400),
      'salt': _NutrientSpec(
          label: l10n.salt,
          unit: 'g',
          value: nutritionData.salt,
          target: nutritionData.targetSalt.toDouble(),
          color: Colors.grey.shade500),
    };

    return SummaryCard(
      // KORREKTUR: internalPadding für diese spezifische Karte ist 12.0
      //internalPadding: const EdgeInsets.all(12.0),
      child: IntrinsicHeight(
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Expanded(
              flex: 3, // KORREKTUR 2: Flex-Wert erhöht, um mehr Platz zu geben
              child: Column(
                children: [
                  Expanded(child: _InfoBox(spec: specs['calories']!)),
                  const SizedBox(height: DesignConstants.spacingS),
                  Expanded(child: _InfoBox(spec: specs['water']!)),
                ],
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              flex: 4, // KORREKTUR 2: Flex-Wert erhöht
              child: Column(
                children: [
                  Expanded(child: _InfoBox(spec: specs['protein']!)),
                  const SizedBox(height: DesignConstants.spacingS),
                  Expanded(child: _InfoBox(spec: specs['carbs']!)),
                  const SizedBox(height: DesignConstants.spacingS),
                  Expanded(child: _InfoBox(spec: specs['fat']!)),
                ],
              ),
            ),
            if (isExpandedView) ...[
              const SizedBox(width: 8),
              Expanded(
                flex: 4, // KORREKTUR 2: Flex-Wert erhöht
                child: Column(
                  children: [
                    Expanded(child: _InfoBox(spec: specs['sugar']!)),
                    const SizedBox(height: DesignConstants.spacingS),
                    Expanded(child: _InfoBox(spec: specs['fiber']!)),
                    const SizedBox(height: DesignConstants.spacingS),
                    Expanded(child: _InfoBox(spec: specs['salt']!)),
                  ],
                ),
              ),
            ]
          ],
        ),
      ),
    );
  }
}
// Ersetze die komplette _InfoBox Klasse in lib/widgets/nutrition_summary_widget.dart

class _InfoBox extends StatelessWidget {
  final _NutrientSpec spec;
  const _InfoBox({required this.spec});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final brightness = theme.brightness;
    final colorScheme = theme.colorScheme;

    final hasTarget = spec.target > 0;
    final rawProgress = hasTarget ? (spec.value / spec.target) : 0.0;
    final progress = rawProgress.clamp(0.0, 1.0);

    // Farben für den Glas-Effekt, identisch zur SummaryCard
    final backgroundColor = brightness == Brightness.dark
        ? Colors.white.withOpacity(0.10)
        : Colors.white.withOpacity(0.65);

    final borderColor = brightness == Brightness.dark
        ? Colors.white.withOpacity(0.20)
        : Colors.black.withOpacity(0.12);

    return Container(
      // Die Dekoration ist jetzt die Glas-Dekoration
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(
            9), // Etwas weniger Rundung für die kleinen Boxen
        border: Border.all(
          color: borderColor,
          width: 1.0, // Etwas dünnerer Rand
        ),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(9),
        child: BackdropFilter(
          filter:
              ImageFilter.blur(sigmaX: 8.0, sigmaY: 8.0), // Etwas weniger Blur
          child: Stack(
            fit: StackFit.expand,
            children: [
              // Der animierte Füllbalken bleibt erhalten
              Align(
                alignment: Alignment.centerLeft,
                child: TweenAnimationBuilder<double>(
                  tween: Tween(begin: 0, end: progress),
                  duration: const Duration(milliseconds: 350),
                  curve: Curves.easeOutCubic,
                  builder: (context, p, child) =>
                      FractionallySizedBox(widthFactor: p, child: child),
                  child: Container(color: spec.color),
                ),
              ),
              // Der Text-Inhalt liegt über dem Füllbalken
              Padding(
                padding:
                    const EdgeInsets.symmetric(horizontal: 10.0, vertical: 4.0),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    FittedBox(
                      fit: BoxFit.scaleDown,
                      child: Text(
                        spec.label,
                        maxLines: 1,
                        style: TextStyle(
                            color: colorScheme.onSurface,
                            fontSize: 16,
                            fontWeight: FontWeight.bold),
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      hasTarget
                          ? '${spec.value.toStringAsFixed(1)} / ${spec.target.toStringAsFixed(0)} ${spec.unit}'
                          : '${spec.value.toStringAsFixed(1)} ${spec.unit}',
                      style: TextStyle(
                        color: colorScheme.onSurface.withOpacity(0.8),
                        fontSize: 14,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
*/
// lib/widgets/nutrition_summary_widget.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/util/design_constants.dart';
import 'dart:ui';

import 'package:lightweight/widgets/glass_progress_bar.dart'; // Für den ImageFilter.blur

class _NutrientSpec {
  final String label;
  final String unit;
  final double value;
  final double target;
  final Color color;

  _NutrientSpec({
    required this.label,
    required this.unit,
    required this.value,
    required this.target,
    required this.color,
  });
}

class NutritionSummaryWidget extends StatelessWidget {
  final DailyNutrition nutritionData;
  final bool isExpandedView;
  final AppLocalizations l10n;

  const NutritionSummaryWidget({
    super.key,
    required this.nutritionData,
    this.isExpandedView = false,
    required this.l10n,
  });

  @override
  Widget build(BuildContext context) {
    return IntrinsicHeight(
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Expanded(
            flex: 3,
            child: Column(
              children: [
                Expanded(
                  child: GlassProgressBar(
                    label: l10n.calories,
                    unit: 'kcal',
                    value: nutritionData.calories.toDouble(),
                    target: nutritionData.targetCalories.toDouble(),
                    color: Colors.orange,
                  ),
                ),
                const SizedBox(height: DesignConstants.spacingS),
                Expanded(
                  child: GlassProgressBar(
                    label: l10n.water,
                    unit: 'ml',
                    value: nutritionData.water.toDouble(),
                    target: nutritionData.targetWater.toDouble(),
                    color: Colors.blue,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            flex: 4,
            child: Column(
              children: [
                Expanded(
                  child: GlassProgressBar(
                    label: l10n.protein,
                    unit: 'g',
                    value: nutritionData.protein.toDouble(),
                    target: nutritionData.targetProtein.toDouble(),
                    color: Colors.red.shade400,
                  ),
                ),
                const SizedBox(height: DesignConstants.spacingS),
                Expanded(
                  child: GlassProgressBar(
                    label: l10n.carbs,
                    unit: 'g',
                    value: nutritionData.carbs.toDouble(),
                    target: nutritionData.targetCarbs.toDouble(),
                    color: Colors.green.shade400,
                  ),
                ),
                const SizedBox(height: DesignConstants.spacingS),
                Expanded(
                  child: GlassProgressBar(
                    label: l10n.fat,
                    unit: 'g',
                    value: nutritionData.fat.toDouble(),
                    target: nutritionData.targetFat.toDouble(),
                    color: Colors.purple.shade300,
                  ),
                ),
              ],
            ),
          ),
          if (isExpandedView) ...[
            const SizedBox(width: 8),
            Expanded(
              flex: 4,
              child: Column(
                children: [
                  Expanded(
                    child: GlassProgressBar(
                      label: l10n.sugar,
                      unit: 'g',
                      value: nutritionData.sugar,
                      target: nutritionData.targetSugar.toDouble(),
                      color: Colors.pink.shade200,
                    ),
                  ),
                  const SizedBox(height: DesignConstants.spacingS),
                  Expanded(
                    child: GlassProgressBar(
                      label: l10n.fiber,
                      unit: 'g',
                      value: nutritionData.fiber,
                      target: nutritionData.targetFiber.toDouble(),
                      color: Colors.brown.shade400,
                    ),
                  ),
                  const SizedBox(height: DesignConstants.spacingS),
                  Expanded(
                    child: GlassProgressBar(
                      label: l10n.salt,
                      unit: 'g',
                      value: nutritionData.salt,
                      target: nutritionData.targetSalt.toDouble(),
                      color: Colors.grey.shade500,
                    ),
                  ),
                  const SizedBox(height: DesignConstants.spacingS),
                  Expanded(
                    child: GlassProgressBar(
                      label: l10n.supplement_caffeine,
                      unit: 'mg',
                      value: nutritionData.caffeine,
                      target: nutritionData.targetCaffeine.toDouble(),
                      color: Colors.brown,
                    ),
                  ),
                ],
              ),
            ),
          ]
        ],
      ),
    );
  }
}

class _InfoBox extends StatelessWidget {
  final _NutrientSpec spec;
  const _InfoBox({required this.spec});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final brightness = theme.brightness;
    final colorScheme = theme.colorScheme;

    final hasTarget = spec.target > 0;
    final rawProgress = hasTarget ? (spec.value / spec.target) : 0.0;
    final progress = rawProgress.clamp(0.0, 1.0);

    final backgroundColor = brightness == Brightness.dark
        ? Colors.white.withOpacity(0.10)
        : Colors.white.withOpacity(0.65);

    final borderColor = brightness == Brightness.dark
        ? Colors.white.withOpacity(0.20)
        : Colors.black.withOpacity(0.12);

    return Container(
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(9),
        border: Border.all(
          color: borderColor,
          width: 1.0,
        ),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(9),
        child: BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 8.0, sigmaY: 8.0),
          child: Stack(
            fit: StackFit.expand,
            children: [
              Align(
                alignment: Alignment.centerLeft,
                child: TweenAnimationBuilder<double>(
                  tween: Tween(begin: 0, end: progress),
                  duration: const Duration(milliseconds: 350),
                  curve: Curves.easeOutCubic,
                  builder: (context, p, child) =>
                      FractionallySizedBox(widthFactor: p, child: child),
                  child: Container(color: spec.color),
                ),
              ),
              Padding(
                padding:
                    const EdgeInsets.symmetric(horizontal: 10.0, vertical: 4.0),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    FittedBox(
                      fit: BoxFit.scaleDown,
                      child: Text(
                        spec.label,
                        maxLines: 1,
                        style: TextStyle(
                            color: colorScheme.onSurface,
                            fontSize: 16,
                            fontWeight: FontWeight.bold),
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      hasTarget
                          ? '${spec.value.toStringAsFixed(1)} / ${spec.target.toStringAsFixed(0)} ${spec.unit}'
                          : '${spec.value.toStringAsFixed(1)} ${spec.unit}',
                      style: TextStyle(
                        color: colorScheme.onSurface.withOpacity(0.8),
                        fontSize: 14,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/glass_bottom_menu.dart =====

import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:lightweight/generated/app_localizations.dart';

/// One action row in the glass menu.
class GlassMenuAction {
  final IconData icon;
  final String label;
  final String? subtitle;
  final VoidCallback onTap;

  GlassMenuAction({
    required this.icon,
    required this.label,
    this.subtitle,
    required this.onTap,
  });
}

/// Show the glass bottom menu with a static blurred scrim (like GlassFab).
/// Drag-to-dismiss is handled by showModalBottomSheet.
Future<T?> showGlassBottomMenu<T>({
  required BuildContext context,
  String? title,
  List<GlassMenuAction>? actions, // ⬅️ jetzt optional
  Widget Function(BuildContext, VoidCallback)? contentBuilder, // ⬅️ NEU
}) {
  assert(
      (actions != null && contentBuilder == null) ||
          (actions == null && contentBuilder != null),
      'Either actions OR contentBuilder must be provided');
  final isDark = Theme.of(context).brightness == Brightness.dark;
  return showModalBottomSheet<T>(
    context: context,
    isScrollControlled: true,
    useRootNavigator: false, // lassen wir so
    useSafeArea: false,
    backgroundColor: Colors.transparent,
    // 👇 animiert automatisch mit dem Sheet (kein „an/aus“)
    barrierColor: isDark
        ? Colors.black.withOpacity(0.50)
        : Colors.black.withOpacity(0.30),
    builder: (ctx) {
      final kb = MediaQuery.of(ctx).viewInsets.bottom; // Tastaturhöhe
      return AnimatedPadding(
        duration: const Duration(milliseconds: 220),
        curve: Curves.easeOutCubic,
        padding: EdgeInsets.only(bottom: kb),
        child: _GlassBottomMenuSheet(
          title: title,
          actions: actions ?? const <GlassMenuAction>[], // ⬅️ nie null
          contentBuilder: contentBuilder, // ⬅️ sicher weitergeben
        ),
      );
    },
  );
}

class _GlassBottomMenuSheet extends StatelessWidget {
  const _GlassBottomMenuSheet({
    this.title,
    this.contentBuilder,
    this.actions = const <GlassMenuAction>[], // ⬅️ Default: leere Liste
  });

  final String? title;
  final Widget Function(BuildContext, VoidCallback)? contentBuilder;
  final List<GlassMenuAction> actions; // ⬅️ non-null

  @override
  Widget build(BuildContext context) {
    final media = MediaQuery.of(context);
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final bottomInset = media.viewPadding.bottom;
    final keyboard = media.viewInsets.bottom; // ⬅️ NEU: Tastaturhöhe

    return SafeArea(
      top: false,
      bottom: false,
      child: Align(
        alignment: Alignment.bottomCenter,
        child: _GlassSurface(
          // straight top line color (like GlassFab), tuned for dark mode
          topBorderColor: isDark
              ? Colors.white.withOpacity(0.22)
              : Colors.black.withOpacity(0.10),
          child: Padding(
            padding: EdgeInsets.only(bottom: bottomInset),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const SizedBox(height: 8),
                // Drag handle
                Container(
                  width: 44,
                  height: 5,
                  decoration: BoxDecoration(
                    color: Colors.white.withOpacity(0.75),
                    borderRadius: BorderRadius.circular(100),
                  ),
                ),
                if (title != null) ...[
                  const SizedBox(height: 10),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    child: Text(
                      title!,
                      textAlign: TextAlign.center,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w700,
                      ),
                    ),
                  ),
                ],
                if (contentBuilder != null) ...[
                  const SizedBox(height: 8),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 12),
                    child: contentBuilder!(
                        context, () => Navigator.of(context).maybePop()),
                  ),
                ] else if (actions.isNotEmpty) ...[
                  Flexible(
                    child: ConstrainedBox(
                      constraints: const BoxConstraints(maxHeight: 420),
                      child: ListView.separated(
                        padding: const EdgeInsets.fromLTRB(8, 12, 8, 8),
                        shrinkWrap: true,
                        itemCount: actions.length,
                        separatorBuilder: (_, __) => const SizedBox(height: 8),
                        itemBuilder: (context, i) {
                          final a = actions[i];
                          return _GlassTile(
                            icon: a.icon,
                            title: a.label,
                            subtitle: a.subtitle,
                            onTap: () {
                              HapticFeedback.selectionClick();
                              Navigator.of(context).maybePop();
                              WidgetsBinding.instance
                                  .addPostFrameCallback((_) => a.onTap());
                            },
                          );
                        },
                      ),
                    ),
                  ),
                ]
/*if (contentBuilder != null) ...[
  const SizedBox(height: 12),
  Padding(
    padding: const EdgeInsets.fromLTRB(12, 0, 12, 12),
    child: Row(
      children: [
        Expanded(
          child: OutlinedButton(
            onPressed: () => Navigator.of(context).maybePop(),
            child: Text(AppLocalizations.of(context)!.cancel),
          ),
        ),1
        const SizedBox(width: 12),
        Expanded(
          child: _InlinePrimaryButton(), // ⬅️ Handler wird im Aufrufer gesetzt (siehe unten)
        ),
      ],
    ),
  ),
]
*/
              ],
            ),
          ),
        ),
      ),
    );
  }
}

/// Frosted glass surface: full width, rounded only on top.
/// IMPORTANT: Straight top line (not following the curve) is painted OUTSIDE the clip.
class _GlassSurface extends StatelessWidget {
  const _GlassSurface({required this.child, required this.topBorderColor});

  final Widget child;
  final Color topBorderColor;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    // Slightly different from summary-cards to stand out
    final c0 = theme.colorScheme.surface.withOpacity(isDark ? 0.86 : 0.94);
    final c1 = theme.colorScheme.surface.withOpacity(isDark ? 0.70 : 0.88);

    return Stack(
      clipBehavior: Clip.none, // allow the straight top line to draw freely
      children: [
        // Blurred glass body with rounded top corners
        ClipRRect(
          borderRadius: const BorderRadius.vertical(top: Radius.circular(24)),
          child: BackdropFilter(
            filter: ImageFilter.blur(sigmaX: 20, sigmaY: 20),
            child: Container(
              width: double.infinity,
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                  colors: [c0, c1],
                ),
              ),
              child: child,
            ),
          ),
        ),
        // Straight top divider line (not following the curve)
// Hard top edge that follows the rounded corners
        Positioned.fill(
          child: IgnorePointer(
            child: CustomPaint(
              painter: _TopEdgePainter(
                color: topBorderColor,
                radius: 24, // ⬅️ dein Top-Radius
                strokeWidth: 1.5,
              ),
            ),
          ),
        ),
      ],
    );
  }
}

/// Individual action row with subtle glass button look.
class _GlassTile extends StatelessWidget {
  const _GlassTile({
    required this.icon,
    required this.title,
    this.subtitle,
    required this.onTap,
  });

  final IconData icon;
  final String title;
  final String? subtitle;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final textTheme = theme.textTheme;

    return Material(
      color: isDark
          ? Colors.white.withOpacity(0.06)
          : Colors.white.withOpacity(0.08),
      borderRadius: BorderRadius.circular(18),
      clipBehavior: Clip.antiAlias,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 12),
          child: Row(
            children: [
              Container(
                width: 42,
                height: 42,
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(12),
                  color: isDark
                      ? Colors.white.withOpacity(0.10)
                      : Colors.white.withOpacity(0.12),
                  border: Border.all(
                    color: Colors.white.withOpacity(isDark ? 0.14 : 0.18),
                    width: 1,
                  ),
                ),
                child: Icon(icon, size: 22),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    if (subtitle != null) ...[
                      const SizedBox(height: 2),
                      Text(
                        subtitle!,
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                        style: textTheme.bodySmall?.copyWith(
                          color: textTheme.bodySmall?.color?.withOpacity(0.8),
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              const SizedBox(width: 12),
              Icon(
                Icons.chevron_right_rounded,
                size: 22,
                color: Colors.white.withOpacity(0.8),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _TopEdgePainter extends CustomPainter {
  final Color color;
  final double radius;
  final double strokeWidth;
  _TopEdgePainter({
    required this.color,
    required this.radius,
    this.strokeWidth = 1.5,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // RRect mit nur oben gerundeten Ecken
    final rrect = RRect.fromRectAndCorners(
      Rect.fromLTWH(0, 0, size.width, size.height),
      topLeft: Radius.circular(radius),
      topRight: Radius.circular(radius),
    );

    // Nur den oberen Bereich zeichnen (inkl. Rundungen)
    final clipBand = Rect.fromLTWH(0, 0, size.width, radius + strokeWidth);
    canvas.save();
    canvas.clipRect(clipBand);

    final p = Paint()
      ..style = PaintingStyle.stroke
      ..strokeWidth = strokeWidth
      ..color = color;

    final path = Path()..addRRect(rrect);
    canvas.drawPath(path, p);
    canvas.restore();
  }

  @override
  bool shouldRepaint(covariant _TopEdgePainter old) =>
      old.color != color ||
      old.radius != radius ||
      old.strokeWidth != strokeWidth;
}

class _InlinePrimaryButton extends StatelessWidget {
  const _InlinePrimaryButton(this.onPressed, this.label);
  final VoidCallback? onPressed;
  final String? label;

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    return FilledButton(
      onPressed: onPressed,
      child: Text(label ?? l10n.add_button),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/keep_alive_page.dart =====

import 'package:flutter/widgets.dart';

class KeepAlivePage extends StatefulWidget {
  final Widget child;
  final Key? storageKey; // optional, falls du’s später brauchen willst

  const KeepAlivePage({super.key, required this.child, this.storageKey});

  @override
  State<KeepAlivePage> createState() => _KeepAlivePageState();
}

class _KeepAlivePageState extends State<KeepAlivePage>
    with AutomaticKeepAliveClientMixin<KeepAlivePage> {
  @override
  bool get wantKeepAlive => true;

  @override
  Widget build(BuildContext context) {
    super.build(context); // wichtig für KeepAlive!
    // Kein PageStorage() mehr -> kein bucket nötig.
    // Optional: mit KeyedSubtree den storageKey an den Subtree hängen
    return widget.storageKey == null
        ? widget.child
        : KeyedSubtree(key: widget.storageKey, child: widget.child);
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/glass_progress_bar.dart =====

// lib/widgets/glass_progress_bar.dart
import 'package:flutter/material.dart';
import 'package:lightweight/theme/color_constants.dart';

class GlassProgressBar extends StatelessWidget {
  final String label;
  final String unit;
  final double value;
  final double target;
  final Color color;
  final double height;
  final double borderRadius;

  const GlassProgressBar({
    super.key,
    required this.label,
    required this.unit,
    required this.value,
    required this.target,
    required this.color,
    this.height = 60.0,
    this.borderRadius = 20.0,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final brightness = theme.brightness;
    final colorScheme = theme.colorScheme;

    final hasTarget = target > 0;
    final rawProgress = hasTarget ? (value / target) : 0.0;
    final progress = rawProgress.clamp(0.0, 1.0);

    final backgroundColor = brightness == Brightness.dark
        ? summary_card_dark_mode
        : summary_card_white_mode;

    return Container(
      height: height,
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(borderRadius),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(borderRadius),
        child: Stack(
          fit: StackFit.expand,
          children: [
            Align(
              alignment: Alignment.centerLeft,
              child: FractionallySizedBox(
                widthFactor: progress,
                child: Container(color: color),
              ),
            ),
            Padding(
              padding:
                  const EdgeInsets.symmetric(horizontal: 12.0, vertical: 4.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  FittedBox(
                    fit: BoxFit.scaleDown,
                    child: Text(
                      label,
                      maxLines: 1,
                      style: TextStyle(
                          color: colorScheme.onSurface,
                          fontSize: 16,
                          fontWeight: FontWeight.bold),
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    hasTarget
                        ? '${value.toStringAsFixed(1)} / ${target.toStringAsFixed(0)} $unit'
                        : '${value.toStringAsFixed(1)} $unit',
                    style: TextStyle(
                      color: colorScheme.onSurface.withOpacity(0.8),
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/off_attribution_widget.dart =====

// lib/widgets/off_attribution_widget.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:url_launcher/url_launcher.dart';

class OffAttributionWidget extends StatelessWidget {
  final TextStyle? textStyle;

  const OffAttributionWidget({super.key, this.textStyle});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    final currentTextStyle = textStyle ??
        theme.textTheme.bodySmall?.copyWith(color: Colors.grey[600]);

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(8.0),
        child: GestureDetector(
          // Macht den Text klickbar
          onTap: () async {
            final uri = Uri.parse("https://openfoodfacts.org/");
            try {
              if (await canLaunchUrl(uri)) {
                await launchUrl(uri);
              } else {
                throw 'Could not launch $uri';
              }
            } catch (e) {
              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                      content: Text(l10n.snackbar_could_not_open_open_link)),
                );
              }
            }
          },
          child: Text(
            l10n.openFoodFactsSource,
            style: currentTextStyle,
            textAlign: TextAlign.center,
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/.dart_tool/flutter_build/dart_plugin_registrant.dart =====

//
// Generated file. Do not edit.
// This file is generated from template in file `flutter_tools/lib/src/flutter_plugins.dart`.
//

// @dart = 3.0

import 'dart:io'; // flutter_ignore: dart_io_import.
import 'package:file_picker/file_picker.dart';
import 'package:image_picker_android/image_picker_android.dart';
import 'package:path_provider_android/path_provider_android.dart';
import 'package:shared_preferences_android/shared_preferences_android.dart';
import 'package:sqflite_android/sqflite_android.dart';
import 'package:url_launcher_android/url_launcher_android.dart';
import 'package:file_picker/file_picker.dart';
import 'package:image_picker_ios/image_picker_ios.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:sqflite_darwin/sqflite_darwin.dart';
import 'package:url_launcher_ios/url_launcher_ios.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:file_picker/file_picker.dart';
import 'package:file_selector_linux/file_selector_linux.dart';
import 'package:image_picker_linux/image_picker_linux.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:share_plus/share_plus.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:url_launcher_linux/url_launcher_linux.dart';
import 'package:file_picker/file_picker.dart';
import 'package:file_selector_macos/file_selector_macos.dart';
import 'package:image_picker_macos/image_picker_macos.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:sqflite_darwin/sqflite_darwin.dart';
import 'package:url_launcher_macos/url_launcher_macos.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:file_picker/file_picker.dart';
import 'package:file_selector_windows/file_selector_windows.dart';
import 'package:image_picker_windows/image_picker_windows.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:share_plus/share_plus.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';
import 'package:url_launcher_windows/url_launcher_windows.dart';

@pragma('vm:entry-point')
class _PluginRegistrant {

  @pragma('vm:entry-point')
  static void register() {
    if (Platform.isAndroid) {
      try {
        FilePickerIO.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerAndroid.registerWith();
      } catch (err) {
        print(
          '`image_picker_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderAndroid.registerWith();
      } catch (err) {
        print(
          '`path_provider_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesAndroid.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqfliteAndroid.registerWith();
      } catch (err) {
        print(
          '`sqflite_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherAndroid.registerWith();
      } catch (err) {
        print(
          '`url_launcher_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isIOS) {
      try {
        FilePickerIO.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerIOS.registerWith();
      } catch (err) {
        print(
          '`image_picker_ios` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqfliteDarwin.registerWith();
      } catch (err) {
        print(
          '`sqflite_darwin` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherIOS.registerWith();
      } catch (err) {
        print(
          '`url_launcher_ios` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isLinux) {
      try {
        DeviceInfoPlusLinuxPlugin.registerWith();
      } catch (err) {
        print(
          '`device_info_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        FilePickerLinux.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        FileSelectorLinux.registerWith();
      } catch (err) {
        print(
          '`file_selector_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerLinux.registerWith();
      } catch (err) {
        print(
          '`image_picker_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PackageInfoPlusLinuxPlugin.registerWith();
      } catch (err) {
        print(
          '`package_info_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderLinux.registerWith();
      } catch (err) {
        print(
          '`path_provider_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharePlusLinuxPlugin.registerWith();
      } catch (err) {
        print(
          '`share_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesLinux.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherLinux.registerWith();
      } catch (err) {
        print(
          '`url_launcher_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isMacOS) {
      try {
        FilePickerMacOS.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        FileSelectorMacOS.registerWith();
      } catch (err) {
        print(
          '`file_selector_macos` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerMacOS.registerWith();
      } catch (err) {
        print(
          '`image_picker_macos` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqfliteDarwin.registerWith();
      } catch (err) {
        print(
          '`sqflite_darwin` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherMacOS.registerWith();
      } catch (err) {
        print(
          '`url_launcher_macos` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isWindows) {
      try {
        DeviceInfoPlusWindowsPlugin.registerWith();
      } catch (err) {
        print(
          '`device_info_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        FilePickerWindows.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        FileSelectorWindows.registerWith();
      } catch (err) {
        print(
          '`file_selector_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerWindows.registerWith();
      } catch (err) {
        print(
          '`image_picker_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PackageInfoPlusWindowsPlugin.registerWith();
      } catch (err) {
        print(
          '`package_info_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderWindows.registerWith();
      } catch (err) {
        print(
          '`path_provider_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharePlusWindowsPlugin.registerWith();
      } catch (err) {
        print(
          '`share_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesWindows.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherWindows.registerWith();
      } catch (err) {
        print(
          '`url_launcher_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    }
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/.dart_tool/dartpad/web_plugin_registrant.dart =====

// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// @dart = 2.13
// ignore_for_file: type=lint

import 'package:device_info_plus/src/device_info_plus_web.dart';
import 'package:file_picker/_internal/file_picker_web.dart';
import 'package:image_picker_for_web/image_picker_for_web.dart';
import 'package:mobile_scanner/src/web/mobile_scanner_web.dart';
import 'package:package_info_plus/src/package_info_plus_web.dart';
import 'package:share_plus/src/share_plus_web.dart';
import 'package:shared_preferences_web/shared_preferences_web.dart';
import 'package:url_launcher_web/url_launcher_web.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  DeviceInfoPlusWebPlugin.registerWith(registrar);
  FilePickerWeb.registerWith(registrar);
  ImagePickerPlugin.registerWith(registrar);
  MobileScannerWeb.registerWith(registrar);
  PackageInfoPlusWebPlugin.registerWith(registrar);
  SharePlusWebPlugin.registerWith(registrar);
  SharedPreferencesPlugin.registerWith(registrar);
  UrlLauncherPlugin.registerWith(registrar);
  registrar.registerMessageHandler();
}

