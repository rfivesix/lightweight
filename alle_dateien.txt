
===== Datei: D:\lightweight\lib\main.dart =====

// lib/main.dart

import 'package:dynamic_color/dynamic_color.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/main_screen.dart';
import 'package:lightweight/services/profile_service.dart';
import 'package:lightweight/services/workout_session_manager.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/screens/onboarding_screen.dart';

void main() {
  WidgetsFlutterBinding.ensureInitialized();
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => WorkoutSessionManager()),
        ChangeNotifierProvider(
          create: (context) {
            final profileService = ProfileService();
            profileService.initialize();
            return profileService;
          },
        ),
      ],
      child: const MyApp(),
    ),
  );
}

Future<bool> _hasSeenOnboarding() async {
  final prefs = await SharedPreferences.getInstance();
  return prefs.getBool('hasSeenOnboarding') == true;
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(statusBarColor: Colors.transparent),
    );

    // Feste Card-Farben (unabhängig von Material You)
    const cardDark = Color(0xFF171717); // tiefes Grau
    const cardLight = Color(0xFFF3F3F3); // sehr helles Grau

    return DynamicColorBuilder(
      builder: (ColorScheme? lightDynamic, ColorScheme? darkDynamic) {
        // === Akzent/Seed aus Dynamic Color (Android 12+) oder Fallback ===
        final Color lightSeed = lightDynamic?.primary ?? Colors.blue;
        final Color darkSeed = darkDynamic?.primary ?? lightSeed;

        // --- Light Scheme aus Seed, aber ohne Material You UI ---
        final lightScheme = ColorScheme.fromSeed(
          seedColor: lightSeed,
          brightness: Brightness.light,
        ).copyWith(
          surface: Colors.white,
        );

        // --- Dark Scheme aus Seed + OLED-Schwarz ---
        final seededDark = ColorScheme.fromSeed(
          seedColor: darkSeed,
          brightness: Brightness.dark,
        );
        final darkScheme = seededDark.copyWith(
          surface: Colors.black,
          surfaceDim: Colors.black,
          surfaceBright: Colors.black,
          surfaceContainerLowest: Colors.black,
          surfaceContainerLow: Colors.black,
          surfaceContainer: Colors.black,
          surfaceContainerHigh: Colors.black,
          surfaceContainerHighest: Colors.black,
        );

        // --- Light Theme (Material2, aber mit ColorScheme aus Seed) ---
        final baseLightTheme = ThemeData(
          useMaterial3: false, // KEIN Material You
          colorScheme: lightScheme,
          primaryColor: lightScheme.primary, // Akzent in M2-Welten
          scaffoldBackgroundColor: Colors.white,
          canvasColor: Colors.white,
          cardColor: cardLight,
          // NEU / ANGEPASST:
          splashFactory: NoSplash.splashFactory,
          splashColor: Colors.transparent,
          highlightColor: Colors.transparent,
          hoverColor: Colors.transparent,

          pageTransitionsTheme: const PageTransitionsTheme(
            builders: {
              TargetPlatform.android: ZoomPageTransitionsBuilder(),
              TargetPlatform.iOS: CupertinoPageTransitionsBuilder(),
              TargetPlatform.macOS: CupertinoPageTransitionsBuilder(),
              TargetPlatform.windows: ZoomPageTransitionsBuilder(),
              TargetPlatform.linux: ZoomPageTransitionsBuilder(),
            },
          ),

          inputDecorationTheme: InputDecorationTheme(
            filled: true,
            fillColor: const Color(0xFFF3F3F3),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide.none,
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(color: lightScheme.primary, width: 2),
            ),
            contentPadding:
                const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
          ),

          bottomSheetTheme: const BottomSheetThemeData(
            backgroundColor: cardLight,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
            ),
            elevation: 0,
          ),

          snackBarTheme: SnackBarThemeData(
            backgroundColor: lightScheme.primary,
            contentTextStyle: TextStyle(
              color: lightScheme.onPrimary,
              fontWeight: FontWeight.w600,
            ),
            behavior: SnackBarBehavior.floating,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),

          dividerTheme: DividerThemeData(
            color: Colors.black.withOpacity(0.08),
            thickness: 1,
            space: 24,
          ),
          appBarTheme: const AppBarTheme(
            elevation: 0,
            scrolledUnderElevation: 0,
            backgroundColor: Colors.white,
            foregroundColor: Colors.black,
            centerTitle: false,
          ),
          textTheme: ThemeData.light().textTheme.apply(
                fontFamily: 'Inter', // Das ist weiterhin korrekt
                bodyColor: Colors.black87,
                displayColor: Colors.black87,
              ),
          // Stellen sicher, dass Akzent sichtbar "lebt"
          elevatedButtonTheme: ElevatedButtonThemeData(
            style: ElevatedButton.styleFrom(
              backgroundColor: lightScheme.primary,
              foregroundColor: lightScheme.onPrimary,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12)),
            ),
          ),
          floatingActionButtonTheme: FloatingActionButtonThemeData(
            backgroundColor: lightScheme.primary,
            foregroundColor: lightScheme.onPrimary,
          ),
          //toggleableActiveColor: lightScheme.primary,
          progressIndicatorTheme:
              ProgressIndicatorThemeData(color: lightScheme.primary),
          textSelectionTheme: TextSelectionThemeData(
            cursorColor: lightScheme.primary,
            selectionColor: lightScheme.primary.withOpacity(0.25),
            selectionHandleColor: lightScheme.primary,
          ),
          checkboxTheme: CheckboxThemeData(
            fillColor: WidgetStateProperty.all(lightScheme.primary),
          ),
          radioTheme: RadioThemeData(
            fillColor: WidgetStateProperty.all(lightScheme.primary),
          ),
          switchTheme: SwitchThemeData(
            thumbColor:
                WidgetStateProperty.resolveWith((s) => lightScheme.primary),
            trackColor: WidgetStateProperty.resolveWith(
                (s) => lightScheme.primary.withOpacity(0.5)),
          ),
          dialogTheme: DialogThemeData(
            backgroundColor: cardLight,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
          ),
        );

        // --- Dark Theme (Material2, OLED, Akzent aus Seed) ---
        final baseDarkTheme = ThemeData(
          useMaterial3: false, // KEIN Material You
          colorScheme: darkScheme,
          primaryColor: darkScheme.primary, // Akzent in M2-Welten
          scaffoldBackgroundColor: Colors.black,
          canvasColor: Colors.black,
          cardColor: cardDark,
          // NEU / ANGEPASST:
          splashFactory: NoSplash.splashFactory,
          splashColor: Colors.transparent,
          highlightColor: Colors.transparent,
          hoverColor: Colors.transparent,

          pageTransitionsTheme: const PageTransitionsTheme(
            builders: {
              TargetPlatform.android: ZoomPageTransitionsBuilder(),
              TargetPlatform.iOS: CupertinoPageTransitionsBuilder(),
              TargetPlatform.macOS: CupertinoPageTransitionsBuilder(),
              TargetPlatform.windows: ZoomPageTransitionsBuilder(),
              TargetPlatform.linux: ZoomPageTransitionsBuilder(),
            },
          ),

          inputDecorationTheme: InputDecorationTheme(
            filled: true,
            fillColor: const Color(0xFF1C1C1C),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide.none,
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(color: darkScheme.primary, width: 2),
            ),
            contentPadding:
                const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
          ),

          bottomSheetTheme: const BottomSheetThemeData(
            backgroundColor: cardDark,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
            ),
            elevation: 0,
          ),

          snackBarTheme: SnackBarThemeData(
            backgroundColor: darkScheme.primary,
            contentTextStyle: TextStyle(
              color: darkScheme.onPrimary,
              fontWeight: FontWeight.w600,
            ),
            behavior: SnackBarBehavior.floating,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),

          dividerTheme: DividerThemeData(
            color: Colors.white.withOpacity(0.08),
            thickness: 1,
            space: 24,
          ),
          appBarTheme: const AppBarTheme(
            elevation: 0,
            scrolledUnderElevation: 0,
            backgroundColor: Colors.black,
            foregroundColor: Colors.white,
            centerTitle: false,
          ),
          textTheme: ThemeData.dark().textTheme.apply(
                fontFamily: 'Inter', // Das ist weiterhin korrekt
                bodyColor: Colors.white,
                displayColor: Colors.white,
              ),
          elevatedButtonTheme: ElevatedButtonThemeData(
            style: ElevatedButton.styleFrom(
              backgroundColor: darkScheme.primary,
              foregroundColor: darkScheme.onPrimary,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12)),
            ),
          ),
          floatingActionButtonTheme: FloatingActionButtonThemeData(
            backgroundColor: darkScheme.primary,
            foregroundColor: darkScheme.onPrimary,
          ),
          //toggleableActiveColor: darkScheme.primary,
          progressIndicatorTheme:
              ProgressIndicatorThemeData(color: darkScheme.primary),
          textSelectionTheme: TextSelectionThemeData(
            cursorColor: darkScheme.primary,
            selectionColor: darkScheme.primary.withOpacity(0.35),
            selectionHandleColor: darkScheme.primary,
          ),
          checkboxTheme: CheckboxThemeData(
            fillColor: WidgetStateProperty.all(darkScheme.primary),
          ),
          radioTheme: RadioThemeData(
            fillColor: WidgetStateProperty.all(darkScheme.primary),
          ),
          switchTheme: SwitchThemeData(
            thumbColor:
                WidgetStateProperty.resolveWith((s) => darkScheme.primary),
            trackColor: WidgetStateProperty.resolveWith(
                (s) => darkScheme.primary.withOpacity(0.5)),
          ),
          dialogTheme: DialogThemeData(
            backgroundColor: cardDark,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
          ),
        );

        return MaterialApp(
          debugShowCheckedModeBanner: false,
          scrollBehavior: NoGlowScrollBehavior(), // iOS-Bounce aktiv, kein Glow
          onGenerateTitle: (context) => AppLocalizations.of(context)!.appTitle,
          localizationsDelegates: AppLocalizations.localizationsDelegates,
          supportedLocales: AppLocalizations.supportedLocales,
          title: "LightWeight",
          theme: baseLightTheme,
          darkTheme: baseDarkTheme,
          themeMode: ThemeMode.system,
          home: FutureBuilder<bool>(
            future: _hasSeenOnboarding(),
            builder: (context, snapshot) {
              if (!snapshot.hasData) {
                return const Scaffold(
                  body: Center(child: CircularProgressIndicator()),
                );
              }
              final seen = snapshot.data ?? false;
              return seen ? const MainScreen() : const OnboardingScreen();
            },
          ),
        );
      },
    );
  }
}

class NoGlowScrollBehavior extends ScrollBehavior {
  @override
  Widget buildOverscrollIndicator(
      BuildContext context, Widget child, ScrollableDetails details) {
    // Keine Glow-Effekte
    return child;
  }

  @override
  ScrollPhysics getScrollPhysics(BuildContext context) {
    // iOS-Style: Bouncing
    return const BouncingScrollPhysics();
  }
}


===== Datei: D:\lightweight\lib\data\backup_manager.dart =====

// lib/data/backup_manager.dart (Finale Version)

import 'dart:convert';
import 'dart:io';
import 'package:csv/csv.dart';
import 'package:intl/intl.dart';
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/lightweight_backup.dart';
import 'package:sqflite/sqflite.dart'; // KORREKTUR: Importiert das neue Modell
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/util/encryption_util.dart';
import 'package:path/path.dart' as p;

class BackupManager {
  final _userDb = DatabaseHelper.instance;
  final _productDb = ProductDatabaseHelper.instance;
  final _workoutDb = WorkoutDatabaseHelper.instance;

  static const int currentSchemaVersion = 1;

  Future<bool> exportFullBackup() async {
    try {
      // ... (Logik zum Sammeln der Daten bleibt identisch)
      final foodEntries = await _userDb.getAllFoodEntries();
      final waterEntries = await _userDb.getAllWaterEntries();
      final favoriteBarcodes = await _userDb.getFavoriteBarcodes();
      final measurementSessions = await _userDb.getMeasurementSessions();
      final productDb = await _productDb.offDatabase;
      final customFoodMaps = await productDb?.query('products',
              where: 'barcode LIKE ?', whereArgs: ['user_created_%']) ??
          [];
      final customFoodItems = customFoodMaps
          .map((map) => FoodItem.fromMap(map, source: FoodItemSource.user))
          .toList();
      final routines = await _workoutDb.getAllRoutinesWithDetails();
      final workoutLogs = await _workoutDb.getFullWorkoutLogs();
      // --- HINZUGEFÜGT: Benutzereinstellungen auslesen ---
      final prefs = await SharedPreferences.getInstance();
      final userPrefs = <String, dynamic>{};
      final keys = prefs.getKeys();
      for (String key in keys) {
        userPrefs[key] = prefs.get(key);
      }

      final backup = LightweightBackup(
        // KORREKTUR: Nutzt das neue Modell
        schemaVersion: currentSchemaVersion,
        foodEntries: foodEntries,
        waterEntries: waterEntries,
        favoriteBarcodes: favoriteBarcodes,
        customFoodItems: customFoodItems,
        measurementSessions: measurementSessions,
        routines: routines,
        workoutLogs: workoutLogs,
        userPreferences: userPrefs,
      );
      final jsonString = jsonEncode(backup.toJson());

      // ... (Logik zum Speichern und Teilen der Datei bleibt identisch)
      final tempDir = await getTemporaryDirectory();
      final timestamp = DateFormat('yyyy-MM-dd_HH-mm').format(DateTime.now());
      final tempFile = File(
          '${tempDir.path}/lightweight_backup_v$currentSchemaVersion-[$timestamp].json');
      await tempFile.writeAsString(jsonString);
      final result = await Share.shareXFiles(
          [XFile(tempFile.path, mimeType: 'application/json')],
          subject: 'Lightweight App Backup - $timestamp');
      await tempFile.delete();
      return result.status == ShareResultStatus.success;
    } catch (e) {
      print("Fehler beim Exportieren der Daten: $e");
      return false;
    }
  }

  Future<bool> importFullBackup(String filePath) async {
    try {
      final file = File(filePath);
      final jsonString = await file.readAsString();
      final jsonMap = jsonDecode(jsonString);

      final backup = LightweightBackup.fromJson(
          jsonMap); // KORREKTUR: Nutzt das neue Modell

      if (backup.schemaVersion > currentSchemaVersion) {
        print(
            "Backup-Version (${backup.schemaVersion}) ist neuer als die App-Version ($currentSchemaVersion). Import abgebrochen.");
        return false;
      }

      // ... (Logik zum Löschen und Einfügen der Daten bleibt identisch)
      // HINZUGEFÜGT: Alte Einstellungen löschen
      final prefs = await SharedPreferences.getInstance();
      await prefs.clear();

      await _userDb.clearAllUserData();
      await _workoutDb.clearAllWorkoutData();
      await _userDb.clearAllUserData();
      await _workoutDb.clearAllWorkoutData();
      final productDb = await _productDb.offDatabase;
      await productDb?.delete('products',
          where: 'barcode LIKE ?', whereArgs: ['user_created_%']);
      // HINZUGEFÜGT: Neue Einstellungen wiederherstellen
      for (final entry in backup.userPreferences.entries) {
        final key = entry.key;
        final value = entry.value;
        if (value is bool) {
          await prefs.setBool(key, value);
        } else if (value is int) {
          await prefs.setInt(key, value);
        } else if (value is double) {
          await prefs.setDouble(key, value);
        } else if (value is String) {
          await prefs.setString(key, value);
        } else if (value is List<String>) {
          await prefs.setStringList(key, value);
        }
      }
      await _userDb.importUserData(
        foodEntries: backup.foodEntries,
        waterEntries: backup.waterEntries,
        favoriteBarcodes: backup.favoriteBarcodes,
        measurementSessions: backup.measurementSessions,
      );
      if (productDb != null) {
        final batch = productDb.batch();
        for (final item in backup.customFoodItems) {
          batch.insert('products', item.toMap(),
              conflictAlgorithm: ConflictAlgorithm.replace);
        }
        await batch.commit(noResult: true);
      }
      await _workoutDb.importWorkoutData(
        routines: backup.routines,
        workoutLogs: backup.workoutLogs,
      );

      print("Import erfolgreich abgeschlossen.");
      return true;
    } catch (e) {
      print("Fehler beim Importieren der Daten: $e");
      return false;
    }
  }
  // --- NEUE METHODEN FÜR CSV-EXPORT ---

  /// Exportiert das gesamte Ernährungstagebuch als CSV-Datei.
  Future<bool> exportNutritionAsCsv() async {
    try {
      final entries = await _userDb.getAllFoodEntries();
      if (entries.isEmpty) return false; // Nichts zu exportieren

      // Performance-Optimierung: Alle benötigten Produkte auf einmal laden
      final uniqueBarcodes = entries.map((e) => e.barcode).toSet().toList();
      final products = await _productDb.getProductsByBarcodes(uniqueBarcodes);
      final productMap = {for (var p in products) p.barcode: p};

      List<List<dynamic>> rows = [];
      // Header-Zeile
      rows.add([
        'date',
        'time',
        'meal_type',
        'food_name',
        'brand',
        'quantity_grams',
        'calories_kcal',
        'protein_g',
        'carbs_g',
        'fat_g',
        'barcode'
      ]);

      for (final entry in entries) {
        final product = productMap[entry.barcode];
        if (product == null) continue;

        final factor = entry.quantityInGrams / 100.0;
        rows.add([
          DateFormat('yyyy-MM-dd').format(entry.timestamp),
          DateFormat('HH:mm').format(entry.timestamp),
          entry.mealType,
          product.name,
          product.brand,
          entry.quantityInGrams,
          (product.calories * factor).round(),
          (product.protein * factor).toStringAsFixed(1),
          (product.carbs * factor).toStringAsFixed(1),
          (product.fat * factor).toStringAsFixed(1),
          entry.barcode,
        ]);
      }
      return await _createAndShareCsv(rows, 'lightweight_nutrition_export');
    } catch (e) {
      print("Fehler beim CSV-Export der Ernährung: $e");
      return false;
    }
  }

  /// Exportiert alle Messwerte als CSV-Datei.
  Future<bool> exportMeasurementsAsCsv() async {
    try {
      final sessions = await _userDb.getMeasurementSessions();
      if (sessions.isEmpty) return false;

      List<List<dynamic>> rows = [];
      rows.add(['date', 'time', 'measurement_type', 'value', 'unit']);

      for (final session in sessions) {
        for (final measurement in session.measurements) {
          rows.add([
            DateFormat('yyyy-MM-dd').format(session.timestamp),
            DateFormat('HH:mm').format(session.timestamp),
            measurement.type,
            measurement.value,
            measurement.unit,
          ]);
        }
      }
      return await _createAndShareCsv(rows, 'lightweight_measurements_export');
    } catch (e) {
      print("Fehler beim CSV-Export der Messwerte: $e");
      return false;
    }
  }

  /// Exportiert den gesamten Trainingsverlauf als CSV-Datei.
  Future<bool> exportWorkoutsAsCsv() async {
    try {
      final logs = await _workoutDb.getFullWorkoutLogs();
      if (logs.isEmpty) return false;

      List<List<dynamic>> rows = [];
      rows.add([
        'workout_start_time',
        'workout_end_time',
        'routine_name',
        'exercise_name',
        'set_order',
        'set_type',
        'weight_kg',
        'reps',
        'rest_seconds',
        'notes'
      ]);

      for (final log in logs) {
        int setOrder = 1;
        for (final set in log.sets) {
          rows.add([
            log.startTime.toIso8601String(),
            log.endTime?.toIso8601String() ?? '',
            log.routineName ?? 'Freies Training',
            set.exerciseName,
            setOrder++,
            set.setType,
            set.weightKg ?? 0,
            set.reps ?? 0,
            set.restTimeSeconds ?? 0,
            log.notes ?? '',
          ]);
        }
      }
      return await _createAndShareCsv(rows, 'lightweight_workouts_export');
    } catch (e) {
      print("Fehler beim CSV-Export der Workouts: $e");
      return false;
    }
  }

  /// Private Helfer-Methode zum Erstellen, Speichern und Teilen einer CSV-Datei.
  Future<bool> _createAndShareCsv(
      List<List<dynamic>> rows, String baseFileName) async {
    final String csvData = const ListToCsvConverter().convert(rows);
    final tempDir = await getTemporaryDirectory();
    final timestamp = DateFormat('yyyy-MM-dd').format(DateTime.now());
    final tempFile = File('${tempDir.path}/$baseFileName-$timestamp.csv');
    await tempFile.writeAsString(csvData);

    final result = await Share.shareXFiles(
      [XFile(tempFile.path, mimeType: 'text/csv')],
      subject: baseFileName,
    );

    await tempFile.delete();
    return result.status == ShareResultStatus.success;
  }

  Future<bool> exportFullBackupEncrypted(String passphrase) async {
    try {
      // Daten sammeln (wie in exportFullBackup)
      final foodEntries = await _userDb.getAllFoodEntries();
      final waterEntries = await _userDb.getAllWaterEntries();
      final favoriteBarcodes = await _userDb.getFavoriteBarcodes();
      final measurementSessions = await _userDb.getMeasurementSessions();
      final productDb = await _productDb.offDatabase;
      final customFoodMaps = await productDb?.query(
            'products',
            where: 'barcode LIKE ?',
            whereArgs: ['user_created_%'],
          ) ??
          [];
      final customFoodItems = customFoodMaps
          .map((m) => FoodItem.fromMap(m, source: FoodItemSource.user))
          .toList();
      final routines = await _workoutDb.getAllRoutinesWithDetails();
      final workoutLogs = await _workoutDb.getFullWorkoutLogs();
      final prefs = await SharedPreferences.getInstance();
      final userPrefs = <String, dynamic>{};
      for (final k in prefs.getKeys()) {
        userPrefs[k] = prefs.get(k);
      }

      final backup = LightweightBackup(
        schemaVersion: currentSchemaVersion,
        foodEntries: foodEntries,
        waterEntries: waterEntries,
        favoriteBarcodes: favoriteBarcodes,
        customFoodItems: customFoodItems,
        measurementSessions: measurementSessions,
        routines: routines,
        workoutLogs: workoutLogs,
        userPreferences: userPrefs,
      );
      final jsonString = jsonEncode(backup.toJson());

      // Verschlüsseln
      final wrapper =
          await EncryptionUtil.encryptString(jsonString, passphrase);
      final wrappedJson = jsonEncode(wrapper);

      final tempDir = await getTemporaryDirectory();
      final ts = DateFormat('yyyy-MM-dd_HH-mm').format(DateTime.now());
      final tempFile = File(
        p.join(tempDir.path,
            'lightweight_backup_enc_v$currentSchemaVersion-[$ts].json'),
      );
      await tempFile.writeAsString(wrappedJson);
      final result = await Share.shareXFiles(
        [XFile(tempFile.path, mimeType: 'application/json')],
        subject: 'Lightweight Encrypted Backup - $ts',
      );
      await tempFile.delete();
      return result.status == ShareResultStatus.success;
    } catch (e) {
      print('Fehler beim verschlüsselten Export: $e');
      return false;
    }
  }

  Future<bool> importFullBackupAuto(String filePath,
      {String? passphrase}) async {
    try {
      final file = File(filePath);
      final raw = await file.readAsString();
      final top = jsonDecode(raw);

      Map<String, dynamic> payload;
      if (top is Map && top['enc'] == EncryptionUtil.wrapperVersion) {
        if (passphrase == null || passphrase.isEmpty) {
          print(
              'Verschlüsseltes Backup erkannt, aber kein Passwort übergeben.');
          return false;
        }
        final clear = await EncryptionUtil.decryptToString(
          Map<String, dynamic>.from(top),
          passphrase,
        );
        payload = jsonDecode(clear) as Map<String, dynamic>;
      } else {
        payload = (top as Map).cast<String, dynamic>();
      }

      final backup = LightweightBackup.fromJson(payload);
      if (backup.schemaVersion > currentSchemaVersion) {
        print(
            'Backup-Version (${backup.schemaVersion}) ist neuer als App-Version ($currentSchemaVersion).');
        return false;
      }

      final prefs = await SharedPreferences.getInstance();
      await prefs.clear();
      await _userDb.clearAllUserData();
      await _workoutDb.clearAllWorkoutData();

      final productDb = await _productDb.offDatabase;
      await productDb?.delete('products',
          where: 'barcode LIKE ?', whereArgs: ['user_created_%']);

      for (final e in backup.userPreferences.entries) {
        final k = e.key;
        final v = e.value;
        if (v is bool)
          await prefs.setBool(k, v);
        else if (v is int)
          await prefs.setInt(k, v);
        else if (v is double)
          await prefs.setDouble(k, v);
        else if (v is String)
          await prefs.setString(k, v);
        else if (v is List<String>) await prefs.setStringList(k, v);
      }

      await _userDb.importUserData(
        foodEntries: backup.foodEntries,
        waterEntries: backup.waterEntries,
        favoriteBarcodes: backup.favoriteBarcodes,
        measurementSessions: backup.measurementSessions,
      );

      if (productDb != null) {
        final batch = productDb.batch();
        for (final item in backup.customFoodItems) {
          batch.insert('products', item.toMap(),
              conflictAlgorithm: ConflictAlgorithm.replace);
        }
        await batch.commit(noResult: true);
      }

      await _workoutDb.importWorkoutData(
        routines: backup.routines,
        workoutLogs: backup.workoutLogs,
      );

      print('Import erfolgreich (auto).');
      return true;
    } catch (e) {
      print('Fehler beim Auto-Import: $e');
      return false;
    }
  }

// lib/data/backup_manager.dart

  Future<bool> runAutoBackupIfDue({
    Duration interval = const Duration(days: 1),
    bool encrypted = false,
    String? passphrase,
    int retention = 7,
    String? dirPath,
    bool force = false, // NEU
  }) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final lastMs = prefs.getInt('auto_backup_last_ms') ?? 0;
      final nowMs = DateTime.now().millisecondsSinceEpoch;
      if (!force && (nowMs - lastMs < interval.inMilliseconds)) {
        print('Auto-Backup: nicht fällig (force=false)'); // Hinweis
        return false;
      }

      // 1) Daten sammeln (wie schon implementiert)
      final foodEntries = await _userDb.getAllFoodEntries();
      final waterEntries = await _userDb.getAllWaterEntries();
      final favoriteBarcodes = await _userDb.getFavoriteBarcodes();
      final measurementSessions = await _userDb.getMeasurementSessions();
      final productDb = await _productDb.offDatabase;
      final customFoodMaps = await productDb?.query(
            'products',
            where: 'barcode LIKE ?',
            whereArgs: ['user_created_%'],
          ) ??
          [];
      final customFoodItems = customFoodMaps
          .map((m) => FoodItem.fromMap(m, source: FoodItemSource.user))
          .toList();
      final routines = await _workoutDb.getAllRoutinesWithDetails();
      final workoutLogs = await _workoutDb.getFullWorkoutLogs();
      final userPrefs = <String, dynamic>{};
      for (final k in prefs.getKeys()) {
        userPrefs[k] = prefs.get(k);
      }
      final backup = LightweightBackup(
        schemaVersion: currentSchemaVersion,
        foodEntries: foodEntries,
        waterEntries: waterEntries,
        favoriteBarcodes: favoriteBarcodes,
        customFoodItems: customFoodItems,
        measurementSessions: measurementSessions,
        routines: routines,
        workoutLogs: workoutLogs,
        userPreferences: userPrefs,
      );
      final jsonString = jsonEncode(backup.toJson());

      // 2) Zielordner auflösen
      final docs = await getApplicationDocumentsDirectory();
      final saved = prefs.getString('auto_backup_dir');
      Directory baseDir = (dirPath != null && dirPath.trim().isNotEmpty)
          ? Directory(dirPath)
          : ((saved != null && saved.trim().isNotEmpty)
              ? Directory(saved)
              : Directory(p.join(docs.path, 'Backups')));
      await baseDir.create(recursive: true);
      final ts = DateFormat('yyyy-MM-dd_HH-mm').format(DateTime.now());

      // 3) Klar/verschlüsselt vorbereiten
      late final String content;
      late final String name;
      if (encrypted) {
        if (passphrase == null || passphrase.isEmpty) {
          print('Auto-Backup ENC: Passwort fehlt');
          return false;
        }
        final wrapper =
            await EncryptionUtil.encryptString(jsonString, passphrase);
        content = jsonEncode(wrapper);
        name = 'lightweight_auto_enc_v$currentSchemaVersion-[$ts].json';
      } else {
        content = jsonString;
        name = 'lightweight_auto_v$currentSchemaVersion-[$ts].json';
      }

      // 4) Schreiben mit Fallback bei Fehler
      File outFile = File(p.join(baseDir.path, name));
      try {
        await outFile.writeAsString(content);
      } on FileSystemException catch (e) {
        print(
            'Auto-Backup: Schreiben in $baseDir fehlgeschlagen, Fallback → App-Ordner ($e)');
        baseDir = Directory(p.join(docs.path, 'Backups'));
        await baseDir.create(recursive: true);
        outFile = File(p.join(baseDir.path, name));
        await outFile.writeAsString(content);
      }

      print('Auto-Backup geschrieben: ${outFile.path}');

      // 5) Retention
      final files = baseDir
          .listSync()
          .whereType<File>()
          .where((f) => p.basename(f.path).startsWith('lightweight_auto'))
          .toList()
        ..sort((a, b) => b.lastModifiedSync().compareTo(a.lastModifiedSync()));
      for (var i = retention; i < files.length; i++) {
        try {
          files[i].deleteSync();
        } catch (_) {}
      }

      await prefs.setInt('auto_backup_last_ms', nowMs);
      return true;
    } catch (e) {
      print('Auto-Backup fehlgeschlagen: $e');
      return false;
    }
  }
}


===== Datei: D:\lightweight\lib\data\database_helper.dart =====

// lib/data/database_helper.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:lightweight/models/measurement.dart';
import 'package:lightweight/models/measurement_session.dart';
import '../models/food_entry.dart';
import '../models/water_entry.dart';
import '../models/chart_data_point.dart';

class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._init();
  static Database? _database;
  DatabaseHelper._init();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB('vita_user.db');
    return _database!;
  }

  Future<Database> _initDB(String fileName) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, fileName);
    return await openDatabase(
      path,
      version: 9,
      onCreate: _createDB,
      onUpgrade: _upgradeDB,
    );
  }

  Future<void> _createDB(Database db, int version) async {
    // Dieser Block beschreibt den Endzustand für eine komplett neue Installation.
    await db.execute(
        'CREATE TABLE food_entries (id INTEGER PRIMARY KEY AUTOINCREMENT, barcode TEXT NOT NULL, timestamp TEXT NOT NULL, quantity_in_grams INTEGER NOT NULL, meal_type TEXT NOT NULL DEFAULT "Snack")');
    await db.execute(
        'CREATE TABLE water_entries (id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp TEXT NOT NULL, quantity_in_ml INTEGER NOT NULL)');
    await db.execute('CREATE TABLE favorites (barcode TEXT PRIMARY KEY)');
    await db.execute(
        'CREATE TABLE measurement_sessions (id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp TEXT NOT NULL)');
    await db.execute(
        'CREATE TABLE measurements (id INTEGER PRIMARY KEY AUTOINCREMENT, session_id INTEGER NOT NULL, type TEXT NOT NULL, value REAL NOT NULL, unit TEXT NOT NULL, FOREIGN KEY (session_id) REFERENCES measurement_sessions(id) ON DELETE CASCADE)');
    print("Benutzer-DB (v9) neu erstellt.");
  }

  Future<void> _upgradeDB(Database db, int oldVersion, int newVersion) async {
    // Dieser Block bringt alte Versionen Schritt für Schritt auf den neuesten Stand.
    if (oldVersion < 2) {
      await db.execute(
          'CREATE TABLE water_entries (id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp TEXT NOT NULL, quantity_in_ml INTEGER NOT NULL)');
    }
    if (oldVersion < 4) {
      await db.execute('CREATE TABLE favorites (barcode TEXT PRIMARY KEY)');
    }
    if (oldVersion < 5) {
      await db.execute(
          'ALTER TABLE food_entries ADD COLUMN meal_type TEXT NOT NULL DEFAULT "Snack"');
    }

    // Upgrade von jedem Zustand vor v9 auf v9 (bereinigt alle alten Measurement-Tabellen)
    if (oldVersion < 9) {
      // Lösche alle möglichen alten Versionen der Tabellen, um sicherzugehen.
      await db.execute('DROP TABLE IF EXISTS measurements');
      await db.execute('DROP TABLE IF EXISTS measurement_sessions');
      // Erstelle die Tabellen in der korrekten, finalen Struktur.
      await db.execute(
          'CREATE TABLE measurement_sessions (id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp TEXT NOT NULL)');
      await db.execute(
          'CREATE TABLE measurements (id INTEGER PRIMARY KEY AUTOINCREMENT, session_id INTEGER NOT NULL, type TEXT NOT NULL, value REAL NOT NULL, unit TEXT NOT NULL, FOREIGN KEY (session_id) REFERENCES measurement_sessions(id) ON DELETE CASCADE)');
      print(
          "Datenbank auf Version 9 aktualisiert: Measurement-Tabellen sauber erstellt.");
    }
  }

  // --- FOOD ENTRIES ---
  Future<void> insertFoodEntry(FoodEntry entry) async {
    // DOC: KORREKTUR: Verwende die lokale 'database' Variable anstatt 'instance.database'
    final db = await database;
    await db.insert('food_entries', entry.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace);
    print("Neuer FoodEntry erfolgreich in der Benutzer-DB gespeichert.");
  }

  // Diese Methode ist für den Home Screen. Wir aktualisieren sie auch gleich.
  Future<List<FoodEntry>> getEntriesForDate(DateTime date) async {
    final db = await database;
    final dateString = date.toIso8601String().substring(0, 10);
    final List<Map<String, dynamic>> maps = await db.query(
      'food_entries',
      where: 'timestamp LIKE ?',
      whereArgs: ['$dateString%'],
    );
    return List.generate(maps.length, (i) {
      return FoodEntry(
        id: maps[i]['id'],
        barcode: maps[i]['barcode'],
        timestamp: DateTime.parse(maps[i]['timestamp']),
        quantityInGrams: maps[i]['quantity_in_grams'],
        mealType: maps[i]['meal_type'] ?? 'Snack', // Neues Feld auslesen
      );
    });
  }

  Future<List<FoodEntry>> getEntriesForDateRange(
      DateTime start, DateTime end) async {
    final db = await database;
    final startDateString = DateFormat('yyyy-MM-dd').format(start);
    final endDate = DateTime(end.year, end.month, end.day, 23, 59, 59);
    final endDateString = endDate.toIso8601String();
    final List<Map<String, dynamic>> maps = await db.query(
      'food_entries',
      where: 'timestamp BETWEEN ? AND ?',
      whereArgs: [startDateString, endDateString],
    );
    return List.generate(maps.length, (i) {
      return FoodEntry(
        id: maps[i]['id'],
        barcode: maps[i]['barcode'],
        timestamp: DateTime.parse(maps[i]['timestamp']),
        quantityInGrams: maps[i]['quantity_in_grams'],
        mealType: maps[i]['meal_type'] ?? 'Snack', // Neues Feld auslesen
      );
    });
  }

  Future<void> deleteFoodEntry(int id) async {
    final db = await database;
    await db.delete('food_entries', where: 'id = ?', whereArgs: [id]);
    print("Eintrag mit ID $id erfolgreich gelöscht.");
  }

  // --- WATER ENTRIES ---
  Future<void> insertWaterEntry(int quantityInMl, DateTime timestamp) async {
    final db = await database;
    await db.insert(
        'water_entries',
        {
          'timestamp': timestamp.toIso8601String(),
          'quantity_in_ml': quantityInMl
        },
        conflictAlgorithm: ConflictAlgorithm.replace);
    print("$quantityInMl ml Wasser erfolgreich gespeichert.");
  }

  Future<int> getWaterForDate(DateTime date) async {
    final db = await database;
    final dateString = date.toIso8601String().substring(0, 10);
    final result = await db.rawQuery(
        'SELECT SUM(quantity_in_ml) as total FROM water_entries WHERE timestamp LIKE ?',
        ['$dateString%']);
    return result.first['total'] as int? ?? 0;
  }

  Future<int> getWaterForDateRange(DateTime start, DateTime end) async {
    final db = await database;
    final startDateString = DateFormat('yyyy-MM-dd').format(start);
    final endDate = DateTime(end.year, end.month, end.day, 23, 59, 59);
    final endDateString = endDate.toIso8601String();
    final result = await db.rawQuery(
        'SELECT SUM(quantity_in_ml) as total FROM water_entries WHERE timestamp BETWEEN ? AND ?',
        [startDateString, endDateString]);
    return result.first['total'] as int? ?? 0;
  }

  Future<List<WaterEntry>> getWaterEntriesForDateRange(
      DateTime start, DateTime end) async {
    final db = await database;
    final startDateString = DateFormat('yyyy-MM-dd').format(start);
    final endDate = DateTime(end.year, end.month, end.day, 23, 59, 59);
    final endDateString = endDate.toIso8601String();
    final List<Map<String, dynamic>> maps = await db.query(
      'water_entries',
      where: 'timestamp BETWEEN ? AND ?',
      whereArgs: [startDateString, endDateString],
    );
    return List.generate(maps.length, (i) => WaterEntry.fromMap(maps[i]));
  }

  Future<void> deleteWaterEntry(int id) async {
    final db = await database;
    await db.delete(
      'water_entries',
      where: 'id = ?',
      whereArgs: [id],
    );
    print("Wasser-Eintrag mit ID $id erfolgreich gelöscht.");
  }

  // --- FAVORITES ---
  Future<void> addFavorite(String barcode) async {
    final db = await database;
    await db.insert('favorites', {'barcode': barcode});
    print("Favorit $barcode hinzugefügt.");
  }

  Future<void> removeFavorite(String barcode) async {
    final db = await database;
    await db.delete('favorites', where: 'barcode = ?', whereArgs: [barcode]);
    print("Favorit $barcode entfernt.");
  }

  Future<bool> isFavorite(String barcode) async {
    final db = await database;
    final List<Map<String, dynamic>> maps =
        await db.query('favorites', where: 'barcode = ?', whereArgs: [barcode]);
    return maps.isNotEmpty;
  }

  Future<List<String>> getFavoriteBarcodes() async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query('favorites');
    return List.generate(maps.length, (i) => maps[i]['barcode'] as String);
  }

  // DOC: NEUE METHODE für die "Zuletzt verwendet"-Liste
  Future<List<String>> getRecentlyUsedBarcodes() async {
    final db = await database;
    // Dieses SQL-Statement ist etwas komplexer:
    // 1. SELECT DISTINCT barcode: Wähle jeden Barcode nur einmal aus.
    // 2. FROM food_entries: Aus der Tabelle der Einträge.
    // 3. ORDER BY timestamp DESC: Sortiere sie absteigend nach dem Zeitstempel (die neuesten zuerst).
    // 4. LIMIT 20: Gib uns nur die Top 20 zurück.
    final List<Map<String, dynamic>> maps = await db.query(
      'food_entries',
      distinct: true,
      columns: ['barcode'],
      orderBy: 'timestamp DESC',
      limit: 20,
    );
    return List.generate(maps.length, (i) => maps[i]['barcode'] as String);
  }

  // --- MEASUREMENTS (SESSION-BASED) ---
  Future<void> insertMeasurementSession(MeasurementSession session) async {
    final db = await database;
    await db.transaction((txn) async {
      final sessionId = await txn.insert(
        'measurement_sessions',
        {'timestamp': session.timestamp.toIso8601String()},
      );

      for (final measurement in session.measurements) {
        // WICHTIG: Wir erstellen hier eine NEUE Map aus dem Measurement-Objekt,
        // das KEINEN Timestamp mehr hat, und fügen die session_id hinzu.
        final measurementMap = {
          'session_id': sessionId,
          'type': measurement.type,
          'value': measurement.value,
          'unit': measurement.unit,
        };
        await txn.insert('measurements', measurementMap);
      }
    });
    print("Neue Measurement-Session erfolgreich gespeichert.");
  }

  Future<List<MeasurementSession>> getMeasurementSessions() async {
    final db = await database;
    final List<Map<String, dynamic>> sessionMaps = await db.query(
      'measurement_sessions',
      orderBy: 'timestamp DESC',
    );

    if (sessionMaps.isEmpty) return [];

    final List<MeasurementSession> sessions = [];
    for (final sessionMap in sessionMaps) {
      final sessionId = sessionMap['id'] as int;
      final List<Map<String, dynamic>> measurementMaps = await db.query(
        'measurements',
        where: 'session_id = ?',
        whereArgs: [sessionId],
      );

      // Die fromMap-Methode im korrigierten Measurement-Modell wird hier verwendet.
      final measurements =
          measurementMaps.map((map) => Measurement.fromMap(map)).toList();

      sessions.add(MeasurementSession(
        id: sessionId,
        timestamp: DateTime.parse(sessionMap['timestamp'] as String),
        measurements: measurements,
      ));
    }
    return sessions;
  }

  Future<void> deleteMeasurementSession(int id) async {
    final db = await database;
    await db.delete('measurement_sessions', where: 'id = ?', whereArgs: [id]);
    print(
        "Measurement-Session mit ID $id (und zugehörige Messwerte) gelöscht.");
  }

  // --- CHART DATA HELPERS ---

  /// Ruft alle Messwerte eines bestimmten Typs ab und gibt sie als
  /// eine Liste von Datenpunkten für einen Graphen zurück.
  Future<List<ChartDataPoint>> getChartDataForType(String type) async {
    final db = await database;

    // Dies ist eine komplexere SQL-Abfrage. Sie verbindet die beiden Tabellen:
    // Sie holt den 'value' aus der 'measurements'-Tabelle und den zugehörigen
    // 'timestamp' aus der 'measurement_sessions'-Tabelle, filtert nach dem
    // gewünschten Typ und sortiert nach Datum.
    final List<Map<String, dynamic>> maps = await db.rawQuery('''
      SELECT
        s.timestamp,
        m.value
      FROM measurements m
      INNER JOIN measurement_sessions s ON m.session_id = s.id
      WHERE m.type = ?
      ORDER BY s.timestamp ASC 
    ''', [type]);

    if (maps.isEmpty) {
      return [];
    }

    // Wandle das Ergebnis der Datenbankabfrage in unsere saubere ChartDataPoint-Liste um.
    return maps.map((map) {
      return ChartDataPoint(
        date: DateTime.parse(map['timestamp'] as String),
        value: map['value'] as double,
      );
    }).toList();
  }

  Future<List<ChartDataPoint>> getChartDataForTypeAndRange(
      String type, DateTimeRange range) async {
    final db = await database;

    final List<Map<String, dynamic>> maps = await db.rawQuery('''
      SELECT
        s.timestamp,
        m.value
      FROM measurements m
      INNER JOIN measurement_sessions s ON m.session_id = s.id
      WHERE m.type = ? AND s.timestamp BETWEEN ? AND ?
      ORDER BY s.timestamp ASC 
    ''', [
      type,
      range.start.toIso8601String(),
      range.end.toIso8601String(),
    ]);

    if (maps.isEmpty) {
      return [];
    }

    return maps.map((map) {
      return ChartDataPoint(
        date: DateTime.parse(map['timestamp'] as String),
        value: map['value'] as double,
      );
    }).toList();
  }

  Future<void> updateFoodEntry(FoodEntry entry) async {
    final db = await database;
    await db.update(
      'food_entries',
      entry.toMap(),
      where: 'id = ?',
      whereArgs: [entry.id],
    );
    print("Eintrag mit ID ${entry.id} erfolgreich aktualisiert.");
  }

  Future<DateTime?> getEarliestMeasurementDate() async {
    final db = await database;
    final maps = await db.query('measurement_sessions',
        orderBy: 'timestamp ASC', limit: 1);
    if (maps.isNotEmpty) {
      return DateTime.parse(maps.first['timestamp'] as String);
    }
    return null;
  }

  Future<DateTime?> getEarliestFoodEntryDate() async {
    final db = await database;
    final maps =
        await db.query('food_entries', orderBy: 'timestamp ASC', limit: 1);
    if (maps.isNotEmpty) {
      return DateTime.parse(maps.first['timestamp'] as String);
    }
    return null;
  }
// In lib/data/database_helper.dart (korrigierte Version der neuen Methoden)

  Future<List<FoodEntry>> getAllFoodEntries() async {
    final db = await database;
    final maps = await db.query('food_entries');
    // KORREKTUR: Nutzt den Standard-Konstruktor, da 'fromJson' nicht existiert.
    return maps
        .map((map) => FoodEntry(
              id: map['id'] as int?,
              barcode: map['barcode'] as String,
              timestamp: DateTime.parse(map['timestamp'] as String),
              quantityInGrams: map['quantity_in_grams'] as int,
              mealType: map['meal_type'] as String,
            ))
        .toList();
  }

  Future<List<WaterEntry>> getAllWaterEntries() async {
    final db = await database;
    final maps = await db.query('water_entries');
    // KORREKTUR: Nutzt die korrekte 'fromMap'-Factory.
    return maps.map((map) => WaterEntry.fromMap(map)).toList();
  }

  Future<void> clearAllUserData() async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('food_entries');
      await txn.delete('water_entries');
      await txn.delete('favorites');
      await txn.delete('measurements');
      await txn.delete('measurement_sessions');
    });
  }

  Future<void> importUserData({
    required List<FoodEntry> foodEntries,
    required List<WaterEntry> waterEntries,
    required List<String> favoriteBarcodes,
    required List<MeasurementSession> measurementSessions,
  }) async {
    final db = await database;
    await db.transaction((txn) async {
      for (final entry in foodEntries) {
        await txn.insert('food_entries', entry.toMap());
      }
      for (final entry in waterEntries) {
        await txn.insert('water_entries', entry.toMap());
      }
      for (final barcode in favoriteBarcodes) {
        await txn.insert('favorites', {'barcode': barcode});
      }
      for (final session in measurementSessions) {
        // KORREKTUR: Erstellt die Map für die Session direkt hier.
        final sessionId = await txn.insert('measurement_sessions',
            {'timestamp': session.timestamp.toIso8601String()});
        for (final measurement in session.measurements) {
          // KORREKTUR: Erstellt die Map für das Measurement hier und fügt die NEUE sessionId hinzu.
          await txn.insert('measurements', {
            ...measurement.toMap(), // Nutzt die existierende toMap()
            'session_id': sessionId, // Überschreibt mit der neuen ID
          });
        }
      }
    });
  }
}


===== Datei: D:\lightweight\lib\data\import_manager.dart =====

// lib/data/import_manager.dart (Final, mit Deutsch-Support)

import 'dart:io';
import 'package:csv/csv.dart';
import 'package:file_picker/file_picker.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/util/mapping_prefs.dart';

class ImportManager {
  Future<int> importHevyCsv() async {
    // ... (Diese Methode bleibt unverändert, sie ist bereits korrekt)
    try {
      final result = await FilePicker.platform
          .pickFiles(type: FileType.custom, allowedExtensions: ['csv']);
      if (result == null || result.files.single.path == null) return 0;
      final filePath = result.files.single.path!;
      final file = File(filePath);
      final content = await file.readAsString();
      final List<List<dynamic>> rows =
          const CsvToListConverter(shouldParseNumbers: false, eol: '\n')
              .convert(content);

      if (rows.length < 2) return 0;

      final workoutGroups = <String, List<Map<String, dynamic>>>{};
      final header = rows.first.map((e) => e.toString().trim()).toList();

      for (var i = 1; i < rows.length; i++) {
        final row = rows[i];
        if (row.length != header.length) continue;
        final rowMap = Map<String, dynamic>.fromIterables(header, row);

        if (rowMap['start_time'] == null ||
            rowMap['start_time'].toString().trim().isEmpty) {
          continue;
        }

        final key = "${rowMap['title']}_${rowMap['start_time']}";
        if (workoutGroups.containsKey(key)) {
          workoutGroups[key]!.add(rowMap);
        } else {
          workoutGroups[key] = [rowMap];
        }
      }

      final db = WorkoutDatabaseHelper.instance;
      int importedWorkouts = 0;
      final knownMap = await MappingPrefs.load();
      for (var group in workoutGroups.values) {
        final firstRow = group.first;
        final newLog = await db.startWorkout(routineName: firstRow['title']);

        final dbInstance = await db.database;
        await dbInstance.update(
            'workout_logs',
            {
              'start_time':
                  _parseHevyDate(firstRow['start_time']).toIso8601String(),
              'end_time':
                  _parseHevyDate(firstRow['end_time']).toIso8601String(),
              'notes': firstRow['description'],
              'status': 'completed',
            },
            where: 'id = ?',
            whereArgs: [newLog.id]);

        int setOrder = 0;
        for (var row in group) {
          final rawName = row['exercise_title']?.toString() ?? '';
          final mappedName = knownMap[rawName.trim().toLowerCase()] ?? rawName;

          final setLog = SetLog(
            workoutLogId: newLog.id!,
            exerciseName: mappedName, // <— statt rawName
            setType: row['set_type'] ?? 'normal',
            weightKg: double.tryParse(row['weight_kg']?.toString() ?? ''),
            reps: int.tryParse(row['reps']?.toString() ?? ''),
            log_order: setOrder++,
            notes: row['exercise_notes'],
            distanceKm: double.tryParse(row['distance_km']?.toString() ?? ''),
            durationSeconds:
                int.tryParse(row['duration_seconds']?.toString() ?? ''),
            rpe: int.tryParse(row['rpe']?.toString() ?? ''),
            supersetId: int.tryParse(row['superset_id']?.toString() ?? ''),
          );
          await db.insertSetLog(setLog);
        }
        importedWorkouts++;
      }
      return importedWorkouts;
    } catch (e) {
      print("Hevy Import Error: $e");
      return -1;
    }
  }

  /// KORREKTUR: Die Parser-Funktion unterstützt jetzt explizit deutsche Monatsnamen.
  DateTime _parseHevyDate(dynamic rawDateString) {
    final dateString = rawDateString?.toString().trim();
    if (dateString == null || dateString.isEmpty) {
      print(
          "Leere oder null Datumszeichenfolge erhalten. Fallback auf DateTime.now()");
      return DateTime.now();
    }

    // Die Liste der Formate wurde um das deutsche Locale erweitert.
    final List<DateFormat> formats = [
      DateFormat("dd MMM yyyy, HH:mm",
          "en_US"), // Probiert zuerst Englisch (Jan, Feb, Apr...)
      DateFormat(
          "dd MMM yyyy, HH:mm", "de_DE"), // Dann Deutsch (März, Mai, Juni...)
      DateFormat("yyyy-MM-dd HH:mm:ss"),
      DateFormat("dd.MM.yyyy, HH:mm"),
    ];

    for (final format in formats) {
      try {
        return format.parse(dateString);
      } catch (e) {
        continue;
      }
    }

    print("Konnte Datum nicht mit bekannten Formaten parsen: '$dateString'");
    return DateTime.now();
  }
}


===== Datei: D:\lightweight\lib\data\product_database_helper.dart =====

// lib/data/product_database_helper.dart

import 'dart:async';
import 'dart:io';
import 'package:flutter/services.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import '../models/food_item.dart';
import './database_helper.dart';

class ProductDatabaseHelper {
  static final ProductDatabaseHelper instance = ProductDatabaseHelper._init();
  ProductDatabaseHelper._init();

  static Database? _offDatabase;
  static Database? _baseDatabase;

  // Ein einfacher Sperrmechanismus, um doppelte Initialisierung zu verhindern.
  static bool _isInitializing = false;

  // Stellt sicher, dass die Datenbanken geladen sind, bevor eine Abfrage erfolgt.
  Future<void> _ensureDatabasesInitialized() async {
    // Wenn die DBs schon da sind, ist alles gut.
    if (_offDatabase != null) {
      return;
    }

    // Wenn die Initialisierung bereits läuft, warte kurz.
    // Dies ist eine einfache Absicherung, keine komplexe Sperre.
    if (_isInitializing) {
      await Future.delayed(const Duration(milliseconds: 50));
      return _ensureDatabasesInitialized();
    }

    _isInitializing = true;

    // EINFACHE, SEQUENZIELLE INITIALISIERUNG - KEIN Future.wait
    try {
      _offDatabase = await _initDB('vita_prep_de.db');
    } catch (e) {
      print(
          "KRITISCHER FEHLER: Die Haupt-Produktdatenbank konnte nicht geladen werden: $e");
    }

    try {
      _baseDatabase = await _initDB('vita_base_foods.db');
    } catch (e) {
      print(
          "INFO: Die optionale Grundnahrungsmittel-DB wurde nicht gefunden. Das ist normal, wenn sie noch nicht hinzugefügt wurde. Fehler: $e");
    }

    _isInitializing = false;
  }

  Future<Database> _initDB(String fileName) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, fileName);
    final exists = await databaseExists(path);

    if (!exists) {
      print(
          "Datenbank '$fileName' existiert nicht, kopiere sie aus den Assets...");
      try {
        await Directory(dirname(path)).create(recursive: true);
        ByteData data = await rootBundle.load(join('assets/db', fileName));
        List<int> bytes =
            data.buffer.asUint8List(data.offsetInBytes, data.lengthInBytes);
        await File(path).writeAsBytes(bytes, flush: true);
        print("Datenbank '$fileName' erfolgreich kopiert.");
      } catch (e) {
        print("Fehler beim Kopieren der Datenbank '$fileName': $e");
        if (await File(path).exists()) await File(path).delete();
        throw Exception(
            "Konnte Datenbank '$fileName' nicht aus den Assets laden.");
      }
    } else {
      print("Bestehende Datenbank '$fileName' gefunden.");
    }
    return await openDatabase(path);
  }

  // ÖFFENTLICHER GETTER FÜR DEN BACKUP-MANAGER
  Future<Database?> get offDatabase async {
    await _ensureDatabasesInitialized();
    return _offDatabase;
  }

  Future<List<FoodItem>> searchProducts(String query) async {
    await _ensureDatabasesInitialized();
    final List<FoodItem> combinedResults = [];

    if (_baseDatabase != null) {
      final List<Map<String, dynamic>> baseMaps = await _baseDatabase!.query(
          'products',
          where: 'name LIKE ?',
          whereArgs: ['%$query%'],
          limit: 25);
      combinedResults.addAll(baseMaps
          .map((map) => FoodItem.fromMap(map, source: FoodItemSource.base)));
    }

    // Die Haupt-DB muss existieren, sonst stürzt die App hier ab, was korrekt ist.
    if (_offDatabase != null) {
      final List<Map<String, dynamic>> offMaps = await _offDatabase!.query(
          'products',
          where: 'name LIKE ? OR brand LIKE ?',
          whereArgs: ['%$query%', '%$query%'],
          limit: 50);
      combinedResults.addAll(offMaps
          .map((map) => FoodItem.fromMap(map, source: FoodItemSource.off)));
    }

    final uniqueResults = <String, FoodItem>{};
    for (var item in combinedResults) {
      uniqueResults.putIfAbsent(item.barcode, () => item);
    }
    return uniqueResults.values.toList();
  }

  Future<FoodItem?> getProductByBarcode(String barcode) async {
    await _ensureDatabasesInitialized();

    if (_baseDatabase != null) {
      final List<Map<String, dynamic>> baseMaps = await _baseDatabase!.query(
          'products',
          where: 'barcode = ?',
          whereArgs: [barcode],
          limit: 1);
      if (baseMaps.isNotEmpty) {
        return FoodItem.fromMap(baseMaps.first, source: FoodItemSource.base);
      }
    }

    if (_offDatabase != null) {
      final List<Map<String, dynamic>> offMaps = await _offDatabase!.query(
          'products',
          where: 'barcode = ?',
          whereArgs: [barcode],
          limit: 1);
      if (offMaps.isNotEmpty) {
        return FoodItem.fromMap(offMaps.first, source: FoodItemSource.off);
      }
    }

    return null;
  }

  Future<void> insertProduct(FoodItem item) async {
    await _ensureDatabasesInitialized();
    if (_offDatabase == null) return;
    await _offDatabase!.insert('products', item.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace);
  }

  Future<List<FoodItem>> _getProductsByBarcodes(List<String> barcodes) async {
    if (barcodes.isEmpty) return [];
    final results = <FoodItem>[];
    for (final barcode in barcodes) {
      final product = await getProductByBarcode(barcode);
      if (product != null) results.add(product);
    }
    return results;
  }

  Future<List<FoodItem>> getFavoriteProducts() async {
    final favoriteBarcodes =
        await DatabaseHelper.instance.getFavoriteBarcodes();
    return await _getProductsByBarcodes(favoriteBarcodes);
  }

  Future<List<FoodItem>> getRecentProducts() async {
    final recentBarcodes =
        await DatabaseHelper.instance.getRecentlyUsedBarcodes();
    return await _getProductsByBarcodes(recentBarcodes);
  }

  Future<List<FoodItem>> getProductsByBarcodes(List<String> barcodes) async {
    if (barcodes.isEmpty) return [];
    await _ensureDatabasesInitialized();

    final db = _offDatabase;
    if (db == null) return [];

    // Erstellt eine Kette von '?' für die IN-Klausel
    final placeholders = List.filled(barcodes.length, '?').join(',');
    final maps = await db.query(
      'products',
      where: 'barcode IN ($placeholders)',
      whereArgs: barcodes,
    );
    return maps
        .map((map) => FoodItem.fromMap(map, source: FoodItemSource.off))
        .toList();
  }
}


===== Datei: D:\lightweight\lib\data\workout_database_helper.dart =====

// lib/data/workout_database_helper.dart

import 'dart:io';
import 'package:flutter/services.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/models/routine_exercise.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/set_template.dart';
import 'package:lightweight/models/workout_log.dart';

class WorkoutDatabaseHelper {
  static final WorkoutDatabaseHelper instance = WorkoutDatabaseHelper._init();
  static Database? _database;
  WorkoutDatabaseHelper._init();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB('vita_training.db');
    return _database!;
  }

  Future<Database> _initDB(String fileName) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, fileName);

    final exists = await databaseExists(path);
    if (!exists) {
      try {
        await Directory(dirname(path)).create(recursive: true);
        ByteData data = await rootBundle.load(join('assets/db', fileName));
        List<int> bytes =
            data.buffer.asUint8List(data.offsetInBytes, data.lengthInBytes);
        await File(path).writeAsBytes(bytes, flush: true);
      } catch (e) {
        rethrow;
      }
    }

    // FINALE LÖSUNG: Wir verwenden NUR onUpgrade.
    return await openDatabase(
      path,
      version: 8,
      onUpgrade: _upgradeDB,
    );
  }

  // Diese Methode bringt eine alte, existierende DB auf den neuesten Stand.
  Future<void> _upgradeDB(Database db, int oldVersion, int newVersion) async {
    print("Führe DB-Upgrade von v$oldVersion auf v$newVersion aus...");
    // Gestaffeltes Upgrade. catchError fängt Fehler ab, falls Spalte schon existiert.
    if (oldVersion < 2) {
      await db
          .execute('ALTER TABLE set_logs ADD COLUMN rest_time_seconds INTEGER')
          .catchError((_) {});
      await db
          .execute('ALTER TABLE set_logs ADD COLUMN is_completed INTEGER')
          .catchError((_) {});
    }
    if (oldVersion < 3) {
      await db
          .execute(
              "ALTER TABLE workout_logs ADD COLUMN status TEXT NOT NULL DEFAULT 'completed'")
          .catchError((_) {});
    }
    if (oldVersion < 4) {
      await db
          .execute(
              "ALTER TABLE routine_exercises ADD COLUMN pause_seconds INTEGER")
          .catchError((_) {});
    }
    if (oldVersion < 5) {
      await db
          .execute("ALTER TABLE set_logs ADD COLUMN log_order INTEGER")
          .catchError((_) {});
    }
    // NEUE MIGRATION
    if (oldVersion < 6) {
      print("Upgrade DB auf v6: Entferne set_index aus set_logs...");
      await db.transaction((txn) async {
        // Schritt 1: Umbenennen
        await txn.execute('ALTER TABLE set_logs RENAME TO set_logs_old');

        // Schritt 2: Neu erstellen
        await txn.execute('''
          CREATE TABLE set_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            workout_log_id INTEGER,
            exercise_name TEXT,
            set_type TEXT,
            weight_kg REAL,
            reps INTEGER,
            rest_time_seconds INTEGER,
            is_completed INTEGER,
            log_order INTEGER
          )
        ''');

        // Schritt 3: Daten kopieren
        await txn.execute('''
          INSERT INTO set_logs (id, workout_log_id, exercise_name, set_type, weight_kg, reps, rest_time_seconds, is_completed, log_order)
          SELECT id, workout_log_id, exercise_name, set_type, weight_kg, reps, rest_time_seconds, is_completed, log_order FROM set_logs_old
        ''');

        // Schritt 4: Alte Tabelle löschen
        await txn.execute('DROP TABLE set_logs_old');
      });
      // NEUE MIGRATION
      if (oldVersion < 7) {
        print("Upgrade DB auf v7: Füge Detail-Spalten zu set_logs hinzu...");
        await db
            .execute("ALTER TABLE set_logs ADD COLUMN notes TEXT")
            .catchError((_) {});
        await db
            .execute("ALTER TABLE set_logs ADD COLUMN distance_km REAL")
            .catchError((_) {});
        await db
            .execute("ALTER TABLE set_logs ADD COLUMN duration_seconds INTEGER")
            .catchError((_) {});
        await db
            .execute("ALTER TABLE set_logs ADD COLUMN rpe INTEGER")
            .catchError((_) {});
      }
      if (oldVersion < 8) {
        print("Upgrade DB auf v8: Füge superset_id zu set_logs hinzu...");
        await db
            .execute("ALTER TABLE set_logs ADD COLUMN superset_id INTEGER")
            .catchError((_) {});
      }
      print("Migration auf v8 erfolgreich abgeschlossen.");
    }
  }

  // --- EXERCISE MANAGEMENT ---
  Future<List<String>> getAllCategories() async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query('exercises',
        columns: ['category_name'],
        distinct: true,
        orderBy: 'category_name ASC');
    return maps
        .map((map) => map['category_name'] as String?)
        .where((category) => category != null && category.isNotEmpty)
        .cast<String>()
        .toList();
  }

  Future<List<Exercise>> searchExercises(
      {String query = '', List<String> selectedCategories = const []}) async {
    final db = await database;
    List<String> whereClauses = [];
    List<dynamic> whereArgs = [];
    if (query.isNotEmpty) {
      whereClauses.add('(name_de LIKE ? OR name_en LIKE ?)');
      whereArgs.addAll(['%$query%', '%$query%']);
    }
    if (selectedCategories.isNotEmpty) {
      String placeholders =
          List.filled(selectedCategories.length, '?').join(', ');
      whereClauses.add('category_name IN ($placeholders)');
      whereArgs.addAll(selectedCategories);
    }
    String finalWhere =
        whereClauses.isNotEmpty ? whereClauses.join(' AND ') : '';
    final String sql = '''
      SELECT e.*, CASE WHEN sl.id IS NOT NULL THEN 0 ELSE 1 END as sort_priority
      FROM exercises e
      LEFT JOIN (SELECT exercise_name, MAX(id) as id FROM set_logs GROUP BY exercise_name) sl 
      ON e.name_de = sl.exercise_name OR e.name_en = sl.exercise_name
      ${finalWhere.isNotEmpty ? 'WHERE $finalWhere' : ''}
      ORDER BY sort_priority ASC, e.name_de ASC
    ''';
    final List<Map<String, dynamic>> maps = await db.rawQuery(sql, whereArgs);
    return List.generate(maps.length, (i) => Exercise.fromMap(maps[i]));
  }

  Future<Exercise> insertExercise(Exercise exercise) async {
    final db = await database;
    final id = await db.insert('exercises', exercise.toMap());
    return exercise.copyWith(id: id);
  }

  Future<Exercise?> getExerciseByName(String name) async {
    final db = await database;
    final maps = await db.query('exercises',
        where: 'name_de = ? OR name_en = ?', whereArgs: [name, name], limit: 1);
    if (maps.isNotEmpty) {
      return Exercise.fromMap(maps.first);
    }
    return null;
  }

  // --- ROUTINE MANAGEMENT ---
  Future<Routine> createRoutine(String name) async {
    final db = await database;
    final id = await db.insert('routines', {'name': name},
        conflictAlgorithm: ConflictAlgorithm.replace);
    return Routine(id: id, name: name);
  }

  Future<void> updateRoutineName(int routineId, String newName) async {
    final db = await database;
    await db.update('routines', {'name': newName},
        where: 'id = ?', whereArgs: [routineId]);
  }

  Future<RoutineExercise?> addExerciseToRoutine(
      int routineId, int exerciseId) async {
    final db = await database;
    final exerciseMaps =
        await db.query('exercises', where: 'id = ?', whereArgs: [exerciseId]);
    if (exerciseMaps.isEmpty) return null;
    final result = await db.rawQuery(
        'SELECT MAX(exercise_order) as max_order FROM routine_exercises WHERE routine_id = ?',
        [routineId]);
    final maxOrder = (result.first['max_order'] as int?) ?? -1;
    final routineExerciseId = await db.insert('routine_exercises', {
      'routine_id': routineId,
      'exercise_id': exerciseId,
      'exercise_order': maxOrder + 1
    });
    final List<SetTemplate> newTemplates = [];
    for (int i = 0; i < 3; i++) {
      final setId = await db.insert('routine_set_templates', {
        'routine_exercise_id': routineExerciseId,
        'set_index': i,
        'set_type': 'normal'
      });
      newTemplates
          .add(SetTemplate(id: setId, setType: 'normal', targetReps: '8-12'));
    }
    return RoutineExercise(
        id: routineExerciseId,
        exercise: Exercise.fromMap(exerciseMaps.first),
        setTemplates: newTemplates);
  }

  Future<void> removeExerciseFromRoutine(int routineExerciseId) async {
    final db = await database;
    await db.delete('routine_exercises',
        where: 'id = ?', whereArgs: [routineExerciseId]);
  }

  Future<void> updateExerciseOrder(
      int routineId, List<RoutineExercise> orderedExercises) async {
    final db = await database;
    final batch = db.batch();
    for (int i = 0; i < orderedExercises.length; i++) {
      final routineExercise = orderedExercises[i];
      batch.update('routine_exercises', {'exercise_order': i},
          where: 'id = ?', whereArgs: [routineExercise.id]);
    }
    await batch.commit(noResult: true);
  }

  Future<List<Routine>> getAllRoutines() async {
    final db = await database;
    final List<Map<String, dynamic>> maps =
        await db.query('routines', orderBy: 'name ASC');
    return List.generate(
        maps.length, (i) => Routine(id: maps[i]['id'], name: maps[i]['name']));
  }

  Future<Routine?> getRoutineById(int id) async {
    final db = await database;
    final routineMaps =
        await db.query('routines', where: 'id = ?', whereArgs: [id]);
    if (routineMaps.isEmpty) return null;
    final routineExerciseMaps = await db.query('routine_exercises',
        where: 'routine_id = ?',
        whereArgs: [id],
        orderBy: 'exercise_order ASC');
    final List<RoutineExercise> routineExercises = [];
    for (final reMap in routineExerciseMaps) {
      final routineExerciseId = reMap['id'] as int;
      final exerciseId = reMap['exercise_id'] as int;
      final exerciseMaps =
          await db.query('exercises', where: 'id = ?', whereArgs: [exerciseId]);
      if (exerciseMaps.isEmpty) continue;
      final setTemplateMaps = await db.query('routine_set_templates',
          where: 'routine_exercise_id = ?',
          whereArgs: [routineExerciseId],
          orderBy: 'set_index ASC');
      final setTemplates =
          setTemplateMaps.map((stMap) => SetTemplate.fromMap(stMap)).toList();
      routineExercises.add(RoutineExercise(
          id: routineExerciseId,
          exercise: Exercise.fromMap(exerciseMaps.first),
          setTemplates: setTemplates,
          pauseSeconds: reMap['pause_seconds'] as int?));
    }
    return Routine(
        id: id,
        name: routineMaps.first['name'] as String,
        exercises: routineExercises);
  }

  Future<void> updateSetTemplate(SetTemplate setTemplate) async {
    final db = await database;
    await db.update(
        'routine_set_templates',
        {
          'set_type': setTemplate.setType,
          'target_reps': setTemplate.targetReps,
          'target_weight': setTemplate.targetWeight
        },
        where: 'id = ?',
        whereArgs: [setTemplate.id]);
  }

  Future<void> replaceSetTemplatesForExercise(
      int routineExerciseId, List<SetTemplate> newTemplates) async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('routine_set_templates',
          where: 'routine_exercise_id = ?', whereArgs: [routineExerciseId]);
      for (int i = 0; i < newTemplates.length; i++) {
        final set = newTemplates[i];
        await txn.insert('routine_set_templates', {
          'routine_exercise_id': routineExerciseId,
          'set_index': i,
          'set_type': set.setType,
          'target_reps': set.targetReps,
          'target_weight': set.targetWeight
        });
      }
    });
  }

  Future<void> deleteRoutine(int routineId) async {
    final db = await database;
    await db.transaction((txn) async {
      final reMaps = await txn.query('routine_exercises',
          where: 'routine_id = ?', whereArgs: [routineId]);
      for (var reMap in reMaps) {
        await txn.delete('routine_set_templates',
            where: 'routine_exercise_id = ?', whereArgs: [reMap['id']]);
      }
      await txn.delete('routine_exercises',
          where: 'routine_id = ?', whereArgs: [routineId]);
      await txn.delete('routines', where: 'id = ?', whereArgs: [routineId]);
    });
  }

  Future<void> duplicateRoutine(int routineId) async {
    final db = await database;
    final originalRoutine = await getRoutineById(routineId);
    if (originalRoutine == null) return;
    await db.transaction((txn) async {
      final newRoutineId = await txn
          .insert('routines', {'name': '${originalRoutine.name} (Kopie)'});
      for (var re in originalRoutine.exercises) {
        final newRoutineExerciseId = await txn.insert('routine_exercises', {
          'routine_id': newRoutineId,
          'exercise_id': re.exercise.id,
          'exercise_order': originalRoutine.exercises.indexOf(re),
          'pause_seconds': re.pauseSeconds
        });
        for (var st in re.setTemplates) {
          await txn.insert('routine_set_templates', {
            'routine_exercise_id': newRoutineExerciseId,
            'set_index': re.setTemplates.indexOf(st),
            'set_type': st.setType,
            'target_reps': st.targetReps,
            'target_weight': st.targetWeight
          });
        }
      }
    });
  }

  Future<void> updatePauseTime(int routineExerciseId, int? seconds) async {
    final db = await database;
    await db.update('routine_exercises', {'pause_seconds': seconds},
        where: 'id = ?', whereArgs: [routineExerciseId]);
  }

  // --- WORKOUT LOGGING ---
  Future<WorkoutLog> startWorkout({String? routineName}) async {
    final db = await database;
    final now = DateTime.now();
    final id = await db.insert('workout_logs', {
      'routine_name': routineName,
      'start_time': now.toIso8601String(),
      'status': 'ongoing'
    });
    return WorkoutLog(
        id: id, routineName: routineName, startTime: now, status: 'ongoing');
  }

  Future<int> insertSetLog(SetLog setLog) async {
    final db = await database;

    if (setLog.id != null) {
      print("--- DEBUG: Update SetLog ID=${setLog.id} ---");
      return await db.update(
        'set_logs',
        setLog.toMap(),
        where: 'id = ?',
        whereArgs: [setLog.id],
      );
    }

    final id = await db.insert(
      'set_logs',
      setLog.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace, // <- statt ignore
    );
    print(
        "--- DEBUG: Insert SetLog (${setLog.exerciseName}, ${setLog.weightKg}kg x ${setLog.reps}) → ID=$id ---");
    return id;
  }

  Future<void> finishWorkout(int workoutLogId) async {
    final db = await database;
    await db.update('workout_logs',
        {'end_time': DateTime.now().toIso8601String(), 'status': 'completed'},
        where: 'id = ?', whereArgs: [workoutLogId]);
  }

  Future<SetLog?> getLastPerformance(String exerciseName) async {
    final db = await database;
    final maps = await db.rawQuery('''
      SELECT * FROM set_logs
      WHERE exercise_name = ? AND set_type != 'warmup' AND reps IS NOT NULL AND weight_kg IS NOT NULL
      ORDER BY id DESC LIMIT 1
    ''', [exerciseName]);
    if (maps.isNotEmpty) return SetLog.fromMap(maps.first);
    return null;
  }

  // --- WORKOUT HISTORY ---
  Future<void> deleteWorkoutLog(int logId) async {
    final db = await database;
    await db.transaction((txn) async {
      await txn
          .delete('set_logs', where: 'workout_log_id = ?', whereArgs: [logId]);
      await txn.delete('workout_logs', where: 'id = ?', whereArgs: [logId]);
    });
  }

  Future<List<WorkoutLog>> getWorkoutLogs() async {
    final db = await database;
    final maps = await db.query('workout_logs',
        where: "status = 'completed'", orderBy: 'start_time DESC');
    return maps.map((map) => WorkoutLog.fromMap(map)).toList();
  }

  Future<WorkoutLog?> getWorkoutLogById(int id) async {
    final db = await database;
    print("--- DEBUG: getWorkoutLogById gestartet für ID: $id ---");

    final logMaps =
        await db.query('workout_logs', where: 'id = ?', whereArgs: [id]);
    if (logMaps.isEmpty) {
      print("--- DEBUG: KEINEN WorkoutLog für ID $id gefunden. Breche ab.");
      return null;
    }
    print("--- DEBUG: WorkoutLog gefunden: ${logMaps.first}");

    final setMaps = await db.query('set_logs',
        where: 'workout_log_id = ?', whereArgs: [id], orderBy: 'id ASC');

    // *** DER ENTSCHEIDENDE DEBUG-PUNKT ***
    print(
        "--- DEBUG: Für workout_log_id $id wurden ${setMaps.length} Sätze in der DB gefunden.");
    if (setMaps.isNotEmpty) {
      print("--- DEBUG: Erster gefundener Satz: ${setMaps.first}");
    }

    final sets = setMaps.map((map) => SetLog.fromMap(map)).toList();

    return WorkoutLog.fromMap(logMaps.first, sets: sets);
  }

  Future<WorkoutLog?> getOngoingWorkout() async {
    final db = await database;
    final maps = await db.query('workout_logs',
        where: "status = 'ongoing'", orderBy: 'start_time DESC', limit: 1);
    if (maps.isNotEmpty) {
      return getWorkoutLogById(maps.first['id'] as int);
    }
    return null;
  }

  Future<WorkoutLog?> getLatestWorkoutLog() async {
    final db = await database;
    final maps =
        await db.query('workout_logs', orderBy: 'start_time DESC', limit: 1);
    if (maps.isNotEmpty) {
      return WorkoutLog.fromMap(maps.first);
    }
    return null;
  }

  Future<List<WorkoutLog>> getWorkoutLogsForDateRange(
      DateTime start, DateTime end) async {
    final db = await database;
    final maps = await db.query(
      'workout_logs',
      where: 'start_time >= ? AND start_time <= ?',
      whereArgs: [start.toIso8601String(), end.toIso8601String()],
      orderBy: 'start_time DESC',
    );

    List<WorkoutLog> logs = [];
    for (final map in maps) {
      final sets = await getSetLogsForWorkout(map['id'] as int);
      logs.add(WorkoutLog.fromMap(map, sets: sets));
    }
    return logs;
  }

  Future<Routine?> getRoutineByName(String name) async {
    final db = await database;
    final maps = await db.query('routines',
        where: 'name = ?', whereArgs: [name], limit: 1);
    if (maps.isNotEmpty) {
      return getRoutineById(maps.first['id'] as int);
    }
    return null;
  }

  Future<void> updateWorkoutLogDetails(
      int logId, DateTime startTime, String? notes) async {
    final db = await database;
    await db.update('workout_logs',
        {'start_time': startTime.toIso8601String(), 'notes': notes},
        where: 'id = ?', whereArgs: [logId]);
  }

  Future<void> updateSetLogs(List<SetLog> updatedSets) async {
    if (updatedSets.isEmpty) return;
    final db = await database;
    final batch = db.batch();
    for (final setLog in updatedSets) {
      batch.update('set_logs', setLog.toMap(),
          where: 'id = ?', whereArgs: [setLog.id]);
    }
    await batch.commit(noResult: true);
  }

  Future<void> deleteSetLogs(List<int> idsToDelete) async {
    if (idsToDelete.isEmpty) return;
    final db = await database;
    final batch = db.batch();
    for (final id in idsToDelete) {
      batch.delete('set_logs', where: 'id = ?', whereArgs: [id]);
    }
    await batch.commit(noResult: true);
  }

  Future<List<SetLog>> getSetLogsForWorkout(int workoutLogId) async {
    final db = await database;
    final maps = await db.query(
      'set_logs',
      where: 'workout_log_id = ?',
      whereArgs: [workoutLogId],
      orderBy: 'log_order ASC',
    );

    return maps.map((map) => SetLog.fromMap(map)).toList();
  }
// --- NEUE METHODEN FÜR BACKUP & RESTORE ---

  Future<List<Routine>> getAllRoutinesWithDetails() async {
    final routines = await getAllRoutines();
    final detailedRoutines = <Routine>[];
    for (final routine in routines) {
      // KORREKTUR 1: Prüfe auf Null, bevor die ID verwendet wird.
      if (routine.id != null) {
        final detailedRoutine =
            await getRoutineById(routine.id!); // routine.id! ist jetzt sicher
        if (detailedRoutine != null) {
          detailedRoutines.add(detailedRoutine);
        }
      }
    }
    return detailedRoutines;
  }

  Future<List<WorkoutLog>> getFullWorkoutLogs() async {
    final db = await database;
    final maps = await db.query('workout_logs', orderBy: 'start_time DESC');
    final logs = <WorkoutLog>[];
    for (final map in maps) {
      final log = await getWorkoutLogById(map['id'] as int);
      if (log != null) {
        logs.add(log);
      }
    }
    return logs;
  }

  Future<void> clearAllWorkoutData() async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('set_logs');
      await txn.delete('workout_logs');
      await txn.delete('routine_set_templates');
      await txn.delete('routine_exercises');
      await txn.delete('routines');
    });
  }

  Future<void> importWorkoutData({
    required List<Routine> routines,
    required List<WorkoutLog> workoutLogs,
  }) async {
    final db = await database;
    await db.transaction((txn) async {
      // Routinen importieren
      for (final routine in routines) {
        final newRoutineId =
            await txn.insert('routines', {'name': routine.name});
        for (final re in routine.exercises) {
          final newReId = await txn.insert('routine_exercises', {
            'routine_id': newRoutineId,
            'exercise_id': re.exercise.id,
            'exercise_order': routine.exercises.indexOf(re),
            'pause_seconds': re.pauseSeconds,
          });
          for (final st in re.setTemplates) {
            // KORREKTUR: Map erstellen und alte ID entfernen
            final stMap = st.toMap();
            stMap.remove('id');
            stMap['routine_exercise_id'] = newReId;
            stMap['set_index'] =
                re.setTemplates.indexOf(st); // Index für die Reihenfolge setzen
            await txn.insert('routine_set_templates', stMap);
          }
        }
      }

      // Workout Logs importieren
      for (final log in workoutLogs) {
        // KORREKTUR 1: Erstelle eine neue Map aus dem WorkoutLog-Objekt.
        final logMap = log.toMap();

        // KORREKTUR 2: Entferne die alte ID. Dies ist SEHR WICHTIG,
        // damit die Datenbank eine neue, eindeutige ID per AUTOINCREMENT vergeben kann.
        logMap.remove('id');

        // KORREKTUR 3: Setze den Status explizit auf 'completed'.
        // Das stellt sicher, dass importierte Workouts im Verlauf erscheinen,
        // da der Verlauf nur Einträge mit diesem Status anzeigt.
        logMap['status'] = 'completed';

        final newLogId = await txn.insert('workout_logs', logMap);

        for (final setLog in log.sets) {
          // Wiederhole den Prozess für jeden Satz (SetLog).
          final setMap = setLog.toMap();
          setMap.remove('id'); // Alte ID entfernen

          // Die workout_log_id MUSS auf die ID des GERADE ERSTELLTEN Logs zeigen.
          setMap['workout_log_id'] = newLogId;

          await txn.insert('set_logs', setMap);
        }
      }
    });
  }

  Future<List<String>> findUnknownExerciseNames() async {
    final db = await database;
    final rows = await db.rawQuery('''
    SELECT DISTINCT sl.exercise_name
    FROM set_logs sl
    LEFT JOIN exercises e
      ON e.name_de = sl.exercise_name OR e.name_en = sl.exercise_name
    WHERE e.id IS NULL
    ORDER BY sl.exercise_name COLLATE NOCASE ASC
  ''');
    return rows
        .map((r) => (r['exercise_name'] as String?) ?? '')
        .where((s) => s.isNotEmpty)
        .toList();
  }

  Future<void> applyExerciseNameMapping(Map<String, String> map) async {
    if (map.isEmpty) return;
    final db = await database;
    await db.transaction((txn) async {
      for (final e in map.entries) {
        await txn.update(
          'set_logs',
          {'exercise_name': e.value},
          where: 'exercise_name = ?',
          whereArgs: [e.key],
        );
      }
    });
  }
}


===== Datei: D:\lightweight\lib\dialogs\quantity_dialog_content.dart =====

// lib/dialogs/quantity_dialog_content.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/util/design_constants.dart';

class QuantityDialogContent extends StatefulWidget {
  final FoodItem item;
  final int? initialQuantity;
  final DateTime? initialTimestamp;
  final String? initialMealType;

  const QuantityDialogContent({
    super.key,
    required this.item,
    this.initialQuantity,
    this.initialTimestamp,
    this.initialMealType,
  });

  @override
  QuantityDialogContentState createState() => QuantityDialogContentState();
}

class QuantityDialogContentState extends State<QuantityDialogContent> {
  late final TextEditingController _textController;
  late DateTime _selectedDateTime;
  bool _countAsWater = false;
  final List<String> _mealTypes = [
    "mealtypeBreakfast",
    "mealtypeLunch",
    "mealtypeDinner",
    "mealtypeSnack"
  ];
  late String _selectedMealType;

  // Öffentliche Getter, damit von außen (über den GlobalKey) darauf zugegriffen werden kann
  String get quantityText => _textController.text;
  DateTime get selectedDateTime => _selectedDateTime;
  bool get countAsWater => _countAsWater;
  String get selectedMealType => _selectedMealType;

  @override
  void initState() {
    super.initState();
    _textController =
        TextEditingController(text: widget.initialQuantity?.toString() ?? '');
    _selectedDateTime = widget.initialTimestamp ?? DateTime.now();
    _selectedMealType = widget.initialMealType ?? "mealtypeSnack";
  }

  @override
  void dispose() {
    _textController.dispose();
    super.dispose();
  }

  Future<void> _selectDate() async {
    final DateTime? picked = await showDatePicker(
        context: context,
        initialDate: _selectedDateTime,
        firstDate: DateTime(2020),
        lastDate: DateTime.now());
    if (picked != null && picked != _selectedDateTime) {
      setState(() {
        _selectedDateTime = DateTime(picked.year, picked.month, picked.day,
            _selectedDateTime.hour, _selectedDateTime.minute);
      });
    }
  }

  Future<void> _selectTime() async {
    final TimeOfDay? picked = await showTimePicker(
        context: context,
        initialTime: TimeOfDay.fromDateTime(_selectedDateTime));
    if (picked != null) {
      setState(() {
        _selectedDateTime = DateTime(
            _selectedDateTime.year,
            _selectedDateTime.month,
            _selectedDateTime.day,
            picked.hour,
            picked.minute);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final formattedDate = DateFormat('dd.MM.yyyy').format(_selectedDateTime);
    final formattedTime = DateFormat.Hm().format(_selectedDateTime);

    String getLocalizedMealName(String key) {
      switch (key) {
        case "mealtypeBreakfast":
          return l10n.mealtypeBreakfast;
        case "mealtypeLunch":
          return l10n.mealtypeLunch;
        case "mealtypeDinner":
          return l10n.mealtypeDinner;
        case "mealtypeSnack":
          return l10n.mealtypeSnack;
        default:
          return "Snack";
      }
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        TextField(
            controller: _textController,
            keyboardType: TextInputType.number,
            decoration: InputDecoration(
                labelText: l10n.amount_in_grams, suffixText: 'g'),
            autofocus: true),
        SizedBox(height: DesignConstants.spacingL),
        DropdownButtonFormField<String>(
          initialValue: _selectedMealType,
          decoration: const InputDecoration(labelText: 'Mahlzeit'),
          items: _mealTypes.map((String key) {
            return DropdownMenuItem<String>(
              value: key,
              child: Text(getLocalizedMealName(key)),
            );
          }).toList(),
          onChanged: (String? newValue) {
            if (newValue != null) {
              setState(() {
                _selectedMealType = newValue;
              });
            }
          },
        ),
        SizedBox(height: DesignConstants.spacingL),
        Row(mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [
          InkWell(
              onTap: _selectDate,
              child: Padding(
                  padding: DesignConstants.cardMargin,
                  child: Row(children: [
                    const Icon(Icons.calendar_today, size: 20),
                    const SizedBox(width: 8),
                    Text(formattedDate, style: const TextStyle(fontSize: 16))
                  ]))),
          InkWell(
              onTap: _selectTime,
              child: Padding(
                  padding: DesignConstants.cardMargin,
                  child: Row(children: [
                    const Icon(Icons.access_time, size: 20),
                    const SizedBox(width: 8),
                    Text(formattedTime, style: const TextStyle(fontSize: 16))
                  ]))),
        ]),
        SizedBox(height: DesignConstants.spacingS),
        CheckboxListTile(
            title: Text(l10n.add_to_water_intake),
            value: _countAsWater,
            onChanged: (bool? newValue) {
              setState(() {
                _countAsWater = newValue ?? false;
              });
            },
            controlAffinity: ListTileControlAffinity.leading,
            contentPadding: EdgeInsets.zero),
      ],
    );
  }
}


===== Datei: D:\lightweight\lib\dialogs\water_dialog_content.dart =====

// lib/dialogs/water_dialog_content.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/design_constants.dart';

class WaterDialogContent extends StatefulWidget {
  const WaterDialogContent({super.key});
  @override
  WaterDialogContentState createState() => WaterDialogContentState();
}

class WaterDialogContentState extends State<WaterDialogContent> {
  late final TextEditingController _textController;
  late DateTime _selectedDateTime;
  late final l10n = AppLocalizations.of(context)!;

  String get quantityText => _textController.text;
  DateTime get selectedDateTime => _selectedDateTime;

  @override
  void initState() {
    super.initState();
    _textController = TextEditingController();
    _selectedDateTime = DateTime.now();
  }

  @override
  void dispose() {
    _textController.dispose();
    super.dispose();
  }

  Future<void> _selectDate() async {
    final DateTime? picked = await showDatePicker(
        context: context,
        initialDate: _selectedDateTime,
        firstDate: DateTime(2020),
        lastDate: DateTime.now());
    if (picked != null && picked != _selectedDateTime) {
      setState(() {
        _selectedDateTime = DateTime(picked.year, picked.month, picked.day,
            _selectedDateTime.hour, _selectedDateTime.minute);
      });
    }
  }

  Future<void> _selectTime() async {
    final TimeOfDay? picked = await showTimePicker(
        context: context,
        initialTime: TimeOfDay.fromDateTime(_selectedDateTime));
    if (picked != null) {
      setState(() {
        _selectedDateTime = DateTime(
            _selectedDateTime.year,
            _selectedDateTime.month,
            _selectedDateTime.day,
            picked.hour,
            picked.minute);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final formattedDate = DateFormat('dd.MM.yyyy').format(_selectedDateTime);
    final formattedTime = DateFormat.Hm().format(_selectedDateTime);
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        TextField(
            controller: _textController,
            keyboardType: TextInputType.number,
            decoration: InputDecoration(
                labelText: l10n.amount_in_milliliters, suffixText: 'ml'),
            autofocus: true),
        SizedBox(height: DesignConstants.spacingL),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            InkWell(
                onTap: _selectDate,
                child: Padding(
                    padding: DesignConstants.cardMargin,
                    child: Row(children: [
                      const Icon(Icons.calendar_today, size: 20),
                      const SizedBox(width: 8),
                      Text(formattedDate, style: const TextStyle(fontSize: 16))
                    ]))),
            InkWell(
                onTap: _selectTime,
                child: Padding(
                    padding: DesignConstants.cardMargin,
                    child: Row(children: [
                      const Icon(Icons.access_time, size: 20),
                      const SizedBox(width: 8),
                      Text(formattedTime, style: const TextStyle(fontSize: 16))
                    ]))),
          ],
        ),
      ],
    );
  }
}


===== Datei: D:\lightweight\lib\generated\app_localizations.dart =====

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart' as intl;

import 'app_localizations_de.dart';
import 'app_localizations_en.dart';

// ignore_for_file: type=lint

/// Callers can lookup localized strings with an instance of AppLocalizations
/// returned by `AppLocalizations.of(context)`.
///
/// Applications need to include `AppLocalizations.delegate()` in their app's
/// `localizationDelegates` list, and the locales they support in the app's
/// `supportedLocales` list. For example:
///
/// ```dart
/// import 'generated/app_localizations.dart';
///
/// return MaterialApp(
///   localizationsDelegates: AppLocalizations.localizationsDelegates,
///   supportedLocales: AppLocalizations.supportedLocales,
///   home: MyApplicationHome(),
/// );
/// ```
///
/// ## Update pubspec.yaml
///
/// Please make sure to update your pubspec.yaml to include the following
/// packages:
///
/// ```yaml
/// dependencies:
///   # Internationalization support.
///   flutter_localizations:
///     sdk: flutter
///   intl: any # Use the pinned version from flutter_localizations
///
///   # Rest of dependencies
/// ```
///
/// ## iOS Applications
///
/// iOS applications define key application metadata, including supported
/// locales, in an Info.plist file that is built into the application bundle.
/// To configure the locales supported by your app, you’ll need to edit this
/// file.
///
/// First, open your project’s ios/Runner.xcworkspace Xcode workspace file.
/// Then, in the Project Navigator, open the Info.plist file under the Runner
/// project’s Runner folder.
///
/// Next, select the Information Property List item, select Add Item from the
/// Editor menu, then select Localizations from the pop-up menu.
///
/// Select and expand the newly-created Localizations item then, for each
/// locale your application supports, add a new item and select the locale
/// you wish to add from the pop-up menu in the Value field. This list should
/// be consistent with the languages listed in the AppLocalizations.supportedLocales
/// property.
abstract class AppLocalizations {
  AppLocalizations(String locale)
      : localeName = intl.Intl.canonicalizedLocale(locale.toString());

  final String localeName;

  static AppLocalizations? of(BuildContext context) {
    return Localizations.of<AppLocalizations>(context, AppLocalizations);
  }

  static const LocalizationsDelegate<AppLocalizations> delegate =
      _AppLocalizationsDelegate();

  /// A list of this localizations delegate along with the default localizations
  /// delegates.
  ///
  /// Returns a list of localizations delegates containing this delegate along with
  /// GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate,
  /// and GlobalWidgetsLocalizations.delegate.
  ///
  /// Additional delegates can be added by appending to this list in
  /// MaterialApp. This list does not have to be used at all if a custom list
  /// of delegates is preferred or required.
  static const List<LocalizationsDelegate<dynamic>> localizationsDelegates =
      <LocalizationsDelegate<dynamic>>[
    delegate,
    GlobalMaterialLocalizations.delegate,
    GlobalCupertinoLocalizations.delegate,
    GlobalWidgetsLocalizations.delegate,
  ];

  /// A list of this localizations delegate's supported locales.
  static const List<Locale> supportedLocales = <Locale>[
    Locale('de'),
    Locale('en')
  ];

  /// No description provided for @appTitle.
  ///
  /// In en, this message translates to:
  /// **'Vita'**
  String get appTitle;

  /// No description provided for @bannerText.
  ///
  /// In en, this message translates to:
  /// **'Recommendation / Current Workout'**
  String get bannerText;

  /// No description provided for @calories.
  ///
  /// In en, this message translates to:
  /// **'Calories'**
  String get calories;

  /// No description provided for @water.
  ///
  /// In en, this message translates to:
  /// **'Water'**
  String get water;

  /// No description provided for @protein.
  ///
  /// In en, this message translates to:
  /// **'Protein'**
  String get protein;

  /// No description provided for @carbs.
  ///
  /// In en, this message translates to:
  /// **'Carbs'**
  String get carbs;

  /// No description provided for @fat.
  ///
  /// In en, this message translates to:
  /// **'Fat'**
  String get fat;

  /// No description provided for @daily.
  ///
  /// In en, this message translates to:
  /// **'Daily'**
  String get daily;

  /// No description provided for @today.
  ///
  /// In en, this message translates to:
  /// **'Today'**
  String get today;

  /// No description provided for @workoutSection.
  ///
  /// In en, this message translates to:
  /// **'Workout section - not yet implemented'**
  String get workoutSection;

  /// No description provided for @addMenuTitle.
  ///
  /// In en, this message translates to:
  /// **'What do you want to add?'**
  String get addMenuTitle;

  /// No description provided for @addFoodOption.
  ///
  /// In en, this message translates to:
  /// **'Food'**
  String get addFoodOption;

  /// No description provided for @addLiquidOption.
  ///
  /// In en, this message translates to:
  /// **'Liquid'**
  String get addLiquidOption;

  /// No description provided for @searchHintText.
  ///
  /// In en, this message translates to:
  /// **'Search...'**
  String get searchHintText;

  /// No description provided for @mealtypeBreakfast.
  ///
  /// In en, this message translates to:
  /// **'Breakfast'**
  String get mealtypeBreakfast;

  /// No description provided for @mealtypeLunch.
  ///
  /// In en, this message translates to:
  /// **'Lunch'**
  String get mealtypeLunch;

  /// No description provided for @mealtypeDinner.
  ///
  /// In en, this message translates to:
  /// **'Dinner'**
  String get mealtypeDinner;

  /// No description provided for @mealtypeSnack.
  ///
  /// In en, this message translates to:
  /// **'Snack'**
  String get mealtypeSnack;

  /// No description provided for @waterHeader.
  ///
  /// In en, this message translates to:
  /// **'Water & Drinks'**
  String get waterHeader;

  /// No description provided for @openFoodFactsSource.
  ///
  /// In en, this message translates to:
  /// **'Data from Open Food Facts'**
  String get openFoodFactsSource;

  /// No description provided for @tabRecent.
  ///
  /// In en, this message translates to:
  /// **'Recent'**
  String get tabRecent;

  /// No description provided for @tabSearch.
  ///
  /// In en, this message translates to:
  /// **'Search'**
  String get tabSearch;

  /// No description provided for @tabFavorites.
  ///
  /// In en, this message translates to:
  /// **'Favorites'**
  String get tabFavorites;

  /// No description provided for @fabCreateOwnFood.
  ///
  /// In en, this message translates to:
  /// **'Custom Food'**
  String get fabCreateOwnFood;

  /// No description provided for @recentEmptyState.
  ///
  /// In en, this message translates to:
  /// **'Your recently used food items\nwill appear here.'**
  String get recentEmptyState;

  /// No description provided for @favoritesEmptyState.
  ///
  /// In en, this message translates to:
  /// **'You don\'t have any favorites yet.\nMark a food with the heart icon to see it here.'**
  String get favoritesEmptyState;

  /// No description provided for @searchInitialHint.
  ///
  /// In en, this message translates to:
  /// **'Please enter a search term.'**
  String get searchInitialHint;

  /// No description provided for @searchNoResults.
  ///
  /// In en, this message translates to:
  /// **'No results found.'**
  String get searchNoResults;

  /// No description provided for @createFoodScreenTitle.
  ///
  /// In en, this message translates to:
  /// **'Create Custom Food'**
  String get createFoodScreenTitle;

  /// No description provided for @formFieldName.
  ///
  /// In en, this message translates to:
  /// **'Name of the food'**
  String get formFieldName;

  /// No description provided for @formFieldBrand.
  ///
  /// In en, this message translates to:
  /// **'Brand (optional)'**
  String get formFieldBrand;

  /// No description provided for @formSectionMainNutrients.
  ///
  /// In en, this message translates to:
  /// **'Main Nutrients (per 100g)'**
  String get formSectionMainNutrients;

  /// No description provided for @formFieldCalories.
  ///
  /// In en, this message translates to:
  /// **'Calories (kcal)'**
  String get formFieldCalories;

  /// No description provided for @formFieldProtein.
  ///
  /// In en, this message translates to:
  /// **'Protein (g)'**
  String get formFieldProtein;

  /// No description provided for @formFieldCarbs.
  ///
  /// In en, this message translates to:
  /// **'Carbohydrates (g)'**
  String get formFieldCarbs;

  /// No description provided for @formFieldFat.
  ///
  /// In en, this message translates to:
  /// **'Fat (g)'**
  String get formFieldFat;

  /// No description provided for @formSectionOptionalNutrients.
  ///
  /// In en, this message translates to:
  /// **'Additional Nutrients (optional, per 100g)'**
  String get formSectionOptionalNutrients;

  /// No description provided for @formFieldSugar.
  ///
  /// In en, this message translates to:
  /// **'Of which sugars (g)'**
  String get formFieldSugar;

  /// No description provided for @formFieldFiber.
  ///
  /// In en, this message translates to:
  /// **'Fiber (g)'**
  String get formFieldFiber;

  /// No description provided for @formFieldKj.
  ///
  /// In en, this message translates to:
  /// **'Kilojoules (kJ)'**
  String get formFieldKj;

  /// No description provided for @formFieldSalt.
  ///
  /// In en, this message translates to:
  /// **'Salt (g)'**
  String get formFieldSalt;

  /// No description provided for @formFieldSodium.
  ///
  /// In en, this message translates to:
  /// **'Sodium (mg)'**
  String get formFieldSodium;

  /// No description provided for @formFieldCalcium.
  ///
  /// In en, this message translates to:
  /// **'Calcium (mg)'**
  String get formFieldCalcium;

  /// No description provided for @buttonSave.
  ///
  /// In en, this message translates to:
  /// **'Save'**
  String get buttonSave;

  /// No description provided for @validatorPleaseEnterName.
  ///
  /// In en, this message translates to:
  /// **'Please enter a name.'**
  String get validatorPleaseEnterName;

  /// No description provided for @validatorPleaseEnterNumber.
  ///
  /// In en, this message translates to:
  /// **'Please enter a valid number.'**
  String get validatorPleaseEnterNumber;

  /// No description provided for @snackbarSaveSuccess.
  ///
  /// In en, this message translates to:
  /// **'{foodName} was saved successfully.'**
  String snackbarSaveSuccess(String foodName);

  /// No description provided for @foodDetailSegmentPortion.
  ///
  /// In en, this message translates to:
  /// **'Portion'**
  String get foodDetailSegmentPortion;

  /// No description provided for @foodDetailSegment100g.
  ///
  /// In en, this message translates to:
  /// **'100g'**
  String get foodDetailSegment100g;

  /// No description provided for @sugar.
  ///
  /// In en, this message translates to:
  /// **'Sugar'**
  String get sugar;

  /// No description provided for @fiber.
  ///
  /// In en, this message translates to:
  /// **'Fiber'**
  String get fiber;

  /// No description provided for @salt.
  ///
  /// In en, this message translates to:
  /// **'Salt'**
  String get salt;

  /// No description provided for @explorerScreenTitle.
  ///
  /// In en, this message translates to:
  /// **'Food Explorer'**
  String get explorerScreenTitle;

  /// No description provided for @nutritionScreenTitle.
  ///
  /// In en, this message translates to:
  /// **'Nutrition Analysis'**
  String get nutritionScreenTitle;

  /// No description provided for @entriesForDateRangeLabel.
  ///
  /// In en, this message translates to:
  /// **'Entries for'**
  String get entriesForDateRangeLabel;

  /// No description provided for @noEntriesForPeriod.
  ///
  /// In en, this message translates to:
  /// **'No entries for this period yet.'**
  String get noEntriesForPeriod;

  /// No description provided for @waterEntryTitle.
  ///
  /// In en, this message translates to:
  /// **'Water'**
  String get waterEntryTitle;

  /// No description provided for @profileScreenTitle.
  ///
  /// In en, this message translates to:
  /// **'Profile & Goals'**
  String get profileScreenTitle;

  /// No description provided for @profileDailyGoals.
  ///
  /// In en, this message translates to:
  /// **'Daily Goals'**
  String get profileDailyGoals;

  /// No description provided for @snackbarGoalsSaved.
  ///
  /// In en, this message translates to:
  /// **'Goals saved successfully!'**
  String get snackbarGoalsSaved;

  /// No description provided for @measurementsScreenTitle.
  ///
  /// In en, this message translates to:
  /// **'Measurements'**
  String get measurementsScreenTitle;

  /// No description provided for @measurementsEmptyState.
  ///
  /// In en, this message translates to:
  /// **'No measurements recorded yet.\nStart with the \'+\' button.'**
  String get measurementsEmptyState;

  /// No description provided for @addMeasurementDialogTitle.
  ///
  /// In en, this message translates to:
  /// **'Add New Measurement'**
  String get addMeasurementDialogTitle;

  /// No description provided for @formFieldMeasurementType.
  ///
  /// In en, this message translates to:
  /// **'Type of Measurement'**
  String get formFieldMeasurementType;

  /// No description provided for @formFieldMeasurementValue.
  ///
  /// In en, this message translates to:
  /// **'Value ({unit})'**
  String formFieldMeasurementValue(Object unit);

  /// No description provided for @validatorPleaseEnterValue.
  ///
  /// In en, this message translates to:
  /// **'Please enter a value'**
  String get validatorPleaseEnterValue;

  /// No description provided for @measurementWeight.
  ///
  /// In en, this message translates to:
  /// **'Body Weight'**
  String get measurementWeight;

  /// No description provided for @measurementFatPercent.
  ///
  /// In en, this message translates to:
  /// **'Body Fat'**
  String get measurementFatPercent;

  /// No description provided for @measurementNeck.
  ///
  /// In en, this message translates to:
  /// **'Neck'**
  String get measurementNeck;

  /// No description provided for @measurementShoulder.
  ///
  /// In en, this message translates to:
  /// **'Shoulder'**
  String get measurementShoulder;

  /// No description provided for @measurementChest.
  ///
  /// In en, this message translates to:
  /// **'Chest'**
  String get measurementChest;

  /// No description provided for @measurementLeftBicep.
  ///
  /// In en, this message translates to:
  /// **'Left Bicep'**
  String get measurementLeftBicep;

  /// No description provided for @measurementRightBicep.
  ///
  /// In en, this message translates to:
  /// **'Right Bicep'**
  String get measurementRightBicep;

  /// No description provided for @measurementLeftForearm.
  ///
  /// In en, this message translates to:
  /// **'Left Forearm'**
  String get measurementLeftForearm;

  /// No description provided for @measurementRightForearm.
  ///
  /// In en, this message translates to:
  /// **'Right Forearm'**
  String get measurementRightForearm;

  /// No description provided for @measurementAbdomen.
  ///
  /// In en, this message translates to:
  /// **'Abdomen'**
  String get measurementAbdomen;

  /// No description provided for @measurementWaist.
  ///
  /// In en, this message translates to:
  /// **'Waist'**
  String get measurementWaist;

  /// No description provided for @measurementHips.
  ///
  /// In en, this message translates to:
  /// **'Hips'**
  String get measurementHips;

  /// No description provided for @measurementLeftThigh.
  ///
  /// In en, this message translates to:
  /// **'Left Thigh'**
  String get measurementLeftThigh;

  /// No description provided for @measurementRightThigh.
  ///
  /// In en, this message translates to:
  /// **'Right Thigh'**
  String get measurementRightThigh;

  /// No description provided for @measurementLeftCalf.
  ///
  /// In en, this message translates to:
  /// **'Left Calf'**
  String get measurementLeftCalf;

  /// No description provided for @measurementRightCalf.
  ///
  /// In en, this message translates to:
  /// **'Right Calf'**
  String get measurementRightCalf;

  /// No description provided for @drawerMenuTitle.
  ///
  /// In en, this message translates to:
  /// **'Vita Menu'**
  String get drawerMenuTitle;

  /// No description provided for @drawerDashboard.
  ///
  /// In en, this message translates to:
  /// **'Dashboard'**
  String get drawerDashboard;

  /// No description provided for @drawerFoodExplorer.
  ///
  /// In en, this message translates to:
  /// **'Food Explorer'**
  String get drawerFoodExplorer;

  /// No description provided for @drawerDataManagement.
  ///
  /// In en, this message translates to:
  /// **'Data Backup'**
  String get drawerDataManagement;

  /// No description provided for @drawerMeasurements.
  ///
  /// In en, this message translates to:
  /// **'Measurements'**
  String get drawerMeasurements;

  /// No description provided for @dataManagementTitle.
  ///
  /// In en, this message translates to:
  /// **'Data Backup'**
  String get dataManagementTitle;

  /// No description provided for @exportCardTitle.
  ///
  /// In en, this message translates to:
  /// **'Export Data'**
  String get exportCardTitle;

  /// No description provided for @exportCardDescription.
  ///
  /// In en, this message translates to:
  /// **'Saves all your journal entries, favorites, and custom foods into a single backup file.'**
  String get exportCardDescription;

  /// No description provided for @exportCardButton.
  ///
  /// In en, this message translates to:
  /// **'Create Backup'**
  String get exportCardButton;

  /// No description provided for @importCardTitle.
  ///
  /// In en, this message translates to:
  /// **'Import Data'**
  String get importCardTitle;

  /// No description provided for @importCardDescription.
  ///
  /// In en, this message translates to:
  /// **'Restores your data from a previously created backup file. WARNING: All data currently stored in the app will be overwritten!'**
  String get importCardDescription;

  /// No description provided for @importCardButton.
  ///
  /// In en, this message translates to:
  /// **'Restore Backup'**
  String get importCardButton;

  /// No description provided for @recommendationDefault.
  ///
  /// In en, this message translates to:
  /// **'Track your first meal!'**
  String get recommendationDefault;

  /// No description provided for @recommendationOverTarget.
  ///
  /// In en, this message translates to:
  /// **'Last {count} days: +{difference} kcal over target'**
  String recommendationOverTarget(Object count, Object difference);

  /// No description provided for @recommendationUnderTarget.
  ///
  /// In en, this message translates to:
  /// **'Last {count} days: {difference} kcal under target'**
  String recommendationUnderTarget(Object count, Object difference);

  /// No description provided for @recommendationOnTarget.
  ///
  /// In en, this message translates to:
  /// **'Last {count} days: Target achieved ✅'**
  String recommendationOnTarget(Object count);

  /// No description provided for @recommendationFirstEntry.
  ///
  /// In en, this message translates to:
  /// **'Great, your first entry is logged!'**
  String get recommendationFirstEntry;

  /// No description provided for @dialogConfirmTitle.
  ///
  /// In en, this message translates to:
  /// **'Confirmation Required'**
  String get dialogConfirmTitle;

  /// No description provided for @dialogConfirmImportContent.
  ///
  /// In en, this message translates to:
  /// **'Do you really want to restore data from this backup?\n\nWARNING: All your current entries, favorites, and custom foods will be permanently deleted and replaced.'**
  String get dialogConfirmImportContent;

  /// No description provided for @dialogButtonCancel.
  ///
  /// In en, this message translates to:
  /// **'Cancel'**
  String get dialogButtonCancel;

  /// No description provided for @dialogButtonOverwrite.
  ///
  /// In en, this message translates to:
  /// **'Yes, overwrite all'**
  String get dialogButtonOverwrite;

  /// No description provided for @snackbarNoFileSelected.
  ///
  /// In en, this message translates to:
  /// **'No file selected.'**
  String get snackbarNoFileSelected;

  /// No description provided for @snackbarImportSuccessTitle.
  ///
  /// In en, this message translates to:
  /// **'Import successful!'**
  String get snackbarImportSuccessTitle;

  /// No description provided for @snackbarImportSuccessContent.
  ///
  /// In en, this message translates to:
  /// **'Your data has been restored. It is recommended to restart the app for a correct display.'**
  String get snackbarImportSuccessContent;

  /// No description provided for @snackbarButtonOK.
  ///
  /// In en, this message translates to:
  /// **'OK'**
  String get snackbarButtonOK;

  /// No description provided for @snackbarImportError.
  ///
  /// In en, this message translates to:
  /// **'Error while importing data.'**
  String get snackbarImportError;

  /// No description provided for @snackbarExportSuccess.
  ///
  /// In en, this message translates to:
  /// **'Backup file has been passed to the system. Please choose a location to save.'**
  String get snackbarExportSuccess;

  /// No description provided for @snackbarExportFailed.
  ///
  /// In en, this message translates to:
  /// **'Export canceled or failed.'**
  String get snackbarExportFailed;

  /// No description provided for @profileUserHeight.
  ///
  /// In en, this message translates to:
  /// **'Height (cm)'**
  String get profileUserHeight;

  /// No description provided for @workoutRoutinesTitle.
  ///
  /// In en, this message translates to:
  /// **'Routines'**
  String get workoutRoutinesTitle;

  /// No description provided for @workoutHistoryTitle.
  ///
  /// In en, this message translates to:
  /// **'Workout History'**
  String get workoutHistoryTitle;

  /// No description provided for @workoutHistoryButton.
  ///
  /// In en, this message translates to:
  /// **'History'**
  String get workoutHistoryButton;

  /// No description provided for @emptyRoutinesTitle.
  ///
  /// In en, this message translates to:
  /// **'No Routines Found'**
  String get emptyRoutinesTitle;

  /// No description provided for @emptyRoutinesSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Create your first routine or start a blank workout.'**
  String get emptyRoutinesSubtitle;

  /// No description provided for @createFirstRoutineButton.
  ///
  /// In en, this message translates to:
  /// **'Create First Routine'**
  String get createFirstRoutineButton;

  /// No description provided for @startEmptyWorkoutButton.
  ///
  /// In en, this message translates to:
  /// **'Free Workout'**
  String get startEmptyWorkoutButton;

  /// No description provided for @editRoutineSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Tap to edit, or start the workout.'**
  String get editRoutineSubtitle;

  /// No description provided for @startButton.
  ///
  /// In en, this message translates to:
  /// **'Start'**
  String get startButton;

  /// No description provided for @addRoutineButton.
  ///
  /// In en, this message translates to:
  /// **'New Routine'**
  String get addRoutineButton;

  /// No description provided for @freeWorkoutTitle.
  ///
  /// In en, this message translates to:
  /// **'Free Workout'**
  String get freeWorkoutTitle;

  /// No description provided for @finishWorkoutButton.
  ///
  /// In en, this message translates to:
  /// **'Finish'**
  String get finishWorkoutButton;

  /// No description provided for @addSetButton.
  ///
  /// In en, this message translates to:
  /// **'Add Set'**
  String get addSetButton;

  /// No description provided for @addExerciseToWorkoutButton.
  ///
  /// In en, this message translates to:
  /// **'Add Exercise to Workout'**
  String get addExerciseToWorkoutButton;

  /// No description provided for @lastTimeLabel.
  ///
  /// In en, this message translates to:
  /// **'Last Time'**
  String get lastTimeLabel;

  /// No description provided for @setLabel.
  ///
  /// In en, this message translates to:
  /// **'Set'**
  String get setLabel;

  /// No description provided for @kgLabel.
  ///
  /// In en, this message translates to:
  /// **'Weight (kg)'**
  String get kgLabel;

  /// No description provided for @repsLabel.
  ///
  /// In en, this message translates to:
  /// **'Reps'**
  String get repsLabel;

  /// No description provided for @restTimerLabel.
  ///
  /// In en, this message translates to:
  /// **'Rest'**
  String get restTimerLabel;

  /// No description provided for @skipButton.
  ///
  /// In en, this message translates to:
  /// **'Skip'**
  String get skipButton;

  /// No description provided for @emptyHistory.
  ///
  /// In en, this message translates to:
  /// **'No completed workouts yet.'**
  String get emptyHistory;

  /// No description provided for @workoutDetailsTitle.
  ///
  /// In en, this message translates to:
  /// **'Workout Details'**
  String get workoutDetailsTitle;

  /// No description provided for @workoutNotFound.
  ///
  /// In en, this message translates to:
  /// **'Workout not found.'**
  String get workoutNotFound;

  /// No description provided for @totalVolumeLabel.
  ///
  /// In en, this message translates to:
  /// **'Total Volume'**
  String get totalVolumeLabel;

  /// No description provided for @notesLabel.
  ///
  /// In en, this message translates to:
  /// **'Notes'**
  String get notesLabel;

  /// No description provided for @hevyImportTitle.
  ///
  /// In en, this message translates to:
  /// **'Hevy Import'**
  String get hevyImportTitle;

  /// No description provided for @hevyImportDescription.
  ///
  /// In en, this message translates to:
  /// **'Import your entire training history from a Hevy CSV export file.'**
  String get hevyImportDescription;

  /// No description provided for @hevyImportButton.
  ///
  /// In en, this message translates to:
  /// **'Import Hevy Data'**
  String get hevyImportButton;

  /// No description provided for @hevyImportSuccess.
  ///
  /// In en, this message translates to:
  /// **'Successfully imported {count} workouts!'**
  String hevyImportSuccess(Object count);

  /// No description provided for @hevyImportFailed.
  ///
  /// In en, this message translates to:
  /// **'Import failed. Please check the file.'**
  String get hevyImportFailed;

  /// No description provided for @startWorkout.
  ///
  /// In en, this message translates to:
  /// **'Start Workout'**
  String get startWorkout;

  /// No description provided for @addMeasurement.
  ///
  /// In en, this message translates to:
  /// **'Add Measurement'**
  String get addMeasurement;

  /// No description provided for @filterToday.
  ///
  /// In en, this message translates to:
  /// **'Today'**
  String get filterToday;

  /// No description provided for @filter7Days.
  ///
  /// In en, this message translates to:
  /// **'7 Days'**
  String get filter7Days;

  /// No description provided for @filter30Days.
  ///
  /// In en, this message translates to:
  /// **'30 Days'**
  String get filter30Days;

  /// No description provided for @filterAll.
  ///
  /// In en, this message translates to:
  /// **'All'**
  String get filterAll;

  /// No description provided for @showLess.
  ///
  /// In en, this message translates to:
  /// **'Show less'**
  String get showLess;

  /// No description provided for @showMoreDetails.
  ///
  /// In en, this message translates to:
  /// **'Show more details'**
  String get showMoreDetails;

  /// No description provided for @deleteConfirmTitle.
  ///
  /// In en, this message translates to:
  /// **'Confirm Deletion'**
  String get deleteConfirmTitle;

  /// No description provided for @deleteConfirmContent.
  ///
  /// In en, this message translates to:
  /// **'Do you really want to delete this entry?'**
  String get deleteConfirmContent;

  /// No description provided for @cancel.
  ///
  /// In en, this message translates to:
  /// **'Cancel'**
  String get cancel;

  /// No description provided for @delete.
  ///
  /// In en, this message translates to:
  /// **'Delete'**
  String get delete;

  /// No description provided for @save.
  ///
  /// In en, this message translates to:
  /// **'Save'**
  String get save;

  /// No description provided for @tabBaseFoods.
  ///
  /// In en, this message translates to:
  /// **'Base Foods'**
  String get tabBaseFoods;

  /// No description provided for @baseFoodsEmptyState.
  ///
  /// In en, this message translates to:
  /// **'This section will soon be filled with a curated list of base foods like fruits, vegetables, and more.'**
  String get baseFoodsEmptyState;

  /// No description provided for @noBrand.
  ///
  /// In en, this message translates to:
  /// **'No Brand'**
  String get noBrand;

  /// No description provided for @unknown.
  ///
  /// In en, this message translates to:
  /// **'Unknown'**
  String get unknown;

  /// No description provided for @backupFileSubject.
  ///
  /// In en, this message translates to:
  /// **'Vita App Backup - {timestamp}'**
  String backupFileSubject(String timestamp);

  /// No description provided for @foodItemSubtitle.
  ///
  /// In en, this message translates to:
  /// **'{brand} - {calories} kcal / 100g'**
  String foodItemSubtitle(String brand, int calories);

  /// No description provided for @foodListSubtitle.
  ///
  /// In en, this message translates to:
  /// **'{grams}g - {time}'**
  String foodListSubtitle(int grams, String time);

  /// No description provided for @foodListTrailingKcal.
  ///
  /// In en, this message translates to:
  /// **'{calories} kcal'**
  String foodListTrailingKcal(int calories);

  /// No description provided for @waterListTrailingMl.
  ///
  /// In en, this message translates to:
  /// **'{milliliters} ml'**
  String waterListTrailingMl(int milliliters);

  /// No description provided for @exerciseCatalogTitle.
  ///
  /// In en, this message translates to:
  /// **'Exercise Catalog'**
  String get exerciseCatalogTitle;

  /// No description provided for @filterByMuscle.
  ///
  /// In en, this message translates to:
  /// **'Filter by muscle group'**
  String get filterByMuscle;

  /// No description provided for @noExercisesFound.
  ///
  /// In en, this message translates to:
  /// **'No exercises found.'**
  String get noExercisesFound;

  /// No description provided for @noDescriptionAvailable.
  ///
  /// In en, this message translates to:
  /// **'No description available.'**
  String get noDescriptionAvailable;

  /// No description provided for @filterByCategory.
  ///
  /// In en, this message translates to:
  /// **'Filter by category'**
  String get filterByCategory;

  /// No description provided for @edit.
  ///
  /// In en, this message translates to:
  /// **'Edit'**
  String get edit;

  /// No description provided for @repsLabelShort.
  ///
  /// In en, this message translates to:
  /// **'reps'**
  String get repsLabelShort;

  /// No description provided for @titleNewRoutine.
  ///
  /// In en, this message translates to:
  /// **'New Routine'**
  String get titleNewRoutine;

  /// No description provided for @titleEditRoutine.
  ///
  /// In en, this message translates to:
  /// **'Edit Routine'**
  String get titleEditRoutine;

  /// No description provided for @validatorPleaseEnterRoutineName.
  ///
  /// In en, this message translates to:
  /// **'Please enter a name for the routine.'**
  String get validatorPleaseEnterRoutineName;

  /// No description provided for @snackbarRoutineCreated.
  ///
  /// In en, this message translates to:
  /// **'Routine created. Now add some exercises.'**
  String get snackbarRoutineCreated;

  /// No description provided for @snackbarRoutineSaved.
  ///
  /// In en, this message translates to:
  /// **'Routine saved.'**
  String get snackbarRoutineSaved;

  /// No description provided for @formFieldRoutineName.
  ///
  /// In en, this message translates to:
  /// **'Name of the routine'**
  String get formFieldRoutineName;

  /// No description provided for @emptyStateAddFirstExercise.
  ///
  /// In en, this message translates to:
  /// **'Add your first exercise.'**
  String get emptyStateAddFirstExercise;

  /// No description provided for @setCount.
  ///
  /// In en, this message translates to:
  /// **'{count,plural, =1{1 set}other{{count} sets}}'**
  String setCount(int count);

  /// No description provided for @fabAddExercise.
  ///
  /// In en, this message translates to:
  /// **'Add Exercise'**
  String get fabAddExercise;

  /// No description provided for @kgLabelShort.
  ///
  /// In en, this message translates to:
  /// **'kg'**
  String get kgLabelShort;

  /// No description provided for @drawerExerciseCatalog.
  ///
  /// In en, this message translates to:
  /// **'Exercise Catalog'**
  String get drawerExerciseCatalog;

  /// No description provided for @lastWorkoutTitle.
  ///
  /// In en, this message translates to:
  /// **'Last Workout'**
  String get lastWorkoutTitle;

  /// No description provided for @repeatButton.
  ///
  /// In en, this message translates to:
  /// **'Repeat'**
  String get repeatButton;

  /// No description provided for @weightHistoryTitle.
  ///
  /// In en, this message translates to:
  /// **'Weight History'**
  String get weightHistoryTitle;

  /// No description provided for @hideSummary.
  ///
  /// In en, this message translates to:
  /// **'Hide Summary'**
  String get hideSummary;

  /// No description provided for @showSummary.
  ///
  /// In en, this message translates to:
  /// **'Show Summary'**
  String get showSummary;

  /// No description provided for @exerciseDataAttribution.
  ///
  /// In en, this message translates to:
  /// **'Exercise data from'**
  String get exerciseDataAttribution;

  /// No description provided for @duplicate.
  ///
  /// In en, this message translates to:
  /// **'Duplicate'**
  String get duplicate;

  /// No description provided for @deleteRoutineConfirmContent.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to permanently delete the routine \'{routineName}\'?'**
  String deleteRoutineConfirmContent(String routineName);

  /// No description provided for @editPauseTimeTitle.
  ///
  /// In en, this message translates to:
  /// **'Edit Pause Duration'**
  String get editPauseTimeTitle;

  /// No description provided for @pauseInSeconds.
  ///
  /// In en, this message translates to:
  /// **'Pause in seconds'**
  String get pauseInSeconds;

  /// No description provided for @editPauseTime.
  ///
  /// In en, this message translates to:
  /// **'Edit Pause'**
  String get editPauseTime;

  /// No description provided for @pauseDuration.
  ///
  /// In en, this message translates to:
  /// **'{seconds} second pause'**
  String pauseDuration(int seconds);

  /// No description provided for @maxPauseDuration.
  ///
  /// In en, this message translates to:
  /// **'Pauses up to {seconds}s'**
  String maxPauseDuration(int seconds);

  /// No description provided for @deleteWorkoutConfirmContent.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to permanently delete this workout log?'**
  String get deleteWorkoutConfirmContent;

  /// No description provided for @removeExercise.
  ///
  /// In en, this message translates to:
  /// **'Remove Exercise'**
  String get removeExercise;

  /// No description provided for @deleteExerciseConfirmTitle.
  ///
  /// In en, this message translates to:
  /// **'Remove Exercise?'**
  String get deleteExerciseConfirmTitle;

  /// No description provided for @deleteExerciseConfirmContent.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to remove \'{exerciseName}\' from this routine?'**
  String deleteExerciseConfirmContent(String exerciseName);

  /// No description provided for @doneButtonLabel.
  ///
  /// In en, this message translates to:
  /// **'Done'**
  String get doneButtonLabel;

  /// No description provided for @setRestTimeButton.
  ///
  /// In en, this message translates to:
  /// **'Set rest time'**
  String get setRestTimeButton;

  /// No description provided for @deleteExerciseButton.
  ///
  /// In en, this message translates to:
  /// **'Delete exercise'**
  String get deleteExerciseButton;

  /// No description provided for @restOverLabel.
  ///
  /// In en, this message translates to:
  /// **'Pause is over'**
  String get restOverLabel;

  /// No description provided for @workoutRunningLabel.
  ///
  /// In en, this message translates to:
  /// **'Workout is active …'**
  String get workoutRunningLabel;

  /// No description provided for @continueButton.
  ///
  /// In en, this message translates to:
  /// **'Continue'**
  String get continueButton;

  /// No description provided for @discardButton.
  ///
  /// In en, this message translates to:
  /// **'Discard'**
  String get discardButton;

  /// No description provided for @workoutStatsTitle.
  ///
  /// In en, this message translates to:
  /// **'Training (7 days)'**
  String get workoutStatsTitle;

  /// No description provided for @workoutsLabel.
  ///
  /// In en, this message translates to:
  /// **'Workouts'**
  String get workoutsLabel;

  /// Label for workout duration summary
  ///
  /// In en, this message translates to:
  /// **'Duration'**
  String get durationLabel;

  /// No description provided for @volumeLabel.
  ///
  /// In en, this message translates to:
  /// **'Volume'**
  String get volumeLabel;

  /// Label for number of sets summary
  ///
  /// In en, this message translates to:
  /// **'Sets'**
  String get setsLabel;

  /// Label for muscle split bar chart
  ///
  /// In en, this message translates to:
  /// **'Muscle Split'**
  String get muscleSplitLabel;

  /// No description provided for @snackbar_could_not_open_open_link.
  ///
  /// In en, this message translates to:
  /// **'Konnte Link nicht öffnen'**
  String get snackbar_could_not_open_open_link;

  /// No description provided for @chart_no_data_for_period.
  ///
  /// In en, this message translates to:
  /// **'Keine Daten für diesen Zeitraum.'**
  String get chart_no_data_for_period;

  /// No description provided for @amount_in_milliliters.
  ///
  /// In en, this message translates to:
  /// **'Menge in Millilitern'**
  String get amount_in_milliliters;

  /// No description provided for @amount_in_grams.
  ///
  /// In en, this message translates to:
  /// **'Menge in Gramm'**
  String get amount_in_grams;

  /// No description provided for @meal_label.
  ///
  /// In en, this message translates to:
  /// **'Mahlzeit'**
  String get meal_label;

  /// No description provided for @add_to_water_intake.
  ///
  /// In en, this message translates to:
  /// **'Zur Trinkmenge hinzufügen'**
  String get add_to_water_intake;

  /// No description provided for @create_exercise_screen_title.
  ///
  /// In en, this message translates to:
  /// **'Eigene Übung erstellen'**
  String get create_exercise_screen_title;

  /// No description provided for @exercise_name_label.
  ///
  /// In en, this message translates to:
  /// **'Name der Übung'**
  String get exercise_name_label;

  /// No description provided for @category_label.
  ///
  /// In en, this message translates to:
  /// **'Kategorie'**
  String get category_label;

  /// No description provided for @description_optional_label.
  ///
  /// In en, this message translates to:
  /// **'Beschreibung (optional)'**
  String get description_optional_label;

  /// No description provided for @primary_muscles_label.
  ///
  /// In en, this message translates to:
  /// **'Primäre Muskeln'**
  String get primary_muscles_label;

  /// No description provided for @primary_muscles_hint.
  ///
  /// In en, this message translates to:
  /// **'z.B. Brust, Trizeps'**
  String get primary_muscles_hint;

  /// No description provided for @secondary_muscles_label.
  ///
  /// In en, this message translates to:
  /// **'Sekundäre Muskeln (optional)'**
  String get secondary_muscles_label;

  /// No description provided for @secondary_muscles_hint.
  ///
  /// In en, this message translates to:
  /// **'z.B. Schultern'**
  String get secondary_muscles_hint;

  /// No description provided for @set_type_normal.
  ///
  /// In en, this message translates to:
  /// **'Normal'**
  String get set_type_normal;

  /// No description provided for @set_type_warmup.
  ///
  /// In en, this message translates to:
  /// **'Warmup'**
  String get set_type_warmup;

  /// No description provided for @set_type_failure.
  ///
  /// In en, this message translates to:
  /// **'Failure'**
  String get set_type_failure;

  /// No description provided for @set_type_dropset.
  ///
  /// In en, this message translates to:
  /// **'Dropset'**
  String get set_type_dropset;

  /// No description provided for @set_reps_hint.
  ///
  /// In en, this message translates to:
  /// **'8-12'**
  String get set_reps_hint;

  /// No description provided for @data_export_button.
  ///
  /// In en, this message translates to:
  /// **'Exportieren'**
  String get data_export_button;

  /// No description provided for @data_import_button.
  ///
  /// In en, this message translates to:
  /// **'Importieren'**
  String get data_import_button;

  /// No description provided for @snackbar_button_ok.
  ///
  /// In en, this message translates to:
  /// **'OK'**
  String get snackbar_button_ok;

  /// No description provided for @measurement_session_detail_view.
  ///
  /// In en, this message translates to:
  /// **'Detailansicht der Messsession.'**
  String get measurement_session_detail_view;

  /// No description provided for @unit_grams.
  ///
  /// In en, this message translates to:
  /// **'g'**
  String get unit_grams;

  /// No description provided for @unit_kcal.
  ///
  /// In en, this message translates to:
  /// **'kcal'**
  String get unit_kcal;

  /// No description provided for @delete_profile_picture_button.
  ///
  /// In en, this message translates to:
  /// **'Profilbild löschen'**
  String get delete_profile_picture_button;

  /// No description provided for @attribution_title.
  ///
  /// In en, this message translates to:
  /// **'Attribution'**
  String get attribution_title;

  /// No description provided for @add_liquid_title.
  ///
  /// In en, this message translates to:
  /// **'Flüssigkeit hinzufügen'**
  String get add_liquid_title;

  /// No description provided for @add_button.
  ///
  /// In en, this message translates to:
  /// **'Hinzufügen'**
  String get add_button;

  /// No description provided for @discard_button.
  ///
  /// In en, this message translates to:
  /// **'Verwerfen'**
  String get discard_button;

  /// No description provided for @continue_workout_button.
  ///
  /// In en, this message translates to:
  /// **'Workout fortsetzen'**
  String get continue_workout_button;

  /// No description provided for @soon_available_snackbar.
  ///
  /// In en, this message translates to:
  /// **'Dieser Screen wird bald verfügbar sein!'**
  String get soon_available_snackbar;

  /// No description provided for @start_button.
  ///
  /// In en, this message translates to:
  /// **'Start'**
  String get start_button;

  /// No description provided for @today_overview_text.
  ///
  /// In en, this message translates to:
  /// **'TODAY IN FOCUS'**
  String get today_overview_text;

  /// No description provided for @quick_add_text.
  ///
  /// In en, this message translates to:
  /// **'QUICK ADD'**
  String get quick_add_text;

  /// No description provided for @scann_barcode_capslock.
  ///
  /// In en, this message translates to:
  /// **'Scan barcode'**
  String get scann_barcode_capslock;

  /// No description provided for @protocol_today_capslock.
  ///
  /// In en, this message translates to:
  /// **'TODAY\'S PROTOCOL'**
  String get protocol_today_capslock;

  /// No description provided for @my_plans_capslock.
  ///
  /// In en, this message translates to:
  /// **'MY PLANS'**
  String get my_plans_capslock;

  /// No description provided for @overview_capslock.
  ///
  /// In en, this message translates to:
  /// **'OVERVIEW'**
  String get overview_capslock;

  /// No description provided for @manage_all_plans.
  ///
  /// In en, this message translates to:
  /// **'Manage all plans'**
  String get manage_all_plans;

  /// No description provided for @free_training.
  ///
  /// In en, this message translates to:
  /// **'free training'**
  String get free_training;

  /// No description provided for @my_consistency.
  ///
  /// In en, this message translates to:
  /// **'MY CONSISTENCY'**
  String get my_consistency;

  /// No description provided for @calendar_currently_not_available.
  ///
  /// In en, this message translates to:
  /// **'The calendar view will be available soon.'**
  String get calendar_currently_not_available;

  /// No description provided for @in_depth_analysis.
  ///
  /// In en, this message translates to:
  /// **'IN-DEPTH ANALYSIS'**
  String get in_depth_analysis;

  /// No description provided for @body_measurements.
  ///
  /// In en, this message translates to:
  /// **'Body measurements'**
  String get body_measurements;

  /// No description provided for @measurements_description.
  ///
  /// In en, this message translates to:
  /// **'Analyze weight, body fat percentage and circumference.'**
  String get measurements_description;

  /// No description provided for @nutrition_description.
  ///
  /// In en, this message translates to:
  /// **'Evaluate macros, calories and trends.'**
  String get nutrition_description;

  /// No description provided for @training_analysis.
  ///
  /// In en, this message translates to:
  /// **'Training analysis'**
  String get training_analysis;

  /// No description provided for @training_analysis_description.
  ///
  /// In en, this message translates to:
  /// **'Track volume, strength and progression.'**
  String get training_analysis_description;

  /// No description provided for @load_dots.
  ///
  /// In en, this message translates to:
  /// **'loading...'**
  String get load_dots;

  /// No description provided for @profile_capslock.
  ///
  /// In en, this message translates to:
  /// **'PROFILE'**
  String get profile_capslock;

  /// No description provided for @settings_capslock.
  ///
  /// In en, this message translates to:
  /// **'SETTINGS'**
  String get settings_capslock;

  /// No description provided for @settingsTitle.
  ///
  /// In en, this message translates to:
  /// **'Settings'**
  String get settingsTitle;

  /// No description provided for @my_goals.
  ///
  /// In en, this message translates to:
  /// **'My goals'**
  String get my_goals;

  /// No description provided for @my_goals_description.
  ///
  /// In en, this message translates to:
  /// **'Adjust calories, macros and water.'**
  String get my_goals_description;

  /// No description provided for @backup_and_import.
  ///
  /// In en, this message translates to:
  /// **'Data backup & import'**
  String get backup_and_import;

  /// No description provided for @backup_and_import_description.
  ///
  /// In en, this message translates to:
  /// **'Create backups, restore, and import data.'**
  String get backup_and_import_description;

  /// No description provided for @about_and_legal_capslock.
  ///
  /// In en, this message translates to:
  /// **'ABOUT & LEGAL'**
  String get about_and_legal_capslock;

  /// No description provided for @attribution_and_license.
  ///
  /// In en, this message translates to:
  /// **'Attribution & Licenses'**
  String get attribution_and_license;

  /// No description provided for @data_from_off_and_wger.
  ///
  /// In en, this message translates to:
  /// **'Data from Open Food Facts and wger.'**
  String get data_from_off_and_wger;

  /// No description provided for @app_version.
  ///
  /// In en, this message translates to:
  /// **'App version'**
  String get app_version;

  /// No description provided for @all_measurements.
  ///
  /// In en, this message translates to:
  /// **'ALL MEASUREMENTS'**
  String get all_measurements;

  /// No description provided for @date_and_time_of_measurement.
  ///
  /// In en, this message translates to:
  /// **'Date & time of measurement'**
  String get date_and_time_of_measurement;

  /// Onboarding slide 1 title
  ///
  /// In en, this message translates to:
  /// **'Welcome to Lightweight'**
  String get onbWelcomeTitle;

  /// Onboarding slide 1 description
  ///
  /// In en, this message translates to:
  /// **'Let’s start by setting personal goals to guide training and nutrition.'**
  String get onbWelcomeBody;

  /// Onboarding slide 2 title
  ///
  /// In en, this message translates to:
  /// **'Track everything'**
  String get onbTrackTitle;

  /// Onboarding slide 2 description
  ///
  /// In en, this message translates to:
  /// **'Log nutrition, workouts, and measurements — all in one place.'**
  String get onbTrackBody;

  /// Onboarding slide 3 title
  ///
  /// In en, this message translates to:
  /// **'Offline-first & privacy'**
  String get onbPrivacyTitle;

  /// Onboarding slide 3 description
  ///
  /// In en, this message translates to:
  /// **'Your data stays on the device. No cloud accounts, no background sync.'**
  String get onbPrivacyBody;

  /// Onboarding final slide title
  ///
  /// In en, this message translates to:
  /// **'All set'**
  String get onbFinishTitle;

  /// Onboarding final slide description
  ///
  /// In en, this message translates to:
  /// **'You’re ready to explore the app. You can adjust settings anytime.'**
  String get onbFinishBody;

  /// Final button label to finish onboarding
  ///
  /// In en, this message translates to:
  /// **'Let’s go!'**
  String get onbFinishCta;

  /// Settings item to reopen onboarding
  ///
  /// In en, this message translates to:
  /// **'Show tutorial again'**
  String get onbShowTutorialAgain;

  /// Optional CTA linking to Goals screen from onboarding
  ///
  /// In en, this message translates to:
  /// **'Set goals'**
  String get onbSetGoalsCta;

  /// Onboarding header title
  ///
  /// In en, this message translates to:
  /// **'Tutorial'**
  String get onbHeaderTitle;

  /// Skip button label in onboarding header
  ///
  /// In en, this message translates to:
  /// **'Skip'**
  String get onbHeaderSkip;

  /// Back button in onboarding footer
  ///
  /// In en, this message translates to:
  /// **'Back'**
  String get onbBack;

  /// Next button in onboarding footer
  ///
  /// In en, this message translates to:
  /// **'Next'**
  String get onbNext;

  /// Guide banner title in onboarding
  ///
  /// In en, this message translates to:
  /// **'How this tutorial works'**
  String get onbGuideTitle;

  /// Guide banner description in onboarding
  ///
  /// In en, this message translates to:
  /// **'Swipe between slides or use Next. Tap the buttons on each slide to try features. You can finish anytime with Skip.'**
  String get onbGuideBody;

  /// CTA to open nutrition tracking from onboarding
  ///
  /// In en, this message translates to:
  /// **'Open nutrition'**
  String get onbCtaOpenNutrition;

  /// CTA to learn more about privacy/offline
  ///
  /// In en, this message translates to:
  /// **'Learn more'**
  String get onbCtaLearnMore;

  /// Badge label shown after completing CTA
  ///
  /// In en, this message translates to:
  /// **'Done'**
  String get onbBadgeDone;

  /// Hint text on goals slide
  ///
  /// In en, this message translates to:
  /// **'Tip: adjust targets first'**
  String get onbTipSetGoals;

  /// Hint text on nutrition slide
  ///
  /// In en, this message translates to:
  /// **'Tip: add one entry today'**
  String get onbTipAddEntry;

  /// Hint on privacy slide about local data control
  ///
  /// In en, this message translates to:
  /// **'You control all data locally'**
  String get onbTipLocalControl;

  /// Onboarding slide 2 replacement body: step-by-step nutrition logging instructions
  ///
  /// In en, this message translates to:
  /// **'How to log nutrition:\n• Open the Food tab.\n• Tap the + button.\n• Search products or scan a barcode.\n• Adjust portion and time.\n• Save to your diary.'**
  String get onbTrackHowBody;

  /// Onboarding slide title for measurements
  ///
  /// In en, this message translates to:
  /// **'Track measurements'**
  String get onbMeasureTitle;

  /// Step-by-step instructions for adding measurements
  ///
  /// In en, this message translates to:
  /// **'How to add measurements:\n• Open the Stats tab.\n• Tap the + button.\n• Choose a metric (e.g., weight, waist, body fat).\n• Enter value and time.\n• Save to your history.'**
  String get onbMeasureBody;

  /// Hint for measurements slide
  ///
  /// In en, this message translates to:
  /// **'Tip: add today’s weight to start your graph'**
  String get onbTipMeasureToday;

  /// Onboarding slide title for training routines
  ///
  /// In en, this message translates to:
  /// **'Train with routines'**
  String get onbTrainTitle;

  /// Instructions for creating a routine and starting a workout
  ///
  /// In en, this message translates to:
  /// **'Create a routine and start a workout:\n• Open the Train tab.\n• Tap Create routine to add exercises and sets.\n• Save the routine.\n• Tap Start to begin, or use “Start empty workout”.'**
  String get onbTrainBody;

  /// Hint for training slide
  ///
  /// In en, this message translates to:
  /// **'Tip: start an empty workout to log a quick session'**
  String get onbTipStartWorkout;

  /// No description provided for @unitsSection.
  ///
  /// In en, this message translates to:
  /// **'units'**
  String get unitsSection;

  /// No description provided for @weightUnit.
  ///
  /// In en, this message translates to:
  /// **'Weight units'**
  String get weightUnit;

  /// No description provided for @lengthUnit.
  ///
  /// In en, this message translates to:
  /// **'unit of length'**
  String get lengthUnit;
}

class _AppLocalizationsDelegate
    extends LocalizationsDelegate<AppLocalizations> {
  const _AppLocalizationsDelegate();

  @override
  Future<AppLocalizations> load(Locale locale) {
    return SynchronousFuture<AppLocalizations>(lookupAppLocalizations(locale));
  }

  @override
  bool isSupported(Locale locale) =>
      <String>['de', 'en'].contains(locale.languageCode);

  @override
  bool shouldReload(_AppLocalizationsDelegate old) => false;
}

AppLocalizations lookupAppLocalizations(Locale locale) {
  // Lookup logic when only language code is specified.
  switch (locale.languageCode) {
    case 'de':
      return AppLocalizationsDe();
    case 'en':
      return AppLocalizationsEn();
  }

  throw FlutterError(
      'AppLocalizations.delegate failed to load unsupported locale "$locale". This is likely '
      'an issue with the localizations generation tool. Please file an issue '
      'on GitHub with a reproducible sample app and the gen-l10n configuration '
      'that was used.');
}


===== Datei: D:\lightweight\lib\generated\app_localizations_de.dart =====

// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for German (`de`).
class AppLocalizationsDe extends AppLocalizations {
  AppLocalizationsDe([String locale = 'de']) : super(locale);

  @override
  String get appTitle => 'Vita';

  @override
  String get bannerText => 'Empfehlung / Aktuelles Workout';

  @override
  String get calories => 'Kalorien';

  @override
  String get water => 'Wasser';

  @override
  String get protein => 'Protein';

  @override
  String get carbs => 'Kohlenhydrate';

  @override
  String get fat => 'Fett';

  @override
  String get daily => 'Täglich';

  @override
  String get today => 'Heute';

  @override
  String get workoutSection => 'Workout-Bereich - noch nicht implementiert';

  @override
  String get addMenuTitle => 'Was möchtest du hinzufügen?';

  @override
  String get addFoodOption => 'Lebensmittel';

  @override
  String get addLiquidOption => 'Flüssigkeit';

  @override
  String get searchHintText => 'Suchen...';

  @override
  String get mealtypeBreakfast => 'Frühstück';

  @override
  String get mealtypeLunch => 'Mittagessen';

  @override
  String get mealtypeDinner => 'Abendessen';

  @override
  String get mealtypeSnack => 'Snack';

  @override
  String get waterHeader => 'Wasser & Getränke';

  @override
  String get openFoodFactsSource => 'Daten von Open Food Facts';

  @override
  String get tabRecent => 'Zuletzt';

  @override
  String get tabSearch => 'Suchen';

  @override
  String get tabFavorites => 'Favoriten';

  @override
  String get fabCreateOwnFood => 'Eigenes Lebensmittel';

  @override
  String get recentEmptyState =>
      'Deine zuletzt verwendeten Lebensmittel\nerscheinen hier.';

  @override
  String get favoritesEmptyState =>
      'Du hast noch keine Favoriten.\nMarkiere ein Lebensmittel mit dem Herz-Icon, um es hier zu sehen.';

  @override
  String get searchInitialHint => 'Bitte gib einen Suchbegriff ein.';

  @override
  String get searchNoResults => 'Keine Ergebnisse gefunden.';

  @override
  String get createFoodScreenTitle => 'Eigenes Lebensmittel erstellen';

  @override
  String get formFieldName => 'Name des Lebensmittels';

  @override
  String get formFieldBrand => 'Marke (optional)';

  @override
  String get formSectionMainNutrients => 'Haupt-Nährwerte (pro 100g)';

  @override
  String get formFieldCalories => 'Kalorien (kcal)';

  @override
  String get formFieldProtein => 'Protein (g)';

  @override
  String get formFieldCarbs => 'Kohlenhydrate (g)';

  @override
  String get formFieldFat => 'Fett (g)';

  @override
  String get formSectionOptionalNutrients =>
      'Weitere Nährwerte (optional, pro 100g)';

  @override
  String get formFieldSugar => 'Davon Zucker (g)';

  @override
  String get formFieldFiber => 'Ballaststoffe (g)';

  @override
  String get formFieldKj => 'Kilojoule (kJ)';

  @override
  String get formFieldSalt => 'Salz (g)';

  @override
  String get formFieldSodium => 'Natrium (mg)';

  @override
  String get formFieldCalcium => 'Kalzium (mg)';

  @override
  String get buttonSave => 'Speichern';

  @override
  String get validatorPleaseEnterName => 'Bitte gib einen Namen ein.';

  @override
  String get validatorPleaseEnterNumber => 'Bitte gib eine gültige Zahl ein.';

  @override
  String snackbarSaveSuccess(String foodName) {
    return '$foodName wurde erfolgreich gespeichert.';
  }

  @override
  String get foodDetailSegmentPortion => 'Portion';

  @override
  String get foodDetailSegment100g => '100g';

  @override
  String get sugar => 'Zucker';

  @override
  String get fiber => 'Ballaststoffe';

  @override
  String get salt => 'Salz';

  @override
  String get explorerScreenTitle => 'Lebensmittel-Explorer';

  @override
  String get nutritionScreenTitle => 'Ernährungsanalyse';

  @override
  String get entriesForDateRangeLabel => 'Einträge für';

  @override
  String get noEntriesForPeriod => 'Noch keine Einträge für diesen Zeitraum.';

  @override
  String get waterEntryTitle => 'Wasser';

  @override
  String get profileScreenTitle => 'Profil & Ziele';

  @override
  String get profileDailyGoals => 'Tägliche Ziele';

  @override
  String get snackbarGoalsSaved => 'Ziele erfolgreich gespeichert!';

  @override
  String get measurementsScreenTitle => 'Messwerte';

  @override
  String get measurementsEmptyState =>
      'Noch keine Messwerte erfasst.\nBeginne mit dem \'+\' Button.';

  @override
  String get addMeasurementDialogTitle => 'Neuen Messwert hinzufügen';

  @override
  String get formFieldMeasurementType => 'Art der Messung';

  @override
  String formFieldMeasurementValue(Object unit) {
    return 'Wert ($unit)';
  }

  @override
  String get validatorPleaseEnterValue => 'Bitte Wert eingeben';

  @override
  String get measurementWeight => 'Körpergewicht';

  @override
  String get measurementFatPercent => 'Körperfett';

  @override
  String get measurementNeck => 'Nacken';

  @override
  String get measurementShoulder => 'Schulter';

  @override
  String get measurementChest => 'Brust';

  @override
  String get measurementLeftBicep => 'Linker Bizeps';

  @override
  String get measurementRightBicep => 'Rechter Bizeps';

  @override
  String get measurementLeftForearm => 'Linker Unterarm';

  @override
  String get measurementRightForearm => 'Rechter Unterarm';

  @override
  String get measurementAbdomen => 'Bauch';

  @override
  String get measurementWaist => 'Taille';

  @override
  String get measurementHips => 'Hüfte';

  @override
  String get measurementLeftThigh => 'Linker Oberschenkel';

  @override
  String get measurementRightThigh => 'Rechter Oberschenkel';

  @override
  String get measurementLeftCalf => 'Linke Wade';

  @override
  String get measurementRightCalf => 'Rechte Wade';

  @override
  String get drawerMenuTitle => 'Vita Menü';

  @override
  String get drawerDashboard => 'Dashboard';

  @override
  String get drawerFoodExplorer => 'Lebensmittel-Explorer';

  @override
  String get drawerDataManagement => 'Datensicherung';

  @override
  String get drawerMeasurements => 'Messwerte';

  @override
  String get dataManagementTitle => 'Datensicherung';

  @override
  String get exportCardTitle => 'Daten exportieren';

  @override
  String get exportCardDescription =>
      'Sichert alle deine Tagebucheinträge, Favoriten und eigenen Lebensmittel in einer einzigen Backup-Datei.';

  @override
  String get exportCardButton => 'Backup erstellen';

  @override
  String get importCardTitle => 'Daten importieren';

  @override
  String get importCardDescription =>
      'Stellt deine Daten aus einer zuvor erstellten Backup-Datei wieder her. ACHTUNG: Alle aktuell in der App gespeicherten Daten werden dabei überschrieben!';

  @override
  String get importCardButton => 'Backup wiederherstellen';

  @override
  String get recommendationDefault => 'Tracke deine erste Mahlzeit!';

  @override
  String recommendationOverTarget(Object count, Object difference) {
    return 'Letzte $count Tage: +$difference kcal über dem Ziel';
  }

  @override
  String recommendationUnderTarget(Object count, Object difference) {
    return 'Letzte $count Tage: $difference kcal unter dem Ziel';
  }

  @override
  String recommendationOnTarget(Object count) {
    return 'Letzte $count Tage: Ziel erreicht ✅';
  }

  @override
  String get recommendationFirstEntry =>
      'Super, dein erster Eintrag ist gemacht!';

  @override
  String get dialogConfirmTitle => 'Bestätigung erforderlich';

  @override
  String get dialogConfirmImportContent =>
      'Möchtest du wirklich die Daten aus diesem Backup wiederherstellen?\n\nACHTUNG: Alle deine aktuellen Einträge, Favoriten und eigenen Lebensmittel werden unwiderruflich gelöscht und ersetzt.';

  @override
  String get dialogButtonCancel => 'Abbrechen';

  @override
  String get dialogButtonOverwrite => 'Ja, alles überschreiben';

  @override
  String get snackbarNoFileSelected => 'Keine Datei ausgewählt.';

  @override
  String get snackbarImportSuccessTitle => 'Import erfolgreich!';

  @override
  String get snackbarImportSuccessContent =>
      'Deine Daten wurden wiederhergestellt. Für eine korrekte Anzeige wird empfohlen, die App jetzt neu zu starten.';

  @override
  String get snackbarButtonOK => 'OK';

  @override
  String get snackbarImportError => 'Fehler beim Importieren der Daten.';

  @override
  String get snackbarExportSuccess =>
      'Backup-Datei wurde an das System übergeben. Bitte wähle einen Speicherort.';

  @override
  String get snackbarExportFailed => 'Export abgebrochen oder fehlgeschlagen.';

  @override
  String get profileUserHeight => 'Körpergröße (cm)';

  @override
  String get workoutRoutinesTitle => 'Trainingspläne';

  @override
  String get workoutHistoryTitle => 'Workout-Verlauf';

  @override
  String get workoutHistoryButton => 'Verlauf';

  @override
  String get emptyRoutinesTitle => 'Keine Trainingspläne gefunden';

  @override
  String get emptyRoutinesSubtitle =>
      'Erstelle deinen ersten Trainingsplan oder starte ein freies Training.';

  @override
  String get createFirstRoutineButton => 'Ersten Plan erstellen';

  @override
  String get startEmptyWorkoutButton => 'Freies Training';

  @override
  String get editRoutineSubtitle =>
      'Tippen zum Bearbeiten, oder starte das Training.';

  @override
  String get startButton => 'Start';

  @override
  String get addRoutineButton => 'Neue Routine';

  @override
  String get freeWorkoutTitle => 'Freies Training';

  @override
  String get finishWorkoutButton => 'Beenden';

  @override
  String get addSetButton => 'Satz hinzufügen';

  @override
  String get addExerciseToWorkoutButton => 'Übung zum Workout hinzufügen';

  @override
  String get lastTimeLabel => 'Letztes Mal';

  @override
  String get setLabel => 'Satz';

  @override
  String get kgLabel => 'Gewicht (kg)';

  @override
  String get repsLabel => 'Wdh';

  @override
  String get restTimerLabel => 'Pause';

  @override
  String get skipButton => 'Überspringen';

  @override
  String get emptyHistory => 'Noch keine Workouts abgeschlossen.';

  @override
  String get workoutDetailsTitle => 'Workout-Details';

  @override
  String get workoutNotFound => 'Workout nicht gefunden.';

  @override
  String get totalVolumeLabel => 'Gesamtvolumen';

  @override
  String get notesLabel => 'Notizen';

  @override
  String get hevyImportTitle => 'Hevy Import';

  @override
  String get hevyImportDescription =>
      'Importiere deine gesamte Trainings-Historie aus einer Hevy CSV-Exportdatei.';

  @override
  String get hevyImportButton => 'Hevy-Daten importieren';

  @override
  String hevyImportSuccess(Object count) {
    return '$count Workouts erfolgreich importiert!';
  }

  @override
  String get hevyImportFailed =>
      'Import fehlgeschlagen. Bitte überprüfe die Datei.';

  @override
  String get startWorkout => 'Workout starten';

  @override
  String get addMeasurement => 'Messwert hinzufügen';

  @override
  String get filterToday => 'Heute';

  @override
  String get filter7Days => '7 Tage';

  @override
  String get filter30Days => '30 Tage';

  @override
  String get filterAll => 'Alle';

  @override
  String get showLess => 'Weniger anzeigen';

  @override
  String get showMoreDetails => 'Mehr Details anzeigen';

  @override
  String get deleteConfirmTitle => 'Löschen bestätigen';

  @override
  String get deleteConfirmContent =>
      'Möchtest du diesen Eintrag wirklich löschen?';

  @override
  String get cancel => 'Abbrechen';

  @override
  String get delete => 'Löschen';

  @override
  String get save => 'Speichern';

  @override
  String get tabBaseFoods => 'Grundnahrungsmittel';

  @override
  String get baseFoodsEmptyState =>
      'Dieser Bereich wird bald mit einer kuratierten Liste von Grundnahrungsmitteln wie Obst, Gemüse und mehr gefüllt sein.';

  @override
  String get noBrand => 'Keine Marke';

  @override
  String get unknown => 'Unbekannt';

  @override
  String backupFileSubject(String timestamp) {
    return 'Vita App Backup - $timestamp';
  }

  @override
  String foodItemSubtitle(String brand, int calories) {
    return '$brand - $calories kcal / 100g';
  }

  @override
  String foodListSubtitle(int grams, String time) {
    return '${grams}g - $time';
  }

  @override
  String foodListTrailingKcal(int calories) {
    return '$calories kcal';
  }

  @override
  String waterListTrailingMl(int milliliters) {
    return '$milliliters ml';
  }

  @override
  String get exerciseCatalogTitle => 'Übungskatalog';

  @override
  String get filterByMuscle => 'Nach Muskelgruppe filtern';

  @override
  String get noExercisesFound => 'Keine Übungen gefunden.';

  @override
  String get noDescriptionAvailable => 'Keine Beschreibung verfügbar.';

  @override
  String get filterByCategory => 'Nach Kategorie filtern';

  @override
  String get edit => 'Bearbeiten';

  @override
  String get repsLabelShort => 'Wdh';

  @override
  String get titleNewRoutine => 'Neue Routine';

  @override
  String get titleEditRoutine => 'Routine bearbeiten';

  @override
  String get validatorPleaseEnterRoutineName =>
      'Bitte gib der Routine einen Namen.';

  @override
  String get snackbarRoutineCreated =>
      'Routine erstellt. Füge nun Übungen hinzu.';

  @override
  String get snackbarRoutineSaved => 'Routine gespeichert.';

  @override
  String get formFieldRoutineName => 'Name der Routine';

  @override
  String get emptyStateAddFirstExercise => 'Füge deine erste Übung hinzu.';

  @override
  String setCount(int count) {
    String _temp0 = intl.Intl.pluralLogic(
      count,
      locale: localeName,
      other: '$count Sätze',
      one: '1 Satz',
    );
    return '$_temp0';
  }

  @override
  String get fabAddExercise => 'Übung hinzufügen';

  @override
  String get kgLabelShort => 'kg';

  @override
  String get drawerExerciseCatalog => 'Übungskatalog';

  @override
  String get lastWorkoutTitle => 'Letztes Workout';

  @override
  String get repeatButton => 'Wiederholen';

  @override
  String get weightHistoryTitle => 'Gewichtsverlauf';

  @override
  String get hideSummary => 'Übersicht ausblenden';

  @override
  String get showSummary => 'Übersicht einblenden';

  @override
  String get exerciseDataAttribution => 'Übungsdaten von';

  @override
  String get duplicate => 'Duplizieren';

  @override
  String deleteRoutineConfirmContent(String routineName) {
    return 'Möchtest du den Trainingsplan \'$routineName\' wirklich unwiderruflich löschen?';
  }

  @override
  String get editPauseTimeTitle => 'Pausendauer bearbeiten';

  @override
  String get pauseInSeconds => 'Pause in Sekunden';

  @override
  String get editPauseTime => 'Pause bearbeiten';

  @override
  String pauseDuration(int seconds) {
    return '$seconds Sekunden Pause';
  }

  @override
  String maxPauseDuration(int seconds) {
    return 'Pausen bis zu ${seconds}s';
  }

  @override
  String get deleteWorkoutConfirmContent =>
      'Möchtest du dieses protokollierte Workout wirklich unwiderruflich löschen?';

  @override
  String get removeExercise => 'Übung entfernen';

  @override
  String get deleteExerciseConfirmTitle => 'Übung entfernen?';

  @override
  String deleteExerciseConfirmContent(String exerciseName) {
    return 'Möchtest du \'$exerciseName\' wirklich aus diesem Trainingsplan entfernen?';
  }

  @override
  String get doneButtonLabel => 'Fertig';

  @override
  String get setRestTimeButton => 'Pause einstellen';

  @override
  String get deleteExerciseButton => 'Übung löschen';

  @override
  String get restOverLabel => 'Pause vorbei';

  @override
  String get workoutRunningLabel => 'Workout läuft …';

  @override
  String get continueButton => 'Weiter';

  @override
  String get discardButton => 'Verwerfen';

  @override
  String get workoutStatsTitle => 'Training (7 Tage)';

  @override
  String get workoutsLabel => 'Workouts';

  @override
  String get durationLabel => 'Dauer';

  @override
  String get volumeLabel => 'Volumen';

  @override
  String get setsLabel => 'Sätze';

  @override
  String get muscleSplitLabel => 'Muskel-Split';

  @override
  String get snackbar_could_not_open_open_link => 'Konnte Link nicht öffnen';

  @override
  String get chart_no_data_for_period => 'Keine Daten für diesen Zeitraum.';

  @override
  String get amount_in_milliliters => 'Menge in Millilitern';

  @override
  String get amount_in_grams => 'Menge in Gramm';

  @override
  String get meal_label => 'Mahlzeit';

  @override
  String get add_to_water_intake => 'Zur Trinkmenge hinzufügen';

  @override
  String get create_exercise_screen_title => 'Eigene Übung erstellen';

  @override
  String get exercise_name_label => 'Name der Übung';

  @override
  String get category_label => 'Kategorie';

  @override
  String get description_optional_label => 'Beschreibung (optional)';

  @override
  String get primary_muscles_label => 'Primäre Muskeln';

  @override
  String get primary_muscles_hint => 'z.B. Brust, Trizeps';

  @override
  String get secondary_muscles_label => 'Sekundäre Muskeln (optional)';

  @override
  String get secondary_muscles_hint => 'z.B. Schultern';

  @override
  String get set_type_normal => 'Normal';

  @override
  String get set_type_warmup => 'Warmup';

  @override
  String get set_type_failure => 'Failure';

  @override
  String get set_type_dropset => 'Dropset';

  @override
  String get set_reps_hint => '8-12';

  @override
  String get data_export_button => 'Exportieren';

  @override
  String get data_import_button => 'Importieren';

  @override
  String get snackbar_button_ok => 'OK';

  @override
  String get measurement_session_detail_view =>
      'Detailansicht der Messsession.';

  @override
  String get unit_grams => 'g';

  @override
  String get unit_kcal => 'kcal';

  @override
  String get delete_profile_picture_button => 'Profilbild löschen';

  @override
  String get attribution_title => 'Attribution';

  @override
  String get add_liquid_title => 'Flüssigkeit hinzufügen';

  @override
  String get add_button => 'Hinzufügen';

  @override
  String get discard_button => 'Verwerfen';

  @override
  String get continue_workout_button => 'Workout fortsetzen';

  @override
  String get soon_available_snackbar =>
      'Dieser Screen wird bald verfügbar sein!';

  @override
  String get start_button => 'Start';

  @override
  String get today_overview_text => 'HEUTE IM BLICK';

  @override
  String get quick_add_text => 'SCHNELLES HINZUFÜGEN';

  @override
  String get scann_barcode_capslock => 'Barcode scannen';

  @override
  String get protocol_today_capslock => 'HEUTIGES PROTOKOLL';

  @override
  String get my_plans_capslock => 'MEINE PLÄNE';

  @override
  String get overview_capslock => 'ÜBERBLICK';

  @override
  String get manage_all_plans => 'Alle Pläne verwalten';

  @override
  String get free_training => 'Freies Training';

  @override
  String get my_consistency => 'MEINE KONSISTENZ';

  @override
  String get calendar_currently_not_available =>
      'Die Kalender-Ansicht ist in Kürze verfügbar.';

  @override
  String get in_depth_analysis => 'TIEFEN-ANALYSE';

  @override
  String get body_measurements => 'Körpermaße';

  @override
  String get measurements_description =>
      'Gewicht, KFA und Umfänge analysieren.';

  @override
  String get nutrition_description => 'Makros, Kalorien und Trends auswerten.';

  @override
  String get training_analysis => 'Trainings-Analyse';

  @override
  String get training_analysis_description =>
      'Volumen, Kraft und Progression verfolgen.';

  @override
  String get load_dots => 'lade...';

  @override
  String get profile_capslock => 'PROFIL';

  @override
  String get settings_capslock => 'EINSTELLUNGEN';

  @override
  String get settingsTitle => 'Einstellungen';

  @override
  String get my_goals => 'Meine Ziele';

  @override
  String get my_goals_description => 'Kalorien, Makros und Wasser anpassen.';

  @override
  String get backup_and_import => 'Datensicherung & Import';

  @override
  String get backup_and_import_description =>
      'Backups erstellen, wiederherstellen und Daten importieren.';

  @override
  String get about_and_legal_capslock => 'ÜBER & RECHTLICHES';

  @override
  String get attribution_and_license => 'Attribution & Lizenzen';

  @override
  String get data_from_off_and_wger => 'Daten von Open Food Facts und wger.';

  @override
  String get app_version => 'App Version';

  @override
  String get all_measurements => 'ALLE MESSWERTE';

  @override
  String get date_and_time_of_measurement => 'Datum & Uhrzeit der Messung';

  @override
  String get onbWelcomeTitle => 'Willkommen bei Lightweight';

  @override
  String get onbWelcomeBody =>
      'Starte mit deinen persönlichen Zielen für Training und Ernährung.';

  @override
  String get onbTrackTitle => 'Alles tracken';

  @override
  String get onbTrackBody =>
      'Erfasse Ernährung, Workouts und Messwerte — alles an einem Ort.';

  @override
  String get onbPrivacyTitle => 'Offline-first & Privatsphäre';

  @override
  String get onbPrivacyBody =>
      'Deine Daten bleiben auf dem Gerät. Keine Cloud-Konten, kein Hintergrund-Sync.';

  @override
  String get onbFinishTitle => 'Alles bereit';

  @override
  String get onbFinishBody =>
      'Du kannst loslegen. Einstellungen lassen sich jederzeit anpassen.';

  @override
  String get onbFinishCta => 'Los geht’s!';

  @override
  String get onbShowTutorialAgain => 'Tutorial erneut anzeigen';

  @override
  String get onbSetGoalsCta => 'Ziele festlegen';

  @override
  String get onbHeaderTitle => 'Tutorial';

  @override
  String get onbHeaderSkip => 'Überspringen';

  @override
  String get onbBack => 'Zurück';

  @override
  String get onbNext => 'Weiter';

  @override
  String get onbGuideTitle => 'So funktioniert das Tutorial';

  @override
  String get onbGuideBody =>
      'Wische zwischen den Folien oder nutze Weiter. Tippe die Buttons auf jeder Folie, um Funktionen auszuprobieren. Du kannst jederzeit über Überspringen beenden.';

  @override
  String get onbCtaOpenNutrition => 'Ernährung öffnen';

  @override
  String get onbCtaLearnMore => 'Mehr erfahren';

  @override
  String get onbBadgeDone => 'Erledigt';

  @override
  String get onbTipSetGoals => 'Tipp: Lege zuerst deine Ziele fest';

  @override
  String get onbTipAddEntry => 'Tipp: Füge heute einen Eintrag hinzu';

  @override
  String get onbTipLocalControl => 'Du kontrollierst alle Daten lokal';

  @override
  String get onbTrackHowBody =>
      'So erfasst du Ernährung:\n• Öffne den Tab „Food“.\n• Tippe auf das + Symbol.\n• Suche Produkte oder scanne einen Barcode.\n• Passe Portion und Uhrzeit an.\n• Speichere in deinem Tagebuch.';

  @override
  String get onbMeasureTitle => 'Messwerte erfassen';

  @override
  String get onbMeasureBody =>
      'So fügst du Messungen hinzu:\n• Öffne den Tab „Stats“.\n• Tippe auf das + Symbol.\n• Wähle eine Messgröße (z. B. Gewicht, Taille, KFA).\n• Gib Wert und Uhrzeit ein.\n• Speichere deinen Eintrag.';

  @override
  String get onbTipMeasureToday =>
      'Tipp: Trage dein heutiges Gewicht ein, um den Graphen zu starten';

  @override
  String get onbTrainTitle => 'Trainieren mit Routinen';

  @override
  String get onbTrainBody =>
      'Routine erstellen und Workout starten:\n• Öffne den Tab „Train“.\n• Tippe auf Routine erstellen und füge Übungen und Sätze hinzu.\n• Speichere die Routine.\n• Tippe auf Start, um zu beginnen – oder nutze „Freies Training starten“.';

  @override
  String get onbTipStartWorkout =>
      'Tipp: Starte ein freies Training für eine schnelle Einheit';

  @override
  String get unitsSection => 'Einheiten';

  @override
  String get weightUnit => 'Gewichtseinheit';

  @override
  String get lengthUnit => 'Längeneinheit';
}


===== Datei: D:\lightweight\lib\generated\app_localizations_en.dart =====

// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for English (`en`).
class AppLocalizationsEn extends AppLocalizations {
  AppLocalizationsEn([String locale = 'en']) : super(locale);

  @override
  String get appTitle => 'Vita';

  @override
  String get bannerText => 'Recommendation / Current Workout';

  @override
  String get calories => 'Calories';

  @override
  String get water => 'Water';

  @override
  String get protein => 'Protein';

  @override
  String get carbs => 'Carbs';

  @override
  String get fat => 'Fat';

  @override
  String get daily => 'Daily';

  @override
  String get today => 'Today';

  @override
  String get workoutSection => 'Workout section - not yet implemented';

  @override
  String get addMenuTitle => 'What do you want to add?';

  @override
  String get addFoodOption => 'Food';

  @override
  String get addLiquidOption => 'Liquid';

  @override
  String get searchHintText => 'Search...';

  @override
  String get mealtypeBreakfast => 'Breakfast';

  @override
  String get mealtypeLunch => 'Lunch';

  @override
  String get mealtypeDinner => 'Dinner';

  @override
  String get mealtypeSnack => 'Snack';

  @override
  String get waterHeader => 'Water & Drinks';

  @override
  String get openFoodFactsSource => 'Data from Open Food Facts';

  @override
  String get tabRecent => 'Recent';

  @override
  String get tabSearch => 'Search';

  @override
  String get tabFavorites => 'Favorites';

  @override
  String get fabCreateOwnFood => 'Custom Food';

  @override
  String get recentEmptyState =>
      'Your recently used food items\nwill appear here.';

  @override
  String get favoritesEmptyState =>
      'You don\'t have any favorites yet.\nMark a food with the heart icon to see it here.';

  @override
  String get searchInitialHint => 'Please enter a search term.';

  @override
  String get searchNoResults => 'No results found.';

  @override
  String get createFoodScreenTitle => 'Create Custom Food';

  @override
  String get formFieldName => 'Name of the food';

  @override
  String get formFieldBrand => 'Brand (optional)';

  @override
  String get formSectionMainNutrients => 'Main Nutrients (per 100g)';

  @override
  String get formFieldCalories => 'Calories (kcal)';

  @override
  String get formFieldProtein => 'Protein (g)';

  @override
  String get formFieldCarbs => 'Carbohydrates (g)';

  @override
  String get formFieldFat => 'Fat (g)';

  @override
  String get formSectionOptionalNutrients =>
      'Additional Nutrients (optional, per 100g)';

  @override
  String get formFieldSugar => 'Of which sugars (g)';

  @override
  String get formFieldFiber => 'Fiber (g)';

  @override
  String get formFieldKj => 'Kilojoules (kJ)';

  @override
  String get formFieldSalt => 'Salt (g)';

  @override
  String get formFieldSodium => 'Sodium (mg)';

  @override
  String get formFieldCalcium => 'Calcium (mg)';

  @override
  String get buttonSave => 'Save';

  @override
  String get validatorPleaseEnterName => 'Please enter a name.';

  @override
  String get validatorPleaseEnterNumber => 'Please enter a valid number.';

  @override
  String snackbarSaveSuccess(String foodName) {
    return '$foodName was saved successfully.';
  }

  @override
  String get foodDetailSegmentPortion => 'Portion';

  @override
  String get foodDetailSegment100g => '100g';

  @override
  String get sugar => 'Sugar';

  @override
  String get fiber => 'Fiber';

  @override
  String get salt => 'Salt';

  @override
  String get explorerScreenTitle => 'Food Explorer';

  @override
  String get nutritionScreenTitle => 'Nutrition Analysis';

  @override
  String get entriesForDateRangeLabel => 'Entries for';

  @override
  String get noEntriesForPeriod => 'No entries for this period yet.';

  @override
  String get waterEntryTitle => 'Water';

  @override
  String get profileScreenTitle => 'Profile & Goals';

  @override
  String get profileDailyGoals => 'Daily Goals';

  @override
  String get snackbarGoalsSaved => 'Goals saved successfully!';

  @override
  String get measurementsScreenTitle => 'Measurements';

  @override
  String get measurementsEmptyState =>
      'No measurements recorded yet.\nStart with the \'+\' button.';

  @override
  String get addMeasurementDialogTitle => 'Add New Measurement';

  @override
  String get formFieldMeasurementType => 'Type of Measurement';

  @override
  String formFieldMeasurementValue(Object unit) {
    return 'Value ($unit)';
  }

  @override
  String get validatorPleaseEnterValue => 'Please enter a value';

  @override
  String get measurementWeight => 'Body Weight';

  @override
  String get measurementFatPercent => 'Body Fat';

  @override
  String get measurementNeck => 'Neck';

  @override
  String get measurementShoulder => 'Shoulder';

  @override
  String get measurementChest => 'Chest';

  @override
  String get measurementLeftBicep => 'Left Bicep';

  @override
  String get measurementRightBicep => 'Right Bicep';

  @override
  String get measurementLeftForearm => 'Left Forearm';

  @override
  String get measurementRightForearm => 'Right Forearm';

  @override
  String get measurementAbdomen => 'Abdomen';

  @override
  String get measurementWaist => 'Waist';

  @override
  String get measurementHips => 'Hips';

  @override
  String get measurementLeftThigh => 'Left Thigh';

  @override
  String get measurementRightThigh => 'Right Thigh';

  @override
  String get measurementLeftCalf => 'Left Calf';

  @override
  String get measurementRightCalf => 'Right Calf';

  @override
  String get drawerMenuTitle => 'Vita Menu';

  @override
  String get drawerDashboard => 'Dashboard';

  @override
  String get drawerFoodExplorer => 'Food Explorer';

  @override
  String get drawerDataManagement => 'Data Backup';

  @override
  String get drawerMeasurements => 'Measurements';

  @override
  String get dataManagementTitle => 'Data Backup';

  @override
  String get exportCardTitle => 'Export Data';

  @override
  String get exportCardDescription =>
      'Saves all your journal entries, favorites, and custom foods into a single backup file.';

  @override
  String get exportCardButton => 'Create Backup';

  @override
  String get importCardTitle => 'Import Data';

  @override
  String get importCardDescription =>
      'Restores your data from a previously created backup file. WARNING: All data currently stored in the app will be overwritten!';

  @override
  String get importCardButton => 'Restore Backup';

  @override
  String get recommendationDefault => 'Track your first meal!';

  @override
  String recommendationOverTarget(Object count, Object difference) {
    return 'Last $count days: +$difference kcal over target';
  }

  @override
  String recommendationUnderTarget(Object count, Object difference) {
    return 'Last $count days: $difference kcal under target';
  }

  @override
  String recommendationOnTarget(Object count) {
    return 'Last $count days: Target achieved ✅';
  }

  @override
  String get recommendationFirstEntry => 'Great, your first entry is logged!';

  @override
  String get dialogConfirmTitle => 'Confirmation Required';

  @override
  String get dialogConfirmImportContent =>
      'Do you really want to restore data from this backup?\n\nWARNING: All your current entries, favorites, and custom foods will be permanently deleted and replaced.';

  @override
  String get dialogButtonCancel => 'Cancel';

  @override
  String get dialogButtonOverwrite => 'Yes, overwrite all';

  @override
  String get snackbarNoFileSelected => 'No file selected.';

  @override
  String get snackbarImportSuccessTitle => 'Import successful!';

  @override
  String get snackbarImportSuccessContent =>
      'Your data has been restored. It is recommended to restart the app for a correct display.';

  @override
  String get snackbarButtonOK => 'OK';

  @override
  String get snackbarImportError => 'Error while importing data.';

  @override
  String get snackbarExportSuccess =>
      'Backup file has been passed to the system. Please choose a location to save.';

  @override
  String get snackbarExportFailed => 'Export canceled or failed.';

  @override
  String get profileUserHeight => 'Height (cm)';

  @override
  String get workoutRoutinesTitle => 'Routines';

  @override
  String get workoutHistoryTitle => 'Workout History';

  @override
  String get workoutHistoryButton => 'History';

  @override
  String get emptyRoutinesTitle => 'No Routines Found';

  @override
  String get emptyRoutinesSubtitle =>
      'Create your first routine or start a blank workout.';

  @override
  String get createFirstRoutineButton => 'Create First Routine';

  @override
  String get startEmptyWorkoutButton => 'Free Workout';

  @override
  String get editRoutineSubtitle => 'Tap to edit, or start the workout.';

  @override
  String get startButton => 'Start';

  @override
  String get addRoutineButton => 'New Routine';

  @override
  String get freeWorkoutTitle => 'Free Workout';

  @override
  String get finishWorkoutButton => 'Finish';

  @override
  String get addSetButton => 'Add Set';

  @override
  String get addExerciseToWorkoutButton => 'Add Exercise to Workout';

  @override
  String get lastTimeLabel => 'Last Time';

  @override
  String get setLabel => 'Set';

  @override
  String get kgLabel => 'Weight (kg)';

  @override
  String get repsLabel => 'Reps';

  @override
  String get restTimerLabel => 'Rest';

  @override
  String get skipButton => 'Skip';

  @override
  String get emptyHistory => 'No completed workouts yet.';

  @override
  String get workoutDetailsTitle => 'Workout Details';

  @override
  String get workoutNotFound => 'Workout not found.';

  @override
  String get totalVolumeLabel => 'Total Volume';

  @override
  String get notesLabel => 'Notes';

  @override
  String get hevyImportTitle => 'Hevy Import';

  @override
  String get hevyImportDescription =>
      'Import your entire training history from a Hevy CSV export file.';

  @override
  String get hevyImportButton => 'Import Hevy Data';

  @override
  String hevyImportSuccess(Object count) {
    return 'Successfully imported $count workouts!';
  }

  @override
  String get hevyImportFailed => 'Import failed. Please check the file.';

  @override
  String get startWorkout => 'Start Workout';

  @override
  String get addMeasurement => 'Add Measurement';

  @override
  String get filterToday => 'Today';

  @override
  String get filter7Days => '7 Days';

  @override
  String get filter30Days => '30 Days';

  @override
  String get filterAll => 'All';

  @override
  String get showLess => 'Show less';

  @override
  String get showMoreDetails => 'Show more details';

  @override
  String get deleteConfirmTitle => 'Confirm Deletion';

  @override
  String get deleteConfirmContent => 'Do you really want to delete this entry?';

  @override
  String get cancel => 'Cancel';

  @override
  String get delete => 'Delete';

  @override
  String get save => 'Save';

  @override
  String get tabBaseFoods => 'Base Foods';

  @override
  String get baseFoodsEmptyState =>
      'This section will soon be filled with a curated list of base foods like fruits, vegetables, and more.';

  @override
  String get noBrand => 'No Brand';

  @override
  String get unknown => 'Unknown';

  @override
  String backupFileSubject(String timestamp) {
    return 'Vita App Backup - $timestamp';
  }

  @override
  String foodItemSubtitle(String brand, int calories) {
    return '$brand - $calories kcal / 100g';
  }

  @override
  String foodListSubtitle(int grams, String time) {
    return '${grams}g - $time';
  }

  @override
  String foodListTrailingKcal(int calories) {
    return '$calories kcal';
  }

  @override
  String waterListTrailingMl(int milliliters) {
    return '$milliliters ml';
  }

  @override
  String get exerciseCatalogTitle => 'Exercise Catalog';

  @override
  String get filterByMuscle => 'Filter by muscle group';

  @override
  String get noExercisesFound => 'No exercises found.';

  @override
  String get noDescriptionAvailable => 'No description available.';

  @override
  String get filterByCategory => 'Filter by category';

  @override
  String get edit => 'Edit';

  @override
  String get repsLabelShort => 'reps';

  @override
  String get titleNewRoutine => 'New Routine';

  @override
  String get titleEditRoutine => 'Edit Routine';

  @override
  String get validatorPleaseEnterRoutineName =>
      'Please enter a name for the routine.';

  @override
  String get snackbarRoutineCreated =>
      'Routine created. Now add some exercises.';

  @override
  String get snackbarRoutineSaved => 'Routine saved.';

  @override
  String get formFieldRoutineName => 'Name of the routine';

  @override
  String get emptyStateAddFirstExercise => 'Add your first exercise.';

  @override
  String setCount(int count) {
    String _temp0 = intl.Intl.pluralLogic(
      count,
      locale: localeName,
      other: '$count sets',
      one: '1 set',
    );
    return '$_temp0';
  }

  @override
  String get fabAddExercise => 'Add Exercise';

  @override
  String get kgLabelShort => 'kg';

  @override
  String get drawerExerciseCatalog => 'Exercise Catalog';

  @override
  String get lastWorkoutTitle => 'Last Workout';

  @override
  String get repeatButton => 'Repeat';

  @override
  String get weightHistoryTitle => 'Weight History';

  @override
  String get hideSummary => 'Hide Summary';

  @override
  String get showSummary => 'Show Summary';

  @override
  String get exerciseDataAttribution => 'Exercise data from';

  @override
  String get duplicate => 'Duplicate';

  @override
  String deleteRoutineConfirmContent(String routineName) {
    return 'Are you sure you want to permanently delete the routine \'$routineName\'?';
  }

  @override
  String get editPauseTimeTitle => 'Edit Pause Duration';

  @override
  String get pauseInSeconds => 'Pause in seconds';

  @override
  String get editPauseTime => 'Edit Pause';

  @override
  String pauseDuration(int seconds) {
    return '$seconds second pause';
  }

  @override
  String maxPauseDuration(int seconds) {
    return 'Pauses up to ${seconds}s';
  }

  @override
  String get deleteWorkoutConfirmContent =>
      'Are you sure you want to permanently delete this workout log?';

  @override
  String get removeExercise => 'Remove Exercise';

  @override
  String get deleteExerciseConfirmTitle => 'Remove Exercise?';

  @override
  String deleteExerciseConfirmContent(String exerciseName) {
    return 'Are you sure you want to remove \'$exerciseName\' from this routine?';
  }

  @override
  String get doneButtonLabel => 'Done';

  @override
  String get setRestTimeButton => 'Set rest time';

  @override
  String get deleteExerciseButton => 'Delete exercise';

  @override
  String get restOverLabel => 'Pause is over';

  @override
  String get workoutRunningLabel => 'Workout is active …';

  @override
  String get continueButton => 'Continue';

  @override
  String get discardButton => 'Discard';

  @override
  String get workoutStatsTitle => 'Training (7 days)';

  @override
  String get workoutsLabel => 'Workouts';

  @override
  String get durationLabel => 'Duration';

  @override
  String get volumeLabel => 'Volume';

  @override
  String get setsLabel => 'Sets';

  @override
  String get muscleSplitLabel => 'Muscle Split';

  @override
  String get snackbar_could_not_open_open_link => 'Konnte Link nicht öffnen';

  @override
  String get chart_no_data_for_period => 'Keine Daten für diesen Zeitraum.';

  @override
  String get amount_in_milliliters => 'Menge in Millilitern';

  @override
  String get amount_in_grams => 'Menge in Gramm';

  @override
  String get meal_label => 'Mahlzeit';

  @override
  String get add_to_water_intake => 'Zur Trinkmenge hinzufügen';

  @override
  String get create_exercise_screen_title => 'Eigene Übung erstellen';

  @override
  String get exercise_name_label => 'Name der Übung';

  @override
  String get category_label => 'Kategorie';

  @override
  String get description_optional_label => 'Beschreibung (optional)';

  @override
  String get primary_muscles_label => 'Primäre Muskeln';

  @override
  String get primary_muscles_hint => 'z.B. Brust, Trizeps';

  @override
  String get secondary_muscles_label => 'Sekundäre Muskeln (optional)';

  @override
  String get secondary_muscles_hint => 'z.B. Schultern';

  @override
  String get set_type_normal => 'Normal';

  @override
  String get set_type_warmup => 'Warmup';

  @override
  String get set_type_failure => 'Failure';

  @override
  String get set_type_dropset => 'Dropset';

  @override
  String get set_reps_hint => '8-12';

  @override
  String get data_export_button => 'Exportieren';

  @override
  String get data_import_button => 'Importieren';

  @override
  String get snackbar_button_ok => 'OK';

  @override
  String get measurement_session_detail_view =>
      'Detailansicht der Messsession.';

  @override
  String get unit_grams => 'g';

  @override
  String get unit_kcal => 'kcal';

  @override
  String get delete_profile_picture_button => 'Profilbild löschen';

  @override
  String get attribution_title => 'Attribution';

  @override
  String get add_liquid_title => 'Flüssigkeit hinzufügen';

  @override
  String get add_button => 'Hinzufügen';

  @override
  String get discard_button => 'Verwerfen';

  @override
  String get continue_workout_button => 'Workout fortsetzen';

  @override
  String get soon_available_snackbar =>
      'Dieser Screen wird bald verfügbar sein!';

  @override
  String get start_button => 'Start';

  @override
  String get today_overview_text => 'TODAY IN FOCUS';

  @override
  String get quick_add_text => 'QUICK ADD';

  @override
  String get scann_barcode_capslock => 'Scan barcode';

  @override
  String get protocol_today_capslock => 'TODAY\'S PROTOCOL';

  @override
  String get my_plans_capslock => 'MY PLANS';

  @override
  String get overview_capslock => 'OVERVIEW';

  @override
  String get manage_all_plans => 'Manage all plans';

  @override
  String get free_training => 'free training';

  @override
  String get my_consistency => 'MY CONSISTENCY';

  @override
  String get calendar_currently_not_available =>
      'The calendar view will be available soon.';

  @override
  String get in_depth_analysis => 'IN-DEPTH ANALYSIS';

  @override
  String get body_measurements => 'Body measurements';

  @override
  String get measurements_description =>
      'Analyze weight, body fat percentage and circumference.';

  @override
  String get nutrition_description => 'Evaluate macros, calories and trends.';

  @override
  String get training_analysis => 'Training analysis';

  @override
  String get training_analysis_description =>
      'Track volume, strength and progression.';

  @override
  String get load_dots => 'loading...';

  @override
  String get profile_capslock => 'PROFILE';

  @override
  String get settings_capslock => 'SETTINGS';

  @override
  String get settingsTitle => 'Settings';

  @override
  String get my_goals => 'My goals';

  @override
  String get my_goals_description => 'Adjust calories, macros and water.';

  @override
  String get backup_and_import => 'Data backup & import';

  @override
  String get backup_and_import_description =>
      'Create backups, restore, and import data.';

  @override
  String get about_and_legal_capslock => 'ABOUT & LEGAL';

  @override
  String get attribution_and_license => 'Attribution & Licenses';

  @override
  String get data_from_off_and_wger => 'Data from Open Food Facts and wger.';

  @override
  String get app_version => 'App version';

  @override
  String get all_measurements => 'ALL MEASUREMENTS';

  @override
  String get date_and_time_of_measurement => 'Date & time of measurement';

  @override
  String get onbWelcomeTitle => 'Welcome to Lightweight';

  @override
  String get onbWelcomeBody =>
      'Let’s start by setting personal goals to guide training and nutrition.';

  @override
  String get onbTrackTitle => 'Track everything';

  @override
  String get onbTrackBody =>
      'Log nutrition, workouts, and measurements — all in one place.';

  @override
  String get onbPrivacyTitle => 'Offline-first & privacy';

  @override
  String get onbPrivacyBody =>
      'Your data stays on the device. No cloud accounts, no background sync.';

  @override
  String get onbFinishTitle => 'All set';

  @override
  String get onbFinishBody =>
      'You’re ready to explore the app. You can adjust settings anytime.';

  @override
  String get onbFinishCta => 'Let’s go!';

  @override
  String get onbShowTutorialAgain => 'Show tutorial again';

  @override
  String get onbSetGoalsCta => 'Set goals';

  @override
  String get onbHeaderTitle => 'Tutorial';

  @override
  String get onbHeaderSkip => 'Skip';

  @override
  String get onbBack => 'Back';

  @override
  String get onbNext => 'Next';

  @override
  String get onbGuideTitle => 'How this tutorial works';

  @override
  String get onbGuideBody =>
      'Swipe between slides or use Next. Tap the buttons on each slide to try features. You can finish anytime with Skip.';

  @override
  String get onbCtaOpenNutrition => 'Open nutrition';

  @override
  String get onbCtaLearnMore => 'Learn more';

  @override
  String get onbBadgeDone => 'Done';

  @override
  String get onbTipSetGoals => 'Tip: adjust targets first';

  @override
  String get onbTipAddEntry => 'Tip: add one entry today';

  @override
  String get onbTipLocalControl => 'You control all data locally';

  @override
  String get onbTrackHowBody =>
      'How to log nutrition:\n• Open the Food tab.\n• Tap the + button.\n• Search products or scan a barcode.\n• Adjust portion and time.\n• Save to your diary.';

  @override
  String get onbMeasureTitle => 'Track measurements';

  @override
  String get onbMeasureBody =>
      'How to add measurements:\n• Open the Stats tab.\n• Tap the + button.\n• Choose a metric (e.g., weight, waist, body fat).\n• Enter value and time.\n• Save to your history.';

  @override
  String get onbTipMeasureToday =>
      'Tip: add today’s weight to start your graph';

  @override
  String get onbTrainTitle => 'Train with routines';

  @override
  String get onbTrainBody =>
      'Create a routine and start a workout:\n• Open the Train tab.\n• Tap Create routine to add exercises and sets.\n• Save the routine.\n• Tap Start to begin, or use “Start empty workout”.';

  @override
  String get onbTipStartWorkout =>
      'Tip: start an empty workout to log a quick session';

  @override
  String get unitsSection => 'units';

  @override
  String get weightUnit => 'Weight units';

  @override
  String get lengthUnit => 'unit of length';
}


===== Datei: D:\lightweight\lib\models\chart_data_point.dart =====

// lib/models/chart_data_point.dart

class ChartDataPoint {
  final DateTime date;
  final double value;

  ChartDataPoint({required this.date, required this.value});
}


===== Datei: D:\lightweight\lib\models\daily_nutrition.dart =====

// lib/models/daily_nutrition.dart

class DailyNutrition {
  // Verbrauchte Nährwerte
  int calories;
  int water;
  int protein;
  int carbs;
  int fat;
  double fiber;
  double sugar;
  double salt;

  // Ziele
  int targetCalories;
  int targetWater;
  int targetProtein;
  int targetCarbs;
  int targetFat;

  // DOC: NEUE ZIELFELDER
  int targetSugar;
  int targetFiber;
  int targetSalt;

  DailyNutrition({
    this.calories = 0,
    this.water = 0,
    this.protein = 0,
    this.carbs = 0,
    this.fat = 0,
    this.fiber = 0.0,
    this.sugar = 0.0,
    this.salt = 0.0,
    this.targetCalories = 0,
    this.targetWater = 0,
    this.targetProtein = 0,
    this.targetCarbs = 0,
    this.targetFat = 0,

    // DOC: Initialisierung der neuen Ziele
    this.targetSugar = 0,
    this.targetFiber = 0,
    this.targetSalt = 0,
  });
}


===== Datei: D:\lightweight\lib\models\exercise.dart =====

// lib/models/exercise.dart

import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';

class Exercise {
  final int? id;
  final String nameDe;
  final String nameEn;
  final String descriptionDe;
  final String descriptionEn;
  final String categoryName;
  final List<String> primaryMuscles;
  final List<String> secondaryMuscles;

  Exercise({
    this.id,
    required this.nameDe,
    required this.nameEn,
    required this.descriptionDe,
    required this.descriptionEn,
    required this.categoryName,
    required this.primaryMuscles,
    required this.secondaryMuscles,
  });

  String getLocalizedName(BuildContext context) {
    final locale = Localizations.localeOf(context);
    return locale.languageCode == 'de' ? nameDe : nameEn;
  }

  String getLocalizedDescription(BuildContext context) {
    final locale = Localizations.localeOf(context);
    final desc = locale.languageCode == 'de' ? descriptionDe : descriptionEn;
    // Fallback, falls eine Beschreibung leer ist
    if (desc.trim().isEmpty) {
      return AppLocalizations.of(context)!.noDescriptionAvailable;
    }
    return desc;
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name_de': nameDe,
      'name_en': nameEn,
      'description_de': descriptionDe,
      'description_en': descriptionEn,
      'category_name': categoryName,
      'primaryMuscles': jsonEncode(primaryMuscles),
      'secondaryMuscles': jsonEncode(secondaryMuscles),
    };
  }

  factory Exercise.fromMap(Map<String, dynamic> map) {
    // Diese Hilfsfunktion wandelt den JSON-String aus der DB in eine List<String> um
    List<String> parseMuscles(String? jsonString) {
      if (jsonString == null || jsonString.isEmpty) return [];
      try {
        // jsonDecode kann eine List<dynamic> zurückgeben, daher der cast.
        return (jsonDecode(jsonString) as List)
            .map((item) => item.toString())
            .toList();
      } catch (e) {
        return []; // Im Fehlerfall leere Liste zurückgeben
      }
    }

    return Exercise(
      id: map['id'],
      nameDe: map['name_de'] ?? '',
      nameEn: map['name_en'] ?? '',
      descriptionDe: map['description_de'] ?? '',
      descriptionEn: map['description_en'] ?? '',
      categoryName: map['category_name'] ?? '',
      // KORREKTUR: Schlüsselnamen auf camelCase ('primaryMuscles') geändert
      primaryMuscles: parseMuscles(map['primaryMuscles']),
      secondaryMuscles: parseMuscles(map['secondaryMuscles']),
    );
  }

  Exercise copyWith({int? id}) {
    return Exercise(
      id: id ?? this.id,
      nameDe: nameDe,
      nameEn: nameEn,
      descriptionDe: descriptionDe,
      descriptionEn: descriptionEn,
      categoryName: categoryName,
      primaryMuscles: primaryMuscles,
      secondaryMuscles: secondaryMuscles,
    );
  }
}


===== Datei: D:\lightweight\lib\models\food_entry.dart =====

// lib/models/food_entry.dart

class FoodEntry {
  final int? id;
  final String barcode;
  final DateTime timestamp;
  final int quantityInGrams;
  final String mealType;

  FoodEntry({
    this.id,
    required this.barcode,
    required this.timestamp,
    required this.quantityInGrams,
    required this.mealType,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'barcode': barcode,
      'timestamp': timestamp.toIso8601String(),
      'quantity_in_grams': quantityInGrams,
      'meal_type': mealType,
    };
  }
}


===== Datei: D:\lightweight\lib\models\food_item.dart =====

// lib/models/food_item.dart

enum FoodItemSource {
  off, // Open Food Facts
  base, // Grundnahrungsmittel-DB
  user // Vom Benutzer erstellt (Standard)
}

class FoodItem {
  final String barcode;
  final String name;
  final String brand;
  final int calories; // pro 100g
  final double protein; // pro 100g
  final double carbs; // pro 100g
  final double fat; // pro 100g
  final FoodItemSource source;

  final double? kj;
  final double? fiber;
  final double? sugar;
  final double? salt;
  final double? sodium;
  final double? calcium;

  FoodItem({
    required this.barcode,
    required this.name,
    this.brand = '',
    required this.calories,
    required this.protein,
    required this.carbs,
    required this.fat,
    this.source = FoodItemSource.user,
    this.kj,
    this.fiber,
    this.sugar,
    this.salt,
    this.sodium,
    this.calcium,
  });

  factory FoodItem.fromMap(Map<String, dynamic> map,
      {required FoodItemSource source}) {
    return FoodItem(
      barcode: map['barcode'] ?? '',
      // KORREKTUR: Kein hartcodierter Fallback mehr. Die UI kümmert sich darum.
      name: map['name'] ?? '',
      brand: map['brand'] ?? '',
      calories: (map['calories_100g'] as num?)?.round() ?? 0,
      protein: (map['protein_100g'] as num?)?.toDouble() ?? 0.0,
      carbs: (map['carbs_100g'] as num?)?.toDouble() ?? 0.0,
      fat: (map['fat_100g'] as num?)?.toDouble() ?? 0.0,
      source: source,
      kj: (map['kj_100g'] as num?)?.toDouble(),
      fiber: (map['fiber_100g'] as num?)?.toDouble(),
      sugar: (map['sugar_100g'] as num?)?.toDouble(),
      salt: (map['salt_100g'] as num?)?.toDouble(),
      sodium: (map['sodium_100g'] as num?)?.toDouble(),
      calcium: (map['calcium_100g'] as num?)?.toDouble(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'barcode': barcode,
      'name': name,
      'brand': brand,
      'calories_100g': calories,
      'protein_100g': protein,
      'carbs_100g': carbs,
      'fat_100g': fat,
      'kj_100g': kj,
      'fiber_100g': fiber,
      'sugar_100g': sugar,
      'salt_100g': salt,
      'sodium_100g': sodium,
      'calcium_100g': calcium,
    };
  }
}


===== Datei: D:\lightweight\lib\models\lightweight_backup.dart =====

// lib/models/lightweight_backup.dart

import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/measurement.dart';
import 'package:lightweight/models/measurement_session.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/water_entry.dart';
import 'package:lightweight/models/workout_log.dart';

class LightweightBackup {
  final int schemaVersion;
  final List<FoodEntry> foodEntries;
  final List<WaterEntry> waterEntries;
  final List<String> favoriteBarcodes;
  final List<FoodItem> customFoodItems;
  final List<MeasurementSession> measurementSessions;
  final List<Routine> routines;
  final List<WorkoutLog> workoutLogs;
  // HINZUGEFÜGT: Ein Feld für die Benutzereinstellungen
  final Map<String, dynamic> userPreferences;

  LightweightBackup({
    required this.schemaVersion,
    required this.foodEntries,
    required this.waterEntries,
    required this.favoriteBarcodes,
    required this.customFoodItems,
    required this.measurementSessions,
    required this.routines,
    required this.workoutLogs,
    required this.userPreferences, // HINZUGEFÜGT
  });

  // Diese Factory nutzt jetzt die exakten Konstruktoren und .fromMap-Methoden deiner Modelle
  factory LightweightBackup.fromJson(Map<String, dynamic> json) {
    return LightweightBackup(
      schemaVersion: json['schemaVersion'] as int? ?? 1,

      foodEntries: (json['foodEntries'] as List<dynamic>?)
              ?.map((e) => FoodEntry(
                    id: e['id'],
                    barcode: e['barcode'],
                    timestamp: DateTime.parse(e['timestamp']),
                    quantityInGrams: e['quantity_in_grams'],
                    mealType: e['meal_type'],
                  ))
              .toList() ??
          [],

      waterEntries: (json['waterEntries'] as List<dynamic>?)
              ?.map((e) => WaterEntry.fromMap(e as Map<String, dynamic>))
              .toList() ??
          [],

      favoriteBarcodes: List<String>.from(json['favoriteBarcodes'] ?? []),

      // Hier wird die Sonderregel für 'source' beachtet
      customFoodItems: (json['customFoodItems'] as List<dynamic>?)
              ?.map((e) => FoodItem.fromMap(e as Map<String, dynamic>,
                  source: FoodItemSource.user))
              .toList() ??
          [],

      measurementSessions: (json['measurementSessions'] as List<dynamic>?)
              ?.map((s) {
            final sessionMap = s as Map<String, dynamic>;
            final measurements = (sessionMap['measurements'] as List<dynamic>?)
                    ?.map((m) => Measurement.fromMap(m as Map<String, dynamic>))
                    .toList() ??
                [];
            return MeasurementSession(
              id: sessionMap['id'],
              timestamp: DateTime.parse(sessionMap['timestamp']),
              measurements: measurements,
            );
          }).toList() ??
          [],

      routines: (json['routines'] as List<dynamic>?)?.map((r) {
            final routineMap = r as Map<String, dynamic>;
            // Hier müssten wir die Routine und ihre Kinder (Exercises, Sets) manuell zusammenbauen
            // Dies ist ein Platzhalter und muss ggf. verfeinert werden, je nachdem,
            // wie detailliert die Routine-Modelle sind.
            return Routine(
              id: routineMap['id'],
              name: routineMap['name'],
              exercises: [], // TODO: Detaillierte Deserialisierung für Routine-Exercises
            );
          }).toList() ??
          [],

      workoutLogs: (json['workoutLogs'] as List<dynamic>?)?.map((log) {
            final logMap = log as Map<String, dynamic>;
            final sets = (logMap['sets'] as List<dynamic>?)
                    ?.map((set) => SetLog.fromMap(set as Map<String, dynamic>))
                    .toList() ??
                [];
            return WorkoutLog.fromMap(logMap, sets: sets);
          }).toList() ??
          [],
      userPreferences: Map<String, dynamic>.from(json['userPreferences'] ?? {}),
    );
  }

  // Diese Methode nutzt jetzt die .toMap() Methoden deiner Modelle
  Map<String, dynamic> toJson() {
    return {
      'schemaVersion': schemaVersion,
      'foodEntries': foodEntries.map((e) => e.toMap()).toList(),
      'waterEntries': waterEntries.map((e) => e.toMap()).toList(),
      'favoriteBarcodes': favoriteBarcodes,
      'customFoodItems': customFoodItems.map((e) => e.toMap()).toList(),
      'measurementSessions': measurementSessions
          .map((s) => {
                'id': s.id,
                'timestamp': s.timestamp.toIso8601String(),
                'measurements': s.measurements.map((m) => m.toMap()).toList(),
              })
          .toList(),
      // Platzhalter für die komplexe Serialisierung von Routinen
      'routines': routines.map((r) => r.toMap()).toList(),
      'workoutLogs': workoutLogs
          .map((log) => {
                ...log.toMap(), // Nutzt die existierende toMap-Methode
                'sets': log.sets
                    .map((s) => s.toMap())
                    .toList(), // Hängt die Sets an
              })
          .toList(),
      'userPreferences': userPreferences,
    };
  }
}


===== Datei: D:\lightweight\lib\models\measurement.dart =====

// lib/models/measurement.dart

class Measurement {
  final int? id;
  final int sessionId;
  final String type;
  final double value;
  final String unit;

  Measurement({
    this.id,
    required this.sessionId,
    required this.type,
    required this.value,
    required this.unit,
  });

  factory Measurement.fromMap(Map<String, dynamic> map) {
    return Measurement(
      id: map['id'],
      sessionId: map['session_id'],
      type: map['type'],
      value: map['value'],
      unit: map['unit'],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'session_id': sessionId,
      'type': type,
      'value': value,
      'unit': unit,
    };
  }
}


===== Datei: D:\lightweight\lib\models\measurement_session.dart =====

// lib/models/measurement_session.dart
import 'package:lightweight/models/measurement.dart';

class MeasurementSession {
  final int? id;
  final DateTime timestamp;
  final List<Measurement> measurements; // Hält die Detailwerte

  MeasurementSession({
    this.id,
    required this.timestamp,
    this.measurements = const [],
  });
}


===== Datei: D:\lightweight\lib\models\routine.dart =====

// lib/models/routine.dart
import 'package:lightweight/models/routine_exercise.dart';

class Routine {
  final int? id;
  final String name;
  final List<RoutineExercise> exercises;

  Routine({
    this.id,
    required this.name,
    this.exercises = const [],
  });

  // BITTE DIESE METHODE HINZUFÜGEN
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'exercises': exercises.map((re) => re.toMap()).toList(),
    };
  }
}


===== Datei: D:\lightweight\lib\models\routine_exercise.dart =====

// lib/models/routine_exercise.dart

import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/set_template.dart';

class RoutineExercise {
  final int? id;
  final Exercise exercise;
  List<SetTemplate> setTemplates;
  final int? pauseSeconds; // NEUES FELD

  RoutineExercise({
    this.id,
    required this.exercise,
    this.setTemplates = const [],
    this.pauseSeconds, // NEUES FELD
  });

  // BITTE DIESE METHODE HINZUFÜGEN ODER ERSETZEN
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'exercise': exercise.toMap(), // Annahme: Exercise hat eine toMap-Methode
      'setTemplates': setTemplates.map((st) => st.toMap()).toList(),
      'pause_seconds': pauseSeconds,
    };
  }
}


===== Datei: D:\lightweight\lib\models\set_log.dart =====

// lib/models/set_log.dart

class SetLog {
  final int? id;
  final int workoutLogId;
  final String exerciseName;
  final String setType;
  final double? weightKg;
  final int? reps;
  final int? restTimeSeconds;
  final bool? isCompleted;
  final int? log_order;
  final String? notes;
  final double? distanceKm;
  final int? durationSeconds;
  final int? rpe;
  final int? supersetId;

  SetLog({
    this.id,
    required this.workoutLogId,
    required this.exerciseName,
    required this.setType,
    this.weightKg,
    this.reps,
    this.restTimeSeconds,
    this.isCompleted,
    this.log_order,
    this.notes,
    this.distanceKm,
    this.durationSeconds,
    this.rpe,
    this.supersetId,
  });

  factory SetLog.fromMap(Map<String, dynamic> map) {
    return SetLog(
      id: map['id'],
      workoutLogId: map['workout_log_id'],
      exerciseName: map['exercise_name'],
      setType: map['set_type'],
      weightKg: map['weight_kg'],
      reps: map['reps'],
      restTimeSeconds: map['rest_time_seconds'],
      isCompleted: map['is_completed'] == 1,
      log_order: map['log_order'],
      notes: map['notes'],
      distanceKm: map['distance_km'],
      durationSeconds: map['duration_seconds'],
      rpe: map['rpe'],
      supersetId: map['superset_id'],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'workout_log_id': workoutLogId,
      'exercise_name': exerciseName,
      'set_type': setType,
      'weight_kg': weightKg,
      'reps': reps,
      'rest_time_seconds': restTimeSeconds,
      'is_completed': isCompleted == true ? 1 : 0,
      'log_order': log_order,
      'notes': notes,
      'distance_km': distanceKm,
      'duration_seconds': durationSeconds,
      'rpe': rpe,
      'superset_id': supersetId,
    };
  }

  SetLog copyWith({
    int? id,
    int? workoutLogId,
    String? exerciseName,
    String? setType,
    double? weightKg,
    int? reps,
    int? restTimeSeconds,
    bool? isCompleted,
    int? log_order,
    String? notes,
    double? distanceKm,
    int? durationSeconds,
    int? rpe,
    int? supersetId,
  }) {
    return SetLog(
      id: id ?? this.id,
      workoutLogId: workoutLogId ?? this.workoutLogId,
      exerciseName: exerciseName ?? this.exerciseName,
      setType: setType ?? this.setType,
      weightKg: weightKg ?? this.weightKg,
      reps: reps ?? this.reps,
      restTimeSeconds: restTimeSeconds ?? this.restTimeSeconds,
      isCompleted: isCompleted ?? this.isCompleted,
      log_order: log_order ?? this.log_order,
      notes: notes ?? this.notes,
      distanceKm: distanceKm ?? this.distanceKm,
      durationSeconds: durationSeconds ?? this.durationSeconds,
      rpe: rpe ?? this.rpe,
      supersetId: supersetId ?? this.supersetId,
    );
  }
}


===== Datei: D:\lightweight\lib\models\set_template.dart =====

// lib/models/set_template.dart

class SetTemplate {
  final int? id;
  final String setType;
  final String? targetReps;
  final double? targetWeight;

  SetTemplate({
    this.id,
    required this.setType,
    this.targetReps,
    this.targetWeight,
  });

  factory SetTemplate.fromMap(Map<String, dynamic> map) {
    return SetTemplate(
      id: map['id'],
      setType: map['set_type'] ?? 'normal',
      targetReps: map['target_reps'],
      targetWeight: map['target_weight'],
    );
  }

  // In lib/models/set_template.dart
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'set_type': setType,
      'target_reps': targetReps,
      'target_weight': targetWeight,
    };
  }

  // NEUE, BENÖTIGTE METHODE
  // Erstellt eine Kopie des Objekts und überschreibt nur die übergebenen Werte.
  SetTemplate copyWith({
    int? id,
    String? setType,
    String? targetReps,
    double? targetWeight,
  }) {
    return SetTemplate(
      id: id ?? this.id,
      setType: setType ?? this.setType,
      targetReps: targetReps ?? this.targetReps,
      targetWeight: targetWeight ?? this.targetWeight,
    );
  }
}


===== Datei: D:\lightweight\lib\models\timeline_entry.dart =====

// lib/models/timeline_entry.dart

import 'package:lightweight/models/tracked_food_item.dart';
import 'package:lightweight/models/water_entry.dart';

// DOC: Dies ist eine "abstrakte" Klasse. Sie dient als gemeinsame
// Schablone für alle Arten von Einträgen in unserem Tagebuch.
// Jedes Timeline-Item MUSS einen Zeitstempel haben, damit wir es sortieren können.
abstract class TimelineEntry {
  DateTime get timestamp;
}

// Ein Eintrag für ein Lebensmittel
class FoodTimelineEntry extends TimelineEntry {
  final TrackedFoodItem trackedItem;
  FoodTimelineEntry(this.trackedItem);

  @override
  DateTime get timestamp => trackedItem.entry.timestamp;
}

// Ein Eintrag für Wasser
class WaterTimelineEntry extends TimelineEntry {
  final WaterEntry waterEntry;
  WaterTimelineEntry(this.waterEntry);

  @override
  DateTime get timestamp => waterEntry.timestamp;
}


===== Datei: D:\lightweight\lib\models\tracked_food_item.dart =====

import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/food_item.dart';

// DOC: Diese Klasse ist ein reines "Anzeige-Modell". Sie kombiniert die Daten
// aus zwei verschiedenen Quellen (unserem Tagebucheintrag und dem Produktkatalog),
// damit die UI sie einfach an einem Ort abgreifen kann.
class TrackedFoodItem {
  final FoodEntry
      entry; // Der eigentliche Tagebucheintrag (mit ID, Menge, Zeit)
  final FoodItem
      item; // Die Details des Lebensmittels (mit Name, Kalorien etc.)

  TrackedFoodItem({
    required this.entry,
    required this.item,
  });

  // Eine kleine Helfer-Eigenschaft, um die berechneten Kalorien für diesen Eintrag zu bekommen.
  int get calculatedCalories {
    return (item.calories / 100 * entry.quantityInGrams).round();
  }
}


===== Datei: D:\lightweight\lib\models\water_entry.dart =====

class WaterEntry {
  final int? id;
  final DateTime timestamp;
  final int quantityInMl;

  WaterEntry({
    this.id,
    required this.timestamp,
    required this.quantityInMl,
  });

  factory WaterEntry.fromMap(Map<String, dynamic> map) {
    return WaterEntry(
      id: map['id'],
      timestamp: DateTime.parse(map['timestamp']),
      quantityInMl: map['quantity_in_ml'],
    );
  }
  // DOC: DIESE METHODE HINZUFÜGEN
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'timestamp': timestamp.toIso8601String(),
      'quantity_in_ml': quantityInMl,
    };
  }
}


===== Datei: D:\lightweight\lib\models\workout_log.dart =====

// lib/models/workout_log.dart

import 'package:lightweight/models/set_log.dart';

class WorkoutLog {
  final int? id;
  final String? routineName;
  final DateTime startTime;
  final DateTime? endTime;
  final String? notes;
  final String status; // NEUES FELD
  final List<SetLog> sets;

  WorkoutLog({
    this.id,
    this.routineName,
    required this.startTime,
    this.endTime,
    this.notes,
    this.status = 'completed', // Standardwert
    this.sets = const [],
  });

  // NEU: Factory-Konstruktor zum Erstellen aus einer Datenbank-Map
  factory WorkoutLog.fromMap(Map<String, dynamic> map,
      {List<SetLog> sets = const []}) {
    return WorkoutLog(
      id: map['id'],
      routineName: map['routine_name'],
      startTime: DateTime.parse(map['start_time'] as String),
      endTime: map['end_time'] != null
          ? DateTime.parse(map['end_time'] as String)
          : null,
      notes: map['notes'],
      status: map['status'] ??
          'completed', // Fallback für alte Einträge ohne Status
      sets: sets,
    );
  }

  // NEU: Methode zum Konvertieren in eine Datenbank-Map
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'routine_name': routineName,
      'start_time': startTime.toIso8601String(),
      'end_time': endTime?.toIso8601String(),
      'notes': notes,
      'status': status,
    };
  }
}


===== Datei: D:\lightweight\lib\screens\add_food_screen.dart =====

// lib/screens/add_food_screen.dart (Final & De-Materialisiert)

import 'package:flutter/material.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/screens/create_food_screen.dart';
import 'package:lightweight/screens/scanner_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/off_attribution_widget.dart';
import 'package:lightweight/widgets/summary_card.dart';

class AddFoodScreen extends StatefulWidget {
  const AddFoodScreen({super.key});

  @override
  State<AddFoodScreen> createState() => _AddFoodScreenState();
}

class _AddFoodScreenState extends State<AddFoodScreen>
    with SingleTickerProviderStateMixin {
  List<FoodItem> _foundFoodItems = [];
  bool _isLoadingSearch = false;
  String _searchInitialText = "";
  final _searchController = TextEditingController();

  List<FoodItem> _favoriteFoodItems = [];
  bool _isLoadingFavorites = true;

  List<FoodItem> _recentFoodItems = [];
  bool _isLoadingRecent = true;

  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 4, vsync: this); // 4 Tabs
    _searchController.addListener(() => setState(() {}));
    _loadFavorites();
    _loadRecentItems();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (_searchInitialText.isEmpty) {
      _searchInitialText = AppLocalizations.of(context)!.searchInitialHint;
    }
  }

  @override
  void dispose() {
    _searchController.dispose();
    _tabController.dispose();
    super.dispose();
  }

  void _runFilter(String enteredKeyword) async {
    final l10n = AppLocalizations.of(context)!;
    if (enteredKeyword.isEmpty) {
      setState(() {
        _foundFoodItems = [];
        _searchInitialText = l10n.searchInitialHint;
      });
      return;
    }
    setState(() {
      _isLoadingSearch = true;
    });

    final results =
        await ProductDatabaseHelper.instance.searchProducts(enteredKeyword);

    if (mounted) {
      setState(() {
        _foundFoodItems = results;
        _isLoadingSearch = false;
        if (results.isEmpty) {
          _searchInitialText = l10n.searchNoResults;
        }
      });
    }
  }

  void _navigateAndCreateFood() {
    Navigator.of(context)
        .push(
      MaterialPageRoute(builder: (context) => const CreateFoodScreen()),
    )
        .then((_) {
      _searchController.clear();
      _runFilter('');
      _loadFavorites();
      _loadRecentItems();
    });
  }

  Future<void> _loadFavorites() async {
    setState(() {
      _isLoadingFavorites = true;
    });
    final results = await ProductDatabaseHelper.instance.getFavoriteProducts();
    if (mounted) {
      setState(() {
        _favoriteFoodItems = results;
        _isLoadingFavorites = false;
      });
    }
  }

  Future<void> _loadRecentItems() async {
    setState(() {
      _isLoadingRecent = true;
    });
    final results = await ProductDatabaseHelper.instance.getRecentProducts();
    if (mounted) {
      setState(() {
        _recentFoodItems = results;
        _isLoadingRecent = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final isLightMode = Theme.of(context).brightness == Brightness.light;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      // KORREKTUR 1: AppBar entfernt, Titel und TabBar direkt in die ListView
      // KORREKTUR 2: Den grauen Balken entfernen, indem wir einen leeren AppBar verwenden.
      appBar: AppBar(
        toolbarHeight: 0, // AppBar komplett "unsichtbar" machen
        elevation: 0,
        backgroundColor: Colors.transparent,
        shadowColor: Colors.transparent, // Schattenfarbe explizit transparent
        surfaceTintColor:
            Colors.transparent, // Surface tint color auch transparent
        bottomOpacity: 0, // Bottom-Border-Opazität auf 0
        forceMaterialTransparency: true, // Erzwingt Transparenz
      ),
      body: Column(
        children: [
          Padding(
            padding:
                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                TabBar(
                  controller: _tabController,
                  isScrollable: false, // Verteilt Tabs gleichmäßig
                  indicator: const BoxDecoration(),
                  splashFactory: NoSplash.splashFactory,
                  overlayColor: WidgetStateProperty.all(Colors.transparent),
                  // KORREKTUR: labelPadding: EdgeInsets.zero, für volle Breite der Tab-Labels
                  labelPadding: EdgeInsets.zero, // Wichtig für exaktes Layout
                  labelColor: isLightMode ? Colors.black : Colors.white,
                  unselectedLabelColor: Colors.grey.shade600,
                  labelStyle: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.w900,
                      letterSpacing: 0.0),
                  unselectedLabelStyle: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w800,
                      letterSpacing: 0.0),
                  tabs: [
                    Tab(text: l10n.tabSearch),
                    Tab(text: l10n.tabBaseFoods),
                    Tab(text: l10n.tabRecent),
                    Tab(text: l10n.tabFavorites),
                  ],
                ),
              ],
            ),
          ),
          // KORREKTUR 3: Padding im TabBarView entfernen, um den Inhalt zum Rand zu bringen
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildSearchTab(l10n),
                _buildBaseFoodsTab(l10n),
                _buildRecentTab(l10n),
                _buildFavoritesTab(l10n),
              ],
            ),
          ),
        ],
      ),
      floatingActionButton: GlassFab(onPressed: _navigateAndCreateFood),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  Widget _buildSearchTab(AppLocalizations l10n) {
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    return Padding(
      // KORREKTUR 4: Horizontaler Padding hier angepasst, um das Abschneiden zu verhindern
      padding: const EdgeInsets.symmetric(
          horizontal: 16.0, vertical: 0), // Vertikalen Padding auf 0 setzen
      child: Column(
        children: [
          Row(
            children: [
              // Die Suchleiste füllt jetzt den verfügbaren Platz
              Expanded(
                child: TextField(
                    controller: _searchController,
                    onChanged: (value) => _runFilter(value),
                    decoration: InputDecoration(
                        hintText: l10n.searchHintText,
                        prefixIcon: Icon(Icons.search,
                            color: colorScheme.onSurfaceVariant, size: 20),
                        suffixIcon: _searchController.text.isNotEmpty
                            ? IconButton(
                                icon: Icon(Icons.clear,
                                    color: colorScheme.onSurfaceVariant),
                                onPressed: () {
                                  _searchController.clear();
                                  _runFilter('');
                                })
                            : null)),
              ),
              const SizedBox(width: 8), // Kleiner Abstand
              // Der neue Scanner-Button
              IconButton(
                style: IconButton.styleFrom(
                  backgroundColor: colorScheme.surfaceContainerHighest,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
                icon: Icon(Icons.qr_code_scanner, color: colorScheme.primary),
                onPressed: _scanBarcodeAndPop, // Ruft die neue Methode auf
              ),
            ],
          ),
          const SizedBox(height: 20),
          Expanded(
            child: _isLoadingSearch
                ? const Center(child: CircularProgressIndicator())
                : _foundFoodItems.isNotEmpty
                    ? ListView.builder(
                        itemCount: _foundFoodItems.length,
                        itemBuilder: (context, index) =>
                            _buildFoodListItem(_foundFoodItems[index]))
                    : Center(
                        child: Text(_searchInitialText,
                            style: textTheme.titleMedium)),
          ),
          if (_foundFoodItems.any((item) => item.source == FoodItemSource.off))
            const OffAttributionWidget(),
        ],
      ),
    );
  }

  Widget _buildBaseFoodsTab(AppLocalizations l10n) {
    return Padding(
      padding: const EdgeInsets.all(24.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.eco_outlined, size: 80, color: Colors.grey.shade400),
          SizedBox(height: DesignConstants.spacingL),
          Text(
            "In Kürze verfügbar",
            style: Theme.of(context).textTheme.headlineSmall,
            textAlign: TextAlign.center,
          ),
          SizedBox(height: DesignConstants.spacingS),
          Text(
            l10n.baseFoodsEmptyState,
            textAlign: TextAlign.center,
            style: Theme.of(context)
                .textTheme
                .bodyLarge
                ?.copyWith(color: Colors.grey.shade600),
          ),
        ],
      ),
    );
  }

  Widget _buildFavoritesTab(AppLocalizations l10n) {
    if (_isLoadingFavorites) {
      return const Center(child: CircularProgressIndicator());
    }
    if (_favoriteFoodItems.isEmpty) {
      // NEUER, AUFGEWERTETER EMPTY STATE
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.favorite_border,
                  size: 80, color: Colors.grey.shade400),
              SizedBox(height: DesignConstants.spacingL),
              Text(
                "Keine Favoriten",
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              SizedBox(height: DesignConstants.spacingS),
              Text(
                l10n.favoritesEmptyState,
                textAlign: TextAlign.center,
                style: Theme.of(context)
                    .textTheme
                    .bodyLarge
                    ?.copyWith(color: Colors.grey.shade600),
              ),
            ],
          ),
        ),
      );
    }
    return Column(children: [
      Expanded(
          child: ListView.builder(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              itemCount: _favoriteFoodItems.length,
              itemBuilder: (context, index) =>
                  _buildFoodListItem(_favoriteFoodItems[index]))),
      if (_favoriteFoodItems.any((item) => item.source == FoodItemSource.off))
        const OffAttributionWidget()
    ]);
  }

  Widget _buildRecentTab(AppLocalizations l10n) {
    if (_isLoadingRecent) {
      return const Center(child: CircularProgressIndicator());
    }
    if (_recentFoodItems.isEmpty) {
      // NEUER, AUFGEWERTETER EMPTY STATE
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.history, size: 80, color: Colors.grey.shade400),
              SizedBox(height: DesignConstants.spacingL),
              Text(
                "Noch nichts erfasst",
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              SizedBox(height: DesignConstants.spacingS),
              Text(
                l10n.recentEmptyState,
                textAlign: TextAlign.center,
                style: Theme.of(context)
                    .textTheme
                    .bodyLarge
                    ?.copyWith(color: Colors.grey.shade600),
              ),
            ],
          ),
        ),
      );
    }
    return Column(children: [
      Expanded(
          child: ListView.builder(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              itemCount: _recentFoodItems.length,
              itemBuilder: (context, index) =>
                  _buildFoodListItem(_recentFoodItems[index]))),
      if (_recentFoodItems.any((item) => item.source == FoodItemSource.off))
        const OffAttributionWidget()
    ]);
  }

  // KORREKTUR 5: _buildFoodListItem verwendet jetzt SummaryCard
  Widget _buildFoodListItem(FoodItem item) {
    final colorScheme = Theme.of(context).colorScheme;
    final l10n = AppLocalizations.of(context)!;

    IconData sourceIcon;
    switch (item.source) {
      case FoodItemSource.base:
        sourceIcon = Icons.star;
        break;
      case FoodItemSource.off:
      case FoodItemSource.user:
        sourceIcon = Icons.inventory_2;
        break;
    }

    return SummaryCard(
      // KORREKTUR: Jetzt mit SummaryCard
      child: ListTile(
        leading: Icon(sourceIcon, color: colorScheme.primary),
        title: Text(item.name.isNotEmpty ? item.name : l10n.unknown,
            style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Text(l10n.foodItemSubtitle(
            item.brand.isNotEmpty ? item.brand : l10n.noBrand, item.calories)),
        trailing: IconButton(
          icon: Icon(Icons.add_circle_outline,
              color: colorScheme.primary, size: 28),
          onPressed: () => Navigator.of(context).pop(item),
        ),
        onTap: () => Navigator.of(context)
            .pop(item), // KORREKTUR: Direkt Pop, da wir hier nur auswählen
      ),
    );
  }

  // FÜGE DIESE NEUE METHODE HINZU
  void _scanBarcodeAndPop() async {
    // Öffne den Scanner und warte auf einen Barcode (String) als Ergebnis
    final String? barcode = await Navigator.of(context).push<String>(
      MaterialPageRoute(builder: (context) => const ScannerScreen()),
    );

    // Wenn ein Barcode zurückgegeben wurde und der Screen noch existiert...
    if (barcode != null && mounted) {
      // ...suche das Produkt in der Datenbank.
      final foodItem =
          await ProductDatabaseHelper.instance.getProductByBarcode(barcode);

      // Wenn das Produkt gefunden wurde...
      if (foodItem != null) {
        // ...schließe den AddFoodScreen und gib das gefundene Item zurück.
        Navigator.of(context).pop(foodItem);
      } else {
        // Wenn nicht, zeige eine kurze Info-Nachricht.
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
                content: Text('Kein Produkt für Barcode "$barcode" gefunden.')),
          );
        }
      }
    }
  }
}


===== Datei: D:\lightweight\lib\screens\add_measurement_screen.dart =====

// lib/screens/add_measurement_screen.dart (Final & De-Materialisiert - Korrigiert)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/measurement.dart';
import 'package:lightweight/models/measurement_session.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart'; // HINZUGEFÜGT

class AddMeasurementScreen extends StatefulWidget {
  const AddMeasurementScreen({super.key});

  @override
  State<AddMeasurementScreen> createState() => _AddMeasurementScreenState();
}

class _AddMeasurementScreenState extends State<AddMeasurementScreen> {
  final _formKey = GlobalKey<FormState>();
  final Map<String, TextEditingController> _controllers = {};
  DateTime _selectedDateTime = DateTime.now();

  final Map<String, String> _measurementTypes = {
    'weight': 'kg',
    'fat_percent': '%',
    'waist': 'cm',
    'abdomen': 'cm',
    'hips': 'cm',
    'neck': 'cm',
    'shoulder': 'cm',
    'chest': 'cm',
    'left_bicep': 'cm',
    'right_bicep': 'cm',
    'left_forearm': 'cm',
    'right_forearm': 'cm',
    'left_thigh': 'cm',
    'right_thigh': 'cm',
    'left_calf': 'cm',
    'right_calf': 'cm',
  };

  @override
  void initState() {
    super.initState();
    for (var key in _measurementTypes.keys) {
      _controllers[key] = TextEditingController();
    }
  }

  @override
  void dispose() {
    _controllers.forEach((key, controller) => controller.dispose());
    super.dispose();
  }

  void _saveSession() async {
    final List<Measurement> measurements = [];
    _controllers.forEach((key, controller) {
      if (controller.text.isNotEmpty) {
        final value = double.tryParse(controller.text.replaceAll(',', '.'));
        if (value != null) {
          measurements.add(Measurement(
            sessionId: 0,
            type: key,
            value: value,
            unit: _measurementTypes[key]!,
          ));
        }
      }
    });

    if (measurements.isNotEmpty) {
      final session = MeasurementSession(
          timestamp: _selectedDateTime, measurements: measurements);
      await DatabaseHelper.instance.insertMeasurementSession(session);
      if (mounted) {
        Navigator.of(context).pop(true);
      }
    } else {
      if (mounted) Navigator.of(context).pop(false);
    }
  }

  String _getLocalizedMeasurementName(String key, AppLocalizations l10n) {
    switch (key) {
      case 'weight':
        return l10n.measurementWeight;
      case 'fat_percent':
        return l10n.measurementFatPercent;
      case 'neck':
        return l10n.measurementNeck;
      case 'shoulder':
        return l10n.measurementShoulder;
      case 'chest':
        return l10n.measurementChest;
      case 'left_bicep':
        return l10n.measurementLeftBicep;
      case 'right_bicep':
        return l10n.measurementRightBicep;
      case 'left_forearm':
        return l10n.measurementLeftForearm;
      case 'right_forearm':
        return l10n.measurementRightForearm;
      case 'abdomen':
        return l10n.measurementAbdomen;
      case 'waist':
        return l10n.measurementWaist;
      case 'hips':
        return l10n.measurementHips;
      case 'left_thigh':
        return l10n.measurementLeftThigh;
      case 'right_thigh':
        return l10n.measurementRightThigh;
      case 'left_calf':
        return l10n.measurementLeftCalf;
      case 'right_calf':
        return l10n.measurementRightCalf;
      default:
        return key;
    }
  }

  Future<void> _selectDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDateTime,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (picked != null && picked != _selectedDateTime) {
      setState(() {
        _selectedDateTime = DateTime(picked.year, picked.month, picked.day,
            _selectedDateTime.hour, _selectedDateTime.minute);
      });
    }
  }

  Future<void> _selectTime() async {
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(_selectedDateTime),
    );
    if (picked != null) {
      setState(() {
        _selectedDateTime = DateTime(
            _selectedDateTime.year,
            _selectedDateTime.month,
            _selectedDateTime.day,
            picked.hour,
            picked.minute);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final textTheme = Theme.of(context).textTheme;

    final formattedDate = DateFormat('dd.MM.yyyy').format(_selectedDateTime);
    final formattedTime = DateFormat.Hm().format(_selectedDateTime);

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.addMeasurementDialogTitle),
        actions: [
          TextButton(
            onPressed: _saveSession,
            style: TextButton.styleFrom(
              foregroundColor: Theme.of(context).appBarTheme.foregroundColor,
            ),
            child: Text(l10n.save),
          ),
        ],
      ),
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: SingleChildScrollView(
        padding: DesignConstants.cardPadding,
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Datum & Uhrzeit Sektion
              Text(l10n.date_and_time_of_measurement,
                  style: textTheme.titleMedium),
              SizedBox(height: DesignConstants.spacingS),
              SummaryCard(
                // KORREKTUR 2: Datum/Uhrzeit in SummaryCard
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                      horizontal: 16.0, vertical: 8.0),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      InkWell(
                          onTap: _selectDate,
                          child: Row(children: [
                            const Icon(Icons.calendar_today, size: 20),
                            const SizedBox(width: 8),
                            Text(formattedDate,
                                style: const TextStyle(fontSize: 16))
                          ])),
                      InkWell(
                          onTap: _selectTime,
                          child: Row(children: [
                            const Icon(Icons.access_time, size: 20),
                            const SizedBox(width: 8),
                            Text(formattedTime,
                                style: const TextStyle(fontSize: 16))
                          ])),
                    ],
                  ),
                ),
              ),
              SizedBox(height: DesignConstants.spacingXL), // KORREKTUR 3: Abstand angepasst

              // Messwerte-Sektion
              Text(l10n.drawerMeasurements,
                  style: textTheme.titleMedium), // TODO: Lokalisieren
              SizedBox(height: DesignConstants.spacingS),
              ..._measurementTypes.keys.map((key) {
                return Padding(
                  padding: const EdgeInsets.only(
                      bottom: 12.0), // KORREKTUR 4: Padding angepasst
                  child: TextFormField(
                    controller: _controllers[key],
                    decoration: InputDecoration(
                      labelText: _getLocalizedMeasurementName(key, l10n),
                      suffixText: _measurementTypes[key],
                    ),
                    keyboardType:
                        const TextInputType.numberWithOptions(decimal: true),
                    validator: (value) {
                      // Nur validieren, wenn etwas eingegeben wurde
                      if (value != null &&
                          value.isNotEmpty &&
                          double.tryParse(value.replaceAll(',', '.')) == null) {
                        return l10n.validatorPleaseEnterNumber;
                      }
                      return null;
                    },
                  ),
                );
              }),
              SizedBox(height: DesignConstants.spacingL), // Abstand zum Ende
            ],
          ),
        ),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\create_exercise_screen.dart =====

// lib/screens/create_exercise_screen.dart
import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/design_constants.dart';

class CreateExerciseScreen extends StatefulWidget {
  const CreateExerciseScreen({super.key});
  @override
  State<CreateExerciseScreen> createState() => _CreateExerciseScreenState();
}

class _CreateExerciseScreenState extends State<CreateExerciseScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _primaryMusclesController = TextEditingController();
  final _secondaryMusclesController = TextEditingController();

  final List<String> _categories = ["Kraft", "Cardio", "Dehnen", "Sonstiges"];
  late final l10n = AppLocalizations.of(context)!;
  late String _selectedCategory;

  @override
  void initState() {
    super.initState();
    _selectedCategory = _categories.first;
  }

  @override
  void dispose() {
    _nameController.dispose();
    _descriptionController.dispose();
    _primaryMusclesController.dispose();
    _secondaryMusclesController.dispose();
    super.dispose();
  }

  void _saveExercise() async {
    if (_formKey.currentState!.validate()) {
      final newExercise = Exercise(
        nameDe: _nameController.text, // Speichern als deutscher Name
        nameEn: _nameController.text, // Und auch als englischer Fallback
        descriptionDe: _descriptionController.text,
        descriptionEn: _descriptionController.text,
        categoryName: _selectedCategory,
        primaryMuscles: _primaryMusclesController.text
            .split(',')
            .map((e) => e.trim())
            .where((e) => e.isNotEmpty)
            .toList(),
        secondaryMuscles: _secondaryMusclesController.text
            .split(',')
            .map((e) => e.trim())
            .where((e) => e.isNotEmpty)
            .toList(),
      );

      await WorkoutDatabaseHelper.instance.insertExercise(newExercise);
      if (mounted) Navigator.of(context).pop(true);
    }
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.create_exercise_screen_title),
        backgroundColor: colorScheme.primary,
        foregroundColor: colorScheme.onPrimary,
        actions: [
          IconButton(
            icon: const Icon(Icons.check),
            onPressed: _saveExercise,
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: DesignConstants.cardPadding,
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              TextFormField(
                controller: _nameController,
                decoration:
                    InputDecoration(labelText: l10n.exercise_name_label),
                validator: (value) => value == null || value.isEmpty
                    ? "Bitte einen Namen eingeben."
                    : null,
              ),
              SizedBox(height: DesignConstants.spacingL),
              DropdownButtonFormField<String>(
                initialValue: _selectedCategory,
                decoration: InputDecoration(labelText: l10n.category_label),
                items: _categories
                    .map(
                        (cat) => DropdownMenuItem(value: cat, child: Text(cat)))
                    .toList(),
                onChanged: (value) {
                  if (value != null) setState(() => _selectedCategory = value);
                },
              ),
              SizedBox(height: DesignConstants.spacingL),
              TextFormField(
                controller: _descriptionController,
                decoration:
                    InputDecoration(labelText: l10n.description_optional_label),
                maxLines: 3,
              ),
              SizedBox(height: DesignConstants.spacingL),
              TextFormField(
                controller: _primaryMusclesController,
                decoration: InputDecoration(
                    labelText: l10n.primary_muscles_label,
                    hintText: l10n.primary_muscles_hint),
              ),
              SizedBox(height: DesignConstants.spacingL),
              TextFormField(
                controller: _secondaryMusclesController,
                decoration: InputDecoration(
                    labelText: l10n.secondary_muscles_label,
                    hintText: l10n.secondary_muscles_hint),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\create_food_screen.dart =====

// lib/screens/create_food_screen.dart (Final & De-Materialisiert)

import 'package:flutter/material.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/util/design_constants.dart';

class CreateFoodScreen extends StatefulWidget {
  const CreateFoodScreen({super.key});

  @override
  State<CreateFoodScreen> createState() => _CreateFoodScreenState();
}

class _CreateFoodScreenState extends State<CreateFoodScreen> {
  final _formKey = GlobalKey<FormState>();

  final _nameController = TextEditingController();
  final _brandController = TextEditingController();
  final _caloriesController = TextEditingController();
  final _proteinController = TextEditingController();
  final _carbsController = TextEditingController();
  final _fatController = TextEditingController();
  final _sugarController = TextEditingController();
  final _fiberController = TextEditingController();
  final _saltController = TextEditingController();

  @override
  void dispose() {
    _nameController.dispose();
    _brandController.dispose();
    _caloriesController.dispose();
    _proteinController.dispose();
    _carbsController.dispose();
    _fatController.dispose();
    _sugarController.dispose();
    _fiberController.dispose();
    _saltController.dispose();
    super.dispose();
  }

  Future<void> _saveFoodItem() async {
    if (_formKey.currentState?.validate() ?? false) {
      final l10n = AppLocalizations.of(context)!;

      final newFoodItem = FoodItem(
        barcode: "user_created_${DateTime.now().millisecondsSinceEpoch}",
        name: _nameController.text,
        brand: _brandController.text,
        calories: int.tryParse(_caloriesController.text) ?? 0,
        protein: double.tryParse(_proteinController.text) ?? 0.0,
        carbs: double.tryParse(_carbsController.text) ?? 0.0,
        fat: double.tryParse(_fatController.text) ?? 0.0,
        sugar: double.tryParse(_sugarController.text),
        fiber: double.tryParse(_fiberController.text),
        salt: double.tryParse(_saltController.text),
        source: FoodItemSource.user,
      );

      await ProductDatabaseHelper.instance.insertProduct(newFoodItem);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(l10n.snackbarSaveSuccess(newFoodItem.name))),
        );
        Navigator.of(context).pop();
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      // KORREKTUR: Eine AppBar hinzugefügt, die den Titel und den Speicher-Button enthält
      appBar: AppBar(
        title: Text(l10n.createFoodScreenTitle),
        actions: [
          // Speicher-Button ist jetzt ein Action-Button in der AppBar
          TextButton(
            onPressed: _saveFoodItem,
            child: Text(l10n.buttonSave),
          )
        ],
      ),
      body: SingleChildScrollView(
        padding: DesignConstants.cardPadding,
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // KORREKTUR: Der alte Header wurde aus dem Body entfernt

              // Formularfelder (unverändert)
              _buildFoodInputField(
                  controller: _nameController,
                  label: l10n.formFieldName,
                  isRequired: true),
              _buildFoodInputField(
                  controller: _brandController, label: l10n.formFieldBrand),

              SizedBox(height: DesignConstants.spacingXL),
              _buildSectionTitle(context, l10n.formSectionMainNutrients),
              SizedBox(height: DesignConstants.spacingL),
              _buildFoodInputField(
                  controller: _caloriesController,
                  label: l10n.formFieldCalories),
              _buildFoodInputField(
                  controller: _proteinController, label: l10n.formFieldProtein),
              _buildFoodInputField(
                  controller: _carbsController, label: l10n.formFieldCarbs),
              _buildFoodInputField(
                  controller: _fatController, label: l10n.formFieldFat),

              SizedBox(height: DesignConstants.spacingXL),
              _buildSectionTitle(context, l10n.formSectionOptionalNutrients),
              SizedBox(height: DesignConstants.spacingL),
              _buildFoodInputField(
                  controller: _sugarController, label: l10n.formFieldSugar),
              _buildFoodInputField(
                  controller: _fiberController, label: l10n.formFieldFiber),
              _buildFoodInputField(
                  controller: _saltController, label: l10n.formFieldSalt),

              const SizedBox(height: 32),
            ],
          ),
        ),
      ),
    );
  }

  // ... (die restlichen _build-Methoden bleiben unverändert hier drin)
  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildFoodInputField({
    required TextEditingController controller,
    required String label,
    bool isRequired = false,
  }) {
    final l10n = AppLocalizations.of(context)!;
    return Padding(
      padding: const EdgeInsets.only(bottom: 12.0),
      child: TextFormField(
        controller: controller,
        decoration: InputDecoration(
          labelText: label,
        ),
        keyboardType: const TextInputType.numberWithOptions(decimal: true),
        validator: (value) {
          if (isRequired && (value == null || value.isEmpty)) {
            return l10n.validatorPleaseEnterName;
          }
          if (value != null &&
              value.isNotEmpty &&
              double.tryParse(value) == null) {
            return l10n.validatorPleaseEnterNumber;
          }
          return null;
        },
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\data_management_screen.dart =====

// lib/screens/data_management_screen.dart (Final & Vollständig)

import 'package:flutter/material.dart';
import 'package:file_picker/file_picker.dart';
import 'package:lightweight/data/backup_manager.dart';
import 'package:lightweight/data/import_manager.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/exercise_mapping_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:shared_preferences/shared_preferences.dart'; // NEU
import 'package:flutter/services.dart'; // NEU (Clipboard)

class DataManagementScreen extends StatefulWidget {
  const DataManagementScreen({super.key});

  @override
  State<DataManagementScreen> createState() => _DataManagementScreenState();
}

class _DataManagementScreenState extends State<DataManagementScreen> {
  // Lade-Zustände für die verschiedenen Aktionen
  bool _isFullBackupRunning = false;
  bool _isCsvExportRunning = false;
  bool _isMigrationRunning = false;
  String? _autoBackupDir; // NEU
  @override
  void initState() {
    super.initState();
    _loadAutoBackupDir(); // NEU
  }

  Future<void> _loadAutoBackupDir() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _autoBackupDir = prefs.getString('auto_backup_dir');
    });
  }

  // --- UNVERÄNDERT: Logik für Komplett-Backup ---
  void _performFullExport() async {
    setState(() => _isFullBackupRunning = true);
    final success = await BackupManager().exportFullBackup();
    if (!mounted) return;
    setState(() => _isFullBackupRunning = false);

    final l10n = AppLocalizations.of(context)!;
    if (success) {
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(l10n.snackbarExportSuccess)));
    } else {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: Text(l10n.snackbarExportFailed),
          backgroundColor: Colors.orange));
    }
  }

  void _performFullImport() async {
    final result = await FilePicker.platform
        .pickFiles(type: FileType.custom, allowedExtensions: ['json']);
    if (result == null || result.files.single.path == null) return;

    final filePath = result.files.single.path!;
    final l10n = AppLocalizations.of(context)!;

    final bool? confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.dialogConfirmTitle),
        content: Text(l10n.dialogConfirmImportContent),
        actions: [
          TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: Text(l10n.dialogButtonCancel)),
          FilledButton(
            style: FilledButton.styleFrom(
                backgroundColor: Theme.of(context).colorScheme.error),
            onPressed: () => Navigator.of(context).pop(true),
            child: Text(l10n.dialogButtonOverwrite),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      setState(() => _isFullBackupRunning = true);
      bool success = await BackupManager().importFullBackupAuto(filePath);
      if (!success) {
        // ggf. verschlüsselte Datei – Passwort abfragen und erneut versuchen
        final pw = await _askPassword(title: 'Enter password to import backup');
        if (pw != null && pw.isNotEmpty) {
          success = await BackupManager()
              .importFullBackupAuto(filePath, passphrase: pw);
        }
      }
      if (!mounted) return;
      setState(() => _isFullBackupRunning = false);
      if (!mounted) return;
      setState(() => _isFullBackupRunning = false);

      if (success) {
        // Neu: Unbekannte Übungsnamen ermitteln und ggf. Mapping anbieten
        final unknown =
            await WorkoutDatabaseHelper.instance.findUnknownExerciseNames();
        if (mounted && unknown.isNotEmpty) {
          final bool? changed = await Navigator.of(context).push<bool>(
            MaterialPageRoute(
                builder: (_) => ExerciseMappingScreen(unknownNames: unknown)),
          );
          // Optional: Nach Anwendung erneut prüfen/refreshen, aber keine Pflicht.
        }

        await showDialog(
          context: context,
          barrierDismissible: false,
          builder: (context) => AlertDialog(
            title: Text(l10n.snackbarImportSuccessTitle),
            content: Text(l10n.snackbarImportSuccessContent),
            actions: [
              FilledButton(
                onPressed: () => Navigator.of(context).pop(),
                child: Text(l10n.snackbarButtonOK),
              ),
            ],
          ),
        );
      } else {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(
            content: Text(l10n.snackbarImportError),
            backgroundColor: Colors.red));
      }
    }
  }

  // --- UNVERÄNDERT: Logik für Hevy-Import ---
  void _performHevyImport() async {
    setState(() => _isMigrationRunning = true);
    final count = await ImportManager().importHevyCsv();
    if (!mounted) return;
    setState(() => _isMigrationRunning = false);

    if (count > 0) {
      final unknown =
          await WorkoutDatabaseHelper.instance.findUnknownExerciseNames();
      if (mounted && unknown.isNotEmpty) {
        await Navigator.of(context).push(
          MaterialPageRoute(
              builder: (_) => ExerciseMappingScreen(unknownNames: unknown)),
        );
      }
    }
    final l10n = AppLocalizations.of(context)!;
    if (count > 0) {
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(l10n.hevyImportSuccess(count))));
    } else {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: Text(l10n.hevyImportFailed), backgroundColor: Colors.red));
    }
  }

  // --- NEU: Helfer-Methode für alle CSV-Exporte ---
  void _exportCsv(Future<bool> Function() exportFunction, String successMessage,
      String failureMessage) async {
    setState(() => _isCsvExportRunning = true);
    final success = await exportFunction();
    if (!mounted) return;
    setState(() => _isCsvExportRunning = false);

    if (success) {
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(successMessage)));
    } else {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: Text(failureMessage), backgroundColor: Colors.orange));
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true, // <- zeigt den Zurück-Pfeil
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          "Data Hub",
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: DesignConstants.cardPadding,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // --- bestehender Inhalt bleibt unverändert ---
              _buildFullBackupCard(context, l10n, theme),
              SizedBox(height: DesignConstants.spacingL),
              _buildAutoBackupCard(context, l10n, theme),
              SizedBox(height: DesignConstants.spacingL),
              _buildCsvExportCard(context, l10n, theme),
              SizedBox(height: DesignConstants.spacingL),
              _buildMigrationCard(context, l10n, theme),
              SizedBox(height: DesignConstants.spacingL),
              _buildExerciseMappingCard(context, l10n, theme),
            ],
          ),
        ),
      ),
    );
  }
  // --- WIDGET BUILDER ---

  Widget _buildFullBackupCard(
      BuildContext context, AppLocalizations l10n, ThemeData theme) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text("Lightweight Datensicherung",
                style: theme.textTheme.headlineSmall),
            SizedBox(height: DesignConstants.spacingS),
            Text(
                "Sichere oder wiederherstelle alle deine App-Daten. Ideal für einen Gerätewechsel.",
                style: theme.textTheme.bodyMedium),
            SizedBox(height: DesignConstants.spacingL),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    icon: const Icon(Icons.upload_file),
                    label: Text(l10n.data_export_button),
                    onPressed: _isFullBackupRunning ? null : _performFullExport,
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton.icon(
                    icon: const Icon(Icons.download_for_offline),
                    label: Text(l10n.data_import_button),
                    style: FilledButton.styleFrom(
                        backgroundColor: theme.colorScheme.error),
                    onPressed: _isFullBackupRunning ? null : _performFullImport,
                  ),
                ),
              ],
            ),
            SizedBox(height: DesignConstants.spacingS),
// NEU: Verschlüsselt exportieren
            SizedBox(
              width: double.infinity,
              child: OutlinedButton.icon(
                icon: const Icon(Icons.lock_outline),
                label: const Text('Verschlüsselt exportieren'),
                onPressed: _isFullBackupRunning
                    ? null
                    : () async {
                        final pw = await _askPassword(
                            title: 'Password for encrypted export');
                        if (pw == null || pw.isEmpty) return;
                        setState(() => _isFullBackupRunning = true);
                        final ok =
                            await BackupManager().exportFullBackupEncrypted(pw);
                        if (!mounted) return;
                        setState(() => _isFullBackupRunning = false);
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                              content: Text(ok
                                  ? 'Verschlüsseltes Backup geteilt.'
                                  : 'Export fehlgeschlagen.')),
                        );
                      },
              ),
            ),

            if (_isFullBackupRunning)
              const Padding(
                padding: EdgeInsets.only(top: 16.0),
                child: Center(child: CircularProgressIndicator()),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildCsvExportCard(
      BuildContext context, AppLocalizations l10n, ThemeData theme) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text("Daten-Export (CSV)", style: theme.textTheme.headlineSmall),
            SizedBox(height: DesignConstants.spacingS),
            Text(
                "Exportiere Teile deiner Daten als CSV-Datei zur Analyse in anderen Programmen.",
                style: theme.textTheme.bodyMedium),
            SizedBox(height: DesignConstants.spacingS),
            _buildExportTile(
              icon: Icons.restaurant_menu,
              title: "Ernährungstagebuch",
              onTap: _isCsvExportRunning
                  ? null
                  : () => _exportCsv(
                      BackupManager().exportNutritionAsCsv,
                      "Ernährungstagebuch wird geteilt...",
                      "Export fehlgeschlagen. Eventuell existieren noch keine Einträge."),
            ),
            _buildExportTile(
              icon: Icons.monitor_weight_outlined,
              title: "Messwerte",
              onTap: _isCsvExportRunning
                  ? null
                  : () => _exportCsv(
                      BackupManager().exportMeasurementsAsCsv,
                      "Messwerte werden geteilt...",
                      "Export fehlgeschlagen. Eventuell existieren noch keine Einträge."),
            ),
            _buildExportTile(
              icon: Icons.fitness_center,
              title: "Trainingsverlauf",
              onTap: _isCsvExportRunning
                  ? null
                  : () => _exportCsv(
                      BackupManager().exportWorkoutsAsCsv,
                      "Trainingsverlauf wird geteilt...",
                      "Export fehlgeschlagen. Eventuell existieren noch keine Einträge."),
            ),
            if (_isCsvExportRunning)
              const Padding(
                padding: EdgeInsets.only(top: 16.0),
                child: Center(child: CircularProgressIndicator()),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildMigrationCard(
      BuildContext context, AppLocalizations l10n, ThemeData theme) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.hevyImportTitle, style: theme.textTheme.headlineSmall),
            SizedBox(height: DesignConstants.spacingS),
            Text(l10n.hevyImportDescription, style: theme.textTheme.bodyMedium),
            SizedBox(height: DesignConstants.spacingL),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                icon: const Icon(Icons.sync_alt),
                label: Text(l10n.hevyImportButton),
                onPressed: _isMigrationRunning ? null : _performHevyImport,
              ),
            ),
            if (_isMigrationRunning)
              const Padding(
                padding: EdgeInsets.only(top: 16.0),
                child: Center(child: CircularProgressIndicator()),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildExportTile(
      {required IconData icon,
      required String title,
      required VoidCallback? onTap}) {
    return ListTile(
      leading: Icon(icon),
      title: Text(title),
      trailing: const Icon(Icons.chevron_right),
      onTap: onTap,
      contentPadding: EdgeInsets.zero,
    );
  }

  Widget _buildExerciseMappingCard(
      BuildContext context, AppLocalizations l10n, ThemeData theme) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Übungen zuordnen', style: theme.textTheme.headlineSmall),
            SizedBox(height: DesignConstants.spacingS),
            Text(
              'Unbekannte Namen aus Logs auf wger-Übungen mappen.',
              style: theme.textTheme.bodyMedium,
            ),
            SizedBox(height: DesignConstants.spacingL),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                icon: const Icon(Icons.rule_folder_outlined),
                label: const Text('Mapping starten'),
                onPressed: _openExerciseMapping,
              ),
            ),
          ],
        ),
      ),
    );
  }

// lib/screens/data_management_screen.dart – Auszug: neue Card
  Widget _buildAutoBackupCard(
      BuildContext context, AppLocalizations l10n, ThemeData theme) {
    return SummaryCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Automatische Backups', style: theme.textTheme.headlineSmall),
            SizedBox(height: DesignConstants.spacingS),
            Text(
              'Legt periodisch eine Sicherung im Ordner ab. Derzeitiger Ordner:',
              style: theme.textTheme.bodyMedium,
            ),
            SizedBox(height: DesignConstants.spacingS),
            SelectableText(
              _autoBackupDir ?? 'App-Dokumente/Backups (Standard)',
              style: theme.textTheme.bodySmall,
            ),
            SizedBox(height: DesignConstants.spacingM),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    icon: const Icon(Icons.folder_open),
                    label: const Text('Ordner wählen'),
                    onPressed: _pickAutoBackupDirectory,
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: OutlinedButton.icon(
                    icon: const Icon(Icons.copy),
                    label: const Text('Pfad kopieren'),
                    onPressed:
                        (_autoBackupDir == null || _autoBackupDir!.isEmpty)
                            ? null
                            : _copyAutoBackupPathToClipboard,
                  ),
                ),
              ],
            ),
            SizedBox(height: DesignConstants.spacingM),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                icon: const Icon(Icons.backup),
                label: const Text('Jetzt Auto-Backup prüfen & ausführen'),
                onPressed: () async {
                  final ok = await BackupManager().runAutoBackupIfDue(
                    interval: const Duration(days: 1),
                    encrypted: false,
                    passphrase: null,
                    retention: 7,
                    dirPath: _autoBackupDir,
                    force: true, // NEU: sofort ausführen
                  );
                  if (!mounted) return;
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                        content: Text(ok
                            ? 'Auto-Backup durchgeführt.'
                            : 'Auto-Backup fehlgeschlagen oder abgebrochen.')),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _openExerciseMapping() async {
    final unknown =
        await WorkoutDatabaseHelper.instance.findUnknownExerciseNames();
    if (!mounted) return;
    if (unknown.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Keine unbekannten Übungen gefunden')),
      );
      return;
    }
    await Navigator.of(context).push(
      MaterialPageRoute(
          builder: (_) => ExerciseMappingScreen(unknownNames: unknown)),
    );
  }

  Future<void> _pickAutoBackupDirectory() async {
    // Directory-Picker (FilePicker unterstützt getDirectoryPath)
    final path = await FilePicker.platform.getDirectoryPath();
    if (path == null) return;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('auto_backup_dir', path);
    setState(() => _autoBackupDir = path);
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Auto-Backup-Ordner gesetzt:\n$path')),
    );
  }

  Future<void> _copyAutoBackupPathToClipboard() async {
    final path = _autoBackupDir;
    if (path == null || path.isEmpty) return;
    await Clipboard.setData(ClipboardData(text: path));
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Pfad kopiert')),
    );
  }

  Future<String?> _askPassword({required String title}) async {
    final controller = TextEditingController();
    bool obscure = true;
    return showDialog<String>(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: Text(title),
          content: TextField(
            controller: controller,
            obscureText: obscure,
            decoration: InputDecoration(
              labelText: 'Password',
              suffixIcon: IconButton(
                icon: Icon(obscure ? Icons.visibility_off : Icons.visibility),
                onPressed: () => setState(() => obscure = !obscure),
              ),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(null),
              child: const Text('Cancel'),
            ),
            FilledButton(
              onPressed: () =>
                  Navigator.of(context).pop(controller.text.trim()),
              child: const Text('OK'),
            ),
          ],
        ),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\edit_routine_screen.dart =====

// lib/screens/edit_routine_screen.dart (Final & De-Materialisiert)

import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/models/routine_exercise.dart';
import 'package:lightweight/models/set_template.dart';
import 'package:lightweight/screens/exercise_catalog_screen.dart';
import 'package:lightweight/screens/exercise_detail_screen.dart';
import 'package:lightweight/util/design_constants.dart';
// Zum Starten der Routine
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/set_type_chip.dart';
import 'package:lightweight/widgets/summary_card.dart'; // HINZUGEFÜGT
import 'package:lightweight/widgets/wger_attribution_widget.dart'; // HINZUGEFÜGT

class EditRoutineScreen extends StatefulWidget {
  final Routine? routine;
  const EditRoutineScreen({super.key, this.routine});

  @override
  State<EditRoutineScreen> createState() => _EditRoutineScreenState();
}

class _EditRoutineScreenState extends State<EditRoutineScreen> {
  final _nameController = TextEditingController();
  List<RoutineExercise> _routineExercises = [];
  bool _isNewRoutine = true;
  int? _routineId;
  String _originalName = '';
  bool _isLoading = false;
  final Map<int, TextEditingController> _repsControllers = {};
  final Map<int, TextEditingController> _weightControllers = {};
  // HINZUGEFÜGT: Für die Animation der Übungsblöcke (eingeklappt beim Drag)
  final Map<int, bool> _exerciseExpanded = {};

  @override
  void initState() {
    super.initState();
    if (widget.routine != null) {
      _isNewRoutine = false;
      _routineId = widget.routine!.id;
      _nameController.text = widget.routine!.name;
      _originalName = widget.routine!.name;
      _loadExercisesForRoutine();
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    for (var c in _repsControllers.values) {
      c.dispose();
    }
    for (var c in _weightControllers.values) {
      c.dispose();
    }
    super.dispose();
  }

  Future<void> _loadExercisesForRoutine() async {
    if (_routineId == null) return;
    setState(() => _isLoading = true);
    final routineWithExercises =
        await WorkoutDatabaseHelper.instance.getRoutineById(_routineId!);
    if (mounted && routineWithExercises != null) {
      // Bereinige alte Controller, bevor neue erstellt werden
      for (var c in _repsControllers.values) {
        c.dispose();
      }
      for (var c in _weightControllers.values) {
        c.dispose();
      }
      _repsControllers.clear();
      _weightControllers.clear();

      for (var re in routineWithExercises.exercises) {
        for (var st in re.setTemplates) {
          _repsControllers[st.id!] = TextEditingController(text: st.targetReps);
          _weightControllers[st.id!] =
              TextEditingController(text: st.targetWeight?.toString() ?? '');
        }
      }

      setState(() {
        _routineExercises = routineWithExercises.exercises;
        _isLoading = false;
      });
    } else if (mounted) {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _addExercises() async {
    if (_isNewRoutine) {
      final success = await _saveRoutine(isAddingExercise: true);
      if (!success) return;
    }
    if (!mounted) return;
    final selectedExercise = await Navigator.of(context).push<Exercise>(
        MaterialPageRoute(
            builder: (context) =>
                const ExerciseCatalogScreen(isSelectionMode: true)));

    if (selectedExercise != null && _routineId != null) {
      // KORREKTUR: Lade nicht die ganze Liste neu. Füge nur die neue Übung zum lokalen State hinzu.
      final newRoutineExercise = await WorkoutDatabaseHelper.instance
          .addExerciseToRoutine(_routineId!, selectedExercise.id!);
      if (newRoutineExercise != null) {
        // Erstelle die Controller für die neuen Sätze
        for (var st in newRoutineExercise.setTemplates) {
          _repsControllers[st.id!] = TextEditingController(text: st.targetReps);
          _weightControllers[st.id!] =
              TextEditingController(text: st.targetWeight?.toString() ?? '');
        }
        setState(() {
          _routineExercises.add(newRoutineExercise);
        });
      }
    }
  }

  Future<bool> _saveRoutine({bool isAddingExercise = false}) async {
    final l10n = AppLocalizations.of(context)!;
    FocusScope.of(context).unfocus();

    if (_nameController.text.trim().isEmpty) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(l10n.validatorPleaseEnterRoutineName)));
      }
      return false;
    }

    int? currentRoutineId = _routineId;

    if (_isNewRoutine) {
      final newRoutine = await WorkoutDatabaseHelper.instance
          .createRoutine(_nameController.text.trim());
      currentRoutineId = newRoutine.id;
      if (mounted) {
        setState(() {
          _routineId = newRoutine.id;
          _isNewRoutine = false;
          _originalName = newRoutine.name;
        });
      }
      if (mounted && !isAddingExercise) {
        ScaffoldMessenger.of(context)
            .showSnackBar(SnackBar(content: Text(l10n.snackbarRoutineCreated)));
      }
    } else {
      if (_nameController.text.trim() != _originalName) {
        await WorkoutDatabaseHelper.instance
            .updateRoutineName(currentRoutineId!, _nameController.text.trim());
      }
    }

    // KORREKTUR: Robuste Speicherlogik für Sätze
    final db = WorkoutDatabaseHelper.instance;
    for (var re in _routineExercises) {
      // 1. Sammle den aktuellen Zustand der Sätze aus den Controllern
      final List<SetTemplate> currentTemplates = [];
      for (var set in re.setTemplates) {
        currentTemplates.add(set.copyWith(
            targetReps: _repsControllers[set.id!]?.text,
            targetWeight: double.tryParse(
                _weightControllers[set.id!]!.text.replaceAll(',', '.'))));
      }
      // 2. Ersetze alle Sätze in der DB mit dem aktuellen Zustand
      await db.replaceSetTemplatesForExercise(re.id!, currentTemplates);
    }

    if (mounted && !isAddingExercise) {
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(l10n.snackbarRoutineSaved)));
      Navigator.of(context).pop(true);
    }
    return true;
  }

  // --- NEUE METHODEN FÜR DIE DIREKTE BEARBEITUNG ---
  void _addSet(RoutineExercise routineExercise) {
    setState(() {
      final newSet = SetTemplate(
          id: DateTime.now().millisecondsSinceEpoch,
          setType: 'normal',
          targetReps: '8-12');
      routineExercise.setTemplates.add(newSet);
      _repsControllers[newSet.id!] =
          TextEditingController(text: newSet.targetReps);
      _weightControllers[newSet.id!] = TextEditingController();
    });
  }

  void _removeSet(
      RoutineExercise routineExercise, int setTemplateId, int index) {
    setState(() {
      routineExercise.setTemplates.removeAt(index);
      _repsControllers.remove(setTemplateId)?.dispose();
      _weightControllers.remove(setTemplateId)?.dispose();
      // TODO: Markiere für späteres Löschen aus DB in _saveRoutine
      // _setsToDelete.add(setTemplateId);
    });
  }

  void _changeSetType(SetTemplate setTemplate, String newType) {
    setState(() {
      // Da SetTemplate immutable ist, müssen wir die Liste modifizieren
      final re = _routineExercises
          .firstWhere((re) => re.setTemplates.contains(setTemplate));
      final setIndex = re.setTemplates.indexOf(setTemplate);
      re.setTemplates[setIndex] = setTemplate.copyWith(setType: newType);
    });
    Navigator.pop(context);
  }

  void _showSetTypePicker(SetTemplate setTemplate) {
    showModalBottomSheet(
      context: context,
      builder: (context) {
        return Wrap(
          children: <Widget>[
            ListTile(
                title: const Text('Normal'),
                onTap: () => _changeSetType(setTemplate, 'normal')),
            ListTile(
                title: const Text('Warmup'),
                onTap: () => _changeSetType(setTemplate, 'warmup')),
            ListTile(
                title: const Text('Failure'),
                onTap: () => _changeSetType(setTemplate, 'failure')),
            ListTile(
                title: const Text('Dropset'),
                onTap: () => _changeSetType(setTemplate, 'dropset')),
          ],
        );
      },
    );
  }

  // NEUE METHODE: Zeigt den Dialog zum Bearbeiten der Pausenzeit
  void _editPauseTime(RoutineExercise routineExercise) async {
    final l10n = AppLocalizations.of(context)!;
    final controller = TextEditingController(
        text: routineExercise.pauseSeconds?.toString() ?? '');

    final result = await showDialog<int?>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.editPauseTimeTitle),
        content: TextField(
          controller: controller,
          keyboardType: TextInputType.number,
          decoration: InputDecoration(
            labelText: l10n.pauseInSeconds,
          ),
        ),
        actions: [
          TextButton(
              onPressed: () => Navigator.of(ctx).pop(),
              child: Text(l10n.cancel)),
          FilledButton(
              onPressed: () {
                final seconds = int.tryParse(controller.text);
                Navigator.of(ctx).pop(seconds);
              },
              child: Text(l10n.save)),
        ],
      ),
    );

    if (result != null) {
      await WorkoutDatabaseHelper.instance
          .updatePauseTime(routineExercise.id!, result);
      _loadExercisesForRoutine(); // Lade neu, um die Anzeige zu aktualisieren
    }
  }

  // NEUE METHODE: Kapselt die Logik zum Löschen einer Übung
  void _deleteSingleExercise(RoutineExercise exerciseToDelete) async {
    final l10n = AppLocalizations.of(context)!;
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.deleteExerciseConfirmTitle),
        content: Text(l10n.deleteExerciseConfirmContent(
            exerciseToDelete.exercise.getLocalizedName(context))),
        actions: [
          TextButton(
              onPressed: () => Navigator.of(ctx).pop(false),
              child: Text(l10n.cancel)),
          TextButton(
              onPressed: () => Navigator.of(ctx).pop(true),
              child: Text(l10n.delete)),
        ],
      ),
    );

    if (confirmed == true && _routineId != null) {
      await WorkoutDatabaseHelper.instance
          .removeExerciseFromRoutine(exerciseToDelete.id!);
      _loadExercisesForRoutine();
    }
  }

  // KORREKTUR: onReorder-Logik für Drag-Feedback
  void _onReorder(int oldIndex, int newIndex) {
    setState(() {
      if (newIndex > oldIndex) {
        newIndex -= 1;
      }
      final RoutineExercise item = _routineExercises.removeAt(oldIndex);
      _routineExercises.insert(newIndex, item);
    });
    if (_routineId != null) {
      WorkoutDatabaseHelper.instance
          .updateExerciseOrder(_routineId!, _routineExercises);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          _isNewRoutine ? l10n.titleNewRoutine : l10n.titleEditRoutine,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
        actions: [
          TextButton(
            onPressed: () => _saveRoutine(),
            child: Text(
              l10n.save,
              style: TextStyle(
                color: Theme.of(context).colorScheme.primary,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      body: Column(
        children: [
          Padding(
            padding:
                DesignConstants.screenPadding,
            child: TextFormField(
              controller: _nameController,
              decoration: InputDecoration(labelText: l10n.formFieldRoutineName),
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return l10n.validatorPleaseEnterRoutineName;
                }
                return null;
              },
            ),
          ),
          SizedBox(height: DesignConstants.spacingM),
          Divider(
            height: 1,
            thickness: 1,
            color: colorScheme.onSurfaceVariant.withOpacity(0.1),
          ),
          Expanded(
            child: _isLoading
                ? const Center(child: CircularProgressIndicator())
                : _routineExercises.isEmpty
                    ? Center(
                        child: Text(
                          l10n.emptyStateAddFirstExercise,
                          style: textTheme.titleMedium,
                        ),
                      )
                    : ReorderableListView.builder(
                        padding: DesignConstants.cardMargin,
                        itemCount: _routineExercises.length,
                        proxyDecorator: (Widget child, int index,
                            Animation<double> animation) {
                          return Material(
                            elevation: 4.0,
                            color: Theme.of(context).scaffoldBackgroundColor,
                            child: child,
                          );
                        },
                        onReorder: _onReorder,
                        itemBuilder: (context, index) {
                          final routineExercise = _routineExercises[index];

                          // KORREKTUR: SummaryCard wurde entfernt
                          return Container(
                            key: ValueKey(routineExercise.id),
                            color: Theme.of(context).scaffoldBackgroundColor,
                            margin: DesignConstants.cardMargin,
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                ListTile(
                                  contentPadding: const EdgeInsets.symmetric(
                                      horizontal: 16.0, vertical: 8.0),
                                  title: InkWell(
                                    onTap: () => Navigator.of(context).push(
                                        MaterialPageRoute(
                                            builder: (context) =>
                                                ExerciseDetailScreen(
                                                    exercise: routineExercise
                                                        .exercise))),
                                    child: Padding(
                                      padding: const EdgeInsets.symmetric(
                                          vertical: 4.0),
                                      child: Text(
                                          routineExercise.exercise
                                              .getLocalizedName(context),
                                          style: textTheme.titleLarge),
                                    ),
                                  ),
                                  leading: ReorderableDragStartListener(
                                    index: index,
                                    child: const Icon(Icons.drag_handle),
                                  ),
                                  trailing: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      IconButton(
                                        icon: const Icon(Icons.timer_outlined),
                                        tooltip: l10n.editPauseTime,
                                        onPressed: () =>
                                            _editPauseTime(routineExercise),
                                      ),
                                      IconButton(
                                        icon: const Icon(Icons.delete_outline,
                                            color: Colors.redAccent),
                                        tooltip: l10n.removeExercise,
                                        onPressed: () => _deleteSingleExercise(
                                            routineExercise),
                                      ),
                                    ],
                                  ),
                                ),
                                Divider(
                                    height: 1,
                                    thickness: 1,
                                    color: colorScheme.onSurfaceVariant
                                        .withOpacity(0.1),
                                    indent: 16,
                                    endIndent: 16),
                                Padding(
                                  padding: const EdgeInsets.symmetric(
                                      horizontal: 16.0),
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      if (routineExercise.pauseSeconds !=
                                              null &&
                                          routineExercise.pauseSeconds! > 0)
                                        Padding(
                                          padding: const EdgeInsets.only(
                                              top: 12.0, bottom: 12.0),
                                          child: Text(
                                            l10n.pauseDuration(
                                                routineExercise.pauseSeconds!),
                                            style: textTheme.bodyMedium
                                                ?.copyWith(
                                                    color: Colors.grey[600],
                                                    fontStyle:
                                                        FontStyle.italic),
                                          ),
                                        ),
                                      Row(
                                        children: [
                                          _buildHeader(l10n.setLabel),
                                          const Spacer(),
                                          _buildHeader(l10n.kgLabel),
                                          _buildHeader(l10n.repsLabel),
                                          const SizedBox(width: 48),
                                        ],
                                      ),
                                      const Divider(),
                                      ...routineExercise.setTemplates
                                          .asMap()
                                          .entries
                                          .map((entry) {
                                        final setIndex = entry.key;
                                        final setTemplate = entry.value;
                                        return _buildSetTemplateRow(
                                            setIndex + 1,
                                            routineExercise,
                                            setTemplate,
                                            setIndex);
                                      }),
                                      SizedBox(height: DesignConstants.spacingS),
                                      TextButton.icon(
                                        onPressed: () =>
                                            _addSet(routineExercise),
                                        icon: const Icon(Icons.add),
                                        label: Text(l10n.addSetButton),
                                      ),
                                    ],
                                  ),
                                )
                              ],
                            ),
                          );
                        },
                      ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 24.0, bottom: 8.0),
            child: WgerAttributionWidget(
              textStyle: textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
            ),
          ),
        ],
      ),
      floatingActionButton: GlassFab(
        onPressed: _addExercises,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  Widget _buildSetTemplateRow(
      int setIndex, RoutineExercise re, SetTemplate template, int listIndex) {
    final l10n = AppLocalizations.of(context)!;
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        children: [
          Expanded(
            flex: 2,
            child: SetTypeChip(
              setType: template.setType,
              setIndex: (template.setType == 'warmup') ? null : setIndex,
              onTap: () => _showSetTypePicker(template),
            ),
          ),
          const Spacer(),
          Expanded(
              flex: 3,
              child: TextFormField(
                controller: _weightControllers[template.id!],
                textAlign: TextAlign.center,
                keyboardType:
                    const TextInputType.numberWithOptions(decimal: true),
                decoration:
                    InputDecoration(hintText: l10n.kgLabelShort, isDense: true),
                validator: (value) {
                  if (value != null &&
                      value.isNotEmpty &&
                      double.tryParse(value.replaceAll(',', '.')) == null) {
                    return "!";
                  }
                  return null;
                },
              )),
          const SizedBox(width: 8),
          Expanded(
              flex: 3,
              child: TextFormField(
                controller: _repsControllers[template.id!],
                textAlign: TextAlign.center,
                keyboardType: TextInputType.number,
                decoration: InputDecoration(
                    hintText: l10n.set_reps_hint, isDense: true),
                validator: (value) {
                  if (value != null &&
                      value.isNotEmpty &&
                      int.tryParse(value) == null) {
                    return "!";
                  }
                  return null;
                },
              )),
          SizedBox(
              width: 48,
              child: IconButton(
                  icon:
                      const Icon(Icons.delete_outline, color: Colors.redAccent),
                  onPressed: () => _removeSet(re, template.id!, listIndex))),
        ],
      ),
    );
  }

  Widget _buildHeader(String text) => Expanded(
      child: Text(text,
          textAlign: TextAlign.center,
          style: TextStyle(
              color: Colors.grey[600],
              fontSize: 12,
              fontWeight: FontWeight.bold)));
}


===== Datei: D:\lightweight\lib\screens\exercise_catalog_screen.dart =====

// lib/screens/exercise_catalog_screen.dart (Final & De-Materialisiert)

import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/screens/exercise_detail_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/wger_attribution_widget.dart'; // HINZUGEFÜGT

class ExerciseCatalogScreen extends StatefulWidget {
  final bool isSelectionMode;
  const ExerciseCatalogScreen({super.key, this.isSelectionMode = false});

  @override
  State<ExerciseCatalogScreen> createState() => _ExerciseCatalogScreenState();
}

class _ExerciseCatalogScreenState extends State<ExerciseCatalogScreen> {
  List<Exercise> _foundExercises = [];
  bool _isLoading = true;
  final _searchController = TextEditingController();
  List<String> _allCategories = [];
  List<String> _selectedCategories = [];

  @override
  void initState() {
    super.initState();
    _searchController.addListener(() => _runFilter(_searchController.text));
    _loadCategories();
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  Future<void> _loadCategories() async {
    final categories = await WorkoutDatabaseHelper.instance.getAllCategories();
    setState(() {
      _allCategories = categories;
      _isLoading = false;
    });
    _runFilter(_searchController.text); // Erste Ladung oder Filter
  }

  void _runFilter(String enteredKeyword) async {
    final results = await WorkoutDatabaseHelper.instance.searchExercises(
      query: enteredKeyword,
      selectedCategories: _selectedCategories,
    );
    if (mounted) {
      setState(() {
        _foundExercises = results;
      });
    }
  }

  void _showFilterDialog(BuildContext context, AppLocalizations l10n) {
    showDialog(
      context: context,
      builder: (context) {
        // Lokaler State für die Auswahl im Dialog
        List<String> tempSelectedCategories = List.from(_selectedCategories);
        return StatefulBuilder(
          builder: (context, setStateSB) {
            return AlertDialog(
              // Nutzt globales DialogTheme
              title: Text(l10n.filterByCategory),
              content: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: _allCategories.map((category) {
                    final isSelected =
                        tempSelectedCategories.contains(category);
                    return ListTile(
                      title: Text(category),
                      leading: Checkbox(
                        value: isSelected,
                        onChanged: (bool? value) {
                          setStateSB(() {
                            // State des Dialogs aktualisieren
                            if (value == true) {
                              tempSelectedCategories.add(category);
                            } else {
                              tempSelectedCategories.remove(category);
                            }
                          });
                        },
                      ),
                    );
                  }).toList(),
                ),
              ),
              actions: [
                TextButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: Text(l10n.cancel)),
                ElevatedButton(
                  // Nutzt globales Theme
                  onPressed: () {
                    setState(() {
                      // State des Haupt-Screens aktualisieren
                      _selectedCategories = tempSelectedCategories;
                    });
                    _runFilter(_searchController.text);
                    Navigator.of(context).pop();
                  },
                  child: Text(l10n.doneButtonLabel),
                ),
              ],
            );
          },
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          "Exercises",
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),

      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      // KORREKTUR 1: AppBar entfernt, Titel und Aktionen im Body
// Body ohne doppelten Titel
      body: Column(
        children: [
          Padding(
            padding:
                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 24.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                if (widget.isSelectionMode)
                  Align(
                    alignment: Alignment.centerRight,
                    child: ElevatedButton(
                      onPressed: () => Navigator.of(context).pop(),
                      child: Text(l10n.doneButtonLabel),
                    ),
                  ),
                SizedBox(height: DesignConstants.spacingS),
                TextField(
                  controller: _searchController,
                  decoration: InputDecoration(
                    hintText: l10n.searchHintText,
                    prefixIcon: Icon(Icons.search,
                        color: colorScheme.onSurfaceVariant, size: 20),
                    suffixIcon: _searchController.text.isNotEmpty
                        ? IconButton(
                            icon: Icon(Icons.clear,
                                color: colorScheme.onSurfaceVariant),
                            onPressed: () => _searchController.clear(),
                          )
                        : null,
                  ),
                ),
                SizedBox(height: DesignConstants.spacingL),
                _buildFilterButton(context, l10n),
              ],
            ),
          ),
          Divider(
            height: 1,
            thickness: 1,
            color: colorScheme.onSurfaceVariant.withOpacity(0.1),
          ),
          Expanded(
            child: _isLoading
                ? const Center(child: CircularProgressIndicator())
                : _foundExercises.isEmpty
                    ? Center(
                        child: Text(l10n.noExercisesFound,
                            style: textTheme.titleMedium))
                    : ListView.builder(
                        padding: DesignConstants.cardPadding,
                        itemCount: _foundExercises.length,
                        itemBuilder: (context, index) {
                          final exercise = _foundExercises[index];
                          return SummaryCard(
                            // KORREKTUR 3: Übungs-Card
                            child: ListTile(
                              leading: const Icon(Icons.fitness_center),
                              title: Text(exercise.getLocalizedName(context),
                                  style: const TextStyle(
                                      fontWeight: FontWeight.bold)),
                              subtitle: Text(exercise.categoryName),
                              trailing: widget.isSelectionMode
                                  ? IconButton(
                                      // Auswahl-Modus: Hinzufügen-Icon
                                      icon: Icon(Icons.add_circle_outline,
                                          color: colorScheme.primary),
                                      onPressed: () =>
                                          Navigator.of(context).pop(exercise),
                                    )
                                  : const Icon(Icons
                                      .chevron_right), // Anzeige-Modus: Pfeil
                              onTap: () {
                                if (widget.isSelectionMode) {
                                  // Im Auswahl-Modus: Bei Klick auch auswählen
                                  Navigator.of(context).pop(exercise);
                                } else {
                                  // Im Anzeige-Modus: Detail-Screen öffnen
                                  Navigator.of(context).push(MaterialPageRoute(
                                      builder: (context) =>
                                          ExerciseDetailScreen(
                                              exercise: exercise)));
                                }
                              },
                            ),
                          );
                        },
                      ),
          ),
          // KORREKTUR 4: WgerAttributionWidget am Ende
          Padding(
            padding: const EdgeInsets.only(top: 16.0, bottom: 8.0),
            child: WgerAttributionWidget(
              textStyle: textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
            ),
          ),
        ],
      ),
    );
  }

  // KORREKTUR 5: Helfer-Widget für den Filter-Button
  Widget _buildFilterButton(BuildContext context, AppLocalizations l10n) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final textTheme = theme.textTheme;

    return Padding(
      padding: const EdgeInsets.only(top: 8.0),
      child: GestureDetector(
        onTap: () => _showFilterDialog(context, l10n),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
          decoration: BoxDecoration(
            color: _selectedCategories.isNotEmpty
                ? colorScheme.primary
                : colorScheme.surfaceContainerHighest.withOpacity(0.5),
            borderRadius: BorderRadius.circular(10.0),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.filter_list,
                  size: 20,
                  color: _selectedCategories.isNotEmpty
                      ? colorScheme.onPrimary
                      : colorScheme.onSurfaceVariant),
              const SizedBox(width: 8),
              Text(
                l10n.filterByCategory,
                style: textTheme.labelLarge?.copyWith(
                  color: _selectedCategories.isNotEmpty
                      ? colorScheme.onPrimary
                      : colorScheme.onSurfaceVariant,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\exercise_detail_screen.dart =====

// lib/screens/exercise_detail_screen.dart (Final & De-Materialisiert - Korrigiert)

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/wger_attribution_widget.dart';

class ExerciseDetailScreen extends StatelessWidget {
  final Exercise exercise;
  const ExerciseDetailScreen({super.key, required this.exercise});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final textTheme = Theme.of(context).textTheme;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        automaticallyImplyLeading: true, // <-- zeigt den Zurück-Pfeil
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        title: Text(
          exercise.getLocalizedName(context),
          style: textTheme.headlineSmall?.copyWith(
            fontWeight: FontWeight.w900,
          ),
        ),
      ),
      body: SingleChildScrollView(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              exercise.categoryName,
              style: textTheme.titleMedium?.copyWith(color: Colors.grey[600]),
            ),
            SizedBox(height: DesignConstants.spacingXL),
            SummaryCard(
              child: Padding(
                padding: DesignConstants.cardPadding,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text("Beschreibung", style: textTheme.titleLarge),
                    SizedBox(height: DesignConstants.spacingS),
                    Text(
                      exercise.getLocalizedDescription(context).isNotEmpty
                          ? exercise.getLocalizedDescription(context)
                          : l10n.noDescriptionAvailable,
                      style: textTheme.bodyMedium,
                    ),
                  ],
                ),
              ),
            ),
            SizedBox(height: DesignConstants.spacingM),
            SummaryCard(
              child: Padding(
                padding: DesignConstants.cardPadding,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text("Involvierte Muskeln", style: textTheme.titleLarge),
                    SizedBox(height: DesignConstants.spacingS),
                    if (exercise.primaryMuscles.isNotEmpty)
                      _buildMuscleRow("Primär:",
                          exercise.primaryMuscles.join(', '), textTheme),
                    if (exercise.secondaryMuscles.isNotEmpty)
                      _buildMuscleRow("Sekundär:",
                          exercise.secondaryMuscles.join(', '), textTheme),
                    if (exercise.primaryMuscles.isEmpty &&
                        exercise.secondaryMuscles.isEmpty)
                      Text("Keine Muskeln angegeben.",
                          style: textTheme.bodyMedium
                              ?.copyWith(color: Colors.grey[600])),
                  ],
                ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.only(top: 24.0, bottom: 8.0),
              child: WgerAttributionWidget(
                textStyle:
                    textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMuscleRow(String label, String muscles, TextTheme textTheme) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(label,
                style: textTheme.bodyMedium
                    ?.copyWith(fontWeight: FontWeight.bold)),
          ),
          Expanded(
            child: Text(muscles, style: textTheme.bodyMedium),
          ),
        ],
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\exercise_mapping_screen.dart =====

// lib/screens/exercise_mapping_screen.dart
import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/screens/exercise_catalog_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/util/mapping_prefs.dart';

class ExerciseMappingScreen extends StatefulWidget {
  final List<String> unknownNames;
  const ExerciseMappingScreen({super.key, required this.unknownNames});

  @override
  State<ExerciseMappingScreen> createState() => _ExerciseMappingScreenState();
}

class _ExerciseMappingScreenState extends State<ExerciseMappingScreen> {
  final Map<String, Exercise> _selection = {};
  bool _applying = false;

  Future<void> _pickTarget(String sourceName) async {
    final Exercise? picked = await Navigator.of(context).push(
      MaterialPageRoute(
          builder: (_) => const ExerciseCatalogScreen(isSelectionMode: true)),
    );
    if (picked != null && mounted) {
      setState(() => _selection[sourceName] = picked);
    }
  }

  Future<void> _apply() async {
    if (_selection.isEmpty) {
      Navigator.of(context).pop(false);
      return;
    }
    setState(() => _applying = true);
    final mapping = <String, String>{
      for (final e in _selection.entries)
        e.key: (e.value.nameEn.isNotEmpty ? e.value.nameEn : e.value.nameDe),
    };
// NEU: persistent speichern
    await MappingPrefs.upsert(mapping); // <— hinzufügen
// Bestehendes: DB-Update anwenden
    await WorkoutDatabaseHelper.instance.applyExerciseNameMapping(mapping);
    if (mounted) {
      setState(() => _applying = false);
      Navigator.of(context).pop(true);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Übungen zuordnen')),
      body: Column(
        children: [
          SizedBox(height: DesignConstants.spacingS),
          Expanded(
            child: ListView.builder(
              itemCount: widget.unknownNames.length,
              itemBuilder: (context, index) {
                final src = widget.unknownNames[index];
                final picked = _selection[src];
                return ListTile(
                  title: Text(src),
                  subtitle: picked == null
                      ? const Text('Keine Auswahl')
                      : Text('→ ${picked.nameDe} / ${picked.nameEn}'),
                  trailing: TextButton.icon(
                    icon: const Icon(Icons.search),
                    label: const Text('Auswählen'),
                    onPressed: () => _pickTarget(src),
                  ),
                );
              },
            ),
          ),
          SafeArea(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                  onPressed: _applying ? null : _apply,
                  icon: _applying
                      ? const SizedBox(
                          width: 16,
                          height: 16,
                          child: CircularProgressIndicator(strokeWidth: 2))
                      : const Icon(Icons.check),
                  label: Text(
                      _applying ? 'Wird angewendet...' : 'Zuordnung anwenden'),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\food_detail_screen.dart =====

// lib/screens/food_detail_screen.dart (Final & De-Materialisiert - OLED Ready)

import 'package:flutter/material.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/tracked_food_item.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/off_attribution_widget.dart';
import 'package:lightweight/widgets/summary_card.dart';

class FoodDetailScreen extends StatefulWidget {
  final TrackedFoodItem? trackedItem;
  final FoodItem? foodItem;

  const FoodDetailScreen({super.key, this.trackedItem, this.foodItem})
      : assert(trackedItem != null || foodItem != null);

  @override
  State<FoodDetailScreen> createState() => _FoodDetailScreenState();
}

class _FoodDetailScreenState extends State<FoodDetailScreen> {
  bool _isFavorite = false;
  bool _showPer100g = false;

  late FoodItem _displayItem;
  int? _trackedQuantity;
  bool get _hasPortionInfo => _trackedQuantity != null;

  @override
  void initState() {
    super.initState();
    if (widget.trackedItem != null) {
      _displayItem = widget.trackedItem!.item;
      _trackedQuantity = widget.trackedItem!.entry.quantityInGrams;
    } else {
      _displayItem = widget.foodItem!;
      _trackedQuantity = null;
      _showPer100g = true;
    }
    _checkIfFavorite();
  }

  Future<void> _checkIfFavorite() async {
    final isFav =
        await DatabaseHelper.instance.isFavorite(_displayItem.barcode);
    if (mounted) setState(() => _isFavorite = isFav);
  }

  Future<void> _toggleFavorite() async {
    if (_isFavorite) {
      await DatabaseHelper.instance.removeFavorite(_displayItem.barcode);
    } else {
      await DatabaseHelper.instance.addFavorite(_displayItem.barcode);
    }
    _checkIfFavorite();
  }

  double _getDisplayValue(double? valuePer100g) {
    if (valuePer100g == null) return 0.0;
    if (_showPer100g || !_hasPortionInfo) {
      return valuePer100g;
    }
    return (valuePer100g / 100 * _trackedQuantity!);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    final displayQuantity =
        _showPer100g || !_hasPortionInfo ? 100 : _trackedQuantity!;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        elevation: 0,
        scrolledUnderElevation: 0,
        title: Text(
          _displayItem.name,
          style: textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w900),
        ),
        actions: [
          IconButton(
            icon: Icon(
              _isFavorite ? Icons.favorite : Icons.favorite_border,
              color:
                  _isFavorite ? Colors.redAccent : colorScheme.onSurfaceVariant,
            ),
            onPressed: _toggleFavorite,
          )
        ],
      ),
      body: SingleChildScrollView(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (_displayItem.brand.isNotEmpty)
              Text(
                _displayItem.brand,
                style: textTheme.titleMedium?.copyWith(color: Colors.grey[600]),
              ),
            Divider(
              height: 32,
              thickness: 1,
              color: colorScheme.onSurfaceVariant.withOpacity(0.1),
            ),
            if (_hasPortionInfo)
              SummaryCard(
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                      horizontal: 16.0, vertical: 8.0),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceAround,
                    children: [
                      _buildToggleButton(
                          context, l10n.foodDetailSegmentPortion, false),
                      _buildToggleButton(
                          context, l10n.foodDetailSegment100g, true),
                    ],
                  ),
                ),
              ),
            if (_hasPortionInfo) SizedBox(height: DesignConstants.spacingL),
            Text("Nährwerte pro ${displayQuantity}g",
                style: textTheme.titleLarge),
            SizedBox(height: DesignConstants.spacingS),
            SummaryCard(
              child: Column(
                children: [
                  _buildNutrientRow(l10n.calories,
                      "${_getDisplayValue(_displayItem.calories.toDouble()).round()} kcal"),
                  _buildNutrientRow(l10n.protein,
                      "${_getDisplayValue(_displayItem.protein).toStringAsFixed(1)} g"),
                  _buildNutrientRow(l10n.carbs,
                      "${_getDisplayValue(_displayItem.carbs).toStringAsFixed(1)} g"),
                  _buildNutrientRow(l10n.fat,
                      "${_getDisplayValue(_displayItem.fat).toStringAsFixed(1)} g"),
                ],
              ),
            ),
            if (_displayItem.sugar != null ||
                _displayItem.fiber != null ||
                _displayItem.salt != null) ...[
              SizedBox(height: DesignConstants.spacingM),
              SummaryCard(
                child: Column(
                  children: [
                    if (_displayItem.sugar != null)
                      _buildNutrientRow(l10n.sugar,
                          "${_getDisplayValue(_displayItem.sugar).toStringAsFixed(1)} g"),
                    if (_displayItem.fiber != null)
                      _buildNutrientRow(l10n.fiber,
                          "${_getDisplayValue(_displayItem.fiber).toStringAsFixed(1)} g"),
                    if (_displayItem.salt != null)
                      _buildNutrientRow(l10n.salt,
                          "${_getDisplayValue(_displayItem.salt).toStringAsFixed(1)} g"),
                  ],
                ),
              ),
            ],
            if (!_displayItem.barcode.startsWith('user_created_'))
              Padding(
                padding: const EdgeInsets.only(top: 24.0, bottom: 8.0),
                child: OffAttributionWidget(
                  textStyle:
                      textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildToggleButton(
      BuildContext context, String label, bool is100gOption) {
    final theme = Theme.of(context);
    final isSelected = _showPer100g == is100gOption;
    return Expanded(
      child: InkWell(
        onTap: () => setState(() => _showPer100g = is100gOption),
        borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM),
        child: Container(
          padding: const EdgeInsets.symmetric(vertical: 12.0, horizontal: 8.0),
          decoration: BoxDecoration(
            color: isSelected
                ? theme.colorScheme.primary.withOpacity(0.2)
                : Colors.transparent,
            borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM),
            border: Border.all(
              color: isSelected
                  ? theme.colorScheme.primary
                  : theme.colorScheme.onSurfaceVariant.withOpacity(0.3),
            ),
          ),
          child: Text(
            label,
            textAlign: TextAlign.center,
            style: theme.textTheme.titleMedium?.copyWith(
              color: isSelected
                  ? theme.colorScheme.primary
                  : theme.colorScheme.onSurface,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildNutrientRow(String label, String value) {
    return ListTile(
      dense: true,
      title: Text(label),
      trailing: Text(
        value,
        style: const TextStyle(fontWeight: FontWeight.bold),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\food_explorer_screen.dart =====

// lib/screens/food_explorer_screen.dart (Final & De-Materialisiert)

import 'package:flutter/material.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/screens/create_food_screen.dart';
import 'package:lightweight/screens/food_detail_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/off_attribution_widget.dart';
import 'package:lightweight/widgets/summary_card.dart'; // HINZUGEFÜGT

class FoodExplorerScreen extends StatefulWidget {
  const FoodExplorerScreen({super.key});

  @override
  State<FoodExplorerScreen> createState() => _FoodExplorerScreenState();
}

class _FoodExplorerScreenState extends State<FoodExplorerScreen>
    with SingleTickerProviderStateMixin {
  List<FoodItem> _foundFoodItems = [];
  bool _isLoadingSearch = false;
  String _searchInitialText = "";
  final _searchController = TextEditingController();

  List<FoodItem> _favoriteFoodItems = [];
  bool _isLoadingFavorites = true;

  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _searchController.addListener(() => setState(() {}));
    _loadFavorites();
  }

  @override
  void dispose() {
    _searchController.dispose();
    _tabController.dispose();
    super.dispose();
  }

  void _runFilter(String enteredKeyword) async {
    final l10n = AppLocalizations.of(context)!;

    if (enteredKeyword.isEmpty) {
      setState(() {
        _foundFoodItems = [];
        _searchInitialText = l10n.searchInitialHint;
      });
      return;
    }
    setState(() {
      _isLoadingSearch = true;
    });
    final results =
        await ProductDatabaseHelper.instance.searchProducts(enteredKeyword);
    if (mounted) {
      setState(() {
        _foundFoodItems = results;
        _isLoadingSearch = false;
        if (results.isEmpty) {
          _searchInitialText = l10n.searchNoResults;
        }
      });
    }
  }

  void _navigateAndCreateFood() {
    Navigator.of(context)
        .push(
      MaterialPageRoute(builder: (context) => const CreateFoodScreen()),
    )
        .then((_) {
      _searchController.clear();
      _runFilter('');
    });
  }

  Future<void> _loadFavorites() async {
    setState(() {
      _isLoadingFavorites = true;
    });
    final results = await ProductDatabaseHelper.instance.getFavoriteProducts();
    if (mounted) {
      setState(() {
        _favoriteFoodItems = results;
        _isLoadingFavorites = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    // KORREKTUR: Direkte Abfrage des Theme-Modus
    final isLightMode = Theme.of(context).brightness == Brightness.light;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: Column(
        children: [
          Padding(
            padding:
                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 24.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(l10n.drawerFoodExplorer,
                    style: textTheme.headlineMedium
                        ?.copyWith(fontWeight: FontWeight.w900, fontSize: 28)),
                SizedBox(height: DesignConstants.spacingL),
                TabBar(
                  controller: _tabController,
                  isScrollable: false,
                  indicator: const BoxDecoration(),
                  splashFactory: NoSplash.splashFactory,
                  overlayColor: WidgetStateProperty.all(Colors.transparent),
                  dividerColor: Colors.transparent,
                  // KORREKTUR: Dynamische Farbe basierend auf dem Theme-Modus
                  labelColor: isLightMode ? Colors.black : Colors.white,
                  unselectedLabelColor: Colors.grey.shade600,
                  labelStyle: const TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.w900,
                      letterSpacing: 0.0),
                  unselectedLabelStyle: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.w800,
                      letterSpacing: 0.0),
                  tabs: [
                    Tab(text: l10n.tabSearch),
                    Tab(text: l10n.tabFavorites),
                  ],
                ),
              ],
            ),
          ),
          Divider(
              height: 1,
              thickness: 1,
              color: colorScheme.onSurfaceVariant.withOpacity(0.1)),
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildSearchTab(l10n),
                _buildFavoritesTab(l10n),
              ],
            ),
          ),
        ],
      ),
      floatingActionButton: GlassFab(
        onPressed: _navigateAndCreateFood,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  Widget _buildSearchTab(AppLocalizations l10n) {
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    return Padding(
      padding: DesignConstants.cardPadding,
      child: Column(
        children: [
          // KORREKTUR 4: TextField nutzt globale InputDecorationTheme
          TextField(
              controller: _searchController,
              onChanged: (value) => _runFilter(value),
              decoration: InputDecoration(
                  hintText: l10n.searchHintText,
                  prefixIcon: Icon(Icons.search,
                      color: colorScheme.onSurfaceVariant, size: 20),
                  suffixIcon: _searchController.text.isNotEmpty
                      ? IconButton(
                          icon: Icon(Icons.clear,
                              color: colorScheme.onSurfaceVariant),
                          onPressed: () {
                            _searchController.clear();
                            _runFilter('');
                          })
                      : null)),
          const SizedBox(height: 20),
          Expanded(
            child: _isLoadingSearch
                ? const Center(child: CircularProgressIndicator())
                : _foundFoodItems.isNotEmpty
                    ? ListView.builder(
                        itemCount: _foundFoodItems.length,
                        itemBuilder: (context, index) =>
                            _buildFoodListItem(_foundFoodItems[index]))
                    : Center(
                        child: Text(_searchInitialText,
                            style: textTheme.titleMedium)),
          ),
          if (_foundFoodItems.any((item) => item.source == FoodItemSource.off))
            const OffAttributionWidget(),
        ],
      ),
    );
  }

  Widget _buildFavoritesTab(AppLocalizations l10n) {
    if (_isLoadingFavorites) {
      return const Center(child: CircularProgressIndicator());
    }
    if (_favoriteFoodItems.isEmpty) {
      return Center(
          child: Text(l10n.favoritesEmptyState,
              textAlign: TextAlign.center,
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  color: Theme.of(context)
                      .colorScheme
                      .onSurface
                      .withOpacity(0.6))));
    }
    return Column(children: [
      Expanded(
          child: ListView.builder(
              padding: DesignConstants.cardPadding,
              itemCount: _favoriteFoodItems.length,
              itemBuilder: (context, index) =>
                  _buildFoodListItem(_favoriteFoodItems[index]))),
      if (_favoriteFoodItems.any((item) => item.source == FoodItemSource.off))
        const OffAttributionWidget()
    ]);
  }

  // KORREKTUR 5: _buildFoodListItem verwendet jetzt SummaryCard
  Widget _buildFoodListItem(FoodItem item) {
    final colorScheme = Theme.of(context).colorScheme;
    final l10n = AppLocalizations.of(context)!;

    IconData sourceIcon;
    switch (item.source) {
      case FoodItemSource.base:
        sourceIcon = Icons.star;
        break;
      case FoodItemSource.off:
      case FoodItemSource.user:
        sourceIcon = Icons.inventory_2;
        break;
    }

    return SummaryCard(
      // KORREKTUR: Jetzt mit SummaryCard
      child: ListTile(
        leading: Icon(sourceIcon, color: colorScheme.primary),
        title: Text(item.name.isNotEmpty ? item.name : l10n.unknown,
            style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Text(l10n.foodItemSubtitle(
            item.brand.isNotEmpty ? item.brand : l10n.noBrand, item.calories)),
        trailing: IconButton(
          icon: Icon(Icons.add_circle_outline,
              color: colorScheme.primary, size: 28),
          onPressed: () => Navigator.of(context).pop(item),
        ),
        onTap: () => Navigator.of(context)
            .push(MaterialPageRoute(
                builder: (context) => FoodDetailScreen(foodItem: item)))
            .then((_) {
          _loadFavorites();
        }),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\goals_screen.dart =====

// lib/screens/goals_screen.dart (Der umbenannte "Meine Ziele"-Screen)

import 'package:flutter/material.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/generated/app_localizations.dart';

// KORREKTUR: Der Klassenname wurde zu GoalsScreen geändert
class GoalsScreen extends StatefulWidget {
  const GoalsScreen({super.key});

  @override
  State<GoalsScreen> createState() => _GoalsScreenState();
}

// KORREKTUR: Der State-Klassenname wurde zu _GoalsScreenState geändert
class _GoalsScreenState extends State<GoalsScreen> {
  final _formKey = GlobalKey<FormState>();
  bool _isLoading = true;

  final _caloriesController = TextEditingController();
  final _proteinController = TextEditingController();
  final _carbsController = TextEditingController();
  final _fatController = TextEditingController();
  final _waterController = TextEditingController();
  final _heightController = TextEditingController();

  final _sugarController = TextEditingController();
  final _fiberController = TextEditingController();
  final _saltController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _loadSettings();
  }

  @override
  void dispose() {
    _caloriesController.dispose();
    _proteinController.dispose();
    _carbsController.dispose();
    _fatController.dispose();
    _waterController.dispose();
    _heightController.dispose();
    _sugarController.dispose();
    _fiberController.dispose();
    _saltController.dispose();
    super.dispose();
  }

  Future<void> _loadSettings() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _heightController.text = (prefs.getInt('userHeight') ?? 180).toString();
      _caloriesController.text =
          (prefs.getInt('targetCalories') ?? 2500).toString();
      _proteinController.text =
          (prefs.getInt('targetProtein') ?? 180).toString();
      _carbsController.text = (prefs.getInt('targetCarbs') ?? 250).toString();
      _fatController.text = (prefs.getInt('targetFat') ?? 80).toString();
      _waterController.text = (prefs.getInt('targetWater') ?? 3000).toString();
      _sugarController.text = (prefs.getInt('targetSugar') ?? 50).toString();
      _fiberController.text = (prefs.getInt('targetFiber') ?? 30).toString();
      _saltController.text = (prefs.getInt('targetSalt') ?? 6).toString();
      _isLoading = false;
    });
  }

  Future<void> _saveSettings() async {
    final isValid = _formKey.currentState?.validate() ?? false;
    if (!isValid) return;
    final prefs = await SharedPreferences.getInstance();

    await prefs.setInt('userHeight', int.parse(_heightController.text));
    await prefs.setInt('targetCalories', int.parse(_caloriesController.text));
    await prefs.setInt('targetProtein', int.parse(_proteinController.text));
    await prefs.setInt('targetCarbs', int.parse(_carbsController.text));
    await prefs.setInt('targetFat', int.parse(_fatController.text));
    await prefs.setInt('targetWater', int.parse(_waterController.text));
    await prefs.setInt('targetSugar', int.parse(_sugarController.text));
    await prefs.setInt('targetFiber', int.parse(_fiberController.text));
    await prefs.setInt('targetSalt', int.parse(_saltController.text));

    if (mounted) {
      final l10n = AppLocalizations.of(context)!;
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(l10n.snackbarGoalsSaved)));
      Navigator.of(context).pop();
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          "Goals",
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
              padding: DesignConstants.cardPadding,
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Text("Persönliche Daten",
                        style: Theme.of(context).textTheme.headlineSmall),
                    SizedBox(height: DesignConstants.spacingL),
                    _buildSettingsField(
                        controller: _heightController,
                        label: l10n.profileUserHeight),
                    SizedBox(height: DesignConstants.spacingXL),
                    Text(l10n.profileDailyGoals,
                        style: Theme.of(context).textTheme.headlineSmall),
                    SizedBox(height: DesignConstants.spacingL),
                    _buildSettingsField(
                        controller: _caloriesController, label: l10n.calories),
                    _buildSettingsField(
                        controller: _proteinController, label: l10n.protein),
                    _buildSettingsField(
                        controller: _carbsController, label: l10n.carbs),
                    _buildSettingsField(
                        controller: _fatController, label: l10n.fat),
                    _buildSettingsField(
                        controller: _waterController, label: l10n.water),
                    SizedBox(height: DesignConstants.spacingXL),
                    Text("Detail-Nährwerte",
                        style: Theme.of(context).textTheme.headlineSmall),
                    SizedBox(height: DesignConstants.spacingL),
                    _buildSettingsField(
                        controller: _sugarController, label: l10n.sugar),
                    _buildSettingsField(
                        controller: _fiberController, label: l10n.fiber),
                    _buildSettingsField(
                        controller: _saltController, label: l10n.salt),
                    const SizedBox(height: 32),
                    ElevatedButton(
                      onPressed: _saveSettings,
                      style: ElevatedButton.styleFrom(
                          backgroundColor: colorScheme.primary,
                          foregroundColor: colorScheme.onPrimary,
                          padding: const EdgeInsets.symmetric(vertical: 16)),
                      child: Text(l10n.buttonSave,
                          style: const TextStyle(fontSize: 18)),
                    ),
                  ],
                ),
              ),
            ),
    );
  }

  Widget _buildSettingsField(
      {required TextEditingController controller, required String label}) {
    final l10n = AppLocalizations.of(context)!;
    return Padding(
      padding: const EdgeInsets.only(bottom: 12.0),
      child: TextFormField(
        controller: controller,
        decoration: InputDecoration(labelText: label),
        keyboardType: TextInputType.number,
        validator: (value) {
          if (value == null || value.isEmpty || num.tryParse(value) == null) {
            return l10n.validatorPleaseEnterNumber;
          }
          return null;
        },
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\home.dart =====

// lib/screens/home.dart (Final & SWR-Lade-Logik)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/chart_data_point.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/screens/measurements_screen.dart';
import 'package:lightweight/screens/nutrition_screen.dart';
import 'package:lightweight/widgets/measurement_chart_widget.dart';
import 'package:lightweight/widgets/nutrition_summary_widget.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/util/date_util.dart';

class Home extends StatefulWidget {
  const Home({super.key});

  @override
  HomeState createState() => HomeState();
}

class HomeState extends State<Home> {
  DailyNutrition? _nutritionData;
  String _recommendationText = "";
  // KORREKTUR: _isLoading wird jetzt nur für den ERSTEN Ladevorgang auf true gesetzt
  bool _isLoading = true;

  List<ChartDataPoint> _weightChartData = [];
  DateTimeRange _currentDateRange = DateTimeRange(
      start: DateTime.now().subtract(const Duration(days: 29)),
      end: DateTime.now());
  final String _chartType = 'weight';
  Map<String, int> _workoutStats = {};
  bool _isFirstLoad = true;

  final List<String> _chartDateRangeKeys = ['30D', '90D', 'All'];
  String _selectedChartRangeKey = '30D';

  @override
  void initState() {
    super.initState();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (_isFirstLoad) {
      loadAllHomeScreenData(
          showLoadingIndicator:
              true); // KORREKTUR: Zeige Indikator nur beim ersten Mal
      _isFirstLoad = false;
    }
  }

  // KORREKTUR: loadAllHomeScreenData akzeptiert jetzt einen optionalen Parameter
  Future<void> loadAllHomeScreenData(
      {bool showLoadingIndicator = false}) async {
    if (!mounted) return;

    // KORREKTUR: Setze _isLoading nur, wenn der Indikator wirklich gezeigt werden soll
    if (showLoadingIndicator) {
      setState(() => _isLoading = true);
    }

    // --- DATEN HIER LADEN ---
    final l10n = AppLocalizations.of(context)!;
    final prefs = await SharedPreferences.getInstance();
    final targetCalories = prefs.getInt('targetCalories') ?? 2500;
    final targetProtein = prefs.getInt('targetProtein') ?? 180;
    final targetCarbs = prefs.getInt('targetCarbs') ?? 250;
    final targetFat = prefs.getInt('targetFat') ?? 80;
    final targetWater = prefs.getInt('targetWater') ?? 3000;

    final entries =
        await DatabaseHelper.instance.getEntriesForDate(DateTime.now());
    final waterIntake =
        await DatabaseHelper.instance.getWaterForDate(DateTime.now());
    final newTodaysNutrition = DailyNutrition(
        targetCalories: targetCalories,
        targetProtein: targetProtein,
        targetCarbs: targetCarbs,
        targetFat: targetFat,
        targetWater: targetWater);
    newTodaysNutrition.water = waterIntake;

    final newWorkoutStats =
        await _getWorkoutStats(); // KORREKTUR: Methode umbenannt
    await _loadChartData(); // Lädt Chart-Daten und setzt _weightChartData

    for (final entry in entries) {
      final foodItem = await ProductDatabaseHelper.instance
          .getProductByBarcode(entry.barcode);
      if (foodItem != null) {
        newTodaysNutrition.calories +=
            (foodItem.calories / 100 * entry.quantityInGrams).round();
        newTodaysNutrition.protein +=
            (foodItem.protein / 100 * entry.quantityInGrams).round();
        newTodaysNutrition.carbs +=
            (foodItem.carbs / 100 * entry.quantityInGrams).round();
        newTodaysNutrition.fat +=
            (foodItem.fat / 100 * entry.quantityInGrams).round();
      }
    }

    final today = DateTime.now();
    final sevenDaysAgo = today.subtract(const Duration(days: 6));
    final recentEntries = await DatabaseHelper.instance
        .getEntriesForDateRange(sevenDaysAgo, today);
    String newRecommendation = l10n.recommendationDefault;
    if (recentEntries.isNotEmpty) {
      final uniqueDaysTracked = recentEntries
          .map((e) => DateFormat.yMd().format(e.timestamp))
          .toSet();
      final numberOfTrackedDays = uniqueDaysTracked.length;
      int totalRecentCalories = 0;
      for (final entry in recentEntries) {
        final foodItem = await ProductDatabaseHelper.instance
            .getProductByBarcode(entry.barcode);
        if (foodItem != null) {
          totalRecentCalories +=
              (foodItem.calories / 100 * entry.quantityInGrams).round();
        }
      }
      final totalTargetCalories = targetCalories * numberOfTrackedDays;
      final difference = totalRecentCalories - totalTargetCalories;
      if (numberOfTrackedDays > 1) {
        final tolerance = totalTargetCalories * 0.05;
        if (difference > tolerance) {
          newRecommendation = l10n.recommendationOverTarget(
              numberOfTrackedDays, difference.round());
        } else if (difference < -tolerance) {
          newRecommendation = l10n.recommendationUnderTarget(
              numberOfTrackedDays, (-difference).round());
        } else {
          newRecommendation = l10n.recommendationOnTarget(numberOfTrackedDays);
        }
      } else {
        newRecommendation = l10n.recommendationFirstEntry;
      }
    }
    // --- DATEN LADEN ENDE ---

    if (mounted) {
      setState(() {
        _nutritionData = newTodaysNutrition; // Neue Daten
        _recommendationText = newRecommendation; // Neue Daten
        _workoutStats = newWorkoutStats; // Neue Daten
        _isLoading = false; // Ladezustand beenden
      });
    }
  }

  Future<void> _loadChartData() async {
    // Hole alle Mess-Sessions und filtere auf den sichtbaren Bereich + Typ "weight"
    final sessions = await DatabaseHelper.instance.getMeasurementSessions();

    // Tagesgrenzen normalisieren (Start 00:00, Ende 23:59:59)
    final start = DateTime(_currentDateRange.start.year,
        _currentDateRange.start.month, _currentDateRange.start.day);
    final end = DateTime(_currentDateRange.end.year,
        _currentDateRange.end.month, _currentDateRange.end.day, 23, 59, 59);

    final points = <ChartDataPoint>[];

    for (final s in sessions) {
      if (s.timestamp.isBefore(start) || s.timestamp.isAfter(end)) continue;

      for (final m in s.measurements) {
        if (m.type == _chartType) {
          // Annahme: ChartDataPoint hat Felder/Named-Ctor "date" und "value"
          points.add(
              ChartDataPoint(date: s.timestamp, value: m.value.toDouble()));
        }
      }
    }

    points.sort((a, b) => a.date.compareTo(b.date));

    if (!mounted) return;
    setState(() {
      _weightChartData = points;
    });
  }

  // KORREKTUR: Methode umbenannt, damit sie Daten ZURÜCKGIBT
  Future<Map<String, int>> _getWorkoutStats() async {
    final today = DateTime.now();
    final sevenDaysAgo = today.subtract(const Duration(days: 6));

    final logs = await WorkoutDatabaseHelper.instance
        .getWorkoutLogsForDateRange(sevenDaysAgo, today);

    int count = logs.length;
    int duration = 0;
    int volume = 0;

    for (final log in logs) {
      if (log.endTime != null) {
        duration += log.endTime!.difference(log.startTime).inMinutes;
      }
      for (final set in log.sets) {
        volume += ((set.weightKg ?? 0) * (set.reps ?? 0)).round();
      }
    }
    return {
      'count': count,
      'duration': duration,
      'volume': volume,
    };
  }

  void _navigateTimeRange(bool forward) {
    // "All" deckt sowieso alles ab – kein Paging
    if (_selectedChartRangeKey == 'All') return;

    final int days = _selectedChartRangeKey == '90D' ? 90 : 30;
    final delta = Duration(days: days);

    final newStart = forward
        ? _currentDateRange.start.add(delta)
        : _currentDateRange.start.subtract(delta);
    final newEnd = forward
        ? _currentDateRange.end.add(delta)
        : _currentDateRange.end.subtract(delta);

    setState(() {
      _currentDateRange = DateTimeRange(start: newStart, end: newEnd);
    });

    // Daten für die neue Range nachladen
    _loadChartData();
  }

  void _navigateToNutritionScreen() {
    Navigator.of(context)
        .push(MaterialPageRoute(builder: (context) => const NutritionScreen()))
        .then((_) => loadAllHomeScreenData(showLoadingIndicator: false));
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;

    // KORREKTUR: Zeige den Ladeindikator nur, wenn _isLoading true UND keine Daten vorhanden sind
    final showLoadingOverlay = _isLoading && _nutritionData == null;

    return Scaffold(
      body: Stack(
        children: [
          // KORREKTUR: Der RefreshIndicator ist immer da, damit man ziehen kann.
          // Der Inhalt wird immer angezeigt, auch wenn _isLoading true ist (alte Daten).
          RefreshIndicator(
            onRefresh: () => loadAllHomeScreenData(
                showLoadingIndicator:
                    false), // KORREKTUR: Kein Ladeindikator bei manueller Aktualisierung
            child: ListView(
              padding:
                  DesignConstants.screenPadding,
              children: [
                _buildBannerCard(l10n),
                SizedBox(height: DesignConstants.spacingS),
                GestureDetector(
                    onTap: _navigateToNutritionScreen,
                    child: _nutritionData != null
                        ? NutritionSummaryWidget(
                            nutritionData: _nutritionData!,
                            isExpandedView: false,
                            l10n: l10n)
                        : const SizedBox.shrink()),
                if (_weightChartData.isNotEmpty) SizedBox(height: DesignConstants.spacingS),
                GestureDetector(
                    onTap: () => Navigator.of(context)
                        .push(MaterialPageRoute(
                            builder: (context) => const MeasurementsScreen()))
                        .then((_) => loadAllHomeScreenData()),
                    child: _buildWeightChartCard(context, colorScheme, l10n)),
                SizedBox(height: DesignConstants.spacingS),
                _buildWorkoutStatsCard(l10n),
              ],
            ),
          ),
          // KORREKTUR: Lade-Overlay nur anzeigen, wenn showLoadingOverlay true ist
          if (showLoadingOverlay)
            Positioned.fill(
              child: Container(
                color: Colors.black.withOpacity(0.5),
                child: const Center(child: CircularProgressIndicator()),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildBannerCard(AppLocalizations l10n) {
    // KORREKTUR: externalMargin wird jetzt gesetzt
    return SummaryCard(
      //internalPadding: const EdgeInsets.symmetric(horizontal: 16.0),
      //externalMargin: EdgeInsets.zero, // Wichtig, da ListView.separated den Abstand steuert
      child: Container(
        height: 100,
        alignment: Alignment.center,
        child: Text(
          _recommendationText,
          textAlign: TextAlign.center,
          style: TextStyle(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
              fontSize: 22,
              fontWeight: FontWeight.w500),
        ),
      ),
    );
  }

  Widget _buildWeightChartCard(
      BuildContext context, ColorScheme colorScheme, AppLocalizations l10n) {
    // KORREKTUR: externalMargin wird jetzt gesetzt
    return SummaryCard(
      //externalMargin: EdgeInsets.zero, // Wichtig
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text("Gewichtsverlauf",
                    style: Theme.of(context)
                        .textTheme
                        .titleMedium
                        ?.copyWith(fontWeight: FontWeight.bold)),
                Expanded(
                  child: Align(
                    alignment: Alignment.centerRight,
                    child: Wrap(
                      spacing: 8.0,
                      alignment: WrapAlignment.end,
                      children: _chartDateRangeKeys
                          .map((key) => _buildFilterButton(key, key))
                          .toList(),
                    ),
                  ),
                ),
              ],
            ),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                // Zurück-Button
                IconButton(
                  icon: const Icon(Icons.chevron_left),
                  onPressed: () => _navigateTimeRange(false),
                ),
                // Datumsanzeige
                Text(
                    "${DateFormat.MMMd().format(_currentDateRange.start)} - ${DateFormat.MMMd().format(_currentDateRange.end)}",
                    style: Theme.of(context).textTheme.bodySmall),
                // Vorwärts-Button (deaktiviert, wenn das End-Datum heute ist)
                IconButton(
                  icon: const Icon(Icons.chevron_right),
                  onPressed: _currentDateRange.end.isSameDate(DateTime.now())
                      ? null
                      : () => _navigateTimeRange(true),
                ),
              ],
            ),
            SizedBox(height: DesignConstants.spacingL),
            MeasurementChartWidget(
              chartType: _chartType,
              dateRange: _currentDateRange,
              lineColor: colorScheme.secondary,
              unit: "kg",
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFilterButton(String label, String key) {
    final theme = Theme.of(context);
    final isSelected = _selectedChartRangeKey == key;
    return GestureDetector(
      onTap: () {
        setState(() {
          _selectedChartRangeKey = key;
        });
        _loadChartData();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10.0, vertical: 6.0),
        decoration: BoxDecoration(
          color: isSelected
              ? theme.colorScheme.primary
              : theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
          borderRadius: BorderRadius.circular(8.0),
        ),
        child: Text(
          label,
          style: theme.textTheme.labelSmall?.copyWith(
            color: isSelected
                ? theme.colorScheme.onPrimary
                : theme.colorScheme.onSurfaceVariant,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  Widget _buildWorkoutStatsCard(AppLocalizations l10n) {
    // KORREKTUR: externalMargin wird jetzt gesetzt
    return SummaryCard(
      //externalMargin: EdgeInsets.zero, // Wichtig
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              l10n.workoutStatsTitle,
              style: Theme.of(context).textTheme.titleLarge,
            ),
            SizedBox(height: DesignConstants.spacingM),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                Column(
                  children: [
                    const Icon(Icons.fitness_center, size: 28),
                    const SizedBox(height: 4),
                    Text(
                      "${_workoutStats['count'] ?? 0}",
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(l10n.workoutsLabel,
                        style: const TextStyle(fontSize: 12)),
                  ],
                ),
                Column(
                  children: [
                    const Icon(Icons.timer, size: 28),
                    const SizedBox(height: 4),
                    Text(
                      "${_workoutStats['duration'] ?? 0} min",
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(l10n.durationLabel,
                        style: const TextStyle(fontSize: 12)),
                  ],
                ),
                Column(
                  children: [
                    const Icon(Icons.monitor_weight, size: 28),
                    const SizedBox(height: 4),
                    Text(
                      "${_workoutStats['volume'] ?? 0} kg",
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(l10n.volumeLabel,
                        style: const TextStyle(fontSize: 12)),
                  ],
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\live_workout_screen.dart =====

// lib/screens/live_workout_screen.dart (Final & De-Materialisiert - Endgültig)

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/models/routine_exercise.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/set_template.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/services/workout_session_manager.dart';
import 'package:lightweight/widgets/set_type_chip.dart';
import 'package:lightweight/widgets/workout_summary_bar.dart';
import 'exercise_catalog_screen.dart';
import 'exercise_detail_screen.dart';
import 'package:provider/provider.dart';
import 'package:lightweight/screens/workout_summary_screen.dart';
import 'package:lightweight/widgets/workout_card.dart';

class LiveWorkoutScreen extends StatefulWidget {
  final Routine? routine;
  final WorkoutLog workoutLog;

  const LiveWorkoutScreen({super.key, this.routine, required this.workoutLog});

  @override
  State<LiveWorkoutScreen> createState() => _LiveWorkoutScreenState();
}

class _LiveWorkoutScreenState extends State<LiveWorkoutScreen> {
  late List<RoutineExercise> _liveExercises;
  final Map<int, Map<String, dynamic>> _setUIData = {};
  final Map<int, TextEditingController> _weightControllers = {};
  final Map<int, TextEditingController> _repsControllers = {};
  final Map<String, SetLog?> _lastPerformances = {};
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    final manager = Provider.of<WorkoutSessionManager>(context, listen: false);
    final isContinuing =
        manager.isActive && manager.workoutLog?.id == widget.workoutLog.id;

    if (isContinuing) {
      _liveExercises = manager.exercises;
    } else {
      if (widget.routine != null) {
        _liveExercises = widget.routine!.exercises.map((re) {
          return RoutineExercise(
            id: re.id,
            exercise: re.exercise,
            setTemplates: re.setTemplates
                .map((st) => SetTemplate.fromMap(st.toMap()))
                .toList(),
            pauseSeconds: re.pauseSeconds,
          );
        }).toList();
      } else {
        _liveExercises = [];
      }
      WidgetsBinding.instance.addPostFrameCallback((_) {
        manager.startWorkout(widget.workoutLog, _liveExercises);
      });
    }
    _initializeScreen();
  }

  @override
  void dispose() {
    for (var c in _weightControllers.values) {
      c.dispose();
    }
    for (var c in _repsControllers.values) {
      c.dispose();
    }
    super.dispose();
  }

  Future<void> _initializeScreen() async {
    for (var routineExercise in _liveExercises) {
      final lastPerf = await WorkoutDatabaseHelper.instance
          .getLastPerformance(routineExercise.exercise.nameEn);
      if (mounted) {
        setState(() =>
            _lastPerformances[routineExercise.exercise.nameEn] = lastPerf);
      }
      for (final template in routineExercise.setTemplates) {
        final templateId = template.id!;
        String initialReps =
            template.targetReps ?? (lastPerf?.reps?.toString() ?? '');
        String initialWeight = (template.targetWeight ?? lastPerf?.weightKg)
                ?.toStringAsFixed(1)
                .replaceAll('.0', '') ??
            '';
        _setUIData[templateId] = {'setType': template.setType};
        _weightControllers[templateId] =
            TextEditingController(text: initialWeight);
        _repsControllers[templateId] = TextEditingController(text: initialReps);
      }
    }
    if (mounted) setState(() => _isLoading = false);
  }

  void _logSet(int setTemplateId, RoutineExercise re) async {
    final weight = double.tryParse(
            _weightControllers[setTemplateId]!.text.replaceAll(',', '.')) ??
        0.0;
    final reps = int.tryParse(_repsControllers[setTemplateId]!.text) ?? 0;
    final setType = _setUIData[setTemplateId]!['setType'] as String;

    await WorkoutSessionManager()
        .logSet(setTemplateId, re, weight, reps, setType);

    setState(() {}); // UI refresh
  }

  void _unlogSet(int setTemplateId) async {
    await WorkoutSessionManager().unlogSet(setTemplateId);
    setState(() {});
  }

  Future<void> _finishWorkout() async {
    final l10n = AppLocalizations.of(context)!;
    // Frage den Nutzer zuerst, ob er wirklich beenden will.
    final bool? confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.finishWorkoutButton), // Titel: "Beenden"
        content: const Text("Möchtest du dieses Workout wirklich abschließen?"),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text(l10n.cancel),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: Text(l10n.finishWorkoutButton),
          ),
        ],
      ),
    );

    // Nur wenn der Nutzer bestätigt hat (confirmed == true)...
    if (confirmed == true && mounted) {
      final logId = widget.workoutLog.id;
      await WorkoutSessionManager().finishWorkout();

      if (mounted && logId != null) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(
            builder: (context) => WorkoutSummaryScreen(logId: logId),
          ),
        );
      }
    }
  }

  void _addSet(RoutineExercise routineExercise) {
    setState(() {
      final newTemplate = SetTemplate(
          id: DateTime.now().millisecondsSinceEpoch, setType: 'normal');
      routineExercise.setTemplates.add(newTemplate);
      final templateId = newTemplate.id!;
      _setUIData[templateId] = {'setType': 'normal'};
      _weightControllers[templateId] = TextEditingController();
      _repsControllers[templateId] = TextEditingController();
    });
  }

  void _removeSet(RoutineExercise routineExercise, int setTemplateId) {
    setState(() {
      routineExercise.setTemplates.removeWhere((st) => st.id == setTemplateId);
      _setUIData.remove(setTemplateId);
      WorkoutSessionManager().completedSets.remove(setTemplateId);
      _weightControllers.remove(setTemplateId)?.dispose();
      _repsControllers.remove(setTemplateId)?.dispose();
    });
  }

  void _addExercise() async {
    final selectedExercise = await Navigator.of(context).push<Exercise>(
      MaterialPageRoute(
          builder: (context) =>
              const ExerciseCatalogScreen(isSelectionMode: true)),
    );

    if (selectedExercise != null) {
      setState(() {
        final newTemplate = SetTemplate(
          id: DateTime.now().millisecondsSinceEpoch + 1,
          setType: 'normal',
        );

        final newRoutineExercise = RoutineExercise(
          id: DateTime.now().millisecondsSinceEpoch,
          exercise: selectedExercise,
          setTemplates: [newTemplate],
        );

        _liveExercises.add(newRoutineExercise);
        WorkoutSessionManager().pauseTimes[newRoutineExercise.id!] = null;

        final templateId = newTemplate.id!;
        _setUIData[templateId] = {'setType': 'normal'};
        _weightControllers[templateId] = TextEditingController();
        _repsControllers[templateId] = TextEditingController();
      });
    }
  }

  void _changeSetType(int setTemplateId, String newType) {
    setState(() {
      _setUIData[setTemplateId]!['setType'] = newType;
    });
    Navigator.pop(context);
  }

  void _showSetTypePicker(int setTemplateId) {
    showModalBottomSheet(
      context: context,
      builder: (context) {
        return Wrap(
          children: <Widget>[
            ListTile(
                title: const Text('Normal'),
                onTap: () => _changeSetType(setTemplateId, 'normal')),
            ListTile(
                title: const Text('Warmup'),
                onTap: () => _changeSetType(setTemplateId, 'warmup')),
            ListTile(
                title: const Text('Failure'),
                onTap: () => _changeSetType(setTemplateId, 'failure')),
            ListTile(
                title: const Text('Dropset'),
                onTap: () => _changeSetType(setTemplateId, 'dropset')),
          ],
        );
      },
    );
  }

  void _editPauseTime(RoutineExercise routineExercise) async {
    final l10n = AppLocalizations.of(context)!;
    final currentPause = WorkoutSessionManager()
        .exercises
        .firstWhere((ex) => ex.id == routineExercise.id)
        .pauseSeconds;

    final controller =
        TextEditingController(text: currentPause?.toString() ?? '');
    final result = await showDialog<int?>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.editPauseTimeTitle),
        content: TextField(
          controller: controller,
          keyboardType: TextInputType.number,
          decoration: InputDecoration(labelText: l10n.pauseInSeconds),
        ),
        actions: [
          TextButton(
              onPressed: () => Navigator.of(ctx).pop(),
              child: Text(l10n.cancel)),
          FilledButton(
              onPressed: () =>
                  Navigator.of(ctx).pop(int.tryParse(controller.text)),
              child: Text(l10n.save)),
        ],
      ),
    );
    if (result != null) {
      WorkoutSessionManager().updatePauseTime(routineExercise, result);
      setState(() {});
    }
  }

  void _removeExercise(RoutineExercise exerciseToRemove) {
    setState(() {
      for (var template in exerciseToRemove.setTemplates) {
        _setUIData.remove(template.id!);
        WorkoutSessionManager().completedSets.remove(template.id!);
        _weightControllers.remove(template.id!)?.dispose();
        _repsControllers.remove(template.id!)?.dispose();
      }
      WorkoutSessionManager().pauseTimes.remove(exerciseToRemove.id!);
      _liveExercises.remove(exerciseToRemove);
    });
  }

  void _onReorder(int oldIndex, int newIndex) {
    setState(() {
      if (newIndex > oldIndex) {
        newIndex -= 1;
      }
      final RoutineExercise item = _liveExercises.removeAt(oldIndex);
      _liveExercises.insert(newIndex, item);
    });
  }

  Widget _buildHeader(String text) => Expanded(
      child: Text(text,
          textAlign: TextAlign.center,
          style: TextStyle(
              color: Colors.grey[600],
              fontSize: 12,
              fontWeight: FontWeight.bold)));

  /// Gibt den anzuzeigenden Text für den Set zurück
  String _getSetDisplayText(String setType, int setIndex) {
    switch (setType) {
      case 'warmup':
        return 'W';
      case 'failure':
        return 'F';
      case 'dropset':
        return 'D';
      default:
        return '$setIndex';
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    final manager = WorkoutSessionManager();

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          widget.workoutLog.routineName ?? l10n.freeWorkoutTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
        actions: [
          TextButton(
            onPressed: _finishWorkout,
            child: Text(
              l10n.finishWorkoutButton,
              style: TextStyle(
                color: Theme.of(context).colorScheme.primary,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : Column(
              children: [
                AnimatedBuilder(
                  animation: manager,
                  builder: (context, _) {
                    return WorkoutSummaryBar(
                      duration: manager.elapsedDuration,
                      volume: manager.totalVolume,
                      sets: manager.totalSets,
                    );
                  },
                ),
                Divider(
                    height: 1,
                    thickness: 1,
                    color: colorScheme.onSurfaceVariant.withOpacity(0.1)),
                Expanded(
                  child: ReorderableListView.builder(
                    //padding: DesignConstants.cardMargin,
                    padding: EdgeInsets.zero,
                    proxyDecorator:
                        (Widget child, int index, Animation<double> animation) {
                      // KORREKTUR: Flaches Design für das Drag-Feedback
                      return Material(
                        elevation: 4.0,
                        color: Theme.of(context).scaffoldBackgroundColor,
                        child: child,
                      );
                    },
                    onReorder: _onReorder,
                    itemCount: _liveExercises.length,
                    itemBuilder: (context, index) {
                      final routineExercise = _liveExercises[index];
                      // KORREKTUR: SummaryCard wurde hier entfernt
                      return WorkoutCard(
                        key: ValueKey(routineExercise.id),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            ListTile(
                              contentPadding: const EdgeInsets.symmetric(
                                  horizontal: 16.0, vertical: 8.0),
                              title: InkWell(
                                onTap: () => Navigator.of(context).push(
                                    MaterialPageRoute(
                                        builder: (context) =>
                                            ExerciseDetailScreen(
                                                exercise:
                                                    routineExercise.exercise))),
                                child: Padding(
                                  padding:
                                      const EdgeInsets.symmetric(vertical: 4.0),
                                  child: Text(
                                    routineExercise.exercise
                                        .getLocalizedName(context),
                                    style: textTheme.titleLarge
                                        ?.copyWith(fontWeight: FontWeight.bold),
                                  ),
                                ),
                              ),
                              leading: ReorderableDragStartListener(
                                index: index,
                                child: const Icon(Icons.drag_handle),
                              ),
                              trailing: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  if (manager.pauseTimes[routineExercise.id!] !=
                                          null &&
                                      manager.pauseTimes[routineExercise.id!]! >
                                          0)
                                    Padding(
                                      padding:
                                          const EdgeInsets.only(right: 4.0),
                                      child: Text(
                                        "${manager.pauseTimes[routineExercise.id!]}s",
                                        style: textTheme.bodyMedium?.copyWith(
                                            color: colorScheme.primary,
                                            fontWeight: FontWeight.bold),
                                      ),
                                    ),
                                  IconButton(
                                    icon: const Icon(Icons.timer_outlined),
                                    tooltip: l10n.editPauseTime,
                                    onPressed: () =>
                                        _editPauseTime(routineExercise),
                                  ),
                                  IconButton(
                                    icon: const Icon(Icons.delete_outline,
                                        color: Colors.redAccent),
                                    tooltip: l10n.removeExercise,
                                    onPressed: () =>
                                        _removeExercise(routineExercise),
                                  ),
                                ],
                              ),
                            ),
                            //const Divider(indent: 16, endIndent: 16),
                            Padding(
                              padding:
                                  const EdgeInsets.symmetric(horizontal: 0.0),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Row(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.center,
                                    children: [
                                      // Set-Label (wie in BuildSetRow flex:2)
                                      Expanded(
                                        flex: 2,
                                        child: Center(
                                            child: Text(
                                          l10n.setLabel,
                                          textAlign: TextAlign.center,
                                          style: TextStyle(
                                            color: Colors.grey[600],
                                            fontSize: 12,
                                            fontWeight: FontWeight.bold,
                                          ),
                                        )),
                                      ),
                                      // Last Time (flex:3)
                                      Expanded(
                                        flex: 3,
                                        child: Center(
                                            child: Text(
                                          l10n.lastTimeLabel,
                                          textAlign: TextAlign.center,
                                          style: TextStyle(
                                            color: Colors.grey[600],
                                            fontSize: 12,
                                            fontWeight: FontWeight.bold,
                                          ),
                                        )),
                                      ),
                                      // KG (flex:2)
                                      Expanded(
                                        flex: 2,
                                        child: Center(
                                            child: Text(
                                          l10n.kgLabel,
                                          textAlign: TextAlign.center,
                                          style: TextStyle(
                                            color: Colors.grey[600],
                                            fontSize: 12,
                                            fontWeight: FontWeight.bold,
                                          ),
                                        )),
                                      ),
                                      // Reps (flex:2)
                                      Expanded(
                                        flex: 2,
                                        child: Center(
                                            child: Text(
                                          l10n.repsLabel,
                                          textAlign: TextAlign.center,
                                          style: TextStyle(
                                            color: Colors.grey[600],
                                            fontSize: 12,
                                            fontWeight: FontWeight.bold,
                                          ),
                                        )),
                                      ),
                                      // Platzhalter für Prüf‐Button (48px breit)
                                      const SizedBox(width: 48),
                                    ],
                                  ),

                                  //const Divider(),
                                  ...routineExercise.setTemplates
                                      .asMap()
                                      .entries
                                      .map((setEntry) {
                                    final setTemplate = setEntry.value;
                                    int workingSetIndex = 0;
                                    for (int i = 0; i <= setEntry.key; i++) {
                                      final currentTemplate =
                                          routineExercise.setTemplates[i];
                                      final currentSetType = _setUIData[
                                          currentTemplate.id!]!['setType'];
                                      if (currentSetType != 'warmup') {
                                        workingSetIndex++;
                                      }
                                    }

                                    return _buildSetRow(
                                      workingSetIndex,
                                      routineExercise,
                                      setTemplate,
                                      manager.completedSets
                                          .contains(setTemplate.id!),
                                      colorScheme,
                                      _lastPerformances[
                                          routineExercise.exercise.nameEn],
                                    );
                                  }),
                                  SizedBox(height: DesignConstants.spacingS),
                                  TextButton.icon(
                                    onPressed: () => _addSet(routineExercise),
                                    icon: const Icon(Icons.add),
                                    label: Text(l10n.addSetButton),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                ),
              ],
            ),
      floatingActionButton: GlassFab(
        onPressed: _addExercise,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
      bottomNavigationBar: AnimatedBuilder(
        animation: manager,
        builder: (context, _) {
          final bar = _buildRestBottomBar(l10n, colorScheme);
          return bar ?? const SizedBox.shrink();
        },
      ),
    );
  }

  Widget _buildSetRow(
    int setIndex,
    RoutineExercise re,
    SetTemplate template,
    bool isCompleted,
    ColorScheme colorScheme,
    SetLog? lastPerf,
  ) {
    final setType = _setUIData[template.id!]!['setType'];

    return Dismissible(
      key: ValueKey(template.id),
      direction:
          isCompleted ? DismissDirection.none : DismissDirection.endToStart,
      onDismissed: (_) => _removeSet(re, template.id!),
      background: Container(
        color: Colors.redAccent,
        alignment: Alignment.centerRight,
        padding: const EdgeInsets.symmetric(horizontal: 20),
        child: const Icon(Icons.delete, color: Colors.white),
      ),
      child: Container(
        decoration: BoxDecoration(
          color:
              isCompleted ? Colors.green.withOpacity(0.4) : Colors.transparent,
        ),
        child: Row(
          children: [
            // Set-Index als große farbige Zahl
            Expanded(
              flex: 2,
              child: Center(
                child: Builder(
                  builder: (_) {
                    Color textColor;
                    switch (setType) {
                      case 'warmup':
                        textColor = Colors.orange;
                        break;
                      case 'dropset':
                        textColor = Colors.blue;
                        break;
                      case 'failure':
                        textColor = Colors.red;
                        break;
                      default:
                        textColor = Colors.grey;
                    }
                    return GestureDetector(
                      onTap: () {
                        if (!isCompleted) _showSetTypePicker(template.id!);
                      },
                      child: Text(
                        _getSetDisplayText(setType, setIndex),
                        style: TextStyle(
                          color: textColor,
                          fontSize: 20,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    );
                  },
                ),
              ),
            ),
            // Last Time
            Expanded(
              flex: 3,
              child: Text(
                lastPerf != null
                    ? "${lastPerf.weightKg?.toStringAsFixed(1).replaceAll('.0', '')}kg × ${lastPerf.reps}"
                    : "-",
                textAlign: TextAlign.center,
                style: TextStyle(color: Colors.grey[500], fontSize: 12),
              ),
            ),
            // Weight input
            Expanded(
              flex: 2,
              child: TextFormField(
                controller: _weightControllers[template.id!],
                textAlign: TextAlign.center,
                keyboardType:
                    const TextInputType.numberWithOptions(decimal: true),
                decoration: const InputDecoration(
                    border: InputBorder.none,
                    isDense: true,
                    fillColor: Colors.transparent),
                enabled: !isCompleted,
              ),
            ),
            const SizedBox(width: 8),
            // Reps input
            Expanded(
              flex: 2,
              child: TextFormField(
                controller: _repsControllers[template.id!],
                textAlign: TextAlign.center,
                keyboardType: TextInputType.number,
                decoration: const InputDecoration(
                    border: InputBorder.none,
                    isDense: true,
                    fillColor: Colors.transparent),
                enabled: !isCompleted,
              ),
            ),
            // Erledigt-Button mit Abstand zum Rand
            Padding(
              padding: const EdgeInsets.only(right: 8.0),
              child: SizedBox(
                width: 48,
                child: IconButton(
                  icon: Icon(
                    isCompleted
                        ? Icons.check_circle
                        : Icons.check_circle_outline,
                    color: isCompleted ? Colors.green : Colors.grey,
                  ),
                  onPressed: () {
                    if (isCompleted) {
                      _unlogSet(template.id!);
                    } else {
                      _logSet(template.id!, re);
                    }
                  },
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget? _buildRestBottomBar(AppLocalizations l10n, ColorScheme colorScheme) {
    final manager = WorkoutSessionManager();
    final isRunning = manager.remainingRestSeconds > 0;
    final isDoneBanner = !isRunning && manager.showRestDone;
    if (!isRunning && !isDoneBanner) return null;

    final theme = Theme.of(context);

    if (isRunning) {
      return BottomAppBar(
        color: colorScheme.surface,
        elevation: 0,
        // KORREKTUR: shape ist null
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                "${l10n.restTimerLabel}: ${manager.remainingRestSeconds}s",
                style: theme.textTheme.titleLarge?.copyWith(
                  fontSize: 22,
                  fontWeight: FontWeight.w700,
                  color: colorScheme.primary,
                ),
              ),
              ElevatedButton(
                onPressed: () {
                  manager.cancelRest();
                },
                child: Text(l10n.skipButton),
              ),
            ],
          ),
        ),
      );
    }
    // Pause vorbei
    return BottomAppBar(
      color: Colors.green.shade600,
      elevation: 0,
      // KORREKTUR: shape ist null
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            const Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 8),
                Text(
                  "Pause vorbei!",
                  style: TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.w700,
                      fontSize: 18),
                ),
              ],
            ),
            TextButton(
              onPressed: () {
                manager.cancelRest();
              },
              child: Text(l10n.snackbar_button_ok),
            ),
          ],
        ),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\main_screen.dart =====

// lib/screens/main_screen.dart (Final & Vollständig Korrigiert)

import 'dart:io';
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/home.dart';
import 'package:lightweight/screens/live_workout_screen.dart';
import 'package:lightweight/screens/nutrition_hub_screen.dart';
import 'package:lightweight/screens/profile_screen.dart';
import 'package:lightweight/services/workout_session_manager.dart';
import 'package:lightweight/util/time_util.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:provider/provider.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/screens/add_food_screen.dart';
import 'package:lightweight/screens/add_measurement_screen.dart';
import 'package:lightweight/screens/routines_screen.dart';
import 'package:lightweight/dialogs/quantity_dialog_content.dart';
import 'package:lightweight/dialogs/water_dialog_content.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/screens/workout_hub_screen.dart';
import 'package:lightweight/screens/statistics_hub_screen.dart';
import 'package:lightweight/services/profile_service.dart';
import 'package:lightweight/widgets/keep_alive_page.dart';

class MainScreen extends StatefulWidget {
  const MainScreen({super.key});
  @override
  State<MainScreen> createState() => _MainScreenState();
}

class _MainScreenState extends State<MainScreen> with TickerProviderStateMixin {
  late final TabController _tabController;

  // KORREKTUR 1: Der Key verwendet jetzt den öffentlichen Klassennamen 'HomeState'.
  final GlobalKey<HomeState> _homeKey = GlobalKey<HomeState>();

  late final List<Widget> _pages;
  bool _isAddMenuOpen = false;
  late final AnimationController _menuController;
  // Hilfsfunktion: NaN -> 0.0 und [0,1] clampen
  double _safe01(double v) => v.isNaN ? 0.0 : v.clamp(0.0, 1.0).toDouble();
  late final l10n = AppLocalizations.of(context)!;

  @override
  void initState() {
    super.initState();
    _pages = [
      KeepAlivePage(
        storageKey: const PageStorageKey('tab_home'),
        child: Home(key: _homeKey),
      ),
      const KeepAlivePage(
        storageKey: PageStorageKey('tab_nutrition'),
        child: NutritionHubScreen(),
      ),
      const KeepAlivePage(
        storageKey: PageStorageKey('tab_workout'),
        child: WorkoutHubScreen(),
      ),
      const KeepAlivePage(
        storageKey: PageStorageKey('tab_stats'),
        child: StatisticsHubScreen(),
      ),
      const KeepAlivePage(
        storageKey: PageStorageKey('tab_profile'),
        child: ProfileScreen(),
      ),
    ];

    // KORREKTUR 2: Der Controller wird jetzt konsistent mit der Länge von _pages (5) initialisiert.
    _tabController = TabController(length: _pages.length, vsync: this);
    _menuController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 400),
    );
  }

  @override
  void dispose() {
    _tabController.dispose();
    _menuController.dispose();
    super.dispose();
  }

  // ===========================================================================
  // ZENTRALISIERTE LOGIK
  // ===========================================================================

  Future<void> _refreshHomeScreen() async {
    if (_tabController.index == 0) {
      _homeKey.currentState?.loadAllHomeScreenData();
    }
  }

  void _addFoodItem(FoodItem item) async {
    final result = await _showQuantityDialog(item);
    if (result != null && mounted) {
      final quantity = result.$1;
      final timestamp = result.$2;
      final countAsWater = result.$3;
      final mealType = result.$4;
      final newEntry = FoodEntry(
          barcode: item.barcode,
          timestamp: timestamp,
          quantityInGrams: quantity,
          mealType: mealType);
      await DatabaseHelper.instance.insertFoodEntry(newEntry);
      if (countAsWater) {
        await DatabaseHelper.instance.insertWaterEntry(quantity, timestamp);
      }
      _refreshHomeScreen();
    }
  }

  void _addWater(int quantityInMl, DateTime timestamp) async {
    await DatabaseHelper.instance.insertWaterEntry(quantityInMl, timestamp);
    _refreshHomeScreen();
  }

  Future<(int, DateTime)?> _showWaterDialog() async {
    final GlobalKey<WaterDialogContentState> dialogStateKey =
        GlobalKey<WaterDialogContentState>();
    return showDialog<(int, DateTime)>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(l10n.add_liquid_title),
          content: WaterDialogContent(key: dialogStateKey),
          actions: [
            TextButton(
                child: Text(l10n.cancel),
                onPressed: () => Navigator.of(context).pop(null)),
            FilledButton(
              child: Text(l10n.add_button),
              onPressed: () {
                final state = dialogStateKey.currentState;
                if (state != null) {
                  final quantity = int.tryParse(state.quantityText);
                  if (quantity != null && quantity > 0) {
                    Navigator.of(context)
                        .pop((quantity, state.selectedDateTime));
                  }
                }
              },
            ),
          ],
        );
      },
    );
  }

  Future<(int, DateTime, bool, String)?> _showQuantityDialog(
      FoodItem item) async {
    final GlobalKey<QuantityDialogContentState> dialogStateKey =
        GlobalKey<QuantityDialogContentState>();
    return showDialog<(int, DateTime, bool, String)?>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(item.name, maxLines: 2, overflow: TextOverflow.ellipsis),
          content: QuantityDialogContent(key: dialogStateKey, item: item),
          actions: [
            TextButton(
                child: Text(l10n.cancel),
                onPressed: () => Navigator.of(context).pop(null)),
            FilledButton(
              child: Text(l10n.add_button),
              onPressed: () {
                final state = dialogStateKey.currentState;
                if (state != null) {
                  final quantity = int.tryParse(state.quantityText);
                  if (quantity != null && quantity > 0) {
                    Navigator.of(context).pop((
                      quantity,
                      state.selectedDateTime,
                      state.countAsWater,
                      state.selectedMealType
                    ));
                  }
                }
              },
            ),
          ],
        );
      },
    );
  }

  // ===========================================================================
  // Diese Methode wird jetzt vom neuen UI aufgerufen
  void _executeAddMenuAction(String action) async {
    // KORREKTUR: Die Navigations-Logik aus deiner AddMenuSheet ist jetzt hier.
    switch (action) {
      case 'start_workout':
        Navigator.of(context).push(
            MaterialPageRoute(builder: (context) => const RoutinesScreen()));
        break;
      case 'add_measurement':
        Navigator.of(context)
            .push(MaterialPageRoute(
                builder: (context) => const AddMeasurementScreen()))
            .then((success) {
          if (success == true) _refreshHomeScreen();
        });
        break;
      case 'add_food':
        final selectedFoodItem = await Navigator.of(context).push<FoodItem>(
            MaterialPageRoute(builder: (context) => const AddFoodScreen()));
        if (selectedFoodItem != null) _addFoodItem(selectedFoodItem);
        break;
      case 'add_liquid':
        final waterResult = await _showWaterDialog();
        if (waterResult != null) _addWater(waterResult.$1, waterResult.$2);
        break;
    }
  }
// In lib/screens/main_screen.dart

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = AppLocalizations.of(context)!;

    final List<Map<String, dynamic>> speedDialActions = [
      {
        'icon': Icons.local_drink,
        'label': l10n.addLiquidOption,
        'action': 'add_liquid'
      },
      {
        'icon': Icons.restaurant_menu,
        'label': l10n.addFoodOption,
        'action': 'add_food'
      },
      {
        'icon': Icons.straighten_outlined,
        'label': l10n.addMeasurement,
        'action': 'add_measurement'
      },
      {
        'icon': Icons.fitness_center,
        'label': l10n.startWorkout,
        'action': 'start_workout'
      },
    ];

    return Stack(
      children: [
        Scaffold(
          appBar: AppBar(
            automaticallyImplyLeading: false,
            elevation: 0,
            backgroundColor: theme.scaffoldBackgroundColor,
            bottom: PreferredSize(
                preferredSize: const Size.fromHeight(0.0),
                child: Container(color: Colors.transparent, height: 0.0)),
            title: TabBar(
              controller: _tabController,
              isScrollable: false,
              labelPadding: const EdgeInsets.symmetric(horizontal: 0.0),
              indicator: const UnderlineTabIndicator(
                borderSide: BorderSide(width: 0.0, color: Colors.transparent),
              ),
              indicatorColor: Colors.transparent,
              indicatorWeight: 0.0001,
              splashFactory: NoSplash.splashFactory,
              overlayColor: WidgetStateProperty.all(Colors.transparent),
              dividerColor: Colors.transparent,
              indicatorSize: TabBarIndicatorSize.label,
              labelColor: theme.brightness == Brightness.light
                  ? Colors.black
                  : Colors.white,
              unselectedLabelColor: Colors.grey.shade600,
              labelStyle: const TextStyle(
                fontSize: 23,
                fontWeight: FontWeight.w900,
                letterSpacing: 0.0,
              ),
              unselectedLabelStyle: const TextStyle(
                fontSize: 23,
                fontWeight: FontWeight.w800,
                letterSpacing: 0.0,
              ),
              tabs: [
                const Tab(text: 'Home'),
                const Tab(text: 'Food'),
                const Tab(text: 'Train'),
                const Tab(text: 'Stats'),
                // KORREKTUR: Der Profil-Tab reagiert jetzt auf seine Auswahl.
                // Erhöht den Radius, wenn der Tab ausgewählt ist.
                AnimatedBuilder(
                  // HINZUGEFÜGT: animated, damit die Größe sich animiert
                  animation: _tabController,
                  builder: (context, child) {
                    final isProfileSelected =
                        _tabController.index == 4; // Index des Profil-Tabs
                    final double radius =
                        isProfileSelected ? 21 : 19; // Größer, wenn aktiv
                    final double iconSize =
                        isProfileSelected ? 24 : 22; // Icon-Größe anpassen

                    return Consumer<ProfileService>(
                      builder: (context, profileService, child) {
                        return Tab(
                          icon: CircleAvatar(
                            radius: radius, // Dynamischer Radius
                            backgroundColor: Colors.grey.shade300,
                            backgroundImage:
                                profileService.profileImagePath != null
                                    ? FileImage(
                                        File(profileService.profileImagePath!))
                                    : null,
                            child: profileService.profileImagePath == null
                                ? Icon(Icons.person,
                                    size: iconSize,
                                    color:
                                        Colors.black54) // Dynamische Icon-Größe
                                : null,
                          ),
                        );
                      },
                    );
                  },
                ),
              ],
            ),
          ),
          body: TabBarView(
            controller: _tabController,
            children: _pages,
          ),
          floatingActionButton: GlassFab(
            onPressed: () {
              setState(() {
                _isAddMenuOpen = !_isAddMenuOpen;
                if (_isAddMenuOpen) {
                  _menuController.forward();
                } else {
                  _menuController.reverse();
                }
              });
            },
          ),
          bottomNavigationBar: Consumer<WorkoutSessionManager>(
            builder: (context, manager, child) {
              if (!manager.isActive) {
                return const SizedBox.shrink();
              }

              return BottomAppBar(
                color: theme.colorScheme.primary,
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                      horizontal: 16.0, vertical: 8.0),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(formatDuration(manager.elapsedDuration),
                          style: const TextStyle(
                              color: Colors.white,
                              fontSize: 18,
                              fontWeight: FontWeight.bold)),
                      Row(
                        // KORREKTUR: Die Buttons in eine eigene Row packen
                        children: [
                          // HINZUGEFÜGT: Der "Verwerfen"-Knopf
                          TextButton(
                            onPressed: () async {
                              final logId = manager.workoutLog?.id;
                              if (logId != null) {
                                await WorkoutDatabaseHelper.instance
                                    .deleteWorkoutLog(logId);
                              }
                              manager
                                  .finishWorkout(); // Beendet die Session im Manager
                            },
                            style: TextButton.styleFrom(
                              backgroundColor: Colors.red
                                  .shade600, // Auffälliges Rot für die Warnung
                              foregroundColor: Colors.white,
                            ),
                            child: Text(l10n.discard_button),
                          ),
                          const SizedBox(
                              width: 8), // Abstand zwischen den Knöpfen
                          ElevatedButton(
                            onPressed: () {
                              if (manager.workoutLog != null &&
                                  manager.workoutLog!.id != null) {
                                Navigator.of(context).push(
                                  MaterialPageRoute(
                                    builder: (context) => LiveWorkoutScreen(
                                      workoutLog: manager.workoutLog!,
                                      routine: null,
                                    ),
                                  ),
                                );
                              }
                            },
                            style: ElevatedButton.styleFrom(
                              backgroundColor: theme.colorScheme.onPrimary,
                              foregroundColor: theme.colorScheme.primary,
                            ),
                            child: Text(l10n.continue_workout_button),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        ),
// Overlay & Speed-Dial
        AnimatedBuilder(
          animation: _menuController,
          builder: (context, _) {
            // Fortschritt sauber in [0,1]
            final v = _safe01(_menuController.value);

            return Offstage(
              // Wenn zu: gar nicht rendern / hittesten
              offstage: v == 0.0,
              child: IgnorePointer(
                // Wenn zu: keine Gesten durchlassen
                ignoring: v == 0.0,
                child: Stack(
                  children: [
                    // Blur-Overlay
                    Opacity(
                      opacity: v,
                      child: GestureDetector(
                        onTap: () {
                          setState(() {
                            _isAddMenuOpen = false;
                            _menuController.reverse();
                          });
                        },
                        child: BackdropFilter(
                          filter: ImageFilter.blur(
                            sigmaX: 6.0 * v,
                            sigmaY: 6.0 * v,
                          ),
                          child: Container(
                            color: Colors.black.withOpacity(0.4 * v),
                          ),
                        ),
                      ),
                    ),

                    // Actions (gestaffelt vom FAB „hochfahren“)
                    Positioned(
                      bottom: 100.0,
                      right: 20.0,
                      child: Material(
                        color: Colors
                            .transparent, // eigener Ink-Kontext -> kein gelber Balken mehr
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.end,
                          children:
                              speedDialActions.asMap().entries.map((entry) {
                            final index = entry.key;
                            final action = entry.value;

                            final curved = CurvedAnimation(
                              parent: _menuController,
                              curve: Interval(
                                (index * 0.12).clamp(0.0, 0.95),
                                1.0,
                                curve: Curves.easeOutBack,
                              ),
                            );

                            final tv = _safe01(curved.value);
                            final offsetY = 90.0 * (index + 1);

                            return Transform.translate(
                              offset: Offset(0, (1 - tv) * offsetY),
                              child: Opacity(
                                opacity: tv,
                                child: Padding(
                                  padding: const EdgeInsets.symmetric(
                                      vertical: 10.0),
                                  child: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      // Text links
                                      Text(
                                        action['label'],
                                        style: TextStyle(
                                          color: Theme.of(context).brightness ==
                                                  Brightness.light
                                              ? Colors.black87
                                              : Colors.white,
                                          fontWeight: FontWeight.bold,
                                          fontSize: 18,
                                        ),
                                      ),
                                      const SizedBox(width: 16),
                                      // Glas-Icon rechts
                                      GestureDetector(
                                        behavior: HitTestBehavior.opaque,
                                        onTap: () {
                                          setState(() {
                                            _isAddMenuOpen = false;
                                            _menuController.reverse();
                                          });
                                          _executeAddMenuAction(
                                              action['action']);
                                        },
                                        child: ClipRRect(
                                          borderRadius:
                                              BorderRadius.circular(20),
                                          child: BackdropFilter(
                                            filter: ImageFilter.blur(
                                                sigmaX: 12, sigmaY: 12),
                                            child: Container(
                                              width: 76,
                                              height: 76,
                                              decoration: BoxDecoration(
                                                color: Colors.white
                                                    .withOpacity(0.15),
                                                borderRadius:
                                                    BorderRadius.circular(20),
                                                border: Border.all(
                                                  color: Colors.white
                                                      .withOpacity(0.3),
                                                  width: 1.5,
                                                ),
                                              ),
                                              child: Icon(
                                                action['icon'],
                                                size: 34,
                                                color: Colors.white,
                                              ),
                                            ),
                                          ),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ),
                            );
                          }).toList(),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      ],
    );
  }
}


===== Datei: D:\lightweight\lib\screens\measurements_screen.dart =====

// lib/screens/measurements_screen.dart (Final & De-Materialisiert - mit AppBar)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/measurement_session.dart';
import 'package:lightweight/screens/add_measurement_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/measurement_chart_widget.dart';
import 'package:lightweight/widgets/summary_card.dart';

class MeasurementsScreen extends StatefulWidget {
  const MeasurementsScreen({super.key});

  @override
  State<MeasurementsScreen> createState() => _MeasurementsScreenState();
}

class _MeasurementsScreenState extends State<MeasurementsScreen> {
  bool _isLoading = true;
  List<MeasurementSession> _sessions = [];
  String? _selectedChartType;
  List<String> _availableMeasurementTypes = [];

  DateTimeRange _currentChartDateRange = DateTimeRange(
    start: DateTime.now().subtract(const Duration(days: 29)),
    end: DateTime.now(),
  );
  final List<String> _chartDateRangeKeys = ['30D', '90D', '180D', 'All'];
  String _selectedChartRangeKey = '30D';

  @override
  void initState() {
    super.initState();
    _loadMeasurements();
  }

  Future<void> _loadMeasurements() async {
    setState(() => _isLoading = true);
    final sessions = await DatabaseHelper.instance.getMeasurementSessions();

    final Set<String> types = {};
    for (final session in sessions) {
      for (final measurement in session.measurements) {
        types.add(measurement.type);
      }
    }

    if (mounted) {
      setState(() {
        _sessions = sessions;
        _availableMeasurementTypes = types.toList()..sort();
        if (_selectedChartType == null &&
            _availableMeasurementTypes.isNotEmpty) {
          _selectedChartType = _availableMeasurementTypes.first;
        }
        _isLoading = false;
      });
      _loadChartData();
    }
  }

  Future<void> _loadChartData() async {
    if (_selectedChartType == null || _selectedChartType!.isEmpty) return;

    final now = DateTime.now();
    DateTime start;
    DateTime end = DateTime(now.year, now.month, now.day, 23, 59, 59);

    switch (_selectedChartRangeKey) {
      case '90D':
        start = now.subtract(const Duration(days: 89));
        break;
      case '180D':
        start = now.subtract(const Duration(days: 179));
        break;
      case 'All':
        final earliest =
            await DatabaseHelper.instance.getEarliestMeasurementDate();
        start = earliest ?? now;
        break;
      case '30D':
      default:
        start = now.subtract(const Duration(days: 29));
    }

    setState(() {
      _currentChartDateRange = DateTimeRange(start: start, end: end);
    });
  }

  Future<void> _deleteSession(int id) async {
    await DatabaseHelper.instance.deleteMeasurementSession(id);
    _loadMeasurements();
  }

  void _navigateToCreateMeasurement() {
    Navigator.of(context)
        .push(MaterialPageRoute(
            builder: (context) => const AddMeasurementScreen()))
        .then((_) => _loadMeasurements());
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          l10n.measurementsScreenTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _sessions.isEmpty
              ? _buildEmptyState(l10n, context)
              : ListView(
                  padding: DesignConstants.cardPadding,
                  children: [
                    if (_availableMeasurementTypes.isNotEmpty) ...[
                      _buildChartSection(
                          l10n, colorScheme, Theme.of(context).textTheme),
                      SizedBox(height: DesignConstants.spacingXL),
                    ],
                    _buildSectionTitle(context, l10n.all_measurements),
                    ..._sessions.map((session) => _buildMeasurementSessionCard(
                        l10n, colorScheme, session))
                  ],
                ),
      floatingActionButton: GlassFab(
        onPressed: _navigateToCreateMeasurement,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  Widget _buildEmptyState(AppLocalizations l10n, BuildContext context) {
    return Center(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(l10n.measurementsEmptyState,
                textAlign: TextAlign.center,
                style: Theme.of(context).textTheme.titleMedium),
            SizedBox(height: DesignConstants.spacingXL),
            ElevatedButton.icon(
              onPressed: _navigateToCreateMeasurement,
              icon: const Icon(Icons.add),
              label: Text(l10n.addMeasurement),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildChartSection(
      AppLocalizations l10n, ColorScheme colorScheme, TextTheme textTheme) {
    if (_selectedChartType == null) return const SizedBox.shrink();

    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: DropdownButtonHideUnderline(
                    child: DropdownButton<String>(
                      value: _selectedChartType,
                      isExpanded: true,
                      onChanged: (String? newValue) {
                        if (newValue != null) {
                          setState(() {
                            _selectedChartType = newValue;
                          });
                          _loadChartData();
                        }
                      },
                      items: _availableMeasurementTypes
                          .map<DropdownMenuItem<String>>((String value) {
                        return DropdownMenuItem<String>(
                          value: value,
                          child:
                              Text(_getLocalizedMeasurementType(l10n, value)),
                        );
                      }).toList(),
                      style: textTheme.titleMedium
                          ?.copyWith(fontWeight: FontWeight.bold),
                      icon: Icon(Icons.arrow_drop_down,
                          color: colorScheme.onSurfaceVariant),
                    ),
                  ),
                ),
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: _chartDateRangeKeys
                      .map((key) => _buildFilterButton(key, key))
                      .toList(),
                ),
              ],
            ),
            SizedBox(height: DesignConstants.spacingL),
            MeasurementChartWidget(
              chartType: _selectedChartType!,
              dateRange: _currentChartDateRange,
              lineColor: colorScheme.primary,
              unit: _getMeasurementUnit(_selectedChartType!),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFilterButton(String label, String key) {
    final theme = Theme.of(context);
    final isSelected = _selectedChartRangeKey == key;
    return GestureDetector(
      onTap: () {
        setState(() {
          _selectedChartRangeKey = key;
        });
        _loadChartData();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10.0, vertical: 6.0),
        decoration: BoxDecoration(
          color: isSelected
              ? theme.colorScheme.primary
              : theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
          borderRadius: BorderRadius.circular(8.0),
        ),
        child: Text(
          label,
          style: theme.textTheme.labelSmall?.copyWith(
            color: isSelected
                ? theme.colorScheme.onPrimary
                : theme.colorScheme.onSurfaceVariant,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  Widget _buildMeasurementSessionCard(AppLocalizations l10n,
      ColorScheme colorScheme, MeasurementSession session) {
    final locale = Localizations.localeOf(context).toString();
    final sortedMeasurements = session.measurements.toList()
      ..sort((a, b) => a.type.compareTo(b.type));

    return Dismissible(
      key: Key('session_${session.id}'),
      direction: DismissDirection.endToStart,
      onDismissed: (direction) => _deleteSession(session.id!),
      background: Container(
        color: Colors.redAccent,
        alignment: Alignment.centerRight,
        padding: const EdgeInsets.symmetric(horizontal: 20),
        child: const Icon(Icons.delete, color: Colors.white),
      ),
      child: SummaryCard(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            ListTile(
              contentPadding:
                  DesignConstants.screenPadding,
              title: Text(
                  DateFormat.yMMMMEEEEd(locale)
                      .add_Hm()
                      .format(session.timestamp),
                  style: const TextStyle(fontWeight: FontWeight.bold)),
              trailing: const Icon(Icons.chevron_right),
              onTap: () {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text(l10n.measurement_session_detail_view)),
                );
              },
            ),
            Divider(
                height: 1,
                thickness: 1,
                color: colorScheme.onSurfaceVariant.withOpacity(0.1)),
            ...sortedMeasurements.map((measurement) => ListTile(
                  contentPadding: const EdgeInsets.symmetric(
                      horizontal: 16.0, vertical: 4.0),
                  leading: _getMeasurementIcon(measurement.type),
                  title: Text(_getLocalizedMeasurementType(
                      l10n, measurement.type)), // l10n übergeben
                  trailing: Text(
                      "${measurement.value.toStringAsFixed(1)} ${measurement.unit}",
                      style: const TextStyle(fontWeight: FontWeight.bold)),
                )),
          ],
        ),
      ),
    );
  }

  // HINZUGEFÜGT: Helfermethoden für Lokalisierung, Einheit und Icons
  String _getLocalizedMeasurementType(AppLocalizations l10n, String type) {
    switch (type) {
      case 'weight':
        return l10n.measurementWeight;
      case 'fat_percent':
        return l10n.measurementFatPercent;
      case 'neck':
        return l10n.measurementNeck;
      case 'shoulder':
        return l10n.measurementShoulder;
      case 'chest':
        return l10n.measurementChest;
      case 'left_bicep':
        return l10n.measurementLeftBicep;
      case 'right_bicep':
        return l10n.measurementRightBicep;
      case 'left_forearm':
        return l10n.measurementLeftForearm;
      case 'right_forearm':
        return l10n.measurementRightForearm;
      case 'abdomen':
        return l10n.measurementAbdomen;
      case 'waist':
        return l10n.measurementWaist;
      case 'hips':
        return l10n.measurementHips;
      case 'left_thigh':
        return l10n.measurementLeftThigh;
      case 'right_thigh':
        return l10n.measurementRightThigh;
      case 'left_calf':
        return l10n.measurementLeftCalf;
      case 'right_calf':
        return l10n.measurementRightCalf;
      default:
        return type;
    }
  }

  String _getMeasurementUnit(String type) {
    // Hier die Einheiten basierend auf dem Typ zurückgeben
    switch (type) {
      case 'weight':
        return 'kg';
      case 'fat_percent':
        return '%';
      case 'neck':
      case 'shoulder':
      case 'chest':
      case 'left_bicep':
      case 'right_bicep':
      case 'left_forearm':
      case 'right_forearm':
      case 'abdomen':
      case 'waist':
      case 'hips':
      case 'left_thigh':
      case 'right_thigh':
      case 'left_calf':
      case 'right_calf':
        return 'cm';
      default:
        return '';
    }
  }

  Icon _getMeasurementIcon(String type) {
    // Hier Icons basierend auf dem Typ zurückgeben
    switch (type) {
      case 'weight':
        return const Icon(Icons.monitor_weight);
      case 'fat_percent':
        return const Icon(Icons.fitness_center);
      case 'neck':
        return const Icon(Icons.accessibility_new);
      case 'shoulder':
        return const Icon(Icons.accessibility_new);
      case 'chest':
        return const Icon(Icons.accessibility_new);
      case 'left_bicep':
        return const Icon(Icons.accessibility_new);
      case 'right_bicep':
        return const Icon(Icons.accessibility_new);
      case 'abdomen':
        return const Icon(Icons.accessibility_new);
      case 'waist':
        return const Icon(Icons.accessibility_new);
      case 'hips':
        return const Icon(Icons.accessibility_new);
      default:
        return const Icon(Icons.straighten);
    }
  }
}


===== Datei: D:\lightweight\lib\screens\measurement_session_detail_screen.dart =====

// lib/screens/measurement_session_detail_screen.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/measurement_session.dart';
import 'package:lightweight/util/design_constants.dart';

class MeasurementSessionDetailScreen extends StatelessWidget {
  final MeasurementSession session;

  const MeasurementSessionDetailScreen({super.key, required this.session});

  // Wir kopieren die Helfer-Methode hierher, um die Namen zu übersetzen.
  String _getLocalizedMeasurementName(String key, AppLocalizations l10n) {
    switch (key) {
      case 'weight':
        return l10n.measurementWeight;
      case 'fat_percent':
        return l10n.measurementFatPercent;
      case 'neck':
        return l10n.measurementNeck;
      // ... (füge hier alle anderen 'case' Anweisungen aus dem measurements_screen.dart ein)
      case 'right_calf':
        return l10n.measurementRightCalf;
      default:
        return key;
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true, // zeigt den Zurück-Pfeil
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          DateFormat.yMMMMd('de_DE').format(session.timestamp),
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      body: ListView(
        padding: DesignConstants.cardPadding,
        children: [
          ...session.measurements.map((measurement) {
            return Card(
              elevation: 2,
              margin: const EdgeInsets.symmetric(vertical: 6),
              child: ListTile(
                title:
                    Text(_getLocalizedMeasurementName(measurement.type, l10n)),
                trailing: Text(
                  "${measurement.value.toStringAsFixed(1)} ${measurement.unit}",
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                ),
              ),
            );
          }),
        ],
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\nutrition_hub_screen.dart =====

// lib/screens/nutrition_hub_screen.dart (Final, nach deinem Feedback)

import 'package:flutter/material.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/dialogs/quantity_dialog_content.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/tracked_food_item.dart';
import 'package:lightweight/screens/add_food_screen.dart';
import 'package:lightweight/screens/create_food_screen.dart';
import 'package:lightweight/screens/food_detail_screen.dart';
import 'package:lightweight/screens/nutrition_screen.dart';
import 'package:lightweight/screens/scanner_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/nutrition_summary_widget.dart'; // HINZUGEFÜGT
import 'package:lightweight/widgets/summary_card.dart';
import 'package:shared_preferences/shared_preferences.dart';

class NutritionHubScreen extends StatefulWidget {
  const NutritionHubScreen({super.key});

  @override
  State<NutritionHubScreen> createState() => _NutritionHubScreenState();
}

class _NutritionHubScreenState extends State<NutritionHubScreen> {
  bool _isLoading = true;
  DailyNutrition? _todaysNutrition;
  Map<String, List<TrackedFoodItem>> _todaysEntriesByMeal = {};

  @override
  void initState() {
    super.initState();
    _loadTodaysData();
  }

  Future<void> _loadTodaysData() async {
    if (!mounted) return;
    setState(() => _isLoading = true);

    final prefs = await SharedPreferences.getInstance();
    final targetCalories = prefs.getInt('targetCalories') ?? 2500;
    final targetProtein = prefs.getInt('targetProtein') ?? 180;
    final targetCarbs = prefs.getInt('targetCarbs') ?? 250;
    final targetFat = prefs.getInt('targetFat') ?? 80;
    final targetWater = prefs.getInt('targetWater') ?? 3000;

    final today = DateTime.now();
    final foodEntries = await DatabaseHelper.instance.getEntriesForDate(today);
    final waterIntake = await DatabaseHelper.instance.getWaterForDate(today);

    final summary = DailyNutrition(
      targetCalories: targetCalories,
      targetProtein: targetProtein,
      targetCarbs: targetCarbs,
      targetFat: targetFat,
      targetWater: targetWater,
    );
    summary.water = waterIntake;

    final Map<String, List<TrackedFoodItem>> groupedEntries = {
      'mealtypeBreakfast': [],
      'mealtypeLunch': [],
      'mealtypeDinner': [],
      'mealtypeSnack': []
    };

    for (final entry in foodEntries) {
      final foodItem = await ProductDatabaseHelper.instance
          .getProductByBarcode(entry.barcode);
      if (foodItem != null) {
        summary.calories +=
            (foodItem.calories / 100 * entry.quantityInGrams).round();
        summary.protein +=
            (foodItem.protein / 100 * entry.quantityInGrams).round();
        summary.carbs += (foodItem.carbs / 100 * entry.quantityInGrams).round();
        summary.fat += (foodItem.fat / 100 * entry.quantityInGrams).round();

        final trackedItem = TrackedFoodItem(entry: entry, item: foodItem);
        groupedEntries[entry.mealType]?.add(trackedItem);
      }
    }

    for (var meal in groupedEntries.values) {
      meal.sort((a, b) => b.entry.timestamp.compareTo(a.entry.timestamp));
    }

    if (mounted) {
      setState(() {
        _todaysNutrition = summary;
        _todaysEntriesByMeal = groupedEntries;
        _isLoading = false;
      });
    }
  }

  // HINZUGEFÜGT: Methoden für Löschen und Bearbeiten

  Future<void> _deleteFoodEntry(int id) async {
    await DatabaseHelper.instance.deleteFoodEntry(id);
    _loadTodaysData(); // Lade die Daten neu, um die Liste zu aktualisieren
  }

  Future<void> _editFoodEntry(TrackedFoodItem trackedItem) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<QuantityDialogContentState> dialogStateKey = GlobalKey();

    final result = await showDialog<(int, DateTime, bool, String)?>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(trackedItem.item.name,
              maxLines: 2, overflow: TextOverflow.ellipsis),
          content: QuantityDialogContent(
            key: dialogStateKey,
            item: trackedItem.item,
            initialQuantity: trackedItem.entry.quantityInGrams,
            initialTimestamp: trackedItem.entry.timestamp,
            initialMealType: trackedItem.entry.mealType,
          ),
          actions: [
            TextButton(
                child: Text(l10n.cancel),
                onPressed: () => Navigator.of(context).pop()),
            FilledButton(
                child: Text(l10n.save),
                onPressed: () {
                  final state = dialogStateKey.currentState;
                  if (state != null) {
                    final quantity = int.tryParse(state.quantityText);
                    if (quantity != null && quantity > 0) {
                      Navigator.of(context).pop((
                        quantity,
                        state.selectedDateTime,
                        state.countAsWater,
                        state.selectedMealType
                      ));
                    }
                  }
                }),
          ],
        );
      },
    );

    if (result != null) {
      final updatedEntry = FoodEntry(
        id: trackedItem.entry.id,
        barcode: trackedItem.item.barcode,
        quantityInGrams: result.$1,
        timestamp: result.$2,
        mealType: result.$4,
      );
      await DatabaseHelper.instance.updateFoodEntry(updatedEntry);
      _loadTodaysData(); // Lade die Daten neu
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final hasEntries =
        _todaysEntriesByMeal.values.any((list) => list.isNotEmpty);

    return Scaffold(
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : RefreshIndicator(
              onRefresh: _loadTodaysData,
              child: ListView(
                padding: DesignConstants.cardPadding,
                children: [
                  _buildSectionTitle(context, l10n.today_overview_text),
                  GestureDetector(
                    onTap: () => Navigator.of(context)
                        .push(MaterialPageRoute(
                            builder: (context) => const NutritionScreen()))
                        .then((_) => _loadTodaysData()),
                    // KORREKTUR 1: Die umgebende SummaryCard entfernt.
                    // NutritionSummaryWidget ist bereits eine SummaryCard.
                    child: _todaysNutrition != null
                        ? NutritionSummaryWidget(
                            nutritionData: _todaysNutrition!,
                            l10n: l10n,
                            isExpandedView: false)
                        : const SizedBox(),
                  ),
                  SizedBox(height: DesignConstants.spacingXL),
                  _buildSectionTitle(context, l10n.quick_add_text),
                  _buildQuickAddButton(
                      context,
                      l10n.addFoodOption,
                      Icons.search,
                      () => Navigator.of(context)
                          .push(MaterialPageRoute(
                              builder: (context) => const AddFoodScreen()))
                          .then((_) => _loadTodaysData())),
                  SizedBox(height: DesignConstants.spacingS),
                  _buildQuickAddButton(context, l10n.scann_barcode_capslock,
                      Icons.qr_code_scanner, _scanBarcodeAndAddFood),
                  SizedBox(height: DesignConstants.spacingS),
                  _buildQuickAddButton(
                      context,
                      l10n.fabCreateOwnFood,
                      Icons.add,
                      () => Navigator.of(context)
                          .push(MaterialPageRoute(
                              builder: (context) => const CreateFoodScreen()))
                          .then((_) => _loadTodaysData())),
                  SizedBox(height: DesignConstants.spacingXL),
                  _buildSectionTitle(context, l10n.protocol_today_capslock),
                  hasEntries
                      ? _buildTodaysLog(l10n)
                      : _buildEmptyLogState(l10n),
                ],
              ),
            ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(title,
          style: Theme.of(context)
              .textTheme
              .labelLarge
              ?.copyWith(color: Colors.grey[600], fontWeight: FontWeight.bold)),
    );
  }

  Widget _buildQuickAddButton(
      BuildContext context, String title, IconData icon, VoidCallback onTap) {
    return SummaryCard(
      child: ListTile(
        leading: Icon(icon),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        onTap: onTap,
        shape:
            RoundedRectangleBorder(borderRadius: BorderRadius.circular(24.0)),
      ),
    );
  }

  Widget _buildTodaysLog(AppLocalizations l10n) {
    // Diese Methode baut die Liste der Mahlzeiten für heute auf
    const mealOrder = [
      "mealtypeBreakfast",
      "mealtypeLunch",
      "mealtypeDinner",
      "mealtypeSnack"
    ];

    return Column(
      children: mealOrder.map((mealKey) {
        final entries = _todaysEntriesByMeal[mealKey];
        if (entries == null || entries.isEmpty) {
          return const SizedBox.shrink();
        }
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.only(top: 16.0, bottom: 8.0, left: 4.0),
              child: Text(_getLocalizedMealName(l10n, mealKey),
                  style: Theme.of(context).textTheme.titleMedium),
            ),
            ...entries.map((item) => _buildFoodEntryTile(l10n, item)),
          ],
        );
      }).toList(),
    );
  }

  Widget _buildFoodEntryTile(
      AppLocalizations l10n, TrackedFoodItem trackedItem) {
    // KORREKTUR: Das ListTile ist jetzt in einem Dismissible-Widget
    return Dismissible(
      key: Key('food_hub_entry_${trackedItem.entry.id}'),

      // Hintergrund für "Bearbeiten" (nach rechts wischen)
      background: Container(
        color: Colors.blueAccent,
        alignment: Alignment.centerLeft,
        padding: const EdgeInsets.symmetric(horizontal: 20),
        child: const Icon(Icons.edit, color: Colors.white),
      ),

      // Hintergrund für "Löschen" (nach links wischen)
      secondaryBackground: Container(
        color: Colors.redAccent,
        alignment: Alignment.centerRight,
        padding: const EdgeInsets.symmetric(horizontal: 20),
        child: const Icon(Icons.delete, color: Colors.white),
      ),

      // Diese Methode wird vor dem Löschen/Bearbeiten aufgerufen
      confirmDismiss: (direction) async {
        if (direction == DismissDirection.startToEnd) {
          // Nach rechts gewischt -> Bearbeiten
          _editFoodEntry(trackedItem);
          return false; // Verhindert, dass das Element aus der Liste entfernt wird
        } else {
          // Nach links gewischt -> Löschen
          return await showDialog<bool>(
                context: context,
                builder: (BuildContext context) {
                  return AlertDialog(
                    title: Text(l10n.deleteConfirmTitle),
                    content: Text(l10n.deleteConfirmContent),
                    actions: <Widget>[
                      TextButton(
                          onPressed: () => Navigator.of(context).pop(false),
                          child: Text(l10n.cancel)),
                      TextButton(
                          onPressed: () => Navigator.of(context).pop(true),
                          child: Text(l10n.delete)),
                    ],
                  );
                },
              ) ??
              false; // Gibt false zurück, wenn der Dialog geschlossen wird
        }
      },

      // Wird nur ausgeführt, wenn confirmDismiss 'true' zurückgibt (also beim Löschen)
      onDismissed: (direction) {
        if (direction == DismissDirection.endToStart) {
          _deleteFoodEntry(trackedItem.entry.id!);
        }
      },

      child: SummaryCard(
        child: ListTile(
          title: Text(trackedItem.item.name),
          subtitle: Text("${trackedItem.entry.quantityInGrams}g"),
          trailing: Text("${trackedItem.calculatedCalories} kcal"),
          onTap: () {
            Navigator.of(context)
                .push(MaterialPageRoute(
                    builder: (context) =>
                        FoodDetailScreen(trackedItem: trackedItem)))
                .then((_) => _loadTodaysData());
          },
        ),
      ),
    );
  }

  Widget _buildEmptyLogState(AppLocalizations l10n) {
    return SummaryCard(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Text(
          l10n.noEntriesForPeriod,
          textAlign: TextAlign.center,
          style: Theme.of(context).textTheme.bodyLarge,
        ),
      ),
    );
  }

  String _getLocalizedMealName(AppLocalizations l10n, String key) {
    switch (key) {
      case "mealtypeBreakfast":
        return l10n.mealtypeBreakfast;
      case "mealtypeLunch":
        return l10n.mealtypeLunch;
      case "mealtypeDinner":
        return l10n.mealtypeDinner;
      case "mealtypeSnack":
        return l10n.mealtypeSnack;
      default:
        return key;
    }
  }

  // DIESE METHODE HINZUFÜGEN
  Future<void> _scanBarcodeAndAddFood() async {
    final String? barcode = await Navigator.of(context).push<String>(
      MaterialPageRoute(builder: (context) => const ScannerScreen()),
    );

    if (barcode != null && mounted) {
      final foodItem =
          await ProductDatabaseHelper.instance.getProductByBarcode(barcode);

      if (foodItem != null) {
        _addFoodItem(foodItem);
      } else {
        // Produkt nicht gefunden, zeige eine Meldung. Optional kannst du hier anbieten,
        // den `CreateFoodScreen` zu öffnen.
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
                content: Text('Kein Produkt für Barcode "$barcode" gefunden.')),
          );
        }
      }
    }
  }

  // DIESE METHODE EBENFALLS HINZUFÜGEN (Code-Duplizierung, aber für den Moment am einfachsten)
  Future<void> _addFoodItem(FoodItem item) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<QuantityDialogContentState> dialogStateKey = GlobalKey();

    final result = await showDialog<(int, DateTime, bool, String)?>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(item.name, maxLines: 2, overflow: TextOverflow.ellipsis),
          content: QuantityDialogContent(key: dialogStateKey, item: item),
          actions: [
            TextButton(
                child: Text(l10n.cancel),
                onPressed: () => Navigator.of(context).pop(null)),
            FilledButton(
              child: Text(l10n.add_button),
              onPressed: () {
                final state = dialogStateKey.currentState;
                if (state != null) {
                  final quantity = int.tryParse(state.quantityText);
                  if (quantity != null && quantity > 0) {
                    Navigator.of(context).pop((
                      quantity,
                      state.selectedDateTime,
                      state.countAsWater,
                      state.selectedMealType
                    ));
                  }
                }
              },
            ),
          ],
        );
      },
    );

    if (result != null && mounted) {
      final newEntry = FoodEntry(
        barcode: item.barcode,
        quantityInGrams: result.$1,
        timestamp: result.$2,
        mealType: result.$4,
      );
      await DatabaseHelper.instance.insertFoodEntry(newEntry);

      if (result.$3) {
        // countAsWater
        await DatabaseHelper.instance.insertWaterEntry(result.$1, result.$2);
      }
      _loadTodaysData(); // Lade die Daten neu, um die UI zu aktualisieren
    }
  }
}


===== Datei: D:\lightweight\lib\screens\nutrition_screen.dart =====

// lib/screens/nutrition_screen.dart (Final & De-Materialisiert - Endgültige Korrektur)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/dialogs/quantity_dialog_content.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/tracked_food_item.dart';
import 'package:lightweight/models/timeline_entry.dart';
import 'package:lightweight/services/ui_state_service.dart';
import 'package:lightweight/widgets/nutrition_summary_widget.dart';
import 'package:lightweight/widgets/summary_card.dart';
import './food_detail_screen.dart';
import 'package:lightweight/util/date_util.dart';

class NutritionScreen extends StatefulWidget {
  const NutritionScreen({super.key});

  @override
  State<NutritionScreen> createState() => _NutritionScreenState();
}

class _NutritionScreenState extends State<NutritionScreen> {
  DailyNutrition? _nutritionData;
  List<dynamic> _displayItems = [];
  bool _isLoading = true;
  DateTimeRange _selectedDateRange = DateTime.now().isSameDate(DateTime.now())
      ? DateTimeRange(
          start: DateTime.now(), end: DateTime.now()) // Einzeltag für heute
      : DateTimeRange(
          start: DateTime.now().subtract(const Duration(days: 6)),
          end: DateTime.now()); // Standard: Letzte 7 Tage
  bool _isSummaryExpanded = UiStateService.instance.isNutritionSummaryExpanded;
  String _selectedRangeKey = '1D';
  bool _isHeaderVisible = true;

  @override
  void initState() {
    super.initState();
    _loadEntriesForDateRange(_selectedDateRange);
  }

  Future<void> _loadEntriesForDateRange(DateTimeRange range) async {
    if (!mounted) return;
    setState(() {
      _isLoading = true;
    });

    final prefs = await SharedPreferences.getInstance();
    final targetCalories = prefs.getInt('targetCalories') ?? 2500;
    final targetProtein = prefs.getInt('targetProtein') ?? 180;
    final targetCarbs = prefs.getInt('targetCarbs') ?? 250;
    final targetFat = prefs.getInt('targetFat') ?? 80;
    final targetWater = prefs.getInt('targetWater') ?? 3000;
    final targetSugar = prefs.getInt('targetSugar') ?? 50;
    final targetFiber = prefs.getInt('targetFiber') ?? 30;
    final targetSalt = prefs.getInt('targetSalt') ?? 6;

    final foodEntries = await DatabaseHelper.instance
        .getEntriesForDateRange(range.start, range.end);
    final waterEntries = await DatabaseHelper.instance
        .getWaterEntriesForDateRange(range.start, range.end);

    final numberOfDays = range.duration.inDays + 1;
    final newNutritionSummary = DailyNutrition(
      // KORREKTUR: Neue Variable
      targetCalories: targetCalories * numberOfDays,
      targetProtein: targetProtein * numberOfDays,
      targetCarbs: targetCarbs * numberOfDays,
      targetFat: targetFat * numberOfDays,
      targetWater: targetWater * numberOfDays,
      targetSugar: targetSugar * numberOfDays,
      targetFiber: targetFiber * numberOfDays,
      targetSalt: targetSalt * numberOfDays,
    );

    final List<FoodTimelineEntry> foodTimeline = [];
    for (final entry in foodEntries) {
      final foodItem = await ProductDatabaseHelper.instance
          .getProductByBarcode(entry.barcode);
      if (foodItem != null) {
        newNutritionSummary.calories +=
            (foodItem.calories / 100 * entry.quantityInGrams).round();
        newNutritionSummary.protein +=
            (foodItem.protein / 100 * entry.quantityInGrams).round();
        newNutritionSummary.carbs +=
            (foodItem.carbs / 100 * entry.quantityInGrams).round();
        newNutritionSummary.fat +=
            (foodItem.fat / 100 * entry.quantityInGrams).round();
        newNutritionSummary.sugar +=
            (foodItem.sugar ?? 0) / 100 * entry.quantityInGrams;
        newNutritionSummary.fiber +=
            (foodItem.fiber ?? 0) / 100 * entry.quantityInGrams;
        newNutritionSummary.salt +=
            (foodItem.salt ?? 0) / 100 * entry.quantityInGrams;
        foodTimeline.add(
            FoodTimelineEntry(TrackedFoodItem(entry: entry, item: foodItem)));
      }
    }

    final waterTimeline =
        waterEntries.map((e) => WaterTimelineEntry(e)).toList();
    newNutritionSummary.water =
        waterEntries.fold(0, (sum, entry) => sum + entry.quantityInMl);

    final List<dynamic> finalDisplayList = [];

    if (range.duration.inDays == 0) {
      final Map<String, List<FoodTimelineEntry>> groupedFood = {};
      for (final entry in foodTimeline) {
        final mealType = entry.trackedItem.entry.mealType;
        if (groupedFood.containsKey(mealType)) {
          groupedFood[mealType]!.add(entry);
        } else {
          groupedFood[mealType] = [entry];
        }
      }

      const mealOrder = [
        "mealtypeBreakfast",
        "mealtypeLunch",
        "mealtypeDinner",
        "mealtypeSnack"
      ];
      for (final mealKey in mealOrder) {
        if (groupedFood.containsKey(mealKey)) {
          finalDisplayList.add(mealKey);
          groupedFood[mealKey]!
              .sort((a, b) => b.timestamp.compareTo(a.timestamp));
          finalDisplayList.addAll(groupedFood[mealKey]!);
        }
      }

      if (waterTimeline.isNotEmpty) {
        finalDisplayList.add("waterHeader");
        waterTimeline.sort((a, b) => b.timestamp.compareTo(a.timestamp));
        finalDisplayList.addAll(waterTimeline);
      }
    } else {
      final List<TimelineEntry> combinedList = [
        ...foodTimeline,
        ...waterTimeline
      ];
      combinedList.sort((a, b) => b.timestamp.compareTo(a.timestamp));

      DateTime? lastDate;
      for (final entry in combinedList) {
        final entryDate = entry.timestamp;
        if (lastDate == null || !entryDate.isSameDate(lastDate)) {
          finalDisplayList.add(entryDate);
          lastDate = entryDate;
        }
        finalDisplayList.add(entry);
      }
    }

    if (mounted) {
      setState(() {
        _nutritionData =
            newNutritionSummary; // KORREKTUR: Die Variable korrekt zuweisen
        _displayItems = finalDisplayList;
        _isLoading = false;
      });
    }
  }

  void _navigateDay(bool forward) {
    final currentDay = _selectedDateRange.start;
    final newDay = currentDay.add(Duration(days: forward ? 1 : -1));
    // Navigation über den heutigen Tag hinaus verhindern
    if (forward && newDay.isAfter(DateTime.now())) return;

    setState(() {
      _selectedDateRange = DateTimeRange(start: newDay, end: newDay);
      _selectedRangeKey = 'custom'; // De-selektiert die Filter-Chips
    });
    _loadEntriesForDateRange(_selectedDateRange);
  }

  Future<void> _setTimeRange(String key) async {
    setState(() => _selectedRangeKey = key);
    final now = DateTime.now();
    DateTime start;
    DateTime end = DateTime(now.year, now.month, now.day, 23, 59, 59);

    switch (key) {
      case '1W':
        start = now.subtract(const Duration(days: 6));
        break;
      case '1M':
        start = now.subtract(const Duration(days: 29));
        break;
      case 'All':
        final earliest =
            await DatabaseHelper.instance.getEarliestFoodEntryDate();
        start = earliest ?? now;
        break;
      case '1D':
      default:
        start = now;
    }

    final normalizedStart = DateTime(start.year, start.month, start.day);
    setState(() =>
        _selectedDateRange = DateTimeRange(start: normalizedStart, end: end));
    _loadEntriesForDateRange(_selectedDateRange);
  }

  Future<void> _deleteFoodEntry(int id) async {
    await DatabaseHelper.instance.deleteFoodEntry(id);
    _loadEntriesForDateRange(_selectedDateRange);
  }

  Future<void> _deleteWaterEntry(int id) async {
    await DatabaseHelper.instance.deleteWaterEntry(id);
    _loadEntriesForDateRange(_selectedDateRange);
  }

  Future<void> _editFoodEntry(TrackedFoodItem trackedItem) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<QuantityDialogContentState> dialogStateKey = GlobalKey();

    final result = await showDialog<(int, DateTime, bool, String)?>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(trackedItem.item.name,
              maxLines: 2, overflow: TextOverflow.ellipsis),
          content: QuantityDialogContent(
            key: dialogStateKey,
            item: trackedItem.item,
            initialQuantity: trackedItem.entry.quantityInGrams,
            initialTimestamp: trackedItem.entry.timestamp,
            initialMealType: trackedItem.entry.mealType,
          ),
          actions: [
            TextButton(
                child: Text(l10n.cancel),
                onPressed: () => Navigator.of(context).pop()),
            FilledButton(
                child: Text(l10n.save),
                onPressed: () {
                  final state = dialogStateKey.currentState;
                  if (state != null) {
                    final quantity = int.tryParse(state.quantityText);
                    if (quantity != null && quantity > 0) {
                      Navigator.of(context).pop((
                        quantity,
                        state.selectedDateTime,
                        state.countAsWater,
                        state.selectedMealType
                      ));
                    }
                  }
                }),
          ],
        );
      },
    );

    if (result != null) {
      final updatedEntry = FoodEntry(
        id: trackedItem.entry.id,
        barcode: trackedItem.item.barcode,
        quantityInGrams: result.$1,
        timestamp: result.$2,
        mealType: result.$4,
      );
      await DatabaseHelper.instance.updateFoodEntry(updatedEntry);
      _loadEntriesForDateRange(_selectedDateRange);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    final locale = Localizations.localeOf(context).toString();

    final rangeText = _selectedDateRange.duration.inDays == 0
        ? DateFormat.yMMMMd(locale).format(_selectedDateRange.start)
        : "${DateFormat.yMMMMd(locale).format(_selectedDateRange.start)} - ${DateFormat.yMMMMd(locale).format(_selectedDateRange.end)}";

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          l10n.nutritionScreenTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: SafeArea(
        top: true,
        child: Stack(
          children: [
            Column(
              children: [
                Container(
                  color: Theme.of(context).scaffoldBackgroundColor,
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                        horizontal: 16.0, vertical: 0.0),
                    //padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 24.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        //SizedBox(height: DesignConstants.spacingL), // <- DIESE ZEILE
                        //SizedBox(height: DesignConstants.spacingXL),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            IconButton(
                                icon: const Icon(Icons.chevron_left),
                                onPressed: () => _navigateDay(false)),
                            Expanded(
                              child: InkWell(
                                onTap: () async {
                                  final picked = await showDateRangePicker(
                                      context: context,
                                      initialDateRange: _selectedDateRange,
                                      firstDate: DateTime(2020),
                                      lastDate: DateTime.now());
                                  if (picked != null) {
                                    setState(() {
                                      _selectedDateRange = picked;
                                      _selectedRangeKey = 'custom';
                                    });
                                    _loadEntriesForDateRange(picked);
                                  }
                                },
                                child: Text(
                                  rangeText,
                                  style: textTheme.titleMedium
                                      ?.copyWith(fontWeight: FontWeight.bold),
                                  textAlign: TextAlign.center,
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ),
                            IconButton(
                                icon: const Icon(Icons.chevron_right),
                                onPressed: _selectedDateRange.end
                                        .isSameDate(DateTime.now())
                                    ? null
                                    : () => _navigateDay(true)),
                          ],
                        ),
                        SizedBox(height: DesignConstants.spacingL),
                        Row(
                          children: [
                            _buildFilterButton(l10n.filterToday, '1D'),
                            _buildFilterButton(l10n.filter7Days, '1W'),
                            _buildFilterButton(l10n.filter30Days, '1M'),
                            _buildFilterButton(l10n.filterAll, 'All'),
                          ],
                        ),
                        SizedBox(height: DesignConstants.spacingL), // <- DIESE ZEILE
                      ],
                    ),
                  ),
                ),
                Divider(
                    height: 1,
                    thickness: 1,
                    color: colorScheme.onSurfaceVariant.withOpacity(0.1)),
                AnimatedSize(
                  duration: const Duration(milliseconds: 300),
                  curve: Curves.easeInOut,
                  child: _isHeaderVisible
                      ? Column(
                          children: [
                            if (_nutritionData != null)
                              Column(
                                children: [
                                  // KORREKTUR: NutritionSummaryWidget in einem Padding, das dem horizontalen ListView-Padding entspricht.
                                  Padding(
                                    padding: const EdgeInsets.symmetric(
                                        horizontal:
                                            16.0), // <- Dieser Padding ist wichtig!
                                    child: NutritionSummaryWidget(
                                        nutritionData: _nutritionData!,
                                        isExpandedView: _isSummaryExpanded,
                                        l10n: l10n),
                                  ),
                                  Row(
                                    mainAxisAlignment:
                                        MainAxisAlignment.spaceEvenly,
                                    children: [
                                      TextButton(
                                        onPressed: () {
                                          setState(() {
                                            _isSummaryExpanded =
                                                !_isSummaryExpanded;
                                            UiStateService.instance
                                                    .isNutritionSummaryExpanded =
                                                _isSummaryExpanded;
                                          });
                                        },
                                        child: Text(_isSummaryExpanded
                                            ? l10n.showLess
                                            : l10n.showMoreDetails),
                                      ),
                                      TextButton(
                                        onPressed: () => setState(
                                            () => _isHeaderVisible = false),
                                        child: Text(l10n.hideSummary),
                                      ),
                                    ],
                                  ),
                                ],
                              ),
                          ],
                        )
                      : Align(
                          alignment: Alignment.centerRight,
                          child: Padding(
                            padding:
                                const EdgeInsets.symmetric(horizontal: 16.0),
                            child: TextButton(
                              onPressed: () =>
                                  setState(() => _isHeaderVisible = true),
                              child: Text(l10n.showSummary),
                            ),
                          ),
                        ),
                ),
                Divider(
                    height: 1,
                    thickness: 1,
                    color: colorScheme.onSurfaceVariant.withOpacity(0.1)),
                Expanded(
                  child: _displayItems.isEmpty
                      ? Center(child: Text(l10n.noEntriesForPeriod))
                      : ListView.separated(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 16.0, vertical: 8.0),
                          itemCount: _displayItems.length,
                          separatorBuilder: (context, index) =>
                              SizedBox(height: DesignConstants.spacingM), // KORREKTUR: Trenner
                          itemBuilder: (context, index) {
                            final item = _displayItems[index];

                            String getLocalizedMealName(String key) {
                              switch (key) {
                                case "mealtypeBreakfast":
                                  return l10n.mealtypeBreakfast;
                                case "mealtypeLunch":
                                  return l10n.mealtypeLunch;
                                case "mealtypeDinner":
                                  return l10n.mealtypeDinner;
                                case "mealtypeSnack":
                                  return l10n.mealtypeSnack;
                                case "waterHeader":
                                  return l10n.waterHeader;
                                default:
                                  return key;
                              }
                            }

                            if (item is DateTime) {
                              return Padding(
                                padding: const EdgeInsets.only(
                                    top: 24.0, bottom: 8.0, left: 8.0),
                                child: Text(
                                  DateFormat.yMMMMEEEEd(locale).format(item),
                                  style: textTheme.titleLarge?.copyWith(
                                      fontWeight: FontWeight.bold,
                                      color: colorScheme.primary),
                                ),
                              );
                            }

                            if (item is String) {
                              return Padding(
                                padding: const EdgeInsets.only(
                                    top: 24.0, bottom: 8.0, left: 8.0),
                                child: Text(getLocalizedMealName(item),
                                    style: textTheme.titleLarge?.copyWith(
                                        fontWeight: FontWeight.bold)),
                              );
                            }

                            if (item is FoodTimelineEntry) {
                              final trackedItem = item.trackedItem;
                              return Dismissible(
                                key: Key('food_${trackedItem.entry.id}'),
                                background: Container(
                                    color: Colors.blueAccent,
                                    alignment: Alignment.centerLeft,
                                    padding: const EdgeInsets.symmetric(
                                        horizontal: 20),
                                    child: const Icon(Icons.edit,
                                        color: Colors.white)),
                                secondaryBackground: Container(
                                    color: Colors.redAccent,
                                    alignment: Alignment.centerRight,
                                    padding: const EdgeInsets.symmetric(
                                        horizontal: 20),
                                    child: const Icon(Icons.delete,
                                        color: Colors.white)),
                                confirmDismiss: (direction) async {
                                  if (direction ==
                                      DismissDirection.startToEnd) {
                                    _editFoodEntry(trackedItem);
                                    return false;
                                  } else {
                                    return await showDialog(
                                          context: context,
                                          builder: (BuildContext context) {
                                            return AlertDialog(
                                              title:
                                                  Text(l10n.deleteConfirmTitle),
                                              content: Text(
                                                  l10n.deleteConfirmContent),
                                              actions: <Widget>[
                                                TextButton(
                                                    onPressed: () =>
                                                        Navigator.of(context)
                                                            .pop(false),
                                                    child: Text(l10n.cancel)),
                                                TextButton(
                                                    onPressed: () =>
                                                        Navigator.of(context)
                                                            .pop(true),
                                                    child: Text(l10n.delete)),
                                              ],
                                            );
                                          },
                                        ) ??
                                        false;
                                  }
                                },
                                onDismissed: (direction) {
                                  if (direction ==
                                      DismissDirection.endToStart) {
                                    _deleteFoodEntry(trackedItem.entry.id!);
                                  }
                                },
                                child: SummaryCard(
                                  //externalMargin: EdgeInsets.zero,
                                  child: ListTile(
                                    leading: const Icon(Icons.restaurant),
                                    title: Text(trackedItem.item.name),
                                    subtitle: Text(l10n.foodListSubtitle(
                                        trackedItem.entry.quantityInGrams,
                                        DateFormat.Hm(locale).format(
                                            trackedItem.entry.timestamp))),
                                    trailing: Text(l10n.foodListTrailingKcal(
                                        trackedItem.calculatedCalories)),
                                    onTap: () => Navigator.of(context)
                                        .push(MaterialPageRoute(
                                            builder: (context) =>
                                                FoodDetailScreen(
                                                    trackedItem: trackedItem)))
                                        .then((_) => _loadEntriesForDateRange(
                                            _selectedDateRange)),
                                  ),
                                ),
                              );
                            }

                            if (item is WaterTimelineEntry) {
                              final waterEntry = item.waterEntry;
                              return Dismissible(
                                key: Key('water_${waterEntry.id}'),
                                direction: DismissDirection.endToStart,
                                onDismissed: (direction) =>
                                    _deleteWaterEntry(waterEntry.id!),
                                background: Container(
                                    color: Colors.red,
                                    alignment: Alignment.centerRight,
                                    padding: const EdgeInsets.symmetric(
                                        horizontal: 20),
                                    child: const Icon(Icons.delete,
                                        color: Colors.white)),
                                child: SummaryCard(
                                  //externalMargin: EdgeInsets.zero,
                                  child: ListTile(
                                    leading: Icon(Icons.local_drink,
                                        color: colorScheme.primary),
                                    title: Text(l10n.waterEntryTitle),
                                    subtitle: Text(DateFormat.Hm(locale)
                                        .format(waterEntry.timestamp)),
                                    trailing: Text(
                                        l10n.waterListTrailingMl(
                                            waterEntry.quantityInMl),
                                        style: const TextStyle(
                                            fontWeight: FontWeight.bold)),
                                  ),
                                ),
                              );
                            }
                            return const SizedBox.shrink();
                          },
                        ),
                ),
              ],
            ),
            if (_isLoading)
              Positioned.fill(
                child: Container(
                  color: Colors.black.withOpacity(0.5),
                  child: const Center(child: CircularProgressIndicator()),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildFilterButton(String label, String key) {
    final theme = Theme.of(context);
    final isSelected = _selectedRangeKey == key;
    return Expanded(
      child: GestureDetector(
        onTap: () => _setTimeRange(key),
        child: Container(
          margin: const EdgeInsets.symmetric(horizontal: 4.0),
          padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
          decoration: BoxDecoration(
            color: isSelected
                ? theme.colorScheme.primary
                : theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
            borderRadius: BorderRadius.circular(10.0),
          ),
          child: Text(
            label,
            textAlign: TextAlign.center,
            style: theme.textTheme.labelLarge?.copyWith(
              color: isSelected
                  ? theme.colorScheme.onPrimary
                  : theme.colorScheme.onSurfaceVariant,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\onboarding_screen.dart =====

// lib/screens/onboarding_screen.dart
import 'package:flutter/material.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/generated/app_localizations.dart';

// TODO: Ersetze diese Imports durch deine echten Screens/Routes
import 'package:lightweight/screens/main_screen.dart';
import 'package:lightweight/screens/routines_screen.dart';
import 'package:lightweight/screens/goals_screen.dart';
import 'package:lightweight/screens/nutrition_hub_screen.dart';

class OnboardingScreen extends StatefulWidget {
  const OnboardingScreen({super.key});
  @override
  State<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenState extends State<OnboardingScreen> {
  final PageController _page = PageController();
  int _index = 0;
  bool _goalVisited = false;
  bool _foodVisited = false;
  bool _trainVisited = false;

  Future<void> _finish() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool('hasSeenOnboarding', true);
    if (!mounted) return;
    // Zurück ins Haupt-UI
    Navigator.of(context).pushAndRemoveUntil(
      MaterialPageRoute(builder: (_) => const MainScreen()),
      (r) => false,
    );
  }

  void _next(int lastIndex) {
    if (_index < lastIndex) {
      _page.animateToPage(
        _index + 1,
        duration: const Duration(milliseconds: 250),
        curve: Curves.easeOut,
      );
    } else {
      _finish();
    }
  }

  void _skip() => _finish();

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    final pages = <Widget>[
      _Slide(
        icon: Icons.flag,
        title: l10n.onbWelcomeTitle,
        body: l10n.onbWelcomeBody,
        primaryCta: _Cta(
          icon: Icons.edit_outlined,
          label: l10n.onbSetGoalsCta,
          onTap: () async {
            await Navigator.of(context).push(
              MaterialPageRoute(builder: (_) => const GoalsScreen()),
            );
            if (!mounted) return;
            setState(() => _goalVisited = true);
          },
        ),
        footer: _goalVisited
            ? _Badge(text: l10n.onbBadgeDone)
            : _Hint(text: l10n.onbTipSetGoals),
      ),
      // 2) Nutrition (nur Beschreibung, kein Link)
      _Slide(
        icon: Icons.restaurant_menu,
        title: l10n
            .onbTrackTitle, // oder eigener Titel, z. B. l10n.onbNutritionTitle
        body: l10n
            .onbTrackHowBody, // bereits eingefügt: Schrittfolge fürs Essen-Loggen
        primaryCta: null,
        footer: _Hint(text: l10n.onbTipAddEntry),
      ),

// 3) Measurements (neue Folie)
      _Slide(
        icon: Icons.monitor_weight_outlined,
        title: l10n.onbMeasureTitle,
        body: l10n.onbMeasureBody, // Schrittfolge zum Hinzufügen von Messungen
        primaryCta: null,
        footer: _Hint(text: l10n.onbTipMeasureToday),
      ),

// 4) Training: Routine erstellen + Workout starten (neue Folie)
      _Slide(
        icon: Icons.fitness_center,
        title: l10n.onbTrainTitle,
        body: l10n.onbTrainBody, // Kombinierte Anleitung Routine/Workout
        primaryCta: null,
        footer: _Hint(text: l10n.onbTipStartWorkout),
      ),

// 5) Offline & Privacy bleibt
      _Slide(
        icon: Icons.lock_outline,
        title: l10n.onbPrivacyTitle,
        body: l10n.onbPrivacyBody,
        primaryCta: null,
        footer: _Hint(text: l10n.onbTipLocalControl),
      ),

// 6) Finish bleibt
      _FinalSlide(
        title: l10n.onbFinishTitle,
        body: l10n.onbFinishBody,
        onFinish: _finish,
      ),
    ];

    final lastIndex = pages.length - 1;

    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            // Header Controls
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 8, 16, 0),
              child: Row(
                children: [
                  Text(l10n.onbHeaderTitle, style: theme.textTheme.titleMedium),
                  const Spacer(),
                  TextButton(onPressed: _skip, child: Text(l10n.onbHeaderSkip)),
                ],
              ),
            ),
            // Compact guide banner
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 0, 16, 8),
              child: Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: theme.colorScheme.primary.withOpacity(0.06),
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(
                    color: theme.colorScheme.primary.withOpacity(0.25),
                  ),
                ),
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Icon(Icons.swipe, color: theme.colorScheme.primary),
                    const SizedBox(width: 12),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            l10n.onbGuideTitle,
                            style: theme.textTheme.titleSmall?.copyWith(
                              fontWeight: FontWeight.w700,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            l10n.onbGuideBody,
                            style: theme.textTheme.bodySmall,
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
            // Pages
            Expanded(
              child: PageView.builder(
                controller: _page,
                onPageChanged: (i) => setState(() => _index = i),
                itemCount: pages.length,
                itemBuilder: (_, i) => pages[i],
              ),
            ),
            // Dots
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: List.generate(
                pages.length,
                (i) => AnimatedContainer(
                  duration: const Duration(milliseconds: 200),
                  margin: const EdgeInsets.all(6),
                  height: 8,
                  width: _index == i ? 24 : 8,
                  decoration: BoxDecoration(
                    color: _index == i
                        ? theme.colorScheme.primary
                        : theme.disabledColor.withOpacity(0.4),
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
              ),
            ),
            // Bottom bar
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 8, 16, 16),
              child: Row(
                children: [
                  Expanded(
                    child: OutlinedButton.icon(
                      onPressed: _index == 0
                          ? null
                          : () => _page.animateToPage(
                                _index - 1,
                                duration: const Duration(milliseconds: 250),
                                curve: Curves.easeOut,
                              ),
                      icon: const Icon(Icons.chevron_left),
                      label: Text(l10n.onbBack),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton.icon(
                      onPressed: () => _next(lastIndex),
                      icon: Icon(_index < lastIndex
                          ? Icons.chevron_right
                          : Icons.check),
                      label: Text(_index < lastIndex
                          ? l10n.onbNext
                          : l10n.onbFinishCta),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _Slide extends StatelessWidget {
  final IconData icon;
  final String title;
  final String body;
  final _Cta? primaryCta;
  final Widget? footer;
  const _Slide({
    required this.icon,
    required this.title,
    required this.body,
    this.primaryCta,
    this.footer,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 72, color: theme.colorScheme.primary),
          SizedBox(height: DesignConstants.spacingL),
          Text(title,
              style: theme.textTheme.headlineSmall,
              textAlign: TextAlign.center),
          SizedBox(height: DesignConstants.spacingS),
          Text(body,
              textAlign: TextAlign.center, style: theme.textTheme.bodyLarge),
          SizedBox(height: DesignConstants.spacingXL),
          if (primaryCta != null)
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: primaryCta!.onTap,
                icon: Icon(primaryCta!.icon),
                label: Text(primaryCta!.label),
              ),
            ),
          if (footer != null) ...[
            SizedBox(height: DesignConstants.spacingM),
            footer!,
          ],
        ],
      ),
    );
  }
}

class _FinalSlide extends StatelessWidget {
  final String title;
  final String body;
  final VoidCallback onFinish;
  const _FinalSlide({
    required this.title,
    required this.body,
    required this.onFinish,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.rocket_launch, size: 72, color: theme.colorScheme.primary),
          SizedBox(height: DesignConstants.spacingL),
          Text(title,
              style: theme.textTheme.headlineSmall,
              textAlign: TextAlign.center),
          SizedBox(height: DesignConstants.spacingS),
          Text(body,
              textAlign: TextAlign.center, style: theme.textTheme.bodyLarge),
          SizedBox(height: DesignConstants.spacingXL),
          SizedBox(
            width: double.infinity,
            child: ElevatedButton.icon(
              onPressed: onFinish,
              icon: const Icon(Icons.check),
              label: Text(AppLocalizations.of(context)!.onbFinishCta),
            ),
          ),
        ],
      ),
    );
  }
}

class _Cta {
  final IconData icon;
  final String label;
  final Future<void> Function()? onTap;
  const _Cta({required this.icon, required this.label, this.onTap});
}

class _Badge extends StatelessWidget {
  final String text;
  const _Badge({required this.text});
  @override
  Widget build(BuildContext context) {
    final c = Theme.of(context).colorScheme;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        color: c.primary.withOpacity(0.15),
        borderRadius: BorderRadius.circular(999),
        border: Border.all(color: c.primary.withOpacity(0.35)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.check_circle, size: 16, color: c.primary),
          const SizedBox(width: 6),
          Text(text,
              style: TextStyle(color: c.primary, fontWeight: FontWeight.w600)),
        ],
      ),
    );
  }
}

class _Hint extends StatelessWidget {
  final String text;
  const _Hint({required this.text});
  @override
  Widget build(BuildContext context) {
    return Text(text,
        style: Theme.of(context)
            .textTheme
            .bodySmall
            ?.copyWith(color: Colors.grey));
  }
}


===== Datei: D:\lightweight\lib\screens\profile_screen.dart =====

// lib/screens/profile_screen.dart (Der neue "Profil-Hub")

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/data_management_screen.dart';
import 'package:lightweight/screens/goals_screen.dart'; // HINZUGEFÜGT: Import für den neuen GoalsScreen
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:lightweight/services/profile_service.dart'; // HINZUGEFÜGT
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/onboarding_screen.dart';

// HINZUGEFÜGT
import 'dart:io';

import 'package:provider/provider.dart'; // HINZUGEFÜGT

class ProfileScreen extends StatefulWidget {
  // KORREKTUR: Ist jetzt StatefulWidget
  const ProfileScreen({super.key});

  @override
  State<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends State<ProfileScreen> {
  // KORREKTUR: State-Klasse
  late final l10n = AppLocalizations.of(context)!;
  late final theme = Theme.of(context);
  late String _appVersion = l10n.load_dots; // Wird dynamisch geladen

  @override
  void initState() {
    super.initState();
    _loadAppVersion();
  }

  Future<void> _loadAppVersion() async {
    final packageInfo = await PackageInfo.fromPlatform();
    if (mounted) {
      setState(() {
        _appVersion = "${packageInfo.version} (${packageInfo.buildNumber})";
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final profileService = Provider.of<ProfileService>(context); // HINZUGEFÜGT

    return Scaffold(
      body: ListView(
        padding: DesignConstants.cardPadding,
        children: [
          // HINZUGEFÜGT: Profilbild-Sektion
          _buildSectionTitle(context, l10n.profile_capslock),
          SummaryCard(
            child: Padding(
              padding: DesignConstants.cardPadding,
              child: Column(
                children: [
                  GestureDetector(
                    onTap: () async {
                      await profileService.pickAndSaveProfileImage();
                    },
                    child: CircleAvatar(
                      radius: 50,
                      backgroundColor: Theme.of(context)
                          .colorScheme
                          .primary
                          .withOpacity(0.1),
                      backgroundImage: profileService.profileImagePath != null
                          ? FileImage(File(profileService.profileImagePath!))
                          : null,
                      child: profileService.profileImagePath == null
                          ? Icon(Icons.camera_alt,
                              size: 50,
                              color: Theme.of(context).colorScheme.primary)
                          : null,
                    ),
                  ),
                  if (profileService.profileImagePath != null)
                    TextButton(
                      onPressed: () async {
                        await profileService.deleteProfileImage();
                      },
                      child: Text(l10n.delete_profile_picture_button),
                    ),
                ],
              ),
            ),
          ),
          SizedBox(height: DesignConstants.spacingXL),
          // Sektion 1: "EINSTELLUNGEN"
          _buildSectionTitle(context, l10n.settings_capslock),
          _buildNavigationCard(
            context: context,
            icon: Icons.flag_outlined,
            title: l10n.my_goals,
            subtitle: l10n.my_goals_description,
            onTap: () {
              // KORREKTUR: Navigation zum neuen GoalsScreen
              Navigator.of(context).push(
                  MaterialPageRoute(builder: (context) => const GoalsScreen()));
            },
          ),
          SizedBox(height: DesignConstants.spacingM),
          _buildNavigationCard(
            context: context,
            icon: Icons.import_export_rounded,
            title: l10n.backup_and_import,
            subtitle: l10n.backup_and_import_description,
            onTap: () {
              Navigator.of(context).push(MaterialPageRoute(
                  builder: (context) => const DataManagementScreen()));
            },
          ),
          SizedBox(height: DesignConstants.spacingM),
          _buildOnboardingCard(context, l10n, theme),
          SizedBox(height: DesignConstants.spacingXL),

          // Sektion 2: "ÜBER & RECHTLICHES"
          _buildSectionTitle(context, l10n.about_and_legal_capslock),
          _buildNavigationCard(
            context: context,
            icon: Icons.info_outline_rounded,
            title: l10n.attribution_and_license,
            subtitle: l10n.data_from_off_and_wger,
            onTap: () {
              showDialog(
                  context: context,
                  builder: (context) => AlertDialog(
                        title: Text(l10n.attribution_title),
                        content: const SingleChildScrollView(
                          child: Text(
                              "Diese App verwendet Daten von externen Quellen:\n\n"
                              "● Übungsdaten und Bilder von wger (wger.de), lizenziert unter der CC-BY-SA 4.0 Lizenz.\n\n"
                              "● Lebensmittel-Datenbank von Open Food Facts (openfoodfacts.org), verfügbar unter der Open Database License (ODbL)."),
                        ),
                        actions: [
                          TextButton(
                              onPressed: () => Navigator.of(context).pop(),
                              child: Text(l10n.snackbar_button_ok)),
                        ],
                      ));
            },
          ),
          SizedBox(height: DesignConstants.spacingM),
          SummaryCard(
            child: ListTile(
              leading: const Icon(Icons.code_rounded),
              title: Text(l10n.app_version,
                  style: const TextStyle(fontWeight: FontWeight.bold)),
              subtitle: Text(
                  _appVersion), // KORREKTUR: Zeigt die dynamische Version an
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildNavigationCard({
    required BuildContext context,
    required IconData icon,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
  }) {
    return SummaryCard(
      child: ListTile(
        contentPadding:
            const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16.0),
        leading:
            Icon(icon, size: 36, color: Theme.of(context).colorScheme.primary),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Text(subtitle),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
        shape:
            RoundedRectangleBorder(borderRadius: BorderRadius.circular(24.0)),
      ),
    );
  }

  Widget _buildOnboardingCard(
      BuildContext context, AppLocalizations l10n, ThemeData theme) {
    return SummaryCard(
      child: ListTile(
        leading: Icon(Icons.school_outlined, color: theme.colorScheme.primary),
        title: Text(
          l10n.onbShowTutorialAgain,
          style: theme.textTheme.titleMedium
              ?.copyWith(fontWeight: FontWeight.w700),
        ),
        subtitle: Text(
          l10n.onbFinishBody, // kurzer Erklärungstext wiederverwendet
          style: theme.textTheme.bodyMedium,
        ),
        trailing: const Icon(Icons.chevron_right),
        onTap: () {
          Navigator.of(context).push(
            MaterialPageRoute(builder: (_) => const OnboardingScreen()),
          );
        },
        contentPadding:
            const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\routines_screen.dart =====

// lib/screens/routines_screen.dart (Final & De-Materialisiert - Korrigiert)

import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/screens/edit_routine_screen.dart';
import 'package:lightweight/screens/live_workout_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/summary_card.dart';

class RoutinesScreen extends StatefulWidget {
  final int? initialRoutineId;
  const RoutinesScreen({super.key, this.initialRoutineId});
  @override
  State<RoutinesScreen> createState() => _RoutinesScreenState();
}

class _RoutinesScreenState extends State<RoutinesScreen> {
  bool _isLoading = true;
  List<Routine> _routines = [];

  @override
  void initState() {
    super.initState();
    _loadRoutines();
  }

  Future<void> _loadRoutines() async {
    setState(() => _isLoading = true);
    final data = await WorkoutDatabaseHelper.instance.getAllRoutines();
    if (mounted) {
      setState(() {
        _routines = data;
        _isLoading = false;
      });
      // Wenn eine initialRoutineId übergeben wurde, direkt dorthin navigieren
      if (widget.initialRoutineId != null) {
        final routineToEdit = _routines.firstWhere(
            (r) => r.id == widget.initialRoutineId,
            orElse: () => throw Exception("Routine not found"));
        WidgetsBinding.instance.addPostFrameCallback((_) {
          Navigator.of(context)
              .push(MaterialPageRoute(
                  builder: (context) =>
                      EditRoutineScreen(routine: routineToEdit)))
              .then((_) => _loadRoutines());
        });
      }
    }
  }

  void _startWorkout(Routine routine) async {
    showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => const Center(child: CircularProgressIndicator()));
    final fullRoutine =
        await WorkoutDatabaseHelper.instance.getRoutineById(routine.id!);
    final newWorkoutLog = await WorkoutDatabaseHelper.instance
        .startWorkout(routineName: routine.name);
    if (!mounted) return;
    Navigator.of(context).pop();
    if (fullRoutine != null) {
      Navigator.of(context)
          .push(MaterialPageRoute(
            builder: (context) => LiveWorkoutScreen(
                routine: fullRoutine, workoutLog: newWorkoutLog),
          ))
          .then((_) => _loadRoutines());
    }
  }

  void _startEmptyWorkout() async {
    final l10n = AppLocalizations.of(context)!;
    final newWorkoutLog = await WorkoutDatabaseHelper.instance
        .startWorkout(routineName: l10n.freeWorkoutTitle);
    if (!mounted) return;
    Navigator.of(context)
        .push(MaterialPageRoute(
          builder: (context) => LiveWorkoutScreen(workoutLog: newWorkoutLog),
        ))
        .then((_) => _loadRoutines());
  }

  void _createNewRoutine() {
    Navigator.of(context)
        .push(
            MaterialPageRoute(builder: (context) => const EditRoutineScreen()))
        .then((_) => _loadRoutines());
  }

// NEUE METHODEN FÜR DAS MENÜ
  void _duplicateRoutine(int routineId) async {
    await WorkoutDatabaseHelper.instance.duplicateRoutine(routineId);
    _loadRoutines();
  }

  void _deleteRoutine(BuildContext context, Routine routine) async {
    final l10n = AppLocalizations.of(context)!;
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.deleteConfirmTitle),
        content: Text(l10n.deleteRoutineConfirmContent(routine.name)),
        actions: [
          TextButton(
              onPressed: () => Navigator.of(ctx).pop(false),
              child: Text(l10n.cancel)),
          TextButton(
              onPressed: () => Navigator.of(ctx).pop(true),
              child: Text(l10n.delete)),
        ],
      ),
    );

    if (confirmed == true) {
      await WorkoutDatabaseHelper.instance.deleteRoutine(routine.id!);
      _loadRoutines();
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final textTheme = Theme.of(context).textTheme; // Hier definiert

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          l10n.workoutRoutinesTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _routines.isEmpty
              ? _buildEmptyState(context, l10n, textTheme)
              : ListView.builder(
                  padding: DesignConstants.cardPadding,
                  itemCount: _routines.length + 1, // statt +2
                  itemBuilder: (context, index) {
                    if (index == 0) {
                      return _buildStartEmptyWorkoutCard(context, l10n);
                    }
                    final routine = _routines[index - 1];
                    return Dismissible(
                      key: Key('routine_${routine.id}'),
                      direction: DismissDirection.endToStart,
                      background: Container(
                        color: Colors.redAccent,
                        alignment: Alignment.centerRight,
                        padding: const EdgeInsets.symmetric(horizontal: 20),
                        child: const Icon(Icons.delete, color: Colors.white),
                      ),
                      confirmDismiss: (direction) async {
                        return await showDialog<bool>(
                              context: context,
                              builder: (ctx) => AlertDialog(
                                title: Text(l10n.deleteConfirmTitle),
                                content: Text(l10n
                                    .deleteRoutineConfirmContent(routine.name)),
                                actions: [
                                  TextButton(
                                      onPressed: () =>
                                          Navigator.of(ctx).pop(false),
                                      child: Text(l10n.cancel)),
                                  TextButton(
                                      onPressed: () =>
                                          Navigator.of(ctx).pop(true),
                                      child: Text(l10n.delete)),
                                ],
                              ),
                            ) ??
                            false;
                      },
                      onDismissed: (direction) {
                        _deleteRoutine(context, routine);
                      },
                      child: SummaryCard(
                        child: ListTile(
                          leading: ElevatedButton(
                            onPressed: () => _startWorkout(routine),
                            child: Text(l10n.startButton),
                          ),
                          title: Text(routine.name,
                              style:
                                  const TextStyle(fontWeight: FontWeight.bold)),
                          subtitle: Text(l10n.editRoutineSubtitle),
                          trailing: PopupMenuButton<String>(
                            icon: Icon(Icons.more_vert,
                                color: textTheme.bodyMedium?.color),
                            onSelected: (value) {
                              if (value == 'duplicate') {
                                _duplicateRoutine(routine.id!);
                              } else if (value == 'delete') {
                                _deleteRoutine(context, routine);
                              }
                            },
                            itemBuilder: (BuildContext context) =>
                                <PopupMenuEntry<String>>[
                              PopupMenuItem<String>(
                                  value: 'duplicate',
                                  child: Text(l10n.duplicate)),
                              PopupMenuItem<String>(
                                  value: 'delete', child: Text(l10n.delete)),
                            ],
                          ),
                          onTap: () {
                            Navigator.of(context)
                                .push(MaterialPageRoute(
                                    builder: (context) =>
                                        EditRoutineScreen(routine: routine)))
                                .then((_) => _loadRoutines());
                          },
                        ),
                      ),
                    );
                  },
                ),
      floatingActionButton: GlassFab(
        onPressed: _createNewRoutine,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  // KORREKTUR 5: _buildStartEmptyWorkoutCard als SummaryCard-Button
  Widget _buildStartEmptyWorkoutCard(
      BuildContext context, AppLocalizations l10n) {
    return SummaryCard(
      child: ListTile(
        leading: const Icon(Icons.play_circle_fill),
        title: Text(l10n.startEmptyWorkoutButton,
            style: const TextStyle(fontWeight: FontWeight.bold)),
        onTap: _startEmptyWorkout,
        shape:
            RoundedRectangleBorder(borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM)),
      ),
    );
  }

// In RoutinesScreen: _buildEmptyState ersetzen/erweitern

  Widget _buildEmptyState(
      BuildContext context, AppLocalizations l10n, TextTheme textTheme) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.list_alt_outlined,
                size: 80, color: Colors.grey.shade400),
            SizedBox(height: DesignConstants.spacingL),
            Text(
              l10n.emptyRoutinesTitle,
              style: textTheme.headlineSmall,
              textAlign: TextAlign.center,
            ),
            SizedBox(height: DesignConstants.spacingS),
            Text(
              l10n.emptyRoutinesSubtitle,
              textAlign: TextAlign.center,
              style: textTheme.bodyLarge?.copyWith(color: Colors.grey.shade600),
            ),
            SizedBox(height: DesignConstants.spacingXL),

            // Bestehender Button: Routine erstellen
            ElevatedButton.icon(
              style: ElevatedButton.styleFrom(
                padding:
                    const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
              ),
              onPressed: _createNewRoutine,
              icon: const Icon(Icons.add),
              label: Text(
                l10n.createFirstRoutineButton,
                style: textTheme.titleMedium?.copyWith(
                  color: Theme.of(context).colorScheme.onPrimary,
                ),
              ),
            ),

            SizedBox(height: DesignConstants.spacingM),

            // NEU: Freies Training starten (sichtbar auch im Empty-State)
            OutlinedButton.icon(
              style: OutlinedButton.styleFrom(
                padding:
                    const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
              ),
              onPressed: _startEmptyWorkout,
              icon: const Icon(Icons.play_circle_fill),
              label: Text(l10n.startEmptyWorkoutButton),
            ),
          ],
        ),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\scanner_screen.dart =====

// lib/screens/scanner_screen.dart

import 'package:flutter/material.dart';
import 'package:mobile_scanner/mobile_scanner.dart';

class ScannerScreen extends StatefulWidget {
  const ScannerScreen({super.key});

  @override
  State<ScannerScreen> createState() => _ScannerScreenState();
}

class _ScannerScreenState extends State<ScannerScreen> {
  final MobileScannerController _controller = MobileScannerController(
    detectionSpeed: DetectionSpeed.normal,
    facing: CameraFacing.back,
  );
  bool _isDone = false;

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final scanWindow = Rect.fromCenter(
      center: MediaQuery.of(context).size.center(Offset.zero),
      width: 250,
      height: 250,
    );

    return Scaffold(
      appBar: AppBar(
        title: const Text("Barcode scannen"),
        backgroundColor: Colors.transparent,
        elevation: 0,
      ),
      backgroundColor: Colors.black,
      body: Stack(
        fit: StackFit.expand,
        children: [
          MobileScanner(
            controller: _controller,
            scanWindow: scanWindow,
            onDetect: (capture) {
              if (!_isDone) {
                final String? code = capture.barcodes.first.rawValue;
                if (code != null) {
                  setState(() {
                    _isDone = true;
                  });
                  Navigator.of(context).pop(code);
                }
              }
            },
          ),
          // Visuelles Overlay
          CustomPaint(
            painter: ScannerOverlay(scanWindow: scanWindow),
          ),
        ],
      ),
    );
  }
}

// Helfer-Klasse für das visuelle Overlay
class ScannerOverlay extends CustomPainter {
  final Rect scanWindow;
  ScannerOverlay({required this.scanWindow});

  @override
  void paint(Canvas canvas, Size size) {
    final backgroundPath = Path()..addRect(Rect.largest);
    final cutoutPath = Path()..addRect(scanWindow);
    final backgroundPaint = Paint()
      ..color = Colors.black.withOpacity(0.5)
      ..style = PaintingStyle.fill
      ..blendMode = BlendMode.dstOut;

    final backgroundWithCutout =
        Path.combine(PathOperation.difference, backgroundPath, cutoutPath);
    canvas.drawPath(backgroundWithCutout, backgroundPaint);

    final borderPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2;
    canvas.drawRect(scanWindow, borderPaint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) {
    return false;
  }
}


===== Datei: D:\lightweight\lib\screens\statistics_hub_screen.dart =====

// lib/screens/statistics_hub_screen.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/measurements_screen.dart';
import 'package:lightweight/screens/nutrition_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';

class StatisticsHubScreen extends StatelessWidget {
  const StatisticsHubScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      body: ListView(
        padding: DesignConstants.cardPadding,
        children: [
          // Sektion 1: "MEINE KONSISTENZ" (Platzhalter)
          _buildSectionTitle(context, l10n.my_consistency),
          SummaryCard(
            child: Padding(
              padding: const EdgeInsets.all(20.0),
              child: Row(
                children: [
                  Icon(Icons.calendar_today_outlined, color: Colors.grey[600]),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Text(
                      l10n.calendar_currently_not_available,
                      style: Theme.of(context)
                          .textTheme
                          .bodyLarge
                          ?.copyWith(color: Colors.grey[600]),
                    ),
                  ),
                ],
              ),
            ),
          ),
          SizedBox(height: DesignConstants.spacingXL),

          // Sektion 2: "TIEFEN-ANALYSE" (Voll funktionsfähig)
          _buildSectionTitle(context, l10n.in_depth_analysis),
          _buildAnalysisGateway(
            context: context,
            icon: Icons.monitor_weight_outlined,
            title: l10n.body_measurements,
            subtitle: l10n.measurements_description,
            onTap: () {
              Navigator.of(context).push(MaterialPageRoute(
                  builder: (context) => const MeasurementsScreen()));
            },
          ),
          SizedBox(height: DesignConstants.spacingM),
          _buildAnalysisGateway(
            context: context,
            icon: Icons.pie_chart_outline_rounded,
            title: l10n.nutritionScreenTitle,
            subtitle: l10n.nutrition_description,
            onTap: () {
              Navigator.of(context).push(MaterialPageRoute(
                  builder: (context) => const NutritionScreen()));
            },
          ),
          SizedBox(height: DesignConstants.spacingM),
          _buildAnalysisGateway(
            context: context,
            icon: Icons.bar_chart_rounded,
            title: l10n.training_analysis,
            subtitle: l10n.training_analysis_description,
            onTap: () {
              // Platzhalter für den zukünftigen Trainings-Analyse-Screen
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text(l10n.soon_available_snackbar)),
              );
            },
          ),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildAnalysisGateway({
    required BuildContext context,
    required IconData icon,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
  }) {
    return SummaryCard(
      child: ListTile(
        contentPadding:
            const EdgeInsets.symmetric(vertical: 12.0, horizontal: 16.0),
        leading:
            Icon(icon, size: 40, color: Theme.of(context).colorScheme.primary),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Text(subtitle),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
        shape:
            RoundedRectangleBorder(borderRadius: BorderRadius.circular(24.0)),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\workout_history_screen.dart =====

// lib/screens/workout_history_screen.dart (Final & De-Materialisiert mit AppBar)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/screens/workout_log_detail_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/util/time_util.dart';
import 'package:lightweight/widgets/summary_card.dart';

class WorkoutHistoryScreen extends StatefulWidget {
  const WorkoutHistoryScreen({super.key});
  @override
  State<WorkoutHistoryScreen> createState() => _WorkoutHistoryScreenState();
}

class _WorkoutHistoryScreenState extends State<WorkoutHistoryScreen> {
  bool _isLoading = true;
  List<WorkoutLog> _logs = [];

  @override
  void initState() {
    super.initState();
    _loadHistory();
  }

  Future<void> _loadHistory() async {
    setState(() => _isLoading = true);
    final data = await WorkoutDatabaseHelper.instance.getWorkoutLogs();
    if (mounted) {
      setState(() {
        _logs = data;
        _isLoading = false;
      });
    }
  }

  Future<void> _deleteLog(int logId) async {
    await WorkoutDatabaseHelper.instance.deleteWorkoutLog(logId);
    _loadHistory();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).toString();
    final colorScheme = Theme.of(context).colorScheme;

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          l10n.workoutHistoryTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
      ),
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _logs.isEmpty
              // KORREKTUR: Aufgewerteter "Empty State"
              ? Center(
                  child: Padding(
                    padding: const EdgeInsets.all(24.0),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.history_toggle_off_outlined,
                            size: 80, color: Colors.grey.shade400),
                        SizedBox(height: DesignConstants.spacingL),
                        Text(
                          "Dein Verlauf ist leer",
                          style: Theme.of(context).textTheme.headlineSmall,
                          textAlign: TextAlign.center,
                        ),
                        SizedBox(height: DesignConstants.spacingS),
                        Text(
                          l10n.emptyHistory,
                          textAlign: TextAlign.center,
                          style: Theme.of(context)
                              .textTheme
                              .bodyLarge
                              ?.copyWith(color: Colors.grey.shade600),
                        ),
                      ],
                    ),
                  ),
                )
              : ListView.builder(
                  padding: DesignConstants.cardPadding,
                  itemCount: _logs.length,
                  itemBuilder: (context, index) {
                    final log = _logs[index];
                    final duration = log.endTime?.difference(log.startTime);

                    return Dismissible(
                      key: Key('log_${log.id}'),
                      direction: DismissDirection.endToStart,
                      background: Container(
                        color: Colors.redAccent,
                        alignment: Alignment.centerRight,
                        padding: const EdgeInsets.symmetric(horizontal: 20),
                        child: const Icon(Icons.delete, color: Colors.white),
                      ),
                      confirmDismiss: (direction) async {
                        return await showDialog<bool>(
                              context: context,
                              builder: (ctx) => AlertDialog(
                                title: Text(l10n.deleteConfirmTitle),
                                content: Text(l10n.deleteWorkoutConfirmContent),
                                actions: [
                                  TextButton(
                                    onPressed: () =>
                                        Navigator.of(ctx).pop(false),
                                    child: Text(l10n.cancel),
                                  ),
                                  TextButton(
                                    onPressed: () =>
                                        Navigator.of(ctx).pop(true),
                                    child: Text(l10n.delete),
                                  ),
                                ],
                              ),
                            ) ??
                            false;
                      },
                      onDismissed: (direction) {
                        _deleteLog(log.id!);
                      },
                      child: SummaryCard(
                        child: ListTile(
                          leading: const Icon(Icons.event_note, size: 40),
                          title: Text(
                            log.routineName ?? l10n.freeWorkoutTitle,
                            style: const TextStyle(fontWeight: FontWeight.bold),
                          ),
                          subtitle: Text(
                            DateFormat.yMMMMd(locale)
                                .add_Hm()
                                .format(log.startTime),
                          ),
                          trailing: duration != null
                              ? Text(
                                  formatDuration(duration),
                                  style: TextStyle(
                                    color: colorScheme.primary,
                                    fontWeight: FontWeight.w500,
                                  ),
                                )
                              : null,
                          onTap: () => Navigator.of(context)
                              .push(
                                MaterialPageRoute(
                                  builder: (context) =>
                                      WorkoutLogDetailScreen(logId: log.id!),
                                ),
                              )
                              .then((_) => _loadHistory()),
                        ),
                      ),
                    );
                  },
                ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\workout_hub_screen.dart =====

// lib/screens/workout_hub_screen.dart (Final, mit einheitlichem Design)

import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/screens/edit_routine_screen.dart';
import 'package:lightweight/screens/exercise_catalog_screen.dart';
import 'package:lightweight/screens/live_workout_screen.dart';
import 'package:lightweight/screens/routines_screen.dart';
import 'package:lightweight/screens/workout_history_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';

class WorkoutHubScreen extends StatefulWidget {
  const WorkoutHubScreen({super.key});

  @override
  State<WorkoutHubScreen> createState() => _WorkoutHubScreenState();
}

class _WorkoutHubScreenState extends State<WorkoutHubScreen> {
  bool _isLoading = true;
  List<Routine> _routines = [];
  late final l10n = AppLocalizations.of(context)!;

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  Future<void> _loadData() async {
    setState(() => _isLoading = true);
    final routines = await WorkoutDatabaseHelper.instance.getAllRoutines();
    if (mounted) {
      setState(() {
        _routines = routines;
        _isLoading = false;
      });
    }
  }

  void _startEmptyWorkout() async {
    final newLog = await WorkoutDatabaseHelper.instance
        .startWorkout(routineName: l10n.free_training);
    if (mounted) {
      Navigator.of(context)
          .push(MaterialPageRoute(
            builder: (context) => LiveWorkoutScreen(workoutLog: newLog),
          ))
          .then((_) => _loadData());
    }
  }

  void _startRoutine(Routine routine) async {
    // Wir brauchen die vollen Details der Routine zum Starten
    final detailedRoutine =
        await WorkoutDatabaseHelper.instance.getRoutineById(routine.id!);
    if (detailedRoutine == null) return;

    final newLog = await WorkoutDatabaseHelper.instance
        .startWorkout(routineName: routine.name);
    if (mounted) {
      Navigator.of(context)
          .push(MaterialPageRoute(
            builder: (context) =>
                LiveWorkoutScreen(routine: detailedRoutine, workoutLog: newLog),
          ))
          .then((_) => _loadData());
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    return Scaffold(
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : RefreshIndicator(
              onRefresh: _loadData,
              child: ListView(
                padding: DesignConstants.cardPadding,
                children: [
                  _buildSectionTitle(context, l10n.start_button),
                  SummaryCard(
                    child: InkWell(
                      onTap: _startEmptyWorkout,
                      borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM),
                      child: Padding(
                        padding: const EdgeInsets.all(20.0),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            const Icon(Icons.add_circle_outline, size: 28),
                            const SizedBox(width: 12),
                            Text(l10n.startEmptyWorkoutButton,
                                style: Theme.of(context).textTheme.titleLarge),
                          ],
                        ),
                      ),
                    ),
                  ),
                  SizedBox(height: DesignConstants.spacingXL),
                  _buildSectionTitle(context, l10n.my_plans_capslock),
                  _routines.isEmpty
                      ? _buildEmptyRoutinesCard(context, l10n)
                      : SizedBox(
                          height: 150,
                          child: ListView.builder(
                            scrollDirection: Axis.horizontal,
                            clipBehavior: Clip.none,
                            itemCount: _routines.length,
                            itemBuilder: (context, index) {
                              return _buildRoutineCard(
                                  context, _routines[index]);
                            },
                          ),
                        ),
                  SizedBox(height: DesignConstants.spacingXL),
                  _buildSectionTitle(context, l10n.overview_capslock),
                  _buildNavigationTile(
                    context: context,
                    icon: Icons.history,
                    title: l10n.workoutHistoryButton,
                    onTap: () => Navigator.of(context).push(MaterialPageRoute(
                        builder: (context) => const WorkoutHistoryScreen())),
                  ),
                  SizedBox(height: DesignConstants.spacingM),
                  _buildNavigationTile(
                    context: context,
                    icon: Icons.list_alt_rounded,
                    title: l10n.manage_all_plans,
                    onTap: () => Navigator.of(context)
                        .push(MaterialPageRoute(
                            builder: (context) => const RoutinesScreen()))
                        .then((_) => _loadData()),
                  ),
                  SizedBox(height: DesignConstants.spacingM),
                  _buildNavigationTile(
                    context: context,
                    icon: Icons.folder_open_outlined,
                    title: l10n.drawerExerciseCatalog,
                    onTap: () => Navigator.of(context).push(MaterialPageRoute(
                        builder: (context) => const ExerciseCatalogScreen())),
                  ),
                ],
              ),
            ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildRoutineCard(BuildContext context, Routine routine) {
    final screenWidth = MediaQuery.of(context).size.width;
    final cardWidth = (screenWidth - 32 - 12) / 2;

    return SizedBox(
      width: cardWidth,
      // KORREKTUR: Wir fügen den Abstand hier als Padding hinzu, nicht als Margin.
      child: Padding(
        padding: const EdgeInsets.only(right: 12.0),
        child: SummaryCard(
          child: InkWell(
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (_) => EditRoutineScreen(routine: routine),
                ),
              );
            },
            borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM),
            child: Padding(
              padding: DesignConstants.cardPadding,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(routine.name,
                      style: Theme.of(context)
                          .textTheme
                          .titleMedium
                          ?.copyWith(fontWeight: FontWeight.bold),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis),
                  ElevatedButton(
                      onPressed: () => _startRoutine(routine),
                      child: Text(l10n.start_button)),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildEmptyRoutinesCard(BuildContext context, AppLocalizations l10n) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          children: [
            Text(l10n.emptyRoutinesTitle,
                style: Theme.of(context).textTheme.titleMedium),
            SizedBox(height: DesignConstants.spacingS),
            Text(l10n.emptyRoutinesSubtitle,
                textAlign: TextAlign.center,
                style: Theme.of(context).textTheme.bodySmall),
            SizedBox(height: DesignConstants.spacingL),
            TextButton.icon(
              onPressed: () => Navigator.of(context)
                  .push(MaterialPageRoute(
                      builder: (context) => const RoutinesScreen()))
                  .then((_) => _loadData()),
              icon: const Icon(Icons.add),
              label: Text(l10n.createFirstRoutineButton),
            )
          ],
        ),
      ),
    );
  }

  Widget _buildNavigationTile({
    required BuildContext context,
    required IconData icon,
    required String title,
    required VoidCallback onTap,
  }) {
    // KORREKTUR: Hier wird jetzt die SummaryCard verwendet.
    return SummaryCard(
      child: ListTile(
        leading: Icon(icon, color: Theme.of(context).colorScheme.primary),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
        shape:
            RoundedRectangleBorder(borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM)),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\screens\workout_log_detail_screen.dart =====

// lib/screens/workout_log_detail_screen.dart (Final & Korrigiert - Edit Mode - Neu mit WorkoutCard)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/screens/exercise_catalog_screen.dart';
import 'package:lightweight/screens/exercise_detail_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/wger_attribution_widget.dart';
import 'package:lightweight/widgets/workout_summary_bar.dart';
import 'package:lightweight/widgets/workout_card.dart';

class WorkoutLogDetailScreen extends StatefulWidget {
  final int logId;
  const WorkoutLogDetailScreen({super.key, required this.logId});

  @override
  State<WorkoutLogDetailScreen> createState() => _WorkoutLogDetailScreenState();
}

class _WorkoutLogDetailScreenState extends State<WorkoutLogDetailScreen> {
  bool _isLoading = true;
  WorkoutLog? _log;
  Map<String, List<SetLog>> _groupedSets = {};
  Map<String, Exercise> _exerciseDetails = {};
  bool _isEditMode = false;
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _notesController;
  final Map<int, TextEditingController> _weightControllers = {};
  final Map<int, TextEditingController> _repsControllers = {};
  DateTime? _editedStartTime;
  Map<String, double> _categoryVolume = {};

  @override
  void initState() {
    super.initState();
    _notesController = TextEditingController();
    _loadDetails();
  }

  @override
  void dispose() {
    _notesController.dispose();
    _clearControllers();
    super.dispose();
  }

  void _clearControllers() {
    for (var controller in _weightControllers.values) {
      controller.dispose();
    }
    for (var controller in _repsControllers.values) {
      controller.dispose();
    }
    _weightControllers.clear();
    _repsControllers.clear();
  }

  /// Gibt den anzuzeigenden Text für den Set zurück
  String _getSetDisplayText(String setType, int setIndex) {
    switch (setType) {
      case 'warmup':
        return 'W';
      case 'failure':
        return 'F';
      case 'dropset':
        return 'D';
      default:
        return '$setIndex';
    }
  }

  Future<void> _loadDetails({bool preserveEditState = false}) async {
    if (!preserveEditState) {
      setState(() => _isLoading = true);
    }

    final data =
        await WorkoutDatabaseHelper.instance.getWorkoutLogById(widget.logId);
    if (data == null) {
      if (mounted) setState(() => _isLoading = false);
      return;
    }

    final groups = <String, List<SetLog>>{};
    for (var set in data.sets) {
      groups.putIfAbsent(set.exerciseName, () => []).add(set);
    }

    final Map<String, double> categoryVolume = {};
    for (final set in data.sets) {
      final exercise = await WorkoutDatabaseHelper.instance
          .getExerciseByName(set.exerciseName);
      if (exercise != null) {
        final volumeForSet = (set.weightKg ?? 0) * (set.reps ?? 0);
        categoryVolume.update(
            exercise.categoryName, (value) => value + volumeForSet,
            ifAbsent: () => volumeForSet);
      }
    }

    final tempExerciseDetails = <String, Exercise>{};
    for (var name in groups.keys) {
      final exercise =
          await WorkoutDatabaseHelper.instance.getExerciseByName(name);
      if (exercise != null) tempExerciseDetails[name] = exercise;
    }

    _notesController.text = data.notes ?? '';
    _editedStartTime = data.startTime;

    _clearControllers();
    for (final setLog in data.sets) {
      _weightControllers[setLog.id!] = TextEditingController(
          text: setLog.weightKg?.toStringAsFixed(1).replaceAll('.0', '') ?? '');
      _repsControllers[setLog.id!] =
          TextEditingController(text: setLog.reps?.toString() ?? '');
    }

    if (!mounted) return;
    setState(() {
      _log = data;
      _groupedSets = groups;
      _exerciseDetails = tempExerciseDetails;
      _categoryVolume = categoryVolume;
      if (!preserveEditState) {
        _isLoading = false;
      }
    });
  }

  void _toggleEditMode() {
    setState(() {
      _isEditMode = !_isEditMode;
      if (_isEditMode) {
        _loadDetails(preserveEditState: true);
      } else {
        _loadDetails();
      }
    });
  }

  Future<void> _pickDateTime() async {
    final date = await showDatePicker(
      context: context,
      initialDate: _editedStartTime ?? DateTime.now(),
      firstDate: DateTime(2020),
      lastDate: DateTime.now().add(const Duration(days: 1)),
    );
    if (date == null) return;

    final time = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(_editedStartTime ?? DateTime.now()),
    );
    if (time == null) return;

    setState(() {
      _editedStartTime =
          DateTime(date.year, date.month, date.day, time.hour, time.minute);
    });
  }

  Future<void> _saveChanges() async {
    FocusScope.of(context).unfocus();
    if (!(_formKey.currentState?.validate() ?? false)) return;

    final l10n = AppLocalizations.of(context)!;
    final dbHelper = WorkoutDatabaseHelper.instance;

    final initialSetIds = _log!.sets.map((s) => s.id!).toSet();
    final currentSets = _groupedSets.values.expand((sets) => sets).toList();

    final idsToDelete = initialSetIds
        .difference(currentSets.map((s) => s.id!).toSet())
        .toList();

    final List<SetLog> setsToUpdate = [];
    final List<SetLog> setsToInsert = [];

    for (final setLog in currentSets) {
      final weight = double.tryParse(
              _weightControllers[setLog.id!]?.text.replaceAll(',', '.') ??
                  '0') ??
          0.0;
      final reps = int.tryParse(_repsControllers[setLog.id!]?.text ?? '0') ?? 0;

      final updatedSet = setLog.copyWith(weightKg: weight, reps: reps);

      if (initialSetIds.contains(setLog.id)) {
        setsToUpdate.add(updatedSet);
      } else {
        setsToInsert.add(updatedSet);
      }
    }

    await dbHelper.updateWorkoutLogDetails(
        widget.logId, _editedStartTime!, _notesController.text);
    if (idsToDelete.isNotEmpty) await dbHelper.deleteSetLogs(idsToDelete);
    if (setsToUpdate.isNotEmpty) await dbHelper.updateSetLogs(setsToUpdate);
    for (final set in setsToInsert) {
      await dbHelper
          .insertSetLog(set.copyWith(id: null, workoutLogId: widget.logId));
    }

    if (mounted) {
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(l10n.snackbarRoutineSaved)));
    }

    setState(() => _isEditMode = false);
    _loadDetails();
  }

  Widget _buildHeader(String text) => Expanded(
      child: Text(text,
          textAlign: TextAlign.center,
          style: TextStyle(
              color: Colors.grey[600],
              fontSize: 12,
              fontWeight: FontWeight.bold)));

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).toString();
    final textTheme = Theme.of(context).textTheme;
    final colorScheme = Theme.of(context).colorScheme;

    double totalVolume = 0.0;
    if (_log != null) {
      for (final set in _log!.sets) {
        totalVolume += (set.weightKg ?? 0) * (set.reps ?? 0);
      }
    }
    final Duration duration =
        _log?.endTime?.difference(_log!.startTime) ?? Duration.zero;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        title: Text(
          l10n.workoutDetailsTitle,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w900,
              ),
        ),
        actions: [
          if (!_isLoading && _log != null)
            _isEditMode
                ? TextButton(
                    onPressed: _saveChanges,
                    child: Text(l10n.save,
                        style: TextStyle(
                          color: colorScheme.primary,
                          fontWeight: FontWeight.bold,
                        )),
                  )
                : IconButton(
                    icon: const Icon(Icons.edit),
                    onPressed: _toggleEditMode,
                  ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _log == null
              ? Center(child: Text(l10n.workoutNotFound))
              : Column(
                  children: [
                    WorkoutSummaryBar(
                      duration: duration,
                      volume: totalVolume,
                      sets: _log!.sets.length,
                    ),
                    Divider(
                        height: 1,
                        thickness: 1,
                        color: colorScheme.onSurfaceVariant.withOpacity(0.1)),
                    Expanded(
                      child: ListView(
                        padding: EdgeInsets.zero,
                        children: [
                          // Header Info Section mit SummaryCard
                          Padding(
                            padding: DesignConstants.cardPadding,
                            child: SummaryCard(
                              child: Padding(
                                padding: const EdgeInsets.all(16.0),
                                child: Form(
                                  key: _formKey,
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      Text(
                                        _log!.routineName ??
                                            l10n.freeWorkoutTitle,
                                        style: textTheme.headlineMedium,
                                      ),
                                      Row(
                                        children: [
                                          Text(DateFormat.yMMMMd(locale)
                                              .add_Hm()
                                              .format(_editedStartTime ??
                                                  _log!.startTime)),
                                          if (_isEditMode)
                                            IconButton(
                                              icon: Icon(Icons.calendar_today,
                                                  size: 18,
                                                  color: colorScheme.primary),
                                              onPressed: _pickDateTime,
                                            )
                                        ],
                                      ),
                                      SizedBox(
                                          height: DesignConstants.spacingM),
                                      _isEditMode
                                          ? TextFormField(
                                              controller: _notesController,
                                              decoration: InputDecoration(
                                                  labelText: l10n.notesLabel),
                                              maxLines: 3,
                                            )
                                          : (_log!.notes != null &&
                                                  _log!.notes!.isNotEmpty
                                              ? Text(
                                                  '${l10n.notesLabel}: ${_log!.notes!}',
                                                  style: const TextStyle(
                                                      fontStyle:
                                                          FontStyle.italic))
                                              : const SizedBox.shrink()),
                                      if (_categoryVolume.isNotEmpty) ...[
                                        const Divider(height: 24),
                                        Text(l10n.muscleSplitLabel,
                                            style: textTheme.titleMedium),
                                        SizedBox(
                                            height: DesignConstants.spacingS),
                                        ..._buildCategoryBars(context),
                                      ],
                                    ],
                                  ),
                                ),
                              ),
                            ),
                          ),

                          // Exercise Sets mit WorkoutCard
                          ..._buildSetList(context, l10n),

                          // Add Exercise Button
                          if (_isEditMode)
                            Padding(
                              padding: const EdgeInsets.all(16.0),
                              child: TextButton.icon(
                                onPressed: () async {
                                  final selectedExercise =
                                      await Navigator.of(context)
                                          .push<Exercise>(
                                    MaterialPageRoute(
                                        builder: (context) =>
                                            const ExerciseCatalogScreen(
                                                isSelectionMode: true)),
                                  );
                                  if (selectedExercise != null) {
                                    setState(() {
                                      final newSet = SetLog(
                                          id: DateTime.now()
                                              .millisecondsSinceEpoch,
                                          workoutLogId: _log!.id!,
                                          exerciseName: selectedExercise
                                              .getLocalizedName(context),
                                          setType: 'normal');
                                      _groupedSets[selectedExercise
                                          .getLocalizedName(context)] = [
                                        newSet
                                      ];
                                      _weightControllers[newSet.id!] =
                                          TextEditingController();
                                      _repsControllers[newSet.id!] =
                                          TextEditingController();
                                    });
                                  }
                                },
                                icon: const Icon(Icons.add),
                                label: Text(l10n.addExerciseToWorkoutButton),
                              ),
                            ),

                          Padding(
                            padding: const EdgeInsets.fromLTRB(
                                16.0, 24.0, 16.0, 8.0),
                            child: WgerAttributionWidget(
                              textStyle: textTheme.bodySmall
                                  ?.copyWith(color: Colors.grey[600]),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
    );
  }

  List<Widget> _buildCategoryBars(BuildContext context) {
    final total = _categoryVolume.values.fold<double>(0, (a, b) => a + b);
    return _categoryVolume.entries.map((entry) {
      final fraction = total > 0 ? entry.value / total : 0.0;
      return Padding(
        padding: const EdgeInsets.symmetric(vertical: 4.0),
        child: Row(
          children: [
            Expanded(
                flex: 2,
                child: Text(entry.key, style: const TextStyle(fontSize: 12))),
            Expanded(
              flex: 5,
              child: LinearProgressIndicator(
                value: fraction,
                backgroundColor: Colors.grey.shade300,
                color: Theme.of(context).colorScheme.primary,
                minHeight: 12,
              ),
            ),
            const SizedBox(width: 8),
            Text("${(fraction * 100).toStringAsFixed(0)}%"),
          ],
        ),
      );
    }).toList();
  }

  Widget _buildSetRow(
      SetLog setLog, int setIndex, String exerciseName, AppLocalizations l10n) {
    final setType = setLog.setType;

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Container(
        decoration: BoxDecoration(
          color: Colors.transparent,
        ),
        child: Row(
          children: [
            // Set-Index als große farbige Zahl (KLICKBAR im Edit-Modus)
            Expanded(
              flex: 2,
              child: Center(
                child: Builder(
                  builder: (_) {
                    Color textColor;
                    switch (setType) {
                      case 'warmup':
                        textColor = Colors.orange;
                        break;
                      case 'dropset':
                        textColor = Colors.blue;
                        break;
                      case 'failure':
                        textColor = Colors.red;
                        break;
                      default:
                        textColor = Colors.grey;
                    }
                    return GestureDetector(
                      onTap: () {
                        if (_isEditMode) _showSetTypePicker(setLog.id!);
                      },
                      child: Text(
                        _getSetDisplayText(setType, setIndex),
                        style: TextStyle(
                          color: textColor,
                          fontSize: 20,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    );
                  },
                ),
              ),
            ),
            // Last Time (leer in History View)
            Expanded(
              flex: 3,
              child: Center(
                child: Text(
                  "-",
                  textAlign: TextAlign.center,
                  style: TextStyle(color: Colors.grey[500], fontSize: 12),
                ),
              ),
            ),
            // Weight
            Expanded(
              flex: 2,
              child: _isEditMode
                  ? TextFormField(
                      controller: _weightControllers[setLog.id!],
                      textAlign: TextAlign.center,
                      keyboardType:
                          const TextInputType.numberWithOptions(decimal: true),
                      decoration: const InputDecoration(
                          border: InputBorder.none,
                          isDense: true,
                          fillColor: Colors.transparent),
                    )
                  : Text(
                      "${setLog.weightKg?.toStringAsFixed(1).replaceAll('.0', '') ?? '0'}",
                      textAlign: TextAlign.center,
                      style: const TextStyle(fontSize: 16),
                    ),
            ),
            const SizedBox(width: 8),
            // Reps
            Expanded(
              flex: 2,
              child: _isEditMode
                  ? TextFormField(
                      controller: _repsControllers[setLog.id!],
                      textAlign: TextAlign.center,
                      keyboardType: TextInputType.number,
                      decoration: const InputDecoration(
                          border: InputBorder.none,
                          isDense: true,
                          fillColor: Colors.transparent),
                    )
                  : Text(
                      "${setLog.reps ?? '0'}",
                      textAlign: TextAlign.center,
                      style: const TextStyle(fontSize: 16),
                    ),
            ),
            // Delete/Done Button
            Padding(
              padding: const EdgeInsets.only(right: 8.0),
              child: SizedBox(
                width: 48,
                child: _isEditMode
                    ? IconButton(
                        icon: const Icon(Icons.delete_outline,
                            color: Colors.redAccent),
                        onPressed: () {
                          setState(() {
                            _groupedSets[exerciseName]
                                ?.removeWhere((s) => s.id == setLog.id);
                            _weightControllers.remove(setLog.id!)?.dispose();
                            _repsControllers.remove(setLog.id!)?.dispose();
                          });
                        },
                      )
                    : Icon(
                        Icons.check_circle,
                        color: Colors.green,
                      ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  List<Widget> _buildSetList(BuildContext context, AppLocalizations l10n) {
    final textTheme = Theme.of(context).textTheme;
    final entries = _groupedSets.entries.toList();

    if (!_isEditMode) {
      // Normale Liste ohne Reorder-Funktionalität
      return entries
          .map((entry) => _buildExerciseCard(context, l10n, entry, -1))
          .toList();
    } else {
      // ReorderableListView für Edit-Modus
      return [
        ReorderableListView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          padding: EdgeInsets.zero,
          onReorder: (int oldIndex, int newIndex) {
            setState(() {
              if (newIndex > oldIndex) {
                newIndex -= 1;
              }
              final item = entries.removeAt(oldIndex);
              entries.insert(newIndex, item);

              // Gruppierte Sets Map neu aufbauen
              _groupedSets.clear();
              for (var entry in entries) {
                _groupedSets[entry.key] = entry.value;
              }
            });
          },
          itemCount: entries.length,
          itemBuilder: (context, index) {
            return _buildExerciseCard(context, l10n, entries[index], index);
          },
        ),
      ];
    }
  }

  Widget _buildExerciseCard(BuildContext context, AppLocalizations l10n,
      MapEntry<String, List<SetLog>> entry, int index) {
    final String exerciseName = entry.key;
    final Exercise? exercise = _exerciseDetails[exerciseName];
    final List<SetLog> sets = entry.value;
    final textTheme = Theme.of(context).textTheme;

    return WorkoutCard(
      key: _isEditMode ? ValueKey(exerciseName) : null,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          ListTile(
            contentPadding:
                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
            leading: _isEditMode
                ? ReorderableDragStartListener(
                    index: index,
                    child: const Icon(Icons.drag_handle),
                  )
                : null,
            title: InkWell(
              onTap: () {
                if (exercise != null) {
                  Navigator.of(context).push(MaterialPageRoute(
                    builder: (context) =>
                        ExerciseDetailScreen(exercise: exercise),
                  ));
                }
              },
              child: Padding(
                padding: const EdgeInsets.symmetric(vertical: 4.0),
                child: Text(
                  exercise?.getLocalizedName(context) ?? exerciseName,
                  style: textTheme.titleLarge
                      ?.copyWith(fontWeight: FontWeight.bold),
                ),
              ),
            ),
            trailing: _isEditMode
                ? IconButton(
                    icon: const Icon(Icons.delete_outline,
                        color: Colors.redAccent),
                    tooltip: l10n.removeExercise,
                    onPressed: () {
                      setState(() {
                        for (var set in sets) {
                          _weightControllers.remove(set.id!)?.dispose();
                          _repsControllers.remove(set.id!)?.dispose();
                        }
                        _groupedSets.remove(exerciseName);
                      });
                    },
                  )
                : const Icon(Icons.info_outline),
          ),

          // Header Row
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 0.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      flex: 2,
                      child: Center(
                          child: Text(
                        l10n.setLabel,
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          color: Colors.grey[600],
                          fontSize: 12,
                          fontWeight: FontWeight.bold,
                        ),
                      )),
                    ),
                    Expanded(
                      flex: 3,
                      child: Center(
                          child: Text(
                        l10n.lastTimeLabel,
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          color: Colors.grey[600],
                          fontSize: 12,
                          fontWeight: FontWeight.bold,
                        ),
                      )),
                    ),
                    Expanded(
                      flex: 2,
                      child: Center(
                          child: Text(
                        l10n.kgLabel,
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          color: Colors.grey[600],
                          fontSize: 12,
                          fontWeight: FontWeight.bold,
                        ),
                      )),
                    ),
                    Expanded(
                      flex: 2,
                      child: Center(
                          child: Text(
                        l10n.repsLabel,
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          color: Colors.grey[600],
                          fontSize: 12,
                          fontWeight: FontWeight.bold,
                        ),
                      )),
                    ),
                    const SizedBox(width: 48),
                  ],
                ),

                // Set Rows
                ...sets.asMap().entries.map((setEntry) {
                  final setLog = setEntry.value;

                  // Normale Sätze zählen (ohne Warmup)
                  int workingSetIndex = 0;
                  for (int i = 0; i <= setEntry.key; i++) {
                    if (sets[i].setType != 'warmup') {
                      workingSetIndex++;
                    }
                  }

                  return _buildSetRow(
                      setLog, workingSetIndex, exerciseName, l10n);
                }),

                // Add Set Button
                if (_isEditMode)
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16.0),
                    child: TextButton.icon(
                      onPressed: () {
                        final newSet = SetLog(
                            id: DateTime.now().millisecondsSinceEpoch,
                            workoutLogId: _log!.id!,
                            exerciseName: exerciseName,
                            setType: 'normal');
                        setState(() {
                          sets.add(newSet);
                          _weightControllers[newSet.id!] =
                              TextEditingController();
                          _repsControllers[newSet.id!] =
                              TextEditingController();
                        });
                      },
                      icon: const Icon(Icons.add),
                      label: Text(l10n.addSetButton),
                    ),
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  void _changeSetType(int setLogId, String newType) {
    setState(() {
      // Finde den SetLog und ändere den setType
      for (var entry in _groupedSets.entries) {
        for (var setLog in entry.value) {
          if (setLog.id == setLogId) {
            // Erstelle eine neue Instanz mit geändertem setType
            final index = entry.value.indexOf(setLog);
            entry.value[index] = setLog.copyWith(setType: newType);
            break;
          }
        }
      }
    });
    Navigator.pop(context);
  }

  void _showSetTypePicker(int setLogId) {
    showModalBottomSheet(
      context: context,
      builder: (context) {
        return Wrap(
          children: <Widget>[
            ListTile(
                title: const Text('Normal'),
                onTap: () => _changeSetType(setLogId, 'normal')),
            ListTile(
                title: const Text('Warmup'),
                onTap: () => _changeSetType(setLogId, 'warmup')),
            ListTile(
                title: const Text('Failure'),
                onTap: () => _changeSetType(setLogId, 'failure')),
            ListTile(
                title: const Text('Dropset'),
                onTap: () => _changeSetType(setLogId, 'dropset')),
          ],
        );
      },
    );
  }
}


===== Datei: D:\lightweight\lib\screens\workout_summary_screen.dart =====

// lib/screens/workout_summary_screen.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/util/time_util.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/workout_summary_bar.dart';

class WorkoutSummaryScreen extends StatefulWidget {
  final int logId;

  const WorkoutSummaryScreen({super.key, required this.logId});

  @override
  State<WorkoutSummaryScreen> createState() => _WorkoutSummaryScreenState();
}

class _WorkoutSummaryScreenState extends State<WorkoutSummaryScreen> {
  bool _isLoading = true;
  WorkoutLog? _log;
  Map<String, double> _volumePerExercise = {};

  @override
  void initState() {
    super.initState();
    _loadWorkoutDetails();
  }

  Future<void> _loadWorkoutDetails() async {
    final data =
        await WorkoutDatabaseHelper.instance.getWorkoutLogById(widget.logId);

    if (data != null) {
      final Map<String, double> volumeMap = {};
      for (var set in data.sets) {
        final volume = (set.weightKg ?? 0) * (set.reps ?? 0);
        volumeMap.update(set.exerciseName, (value) => value + volume,
            ifAbsent: () => volume);
      }

      if (mounted) {
        setState(() {
          _log = data;
          _volumePerExercise = volumeMap;
          _isLoading = false;
        });
      }
    } else {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final textTheme = Theme.of(context).textTheme;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        automaticallyImplyLeading: false, // Verhindert den Zurück-Pfeil
        title: Text("Workout Abgeschlossen",
            style: textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w900)),
        elevation: 0,
        backgroundColor: Colors.transparent,
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _log == null
              ? Center(child: Text(l10n.workoutNotFound))
              : Padding(
                  padding: DesignConstants.cardPadding,
                  child: Column(
                    children: [
                      // Gesamt-Statistiken
                      WorkoutSummaryBar(
                        duration: _log!.endTime?.difference(_log!.startTime),
                        volume:
                            _volumePerExercise.values.fold(0, (a, b) => a + b),
                        sets: _log!.sets.length,
                      ),
                      SizedBox(height: DesignConstants.spacingXL),

                      // Liste der Übungen
                      Expanded(
                        child: ListView(
                          children: [
                            Text("Übersicht der Übungen",
                                style: textTheme.titleMedium),
                            SizedBox(height: DesignConstants.spacingS),
                            ..._volumePerExercise.entries.map((entry) {
                              return SummaryCard(
                                child: ListTile(
                                  title: Text(entry.key,
                                      style: const TextStyle(
                                          fontWeight: FontWeight.bold)),
                                  trailing: Text(
                                      "${entry.value.toStringAsFixed(0)} kg",
                                      style: textTheme.bodyLarge),
                                ),
                              );
                            }),
                          ],
                        ),
                      ),
                      SizedBox(height: DesignConstants.spacingXL),

                      // Fertig-Button
                      SizedBox(
                        width: double.infinity,
                        child: ElevatedButton(
                          style: ElevatedButton.styleFrom(
                            padding: const EdgeInsets.symmetric(vertical: 16),
                          ),
                          onPressed: () {
                            // Schließt den Summary-Screen und kehrt zum vorherigen Screen zurück
                            // (vermutlich der Routines- oder Home-Screen)
                            Navigator.of(context).pop();
                          },
                          child: Text(l10n.doneButtonLabel,
                              style: const TextStyle(fontSize: 18)),
                        ),
                      ),
                    ],
                  ),
                ),
    );
  }
}


===== Datei: D:\lightweight\lib\services\profile_service.dart =====

// lib/services/profile_service.dart

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';

class ProfileService extends ChangeNotifier {
  static final ProfileService _instance = ProfileService._internal();
  factory ProfileService() => _instance;
  ProfileService._internal();

  String? _profileImagePath;
  String? get profileImagePath => _profileImagePath;

  static const String _profileImageKey = 'profileImagePath';

  // Units
  bool _useKg = true;
  bool get useKg => _useKg;
  bool _useCm = true;
  bool get useCm => _useCm;

  Future<void> initialize() async {
    final prefs = await SharedPreferences.getInstance();
    _profileImagePath = prefs.getString(_profileImageKey);
    _useKg = prefs.getBool('useKg') ?? true;
    _useCm = prefs.getBool('useCm') ?? true;
    notifyListeners();
  }

  Future<void> setUseKg(bool value) async {
    _useKg = value;
    notifyListeners();
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool('useKg', value);
  }

  Future<void> setUseCm(bool value) async {
    _useCm = value;
    notifyListeners();
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool('useCm', value);
  }

  Future<void> pickAndSaveProfileImage() async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(source: ImageSource.gallery);
    if (pickedFile != null) {
      final appDir = await getApplicationDocumentsDirectory();
      const fileName = 'profile_image.jpg';
      final localPath = '${appDir.path}/$fileName';
      final newImage = await File(pickedFile.path).copy(localPath);
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_profileImageKey, newImage.path);
      _profileImagePath = newImage.path;
      notifyListeners();
    }
  }

  Future<void> deleteProfileImage() async {
    final prefs = await SharedPreferences.getInstance();
    final currentPath = prefs.getString(_profileImageKey);
    if (currentPath != null) {
      try {
        await File(currentPath).delete();
      } catch (e) {
        debugPrint('Fehler beim Löschen des Profilbildes: $e');
      }
      await prefs.remove(_profileImageKey);
      _profileImagePath = null;
      notifyListeners();
    }
  }
} // <-- Klasse hier schließen

// Extension außerhalb der Klasse deklarieren
extension UnitConverter on ProfileService {
  double toDisplayWeight(double kg) => useKg ? kg : kg * 2.20462;
  double toStorageWeight(double display) => useKg ? display : display / 2.20462;

  double toDisplayLength(double cm) => useCm ? cm : cm / 2.54;
  double toStorageLength(double display) => useCm ? display : display * 2.54;

  String weightLabel() => useKg ? 'kg' : 'lbs';
  String lengthLabel() => useCm ? 'cm' : 'in';
}


===== Datei: D:\lightweight\lib\services\ui_state_service.dart =====

// lib/services/ui_state_service.dart

class UiStateService {
  // Statische Instanz, die beim ersten Zugriff erstellt wird (Singleton-Pattern)
  static final UiStateService instance = UiStateService._internal();

  // Privater Konstruktor
  UiStateService._internal();

  // Der Zustand, den wir speichern wollen
  bool isNutritionSummaryExpanded = true; // Standardmäßig AN, wie gewünscht
}


===== Datei: D:\lightweight\lib\services\workout_session_manager.dart =====

// lib/services/workout_session_manager.dart (mit Live-Timer)

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:vibration/vibration.dart';
import 'package:lightweight/models/routine_exercise.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/data/workout_database_helper.dart';

/// Singleton-Manager, der eine laufende Workout-Session global verwaltet.
class WorkoutSessionManager extends ChangeNotifier {
  static final WorkoutSessionManager _instance =
      WorkoutSessionManager._internal();
  factory WorkoutSessionManager() => _instance;
  WorkoutSessionManager._internal();

  WorkoutLog? _workoutLog;
  List<RoutineExercise> _exercises = [];
  final Map<int, int?> pauseTimes = {};
  final Set<int> completedSets = {};
  final Map<int, int> _templateIdToSetLogId = {};

  Timer? _restTimer;
  int _remainingRestSeconds = 0;
  Timer? _restDoneBannerTimer;
  bool _showRestDone = false;

  // HINZUGEFÜGT: Neue Variablen für den Workout-Timer
  Timer? _workoutDurationTimer;
  Duration _elapsedDuration = Duration.zero;
  // HINZUGEFÜGT: Neue Variablen für die Live-Statistiken
  double _totalVolume = 0.0;
  int _totalSets = 0;

  // Getter
  double get totalVolume => _totalVolume;
  int get totalSets => _totalSets;
  WorkoutLog? get workoutLog => _workoutLog;
  List<RoutineExercise> get exercises => _exercises;
  int get remainingRestSeconds => _remainingRestSeconds;
  bool get isActive => _workoutLog != null && _workoutLog!.endTime == null;
  bool get showRestDone => _showRestDone;

  // HINZUGEFÜGT: Getter für die vergangene Zeit
  Duration get elapsedDuration => _elapsedDuration;

  void cancelRest() {
    _restTimer?.cancel();
    _restDoneBannerTimer?.cancel();
    _remainingRestSeconds = 0;
    _showRestDone = false;
    notifyListeners();
  }

  /// Neues Workout starten
  void startWorkout(WorkoutLog log, List<RoutineExercise> routineExercises) {
    _workoutLog = log;
    _exercises = routineExercises;
    pauseTimes.clear();
    for (var re in routineExercises) {
      pauseTimes[re.id!] = re.pauseSeconds;
    }
    completedSets.clear();
    _templateIdToSetLogId.clear();

    // HINZUGEFÜGT: Statistiken zurücksetzen
    _totalVolume = 0.0;
    _totalSets = 0;

    // HINZUGEFÜGT: Starte den Workout-Timer
    _startWorkoutTimer();

    notifyListeners();
  }

  Future<void> logSet(int templateId, RoutineExercise re, double weight,
      int reps, String setType) async {
    if (_workoutLog == null || _workoutLog!.id == null) {
      debugPrint(
          "[ERROR] logSet aufgerufen, aber workoutLog ist null oder hat keine ID!");
      return;
    }

    final restTime = pauseTimes[re.id!];

    final setLogToSave = SetLog(
      workoutLogId: _workoutLog!.id!,
      exerciseName: re.exercise.nameEn,
      setType: setType, // <- Hier den übergebenen setType verwenden
      weightKg: weight,
      reps: reps,
      restTimeSeconds: restTime,
      isCompleted: true,
      log_order: _exercises.indexOf(re),
    );

    final newSetLogId =
        await WorkoutDatabaseHelper.instance.insertSetLog(setLogToSave);
    _templateIdToSetLogId[templateId] = newSetLogId;
    completedSets.add(templateId);

    _totalVolume += weight * reps;
    _totalSets++;

    if (restTime != null && restTime > 0) {
      _startRestTimer(restTime);
    }
    notifyListeners();
  }

  Future<void> unlogSet(int templateId) async {
    final setLogId = _templateIdToSetLogId[templateId];
    if (setLogId != null) {
      // HINWEIS: Um das Volumen korrekt zu reduzieren, müssten wir hier
      // den SetLog aus der DB lesen, bevor wir ihn löschen.
      // Fürs Erste ist das Zurücksetzen einfacher und meist ausreichend.
      // Wir berechnen das Volumen beim nächsten logSet einfach neu.
      // EINFÜHRUNG: Wir berechnen die Stats neu, um Konsistenz zu gewährleisten
      await _recalculateStats();

      await WorkoutDatabaseHelper.instance.deleteSetLogs([setLogId]);
      completedSets.remove(templateId);
      _templateIdToSetLogId.remove(templateId);

      notifyListeners();
    }
  }

  /// Pause einstellen
  void updatePauseTime(RoutineExercise re, int? seconds) {
    pauseTimes[re.id!] = seconds;
    notifyListeners();
  }

  /// Workout beenden
  Future<void> finishWorkout() async {
    if (_workoutLog == null) return;
    await WorkoutDatabaseHelper.instance.finishWorkout(_workoutLog!.id!);

    // HINZUGEFÜGT: Stoppe beide Timer
    _stopWorkoutTimer();
    _restTimer?.cancel();
    _totalVolume = 0.0; // HINZUGEFÜGT
    _totalSets = 0; // HINZUGEFÜGT

    _remainingRestSeconds = 0;
    _workoutLog = null;
    _exercises = [];
    notifyListeners();
  }

  // HINZUGEFÜGT: Eine Helfermethode, um die Stats neu zu berechnen
  Future<void> _recalculateStats() async {
    // Diese Methode ist ein Platzhalter. Eine volle Implementierung
    // würde hier die `completedSets` durchgehen und das Volumen neu aufbauen.
    // Fürs Erste reicht das einfache Inkrementieren/Dekrementieren.
    // Bei `unlogSet` wird die Komplexität sichtbar.
  }

  void _startRestTimer(int seconds) {
    _restTimer?.cancel();
    _restDoneBannerTimer?.cancel();

    _remainingRestSeconds = seconds;
    _showRestDone = false;
    notifyListeners();

    _restTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_remainingRestSeconds > 0) {
        _remainingRestSeconds--;
        notifyListeners();
      } else {
        timer.cancel();
        Vibration.vibrate(duration: 500);

        // 10s grüner Hinweis „Pause vorbei!“ anzeigen
        _showRestDone = true;
        notifyListeners();

        _restDoneBannerTimer = Timer(const Duration(seconds: 10), () {
          _showRestDone = false;
          notifyListeners();
        });
      }
    });
  }

  /// Resttimer überspringen
  void skipRestTimer() {
    _restTimer?.cancel();
    _remainingRestSeconds = 0;
    notifyListeners();
  }

  // HINZUGEFÜGT: Neue Methoden zum Steuern des Workout-Timers
  void _startWorkoutTimer() {
    _workoutDurationTimer?.cancel(); // Stoppe einen eventuell alten Timer
    _elapsedDuration = Duration.zero; // Setze die Zeit zurück

    // Berechne die bereits vergangene Zeit seit dem Start des Workouts,
    // falls die App zwischendurch geschlossen wurde.
    if (_workoutLog != null) {
      _elapsedDuration = DateTime.now().difference(_workoutLog!.startTime);
    }

    _workoutDurationTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      // Berechne die Dauer bei jedem Tick neu, um maximale Genauigkeit zu gewährleisten
      if (_workoutLog != null) {
        _elapsedDuration = DateTime.now().difference(_workoutLog!.startTime);
        notifyListeners(); // Benachrichtige die UI über die neue Dauer
      } else {
        timer
            .cancel(); // Sicherheitshalber stoppen, wenn kein Workout mehr aktiv ist
      }
    });
  }

  void _stopWorkoutTimer() {
    _workoutDurationTimer?.cancel();
  }

  /// Ändert das Gewicht für ein laufendes Set (in kg).
  void updateWeight(int templateId, double newWeight) {
    // Hier solltest du sowohl den Controller-Text als auch die interne Logik aktualisieren
    // Beispiel: Wenn du inline die Controller-Map verwenden willst, dann:
    // _weightControllers[templateId]?.text = newWeight.toStringAsFixed(1);

    // Optional: setze eine Interims-Statistik-Aktualisierung auf
    notifyListeners();
  }

  /// Ändert die Reps für ein laufendes Set.
  void updateReps(int templateId, int newReps) {
    // Beispiel: _repsControllers[templateId]?.text = newReps.toString();
    notifyListeners();
  }
}


===== Datei: D:\lightweight\lib\theme\app_colors.dart =====

import 'package:flutter/material.dart';

@immutable
class AppSurfaces extends ThemeExtension<AppSurfaces> {
  final Color summaryCard;
  const AppSurfaces({required this.summaryCard});

  @override
  AppSurfaces copyWith({Color? summaryCard}) =>
      AppSurfaces(summaryCard: summaryCard ?? this.summaryCard);

  @override
  AppSurfaces lerp(ThemeExtension<AppSurfaces>? other, double t) {
    if (other is! AppSurfaces) return this;
    return AppSurfaces(
      summaryCard: Color.lerp(summaryCard, other.summaryCard, t)!,
    );
  }
}


===== Datei: D:\lightweight\lib\util\date_util.dart =====

// lib/util/date_util.dart

extension DateOnlyCompare on DateTime {
  bool isSameDate(DateTime other) {
    return year == other.year && month == other.month && day == other.day;
  }
}


===== Datei: D:\lightweight\lib\util\design_constants.dart =====

// lib/util/design_constants.dart
import 'package:flutter/material.dart';

class DesignConstants {
  // === SPACING ===
  // Card Padding
  static const double cardPaddingInternal = 16.0; // Innenabstand von Cards
  static const double cardPaddingExternal = 8.0;  // Außenabstand zwischen Cards
  
  // General Spacing
  static const double spacingXS = 4.0;   // Sehr kleine Abstände
  static const double spacingS = 8.0;    // Kleine Abstände  
  static const double spacingM = 12.0;   // Mittlere Abstände
  static const double spacingL = 16.0;   // Standard-Abstände
  static const double spacingXL = 24.0;  // Große Abstände
  static const double spacingXXL = 32.0; // Sehr große Abstände
  
  // Screen Padding
  static const double screenPaddingHorizontal = 16.0;
  static const double screenPaddingVertical = 8.0;
  
  // === BORDER RADIUS ===
  static const double borderRadiusS = 8.0;   // Kleine Rundung
  static const double borderRadiusM = 12.0;  // Standard Rundung
  static const double borderRadiusL = 16.0;  // Große Rundung
  
  // === LIST SPACING ===
  static const double listItemSpacing = 8.0;
  static const double listSectionSpacing = 24.0;
  
  // === BUTTON SPACING ===
  static const double buttonPadding = 16.0;
  static const double buttonSpacing = 12.0;
  
  // === ICON SIZES ===
  static const double iconSizeS = 16.0;
  static const double iconSizeM = 20.0;
  static const double iconSizeL = 24.0;
  static const double iconSizeXL = 32.0;
  
  // === EDGE INSETS SHORTCUTS ===
  static const EdgeInsets cardPadding = EdgeInsets.all(cardPaddingInternal);
  static const EdgeInsets cardMargin = EdgeInsets.symmetric(vertical: cardPaddingExternal);
  static const EdgeInsets screenPadding = EdgeInsets.symmetric(
    horizontal: screenPaddingHorizontal,
    vertical: screenPaddingVertical,
  );
  static const EdgeInsets listPadding = EdgeInsets.all(spacingL);
  static const EdgeInsets buttonContentPadding = EdgeInsets.symmetric(
    horizontal: buttonPadding,
    vertical: spacingM,
  );
}

===== Datei: D:\lightweight\lib\util\encryption_util.dart =====

// lib/util/encryption_util.dart
import 'dart:convert';
import 'dart:math';
import 'package:cryptography/cryptography.dart';

class EncryptionUtil {
  static final _algo = AesGcm.with256bits();
  static const wrapperVersion = 'LWENC-1';

  static Future<Map<String, dynamic>> encryptString(
      String plaintext, String passphrase) async {
    final salt = _randomBytes(16);
    final nonce = _randomBytes(12);
    final key = await _deriveKey(passphrase, salt);
    final box = await _algo.encrypt(
      utf8.encode(plaintext),
      secretKey: key,
      nonce: nonce,
    );
    return {
      'enc': wrapperVersion,
      'salt': base64Encode(salt),
      'nonce': base64Encode(nonce),
      'cipher': base64Encode(box.cipherText),
      'mac': base64Encode(box.mac.bytes),
    };
  }

  static Future<String> decryptToString(
      Map<String, dynamic> wrapper, String passphrase) async {
    if (wrapper['enc'] != wrapperVersion) {
      throw ArgumentError('Unknown encryption wrapper');
    }
    final salt = base64Decode(wrapper['salt'] as String);
    final nonce = base64Decode(wrapper['nonce'] as String);
    final cipher = base64Decode(wrapper['cipher'] as String);
    final mac = Mac(base64Decode(wrapper['mac'] as String));
    final key = await _deriveKey(passphrase, salt);
    final clear = await _algo.decrypt(
      SecretBox(cipher, nonce: nonce, mac: mac),
      secretKey: key,
    );
    return utf8.decode(clear);
  }

  static Future<SecretKey> _deriveKey(String passphrase, List<int> salt) async {
    final pbkdf2 = Pbkdf2(
      macAlgorithm: Hmac.sha256(),
      iterations: 150000,
      bits: 256,
    );
    return await pbkdf2.deriveKey(
      secretKey: SecretKey(utf8.encode(passphrase)),
      nonce: salt,
    );
  }

  static List<int> _randomBytes(int length) {
    final rnd = Random.secure();
    return List<int>.generate(length, (_) => rnd.nextInt(256));
  }
}


===== Datei: D:\lightweight\lib\util\l10n_ext.dart =====

// lib/util/l10n_ext.dart
import 'package:flutter/widgets.dart';
import 'package:lightweight/generated/app_localizations.dart';

extension L10nX on BuildContext {
  AppLocalizations get l10n => AppLocalizations.of(this)!;
}


===== Datei: D:\lightweight\lib\util\mapping_prefs.dart =====

// lib/util/mapping_prefs.dart
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';

class MappingPrefs {
  static const _kKey = 'exercise_name_mappings_v1';

  // Lädt Map<externalName, targetName> (case-insensitive Lookup via normalize).
  static Future<Map<String, String>> load() async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_kKey);
    if (raw == null || raw.isEmpty) return {};
    try {
      final Map<String, dynamic> m = jsonDecode(raw);
      return m.map((k, v) => MapEntry(_norm(k), (v as String?)?.trim() ?? ''));
    } catch (_) {
      return {};
    }
  }

  // Fügt/aktualisiert Einträge und speichert als JSON-String.
  static Future<void> upsert(Map<String, String> entries) async {
    if (entries.isEmpty) return;
    final prefs = await SharedPreferences.getInstance();
    final current = await load();
    entries.forEach((k, v) {
      final key = _norm(k);
      final val = (v).trim();
      if (val.isNotEmpty) current[key] = val;
    });
    await prefs.setString(_kKey, jsonEncode(current));
  }

  // Holt eine Zielzuordnung, falls vorhanden.
  static Future<String?> lookup(String externalName) async {
    final m = await load();
    return m[_norm(externalName)];
  }

  static String _norm(String s) => s.trim().toLowerCase();
}


===== Datei: D:\lightweight\lib\util\time_util.dart =====

// lib/util/time_util.dart

/// Formatiert eine Duration in einen String wie "HH:MM:SS" oder "MM:SS".
String formatDuration(Duration d) {
  // .abs() stellt sicher, dass wir keine negativen Werte anzeigen,
  // falls es zu kleinen Zeit-Inkonsistenzen kommt.
  d = d.abs();

  var seconds = d.inSeconds;
  final hours = seconds ~/ Duration.secondsPerHour;
  seconds -= hours * Duration.secondsPerHour;
  final minutes = seconds ~/ Duration.secondsPerMinute;
  seconds -= minutes * Duration.secondsPerMinute;

  final hoursString = hours > 0 ? '${hours.toString()}:' : '';
  final minutesString = minutes.toString().padLeft(2, '0');
  final secondsString = seconds.toString().padLeft(2, '0');

  return '$hoursString$minutesString:$secondsString';
}


===== Datei: D:\lightweight\lib\widgets\add_menu_sheet.dart =====

// lib/widgets/add_menu_sheet.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/design_constants.dart';

class AddMenuSheet extends StatelessWidget {
  const AddMenuSheet({super.key});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;

    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Text(
              l10n.addMenuTitle,
              style: Theme.of(context).textTheme.titleLarge,
              textAlign: TextAlign.center,
            ),
            SizedBox(height: DesignConstants.spacingXL),
            _buildMenuOption(
              context: context,
              colorScheme: colorScheme,
              icon: Icons.fitness_center,
              title: l10n.startWorkout,
              onTap: () => Navigator.of(context).pop('start_workout'),
            ),
            SizedBox(height: DesignConstants.spacingM),
            _buildMenuOption(
              context: context,
              colorScheme: colorScheme,
              icon: Icons.straighten_outlined,
              title: l10n.addMeasurement,
              onTap: () => Navigator.of(context).pop('add_measurement'),
            ),
            const Divider(height: 24, indent: 16, endIndent: 16),
            _buildMenuOption(
              context: context,
              colorScheme: colorScheme,
              icon: Icons.restaurant_menu,
              title: l10n.addFoodOption,
              onTap: () => Navigator.of(context).pop('add_food'),
            ),
            SizedBox(height: DesignConstants.spacingM),
            _buildMenuOption(
              context: context,
              colorScheme: colorScheme,
              icon: Icons.local_drink,
              title: l10n.addLiquidOption,
              onTap: () => Navigator.of(context).pop('add_liquid'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMenuOption({
    required BuildContext context,
    required ColorScheme colorScheme,
    required IconData icon,
    required String title,
    required VoidCallback onTap,
  }) {
    return ListTile(
      leading: Icon(icon, color: colorScheme.primary),
      title: Text(
        title,
        style:
            TextStyle(color: colorScheme.primary, fontWeight: FontWeight.w500),
      ),
      tileColor: colorScheme.surfaceContainerHighest.withOpacity(0.5),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      onTap: onTap,
    );
  }
}


===== Datei: D:\lightweight\lib\widgets\compact_nutrition_bar.dart =====

// lib/widgets/compact_nutrition_bar.dart

import 'package:flutter/material.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/util/design_constants.dart';

class CompactNutritionBar extends StatelessWidget {
  final DailyNutrition nutritionData;
  const CompactNutritionBar({super.key, required this.nutritionData});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: DesignConstants.cardMargin,
      child: Column(
        children: [
          _buildProgressBar(
            context: context,
            label: 'Kalorien',
            value: nutritionData.calories.toDouble(),
            target: nutritionData.targetCalories.toDouble(),
            unit: 'kcal',
            color: Colors.orange,
          ),
          SizedBox(height: DesignConstants.spacingM),
          _buildProgressBar(
            context: context,
            label: 'Protein',
            value: nutritionData.protein.toDouble(),
            target: nutritionData.targetProtein.toDouble(),
            unit: 'g',
            color: Colors.red.shade400,
          ),
          SizedBox(height: DesignConstants.spacingM),
          _buildProgressBar(
              context: context,
              label: 'Wasser',
              value: nutritionData.water.toDouble(),
              target: nutritionData.targetWater.toDouble(),
              unit: 'L',
              isWater: true,
              color: Colors.blue),
        ],
      ),
    );
  }

  Widget _buildProgressBar({
    required BuildContext context,
    required String label,
    required double value,
    required double target,
    required String unit,
    required Color color,
    bool isWater = false,
  }) {
    final progress = target > 0 ? (value / target).clamp(0.0, 1.0) : 0.0;
    final displayValue =
        isWater ? (value / 1000).toStringAsFixed(1) : value.toStringAsFixed(0);
    final displayTarget = isWater
        ? (target / 1000).toStringAsFixed(0)
        : target.toStringAsFixed(0);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(label,
                style: Theme.of(context)
                    .textTheme
                    .bodyMedium
                    ?.copyWith(fontWeight: FontWeight.bold)),
            Text('$displayValue / $displayTarget $unit',
                style: Theme.of(context).textTheme.bodySmall),
          ],
        ),
        const SizedBox(height: 4),
        LinearProgressIndicator(
          value: progress,
          backgroundColor: color.withOpacity(0.2),
          color: color,
          minHeight: 8,
          borderRadius: BorderRadius.circular(4),
        ),
      ],
    );
  }
}


===== Datei: D:\lightweight\lib\widgets\editable_set_row.dart =====

// lib/widgets/editable_set_row.dart

import 'package:flutter/material.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/widgets/set_type_chip.dart';
import 'package:lightweight/generated/app_localizations.dart';

class EditableSetRow extends StatefulWidget {
  const EditableSetRow({
    super.key,
    required this.setLog,
    required this.setIndex,
    required this.onWeightChanged,
    required this.onRepsChanged,
    required this.onDelete,
  });

  final SetLog setLog;
  final int setIndex;
  final ValueChanged<String> onWeightChanged;
  final ValueChanged<String> onRepsChanged;
  final VoidCallback onDelete;

  @override
  State<EditableSetRow> createState() => _EditableSetRowState();
}

class _EditableSetRowState extends State<EditableSetRow> {
  late final TextEditingController _weightController;
  late final TextEditingController _repsController;

  @override
  void initState() {
    super.initState();
    _weightController = TextEditingController(
        text:
            widget.setLog.weightKg?.toStringAsFixed(2).replaceAll('.00', '') ??
                '');
    _repsController =
        TextEditingController(text: widget.setLog.reps?.toString() ?? '');

    // Melde Änderungen an den Parent-Screen
    _weightController.addListener(() {
      widget.onWeightChanged(_weightController.text);
    });
    _repsController.addListener(() {
      widget.onRepsChanged(_repsController.text);
    });
  }

  @override
  void dispose() {
    _weightController.dispose();
    _repsController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          SetTypeChip(
              setType: widget.setLog.setType, setIndex: widget.setIndex),
          const SizedBox(width: 16),
          Expanded(
            child: TextFormField(
              controller: _weightController,
              decoration:
                  InputDecoration(labelText: l10n.kgLabel, isDense: true),
              keyboardType:
                  const TextInputType.numberWithOptions(decimal: true),
              validator: (value) => (value == null ||
                      value.trim().isEmpty ||
                      double.tryParse(value.replaceAll(',', '.')) == null)
                  ? "!"
                  : null,
            ),
          ),
          const SizedBox(width: 8),
          const Text("x"),
          const SizedBox(width: 8),
          Expanded(
            child: TextFormField(
              controller: _repsController,
              decoration:
                  InputDecoration(labelText: l10n.repsLabel, isDense: true),
              keyboardType: TextInputType.number,
              validator: (value) => (value == null ||
                      value.trim().isEmpty ||
                      int.tryParse(value) == null)
                  ? "!"
                  : null,
            ),
          ),
          IconButton(
            icon: const Icon(Icons.delete_outline, color: Colors.redAccent),
            tooltip: l10n.delete,
            onPressed: widget.onDelete,
          ),
        ],
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\widgets\glass_fab.dart =====

import 'dart:ui';
import 'package:flutter/material.dart';

class GlassFab extends StatefulWidget {
  final VoidCallback onPressed;
  final IconData icon;
  final String? label; // optionaler Text

  const GlassFab({
    super.key,
    required this.onPressed,
    this.icon = Icons.add,
    this.label,
  });

  @override
  State<GlassFab> createState() => _GlassFabState();
}

class _GlassFabState extends State<GlassFab>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 150),
      lowerBound: 0.0,
      upperBound: 0.1,
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _onTapDown(TapDownDetails details) => _controller.forward();
  void _onTapUp(TapUpDetails details) {
    _controller.reverse();
    widget.onPressed();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTapDown: _onTapDown,
      onTapUp: _onTapUp,
      onTapCancel: () => _controller.reverse(),
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, child) {
          final scale = 1 - _controller.value;
          return Transform.scale(
            scale: scale,
            child: child,
          );
        },
        child: ClipRRect(
          borderRadius: BorderRadius.circular(20), // viereckiger
          child: BackdropFilter(
            filter: ImageFilter.blur(sigmaX: 12, sigmaY: 12),
            child: Container(
              width: 76, // doppelt so breit
              height: 76, // nur minimal höher
              decoration: BoxDecoration(
                color: Colors.white.withOpacity(0.15),
                borderRadius: BorderRadius.circular(20),
                border: Border.all(
                  color: Colors.white.withOpacity(0.3),
                  width: 1.5,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.3),
                    blurRadius: 12,
                    offset: const Offset(0, 6),
                  ),
                ],
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    widget.icon,
                    size: 30,
                    color: Colors.white,
                  ),
                  if (widget.label != null) ...[
                    const SizedBox(width: 8),
                    Text(
                      widget.label!,
                      style: const TextStyle(
                        color: Colors.white,
                        fontWeight: FontWeight.bold,
                        fontSize: 18,
                      ),
                    ),
                  ],
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\widgets\glass_menu.dart =====

import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:lightweight/util/design_constants.dart';

class GlassMenuItem {
  final IconData icon;
  final String label;
  final VoidCallback onTap;

  GlassMenuItem({required this.icon, required this.label, required this.onTap});
}

class GlassMenu extends StatefulWidget {
  final List<GlassMenuItem> items;
  final VoidCallback onDismiss;

  const GlassMenu({
    super.key,
    required this.items,
    required this.onDismiss,
  });

  @override
  State<GlassMenu> createState() => _GlassMenuState();
}

class _GlassMenuState extends State<GlassMenu>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 400),
    )..forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: widget.onDismiss,
      child: Scaffold(
        backgroundColor: Colors.black.withOpacity(0.4),
        body: Center(
          child: Wrap(
            spacing: 24,
            runSpacing: 24,
            children: List.generate(widget.items.length, (index) {
              final item = widget.items[index];
              final intervalStart = index * 0.1;
              final intervalEnd = intervalStart + 0.5;

              final animation = CurvedAnimation(
                parent: _controller,
                curve: Interval(intervalStart, intervalEnd,
                    curve: Curves.easeOutBack),
              );

              return ScaleTransition(
                scale: animation,
                child: FadeTransition(
                  opacity: animation,
                  child: GestureDetector(
                    onTap: () {
                      item.onTap();
                      widget.onDismiss();
                    },
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        _buildGlassIcon(item.icon),
                        SizedBox(height: DesignConstants.spacingM),
                        Text(
                          item.label,
                          style:
                              Theme.of(context).textTheme.titleLarge?.copyWith(
                                    color: Colors.white,
                                    fontWeight: FontWeight.bold,
                                  ),
                        ),
                      ],
                    ),
                  ),
                ),
              );
            }),
          ),
        ),
      ),
    );
  }

  Widget _buildGlassIcon(IconData icon) {
    return ClipRRect(
      borderRadius: BorderRadius.circular(20),
      child: BackdropFilter(
        filter: ImageFilter.blur(sigmaX: 12, sigmaY: 12),
        child: Container(
          width: 76,
          height: 76,
          decoration: BoxDecoration(
            color: Colors.white.withOpacity(0.15),
            borderRadius: BorderRadius.circular(20),
            border: Border.all(
              color: Colors.white.withOpacity(0.3),
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.3),
                blurRadius: 12,
                offset: const Offset(0, 6),
              ),
            ],
          ),
          child: Icon(icon, size: 34, color: Colors.white),
        ),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\widgets\keep_alive_page.dart =====

import 'package:flutter/widgets.dart';

class KeepAlivePage extends StatefulWidget {
  final Widget child;
  final Key? storageKey; // optional, falls du’s später brauchen willst

  const KeepAlivePage({super.key, required this.child, this.storageKey});

  @override
  State<KeepAlivePage> createState() => _KeepAlivePageState();
}

class _KeepAlivePageState extends State<KeepAlivePage>
    with AutomaticKeepAliveClientMixin<KeepAlivePage> {
  @override
  bool get wantKeepAlive => true;

  @override
  Widget build(BuildContext context) {
    super.build(context); // wichtig für KeepAlive!
    // Kein PageStorage() mehr -> kein bucket nötig.
    // Optional: mit KeyedSubtree den storageKey an den Subtree hängen
    return widget.storageKey == null
        ? widget.child
        : KeyedSubtree(key: widget.storageKey, child: widget.child);
  }
}


===== Datei: D:\lightweight\lib\widgets\measurement_chart_widget.dart =====

// lib/widgets/measurement_chart_widget.dart (Final & De-Materialisiert)

import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/models/chart_data_point.dart';
import 'package:intl/intl.dart'; // Für das Datumsformat im Chart
import 'package:lightweight/generated/app_localizations.dart';

class MeasurementChartWidget extends StatefulWidget {
  final String chartType;
  final DateTimeRange dateRange;
  final Color lineColor;
  final String unit;

  const MeasurementChartWidget({
    super.key,
    required this.chartType,
    required this.dateRange,
    required this.lineColor,
    required this.unit,
  });

  @override
  State<MeasurementChartWidget> createState() => _MeasurementChartWidgetState();
}

class _MeasurementChartWidgetState extends State<MeasurementChartWidget> {
  List<ChartDataPoint> _dataPoints = [];
  bool _isLoadingChart = true;
  late final l10n = AppLocalizations.of(context)!;

  @override
  void initState() {
    super.initState();
    _loadChartData();
  }

  @override
  void didUpdateWidget(covariant MeasurementChartWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Nur neu laden, wenn sich Typ oder Datumsbereich geändert hat
    if (oldWidget.chartType != widget.chartType ||
        oldWidget.dateRange != widget.dateRange) {
      _loadChartData();
    }
  }

  Future<void> _loadChartData() async {
    setState(() => _isLoadingChart = true);
    final data = await DatabaseHelper.instance
        .getChartDataForTypeAndRange(widget.chartType, widget.dateRange);
    if (mounted) {
      setState(() {
        _dataPoints = data;
        _isLoadingChart = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoadingChart) {
      return const SizedBox(
        height: 200, // Feste Höhe für den Chart-Bereich
        child: Center(child: CircularProgressIndicator()),
      );
    }
    if (_dataPoints.isEmpty) {
      return SizedBox(
        height: 200,
        child: Center(child: Text(l10n.chart_no_data_for_period)),
      );
    }

    // Chart-Daten normalisieren (Min/Max Werte für die Skalierung)
    final double minY =
        _dataPoints.map((p) => p.value).reduce((a, b) => a < b ? a : b) *
            0.95; // 5% Puffer
    final double maxY =
        _dataPoints.map((p) => p.value).reduce((a, b) => a > b ? a : b) * 1.05;

    // X-Achsen-Labels anpassen (nur Monat/Tag anzeigen)
    final List<FlSpot> spots = _dataPoints.asMap().entries.map((entry) {
      return FlSpot(entry.key.toDouble(), entry.value.value);
    }).toList();

    return SizedBox(
      height: 200, // Feste Höhe für den Chart
      child: LineChart(
        LineChartData(
          gridData: FlGridData(
            show: true,
            drawHorizontalLine: true,
            drawVerticalLine: true,
            horizontalInterval: (maxY - minY) / 5, // 5 horizontale Linien
            getDrawingHorizontalLine: (value) => FlLine(
              color: Theme.of(context)
                  .colorScheme
                  .onSurfaceVariant
                  .withOpacity(0.1),
              strokeWidth: 1,
            ),
            getDrawingVerticalLine: (value) => FlLine(
              color: Theme.of(context)
                  .colorScheme
                  .onSurfaceVariant
                  .withOpacity(0.1),
              strokeWidth: 1,
            ),
          ),
          titlesData: FlTitlesData(
            show: true,
            rightTitles:
                const AxisTitles(sideTitles: SideTitles(showTitles: false)),
            topTitles:
                const AxisTitles(sideTitles: SideTitles(showTitles: false)),
            bottomTitles: AxisTitles(
              sideTitles: SideTitles(
                showTitles: true,
                reservedSize: 30,
                getTitlesWidget: (value, meta) {
                  final index = value.toInt();
                  if (index >= 0 && index < _dataPoints.length) {
                    final date = _dataPoints[index].date;
                    // Zeige nur den ersten des Monats oder wenn es viele Datenpunkte gibt
                    if (index == 0 ||
                        date.day == 1 ||
                        _dataPoints.length > 10) {
                      return Padding(
                        padding: const EdgeInsets.only(top: 8.0),
                        child: Text(DateFormat.MMMd().format(date),
                            style: Theme.of(context).textTheme.bodySmall),
                      );
                    }
                  }
                  return const SizedBox.shrink();
                },
              ),
            ),
            leftTitles: AxisTitles(
              sideTitles: SideTitles(
                showTitles: true,
                reservedSize: 40,
                getTitlesWidget: (value, meta) {
                  return Text(value.toStringAsFixed(0),
                      style: Theme.of(context).textTheme.bodySmall);
                },
              ),
            ),
          ),
          borderData: FlBorderData(
            show: true,
            border: Border.all(
                color: Theme.of(context)
                    .colorScheme
                    .onSurfaceVariant
                    .withOpacity(0.1),
                width: 1),
          ),
          lineBarsData: [
            LineChartBarData(
              spots: spots,
              isCurved: true,
              gradient: LinearGradient(
                colors: [widget.lineColor.withOpacity(0.5), widget.lineColor],
                begin: Alignment.bottomCenter,
                end: Alignment.topCenter,
              ),
              barWidth: 3,
              isStrokeCapRound: true,
              dotData: FlDotData(
                show: _dataPoints.length <
                    10, // Nur Punkte anzeigen, wenn nicht zu viele Datenpunkte vorhanden sind
                getDotPainter: (spot, percent, bar, index) =>
                    FlDotCirclePainter(
                  radius: 3,
                  color: widget.lineColor,
                  strokeWidth: 1,
                  strokeColor: Colors.white,
                ),
              ),
              belowBarData: BarAreaData(
                show: true,
                gradient: LinearGradient(
                  colors: [
                    widget.lineColor.withOpacity(0.2),
                    widget.lineColor.withOpacity(0.0),
                  ],
                  begin: Alignment.bottomCenter,
                  end: Alignment.topCenter,
                ),
              ),
            ),
          ],
          minY: minY,
          maxY: maxY,
        ),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\widgets\nutrition_summary_widget.dart =====

// lib/widgets/nutrition_summary_widget.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';

class _NutrientSpec {
  final String label;
  final String unit;
  final double value;
  final double target;
  final Color color;

  _NutrientSpec({
    required this.label,
    required this.unit,
    required this.value,
    required this.target,
    required this.color,
  });
}

class NutritionSummaryWidget extends StatelessWidget {
  final DailyNutrition nutritionData;
  final bool isExpandedView;
  final AppLocalizations l10n;

  const NutritionSummaryWidget({
    super.key,
    required this.nutritionData,
    this.isExpandedView = false,
    required this.l10n,
  });

  @override
  Widget build(BuildContext context) {
    final specs = <String, _NutrientSpec>{
      'calories': _NutrientSpec(
          label: l10n.calories,
          unit: 'kcal',
          value: nutritionData.calories.toDouble(),
          target: nutritionData.targetCalories.toDouble(),
          color: Colors.orange),
      'water': _NutrientSpec(
          label: l10n.water,
          unit: 'ml',
          value: nutritionData.water.toDouble(),
          target: nutritionData.targetWater.toDouble(),
          color: Colors.blue),
      'protein': _NutrientSpec(
          label: l10n.protein,
          unit: 'g',
          value: nutritionData.protein.toDouble(),
          target: nutritionData.targetProtein.toDouble(),
          color: Colors.red.shade400),
      'carbs': _NutrientSpec(
          label: l10n.carbs,
          unit: 'g',
          value: nutritionData.carbs.toDouble(),
          target: nutritionData.targetCarbs.toDouble(),
          color: Colors.green.shade400),
      'fat': _NutrientSpec(
          label: l10n.fat,
          unit: 'g',
          value: nutritionData.fat.toDouble(),
          target: nutritionData.targetFat.toDouble(),
          color: Colors.purple.shade300),
      'sugar': _NutrientSpec(
          label: l10n.sugar,
          unit: 'g',
          value: nutritionData.sugar,
          target: nutritionData.targetSugar.toDouble(),
          color: Colors.pink.shade200),
      'fiber': _NutrientSpec(
          label: l10n.fiber,
          unit: 'g',
          value: nutritionData.fiber,
          target: nutritionData.targetFiber.toDouble(),
          color: Colors.brown.shade400),
      'salt': _NutrientSpec(
          label: l10n.salt,
          unit: 'g',
          value: nutritionData.salt,
          target: nutritionData.targetSalt.toDouble(),
          color: Colors.grey.shade500),
    };

    return SummaryCard(
      // KORREKTUR: internalPadding für diese spezifische Karte ist 12.0
      //internalPadding: const EdgeInsets.all(12.0),
      child: IntrinsicHeight(
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Expanded(
              flex: 3, // KORREKTUR 2: Flex-Wert erhöht, um mehr Platz zu geben
              child: Column(
                children: [
                  Expanded(child: _InfoBox(spec: specs['calories']!)),
                  SizedBox(height: DesignConstants.spacingS),
                  Expanded(child: _InfoBox(spec: specs['water']!)),
                ],
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              flex: 4, // KORREKTUR 2: Flex-Wert erhöht
              child: Column(
                children: [
                  Expanded(child: _InfoBox(spec: specs['protein']!)),
                  SizedBox(height: DesignConstants.spacingS),
                  Expanded(child: _InfoBox(spec: specs['carbs']!)),
                  SizedBox(height: DesignConstants.spacingS),
                  Expanded(child: _InfoBox(spec: specs['fat']!)),
                ],
              ),
            ),
            if (isExpandedView) ...[
              const SizedBox(width: 8),
              Expanded(
                flex: 4, // KORREKTUR 2: Flex-Wert erhöht
                child: Column(
                  children: [
                    Expanded(child: _InfoBox(spec: specs['sugar']!)),
                    SizedBox(height: DesignConstants.spacingS),
                    Expanded(child: _InfoBox(spec: specs['fiber']!)),
                    SizedBox(height: DesignConstants.spacingS),
                    Expanded(child: _InfoBox(spec: specs['salt']!)),
                  ],
                ),
              ),
            ]
          ],
        ),
      ),
    );
  }
}

class _InfoBox extends StatelessWidget {
  final _NutrientSpec spec;
  const _InfoBox({required this.spec});

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final hasTarget = spec.target > 0;
    final rawProgress = hasTarget ? (spec.value / spec.target) : 0.0;
    final progress = rawProgress.clamp(0.0, 1.0);

    return Container(
      decoration: BoxDecoration(
        color: colorScheme.surface.withOpacity(0.5),
        borderRadius: BorderRadius.circular(9),
        // KORREKTUR: Schatten für _InfoBox entfernt
        // boxShadow: [ ... ], // Diese Zeilen können entfernt oder auskommentiert werden
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(9),
        child: Stack(
          fit: StackFit.expand,
          children: [
            Container(color: colorScheme.onSurface.withOpacity(0.12)),
            Align(
              alignment: Alignment.centerLeft,
              child: TweenAnimationBuilder<double>(
                tween: Tween(begin: 0, end: progress),
                duration: const Duration(milliseconds: 350),
                curve: Curves.easeOutCubic,
                builder: (context, p, child) =>
                    FractionallySizedBox(widthFactor: p, child: child),
                child: Container(color: spec.color),
              ),
            ),
            Padding(
              padding:
                  const EdgeInsets.symmetric(horizontal: 10.0, vertical: 4.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  FittedBox(
                    fit: BoxFit.scaleDown,
                    child: Text(
                      spec.label,
                      maxLines: 1,
                      style: TextStyle(
                          color: colorScheme.onSurface,
                          fontSize: 16,
                          fontWeight: FontWeight.bold),
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    hasTarget
                        ? '${spec.value.toStringAsFixed(1)} / ${spec.target.toStringAsFixed(0)} ${spec.unit}'
                        : '${spec.value.toStringAsFixed(1)} ${spec.unit}',
                    style: TextStyle(
                      color: colorScheme.onSurface.withOpacity(0.8),
                      fontSize: 14,
                      // KORREKTUR: Schatten für Text in _InfoBox entfernt
                      // shadows: [Shadow(blurRadius: 1.0, color: colorScheme.surface.withOpacity(0.7), offset: const Offset(1.0, 1.0))],
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\widgets\off_attribution_widget.dart =====

// lib/widgets/off_attribution_widget.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:url_launcher/url_launcher.dart';

class OffAttributionWidget extends StatelessWidget {
  final TextStyle? textStyle;

  const OffAttributionWidget({super.key, this.textStyle});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    final currentTextStyle = textStyle ??
        theme.textTheme.bodySmall?.copyWith(color: Colors.grey[600]);

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(8.0),
        child: GestureDetector(
          // Macht den Text klickbar
          onTap: () async {
            final uri = Uri.parse("https://openfoodfacts.org/");
            try {
              if (await canLaunchUrl(uri)) {
                await launchUrl(uri);
              } else {
                throw 'Could not launch $uri';
              }
            } catch (e) {
              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                      content: Text(l10n.snackbar_could_not_open_open_link)),
                );
              }
            }
          },
          child: Text(
            l10n.openFoodFactsSource,
            style: currentTextStyle,
            textAlign: TextAlign.center,
          ),
        ),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\widgets\set_type_chip.dart =====

// lib/widgets/set_type_chip.dart

import 'package:flutter/material.dart';

class SetTypeChip extends StatelessWidget {
  final String setType;
  final int? setIndex; // Der tatsächliche Arbeits-Satz-Index (ohne Warmups)
  final bool isCompleted;
  final VoidCallback? onTap;

  const SetTypeChip({
    super.key,
    required this.setType,
    required this.setIndex,
    this.isCompleted = false,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final Map<String, dynamic> typeInfo = {
      'normal': {
        'char': setIndex.toString(),
        'color': Theme.of(context).colorScheme.primary
      },
      'warmup': {'char': 'W', 'color': Colors.orange.shade700},
      'failure': {'char': 'F', 'color': Colors.red.shade700},
      'dropset': {'char': 'D', 'color': Colors.blue.shade700},
    };
    final type = typeInfo[setType] ?? typeInfo['normal']!;

    return InkWell(
      onTap: isCompleted ? null : onTap,
      borderRadius: BorderRadius.circular(14),
      child: CircleAvatar(
        radius: 14,
        backgroundColor: isCompleted ? Colors.grey[300] : type['color'],
        child: Text(
          type['char'],
          style: TextStyle(
            color: isCompleted ? Colors.grey[700] : Colors.white,
            fontWeight: FontWeight.bold,
            fontSize: 12,
          ),
        ),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\widgets\shadow_container.dart =====

// lib/widgets/shadow_container.dart

import 'package:flutter/material.dart';

class ShadowContainer extends StatelessWidget {
  final Widget child;
  final BorderRadiusGeometry borderRadius;
  final List<BoxShadow>? boxShadow;
  final EdgeInsetsGeometry? margin; // Optionaler externer Margin

  const ShadowContainer({
    super.key,
    required this.child,
    this.borderRadius = const BorderRadius.all(Radius.circular(16.0)),
    this.boxShadow,
    this.margin,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: margin,
      decoration: BoxDecoration(
        borderRadius: borderRadius,
        boxShadow: boxShadow ??
            [
              // Standard-Schatten, wenn keiner angegeben ist
              BoxShadow(
                color: Colors.black.withOpacity(0.08),
                blurRadius: 15,
                spreadRadius: 0,
                offset: const Offset(0, 8),
              ),
            ],
      ),
      child: ClipRRect(
        // ClipRRect, um den Inhalt innerhalb der Ecken zu halten
        borderRadius: borderRadius,
        child: child,
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\widgets\summary_card.dart =====

import 'package:flutter/material.dart';

class SummaryCard extends StatelessWidget {
  final Widget child;
  final EdgeInsetsGeometry padding;

  const SummaryCard({
    super.key,
    required this.child,
    this.padding = const EdgeInsets.all(12.0),
  });

  @override
  Widget build(BuildContext context) {
    final brightness = Theme.of(context).brightness;

    final background = brightness == Brightness.dark
        ? const Color.fromARGB(255, 22, 22, 22) // tiefes Grau für Dark Mode
        : const Color.fromARGB(
            255, 253, 253, 253); // sehr helles Grau für Light Mode

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 6.0),
      padding: padding,
      decoration: BoxDecoration(
        color: background,
        borderRadius: BorderRadius.circular(20),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.25),
            blurRadius: 6,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: child,
    );
  }
}


===== Datei: D:\lightweight\lib\widgets\wger_attribution_widget.dart =====

// lib/widgets/wger_attribution_widget.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:url_launcher/url_launcher.dart';

class WgerAttributionWidget extends StatelessWidget {
  final TextStyle? textStyle;

  const WgerAttributionWidget({super.key, this.textStyle});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final currentTextStyle = textStyle ??
        theme.textTheme.bodySmall?.copyWith(color: Colors.grey[600]);

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(8.0),
        child: GestureDetector(
          // Macht den Text klickbar
          onTap: () async {
            final uri = Uri.parse("https://wger.de/"); // <-- Geänderte URL
            try {
              if (await canLaunchUrl(uri)) {
                await launchUrl(uri);
              } else {
                throw 'Could not launch $uri';
              }
            } catch (e) {
              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                      content: Text(l10n.snackbar_could_not_open_open_link)),
                );
              }
            }
          },
          child: Text(
            l10n.exerciseDataAttribution, // <-- Geänderter Text
            style: currentTextStyle,
            textAlign: TextAlign.center,
          ),
        ),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\widgets\workout_card.dart =====

// lib/widgets/workout_card.dart
import 'package:flutter/material.dart';

class WorkoutCard extends StatelessWidget {
  /// Child content padding (now zero to span full width).
  final EdgeInsetsGeometry padding;

  /// Outer margin (now zero to span full width).
  final EdgeInsetsGeometry margin;

  final dynamic child;

  const WorkoutCard({
    Key? key,
    required this.child,
    this.padding = EdgeInsets.zero,
    this.margin = EdgeInsets.zero,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    // transparent background for the card itself
    const background = Colors.transparent;

    return Container(
      margin: margin,
      padding: padding,
      decoration: BoxDecoration(
        color: background,
        borderRadius: BorderRadius.circular(20),
        // remove default shadow if you want full transparency
        boxShadow: [
          // optional: keep or remove shadow
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 4,
            offset: const Offset(0, 1),
          ),
        ],
      ),
      child: _AlternatingBackground(
        child: child,
      ),
    );
  }
}

/// Wraps the child and applies alternating grey backgrounds to its direct row children.
class _AlternatingBackground extends StatelessWidget {
  final Widget child;
  const _AlternatingBackground({required this.child});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: List<Widget>.from(
        (child as Column).children.asMap().entries.map((entry) {
          final idx = entry.key;
          final row = entry.value;
          final color = idx.isOdd
              ? Colors.grey.shade900.withOpacity(0.1)
              : Colors.grey.shade900.withOpacity(0.05);
          return Container(
            color: color,
            child: row,
          );
        }),
      ),
    );
  }
}


===== Datei: D:\lightweight\lib\widgets\workout_summary_bar.dart =====

// lib/widgets/workout_summary_bar.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/time_util.dart'; // Wir erstellen diese Hilfsdatei gleich

class WorkoutSummaryBar extends StatelessWidget {
  const WorkoutSummaryBar({
    super.key,
    this.duration,
    required this.volume,
    required this.sets,
  });

  // 'duration' ist optional, da es live aktualisiert wird
  // und nicht immer als fester Wert übergeben wird.
  final Duration? duration;
  final double volume;
  final int sets;

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(
        context)!; // Annahme: AppLocalizations ist verfügbar

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            // --- Dauer ---
            _buildStatColumn(
              context: context,
              label: l10n.durationLabel,
              // Nutzt unsere neue Hilfsfunktion zur Formatierung
              value: formatDuration(duration ?? Duration.zero),
              highlight: true, // Hebt die Dauer hervor
            ),
            // --- Volumen ---
            _buildStatColumn(
              context: context,
              label: l10n.volumeLabel,
              value: "${volume.toStringAsFixed(0)} kg",
            ),

            // --- Sätze ---
            _buildStatColumn(
              context: context,
              label: l10n.setsLabel,
              value: sets.toString(),
            ),
          ],
        ),
      ),
    );
  }

  /// Ein kleines Helfer-Widget für eine einzelne Statistik-Spalte.
  Widget _buildStatColumn({
    required BuildContext context,
    required String label,
    required String value,
    bool highlight = false,
  }) {
    final theme = Theme.of(context);
    final valueStyle = theme.textTheme.titleMedium?.copyWith(
      fontWeight: highlight ? FontWeight.bold : FontWeight.normal,
      color: highlight
          ? theme.colorScheme.primary
          : theme.textTheme.titleMedium?.color,
    );

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          label.toUpperCase(),
          style: theme.textTheme.labelSmall?.copyWith(
            color: Colors.grey[600],
            letterSpacing: 0.8,
          ),
        ),
        const SizedBox(height: 4),
        Text(value, style: valueStyle),
      ],
    );
  }
}

