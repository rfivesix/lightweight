
===== Datei: /Users/richard/Projects/Lightweight/lightweight/test/widget_test.dart =====

// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:lightweight/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/main.dart =====

// lib/main.dart
// VOLLSTÄNDIGER CODE (MIT PREDICTIVE BACK)

import 'package:dynamic_color/dynamic_color.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:lightweight/data/backup_manager.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/main_screen.dart';
import 'package:lightweight/services/profile_service.dart';
import 'package:lightweight/services/workout_session_manager.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/screens/onboarding_screen.dart';
import 'package:lightweight/services/theme_service.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Führe das Auto-Backup im Hintergrund aus, ohne darauf zu warten.
  // Fehler werden innerhalb des Managers abgefangen und geloggt.
  BackupManager().runAutoBackupIfDue();

  // 1. Erstelle die Manager-Instanz
  final workoutSessionManager = WorkoutSessionManager();

  // 2. Rufe die neue, gekapselte Wiederherstellungsmethode auf
  // Annahme: Diese Methode existiert jetzt in deinem WorkoutSessionManager
  await workoutSessionManager.tryRestoreSession();

  final themeService = ThemeService(); // Create an instance
  // 3. Starte die App mit der (möglicherweise wiederhergestellten) Instanz
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider.value(value: workoutSessionManager),
        ChangeNotifierProvider(
          create: (context) {
            final profileService = ProfileService();
            profileService.initialize();
            return profileService;
          },
        ),
        ChangeNotifierProvider.value(
          value: themeService,
        ), // Provide the ThemeService
      ],
      child: const MyApp(),
    ),
  );
}

Future<bool> _hasSeenOnboarding() async {
  final prefs = await SharedPreferences.getInstance();
  return prefs.getBool('hasSeenOnboarding') == true;
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(statusBarColor: Colors.transparent),
    );

    const cardDark = Color(0xFF171717);
    const cardLight = Color(0xFFF3F3F3);

    // HINWEIS: Provider.of<ThemeService>(context) wurde von hier entfernt.

    return DynamicColorBuilder(
      builder: (ColorScheme? lightDynamic, ColorScheme? darkDynamic) {
        // === Akzent/Seed aus Dynamic Color (Android 12+) oder Fallback ===
        final Color lightSeed = lightDynamic?.primary ?? Colors.blue;
        final Color darkSeed = darkDynamic?.primary ?? lightSeed;

        // --- Light Scheme aus Seed, aber ohne Material You UI ---
        final lightScheme = ColorScheme.fromSeed(
          seedColor: lightSeed,
          brightness: Brightness.light,
        ).copyWith(surface: Colors.white);

        // --- Dark Scheme aus Seed + OLED-Schwarz ---
        final seededDark = ColorScheme.fromSeed(
          seedColor: darkSeed,
          brightness: Brightness.dark,
        );
        final darkScheme = seededDark.copyWith(
          surface: Colors.black,
          surfaceDim: Colors.black,
          surfaceBright: Colors.black,
          surfaceContainerLowest: Colors.black,
          surfaceContainerLow: Colors.black,
          surfaceContainer: Colors.black,
          surfaceContainerHigh: Colors.black,
          surfaceContainerHighest: Colors.black,
        );

        // --- Light Theme (Material2, aber mit ColorScheme aus Seed) ---
        final baseLightTheme = ThemeData(
          useMaterial3: false, // KEIN Material You
          colorScheme: lightScheme,
          primaryColor: lightScheme.primary, // Akzent in M2-Welten
          scaffoldBackgroundColor: Colors.white,
          canvasColor: Colors.white,
          cardColor: cardLight,
          // NEU / ANGEPASST:
          splashFactory: NoSplash.splashFactory,
          splashColor: Colors.transparent,
          highlightColor: Colors.transparent,
          hoverColor: Colors.transparent,

          pageTransitionsTheme: const PageTransitionsTheme(
            builders: {
              // ÄNDERUNG: Predictive Back für Android aktiviert
              TargetPlatform.android: PredictiveBackPageTransitionsBuilder(),
              TargetPlatform.iOS: CupertinoPageTransitionsBuilder(),
              TargetPlatform.macOS: CupertinoPageTransitionsBuilder(),
              TargetPlatform.windows: ZoomPageTransitionsBuilder(),
              TargetPlatform.linux: ZoomPageTransitionsBuilder(),
            },
          ),

          inputDecorationTheme: InputDecorationTheme(
            filled: true,
            fillColor: const Color(0xFFF3F3F3),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide.none,
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(color: lightScheme.primary, width: 2),
            ),
            contentPadding: const EdgeInsets.symmetric(
              horizontal: 12,
              vertical: 12,
            ),
          ),

          bottomSheetTheme: const BottomSheetThemeData(
            backgroundColor: cardLight,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
            ),
            elevation: 0,
          ),

          snackBarTheme: SnackBarThemeData(
            backgroundColor: lightScheme.primary,
            contentTextStyle: TextStyle(
              color: lightScheme.onPrimary,
              fontWeight: FontWeight.w600,
            ),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12),
            ),
          ),

          dividerTheme: DividerThemeData(
            color: Colors.black.withOpacity(0.08),
            thickness: 1,
            space: 24,
          ),

          textTheme: ThemeData.light().textTheme.apply(
                fontFamily: 'Inter', // Das ist weiterhin korrekt
                bodyColor: Colors.black87,
                displayColor: Colors.black87,
              ),
          // Stellen sicher, dass Akzent sichtbar "lebt"
          elevatedButtonTheme: ElevatedButtonThemeData(
            style: ElevatedButton.styleFrom(
              backgroundColor: lightScheme.primary,
              foregroundColor: lightScheme.onPrimary,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
          ),
          floatingActionButtonTheme: FloatingActionButtonThemeData(
            backgroundColor: lightScheme.primary,
            foregroundColor: lightScheme.onPrimary,
          ),
          //toggleableActiveColor: lightScheme.primary,
          progressIndicatorTheme: ProgressIndicatorThemeData(
            color: lightScheme.primary,
          ),
          textSelectionTheme: TextSelectionThemeData(
            cursorColor: lightScheme.primary,
            selectionColor: lightScheme.primary.withOpacity(0.25),
            selectionHandleColor: lightScheme.primary,
          ),
          checkboxTheme: CheckboxThemeData(
            fillColor: WidgetStateProperty.all(lightScheme.primary),
          ),
          radioTheme: RadioThemeData(
            fillColor: WidgetStateProperty.all(lightScheme.primary),
          ),
          switchTheme: SwitchThemeData(
            thumbColor: WidgetStateProperty.resolveWith(
              (s) => lightScheme.primary,
            ),
            trackColor: WidgetStateProperty.resolveWith(
              (s) => lightScheme.primary.withOpacity(0.5),
            ),
          ),
          dialogTheme: DialogThemeData(
            backgroundColor: cardLight,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(20),
            ),
          ),
        );

        // --- Dark Theme (Material2, OLED, Akzent aus Seed) ---
        final baseDarkTheme = ThemeData(
          useMaterial3: false, // KEIN Material You
          colorScheme: darkScheme,
          primaryColor: darkScheme.primary, // Akzent in M2-Welten
          scaffoldBackgroundColor: Colors.black,
          canvasColor: Colors.black,
          cardColor: cardDark,
          // NEU / ANGEPASST:
          splashFactory: NoSplash.splashFactory,
          splashColor: Colors.transparent,
          highlightColor: Colors.transparent,
          hoverColor: Colors.transparent,

          pageTransitionsTheme: const PageTransitionsTheme(
            builders: {
              // ÄNDERUNG: Predictive Back für Android aktiviert
              TargetPlatform.android: PredictiveBackPageTransitionsBuilder(),
              TargetPlatform.iOS: CupertinoPageTransitionsBuilder(),
              TargetPlatform.macOS: CupertinoPageTransitionsBuilder(),
              TargetPlatform.windows: ZoomPageTransitionsBuilder(),
              TargetPlatform.linux: ZoomPageTransitionsBuilder(),
            },
          ),

          inputDecorationTheme: InputDecorationTheme(
            filled: true,
            fillColor: const Color(0xFF1C1C1C),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide.none,
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(color: darkScheme.primary, width: 2),
            ),
            contentPadding: const EdgeInsets.symmetric(
              horizontal: 12,
              vertical: 12,
            ),
          ),

          bottomSheetTheme: const BottomSheetThemeData(
            backgroundColor: cardDark,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
            ),
            elevation: 0,
          ),

          snackBarTheme: SnackBarThemeData(
            backgroundColor: darkScheme.primary,
            contentTextStyle: TextStyle(
              color: darkScheme.onPrimary,
              fontWeight: FontWeight.w600,
            ),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12),
            ),
          ),

          dividerTheme: DividerThemeData(
            color: Colors.white.withOpacity(0.08),
            thickness: 1,
            space: 24,
          ),

          textTheme: ThemeData.dark().textTheme.apply(
                fontFamily: 'Inter', // Das ist weiterhin korrekt
                bodyColor: Colors.white,
                displayColor: Colors.white,
              ),
          elevatedButtonTheme: ElevatedButtonThemeData(
            style: ElevatedButton.styleFrom(
              backgroundColor: darkScheme.primary,
              foregroundColor: darkScheme.onPrimary,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
          ),
          floatingActionButtonTheme: FloatingActionButtonThemeData(
            backgroundColor: darkScheme.primary,
            foregroundColor: darkScheme.onPrimary,
          ),
          //toggleableActiveColor: darkScheme.primary,
          progressIndicatorTheme: ProgressIndicatorThemeData(
            color: darkScheme.primary,
          ),
          textSelectionTheme: TextSelectionThemeData(
            cursorColor: darkScheme.primary,
            selectionColor: darkScheme.primary.withOpacity(0.35),
            selectionHandleColor: darkScheme.primary,
          ),
          checkboxTheme: CheckboxThemeData(
            fillColor: WidgetStateProperty.all(darkScheme.primary),
          ),
          radioTheme: RadioThemeData(
            fillColor: WidgetStateProperty.all(darkScheme.primary),
          ),
          switchTheme: SwitchThemeData(
            thumbColor: WidgetStateProperty.resolveWith(
              (s) => darkScheme.primary,
            ),
            trackColor: WidgetStateProperty.resolveWith(
              (s) => darkScheme.primary.withOpacity(0.5),
            ),
          ),
          dialogTheme: DialogThemeData(
            backgroundColor: cardDark,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(20),
            ),
          ),
        );
        // KORREKTUR HIER: Wir verwenden einen Consumer, um an den ThemeService zu kommen.
        return Consumer<ThemeService>(
          builder: (context, themeService, child) {
            return MaterialApp(
              debugShowCheckedModeBanner: false,
              scrollBehavior: NoGlowScrollBehavior(),
              onGenerateTitle: (context) =>
                  AppLocalizations.of(context)!.appTitle,
              localizationsDelegates: AppLocalizations.localizationsDelegates,
              supportedLocales: AppLocalizations.supportedLocales,
              title: "LightWeight",
              theme: baseLightTheme,
              darkTheme: baseDarkTheme,
              themeMode:
                  themeService.themeMode, // Jetzt funktioniert der Zugriff
              home: child, // Das home-Widget wird weitergereicht
            );
          },
          // Der FutureBuilder wird zum 'child' des Consumers, um nicht bei jeder
          // Theme-Änderung neu aufgebaut zu werden.
          child: FutureBuilder<bool>(
            future: _hasSeenOnboarding(),
            builder: (context, snapshot) {
              if (!snapshot.hasData) {
                return const Scaffold(
                  body: Center(child: CircularProgressIndicator()),
                );
              }
              final seen = snapshot.data ?? false;
              return seen ? const MainScreen() : const OnboardingScreen();
            },
          ),
        );
      },
    );
  }
}

class NoGlowScrollBehavior extends ScrollBehavior {
  @override
  Widget buildOverscrollIndicator(
    BuildContext context,
    Widget child,
    ScrollableDetails details,
  ) {
    // Keine Glow-Effekte
    return child;
  }

  @override
  ScrollPhysics getScrollPhysics(BuildContext context) {
    // iOS-Style: Bouncing
    return const BouncingScrollPhysics();
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/generated/app_localizations.dart =====

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart' as intl;

import 'app_localizations_de.dart';
import 'app_localizations_en.dart';

// ignore_for_file: type=lint

/// Callers can lookup localized strings with an instance of AppLocalizations
/// returned by `AppLocalizations.of(context)`.
///
/// Applications need to include `AppLocalizations.delegate()` in their app's
/// `localizationDelegates` list, and the locales they support in the app's
/// `supportedLocales` list. For example:
///
/// ```dart
/// import 'generated/app_localizations.dart';
///
/// return MaterialApp(
///   localizationsDelegates: AppLocalizations.localizationsDelegates,
///   supportedLocales: AppLocalizations.supportedLocales,
///   home: MyApplicationHome(),
/// );
/// ```
///
/// ## Update pubspec.yaml
///
/// Please make sure to update your pubspec.yaml to include the following
/// packages:
///
/// ```yaml
/// dependencies:
///   # Internationalization support.
///   flutter_localizations:
///     sdk: flutter
///   intl: any # Use the pinned version from flutter_localizations
///
///   # Rest of dependencies
/// ```
///
/// ## iOS Applications
///
/// iOS applications define key application metadata, including supported
/// locales, in an Info.plist file that is built into the application bundle.
/// To configure the locales supported by your app, you’ll need to edit this
/// file.
///
/// First, open your project’s ios/Runner.xcworkspace Xcode workspace file.
/// Then, in the Project Navigator, open the Info.plist file under the Runner
/// project’s Runner folder.
///
/// Next, select the Information Property List item, select Add Item from the
/// Editor menu, then select Localizations from the pop-up menu.
///
/// Select and expand the newly-created Localizations item then, for each
/// locale your application supports, add a new item and select the locale
/// you wish to add from the pop-up menu in the Value field. This list should
/// be consistent with the languages listed in the AppLocalizations.supportedLocales
/// property.
abstract class AppLocalizations {
  AppLocalizations(String locale)
      : localeName = intl.Intl.canonicalizedLocale(locale.toString());

  final String localeName;

  static AppLocalizations? of(BuildContext context) {
    return Localizations.of<AppLocalizations>(context, AppLocalizations);
  }

  static const LocalizationsDelegate<AppLocalizations> delegate =
      _AppLocalizationsDelegate();

  /// A list of this localizations delegate along with the default localizations
  /// delegates.
  ///
  /// Returns a list of localizations delegates containing this delegate along with
  /// GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate,
  /// and GlobalWidgetsLocalizations.delegate.
  ///
  /// Additional delegates can be added by appending to this list in
  /// MaterialApp. This list does not have to be used at all if a custom list
  /// of delegates is preferred or required.
  static const List<LocalizationsDelegate<dynamic>> localizationsDelegates =
      <LocalizationsDelegate<dynamic>>[
    delegate,
    GlobalMaterialLocalizations.delegate,
    GlobalCupertinoLocalizations.delegate,
    GlobalWidgetsLocalizations.delegate,
  ];

  /// A list of this localizations delegate's supported locales.
  static const List<Locale> supportedLocales = <Locale>[
    Locale('de'),
    Locale('en')
  ];

  /// No description provided for @appTitle.
  ///
  /// In en, this message translates to:
  /// **'Hypertrack'**
  String get appTitle;

  /// No description provided for @bannerText.
  ///
  /// In en, this message translates to:
  /// **'Recommendation / Current Workout'**
  String get bannerText;

  /// No description provided for @calories.
  ///
  /// In en, this message translates to:
  /// **'Calories'**
  String get calories;

  /// No description provided for @water.
  ///
  /// In en, this message translates to:
  /// **'Water'**
  String get water;

  /// No description provided for @protein.
  ///
  /// In en, this message translates to:
  /// **'Protein'**
  String get protein;

  /// No description provided for @carbs.
  ///
  /// In en, this message translates to:
  /// **'Carbs'**
  String get carbs;

  /// No description provided for @fat.
  ///
  /// In en, this message translates to:
  /// **'Fat'**
  String get fat;

  /// No description provided for @daily.
  ///
  /// In en, this message translates to:
  /// **'Daily'**
  String get daily;

  /// No description provided for @today.
  ///
  /// In en, this message translates to:
  /// **'Today'**
  String get today;

  /// No description provided for @workoutSection.
  ///
  /// In en, this message translates to:
  /// **'Workout section - not yet implemented'**
  String get workoutSection;

  /// No description provided for @addMenuTitle.
  ///
  /// In en, this message translates to:
  /// **'What do you want to add?'**
  String get addMenuTitle;

  /// No description provided for @addFoodOption.
  ///
  /// In en, this message translates to:
  /// **'add Food'**
  String get addFoodOption;

  /// No description provided for @addLiquidOption.
  ///
  /// In en, this message translates to:
  /// **'add Liquid'**
  String get addLiquidOption;

  /// No description provided for @searchHintText.
  ///
  /// In en, this message translates to:
  /// **'Search...'**
  String get searchHintText;

  /// No description provided for @mealtypeBreakfast.
  ///
  /// In en, this message translates to:
  /// **'Breakfast'**
  String get mealtypeBreakfast;

  /// No description provided for @mealtypeLunch.
  ///
  /// In en, this message translates to:
  /// **'Lunch'**
  String get mealtypeLunch;

  /// No description provided for @mealtypeDinner.
  ///
  /// In en, this message translates to:
  /// **'Dinner'**
  String get mealtypeDinner;

  /// No description provided for @mealtypeSnack.
  ///
  /// In en, this message translates to:
  /// **'Snack'**
  String get mealtypeSnack;

  /// No description provided for @waterHeader.
  ///
  /// In en, this message translates to:
  /// **'Water & Drinks'**
  String get waterHeader;

  /// No description provided for @openFoodFactsSource.
  ///
  /// In en, this message translates to:
  /// **'Data from Open Food Facts'**
  String get openFoodFactsSource;

  /// No description provided for @tabRecent.
  ///
  /// In en, this message translates to:
  /// **'Recent'**
  String get tabRecent;

  /// No description provided for @tabSearch.
  ///
  /// In en, this message translates to:
  /// **'Search'**
  String get tabSearch;

  /// No description provided for @tabFavorites.
  ///
  /// In en, this message translates to:
  /// **'Favorites'**
  String get tabFavorites;

  /// No description provided for @fabCreateOwnFood.
  ///
  /// In en, this message translates to:
  /// **'Custom Food'**
  String get fabCreateOwnFood;

  /// No description provided for @recentEmptyState.
  ///
  /// In en, this message translates to:
  /// **'Your recently used food items\nwill appear here.'**
  String get recentEmptyState;

  /// No description provided for @favoritesEmptyState.
  ///
  /// In en, this message translates to:
  /// **'You don\'t have any favorites yet.\nMark a food with the heart icon to see it here.'**
  String get favoritesEmptyState;

  /// No description provided for @searchInitialHint.
  ///
  /// In en, this message translates to:
  /// **'Please enter a search term.'**
  String get searchInitialHint;

  /// No description provided for @searchNoResults.
  ///
  /// In en, this message translates to:
  /// **'No results found.'**
  String get searchNoResults;

  /// No description provided for @createFoodScreenTitle.
  ///
  /// In en, this message translates to:
  /// **'Create Custom Food'**
  String get createFoodScreenTitle;

  /// No description provided for @formFieldName.
  ///
  /// In en, this message translates to:
  /// **'Name of the food'**
  String get formFieldName;

  /// No description provided for @formFieldBrand.
  ///
  /// In en, this message translates to:
  /// **'Brand (optional)'**
  String get formFieldBrand;

  /// No description provided for @formSectionMainNutrients.
  ///
  /// In en, this message translates to:
  /// **'Main Nutrients (per 100g)'**
  String get formSectionMainNutrients;

  /// No description provided for @formFieldCalories.
  ///
  /// In en, this message translates to:
  /// **'Calories (kcal)'**
  String get formFieldCalories;

  /// No description provided for @formFieldProtein.
  ///
  /// In en, this message translates to:
  /// **'Protein (g)'**
  String get formFieldProtein;

  /// No description provided for @formFieldCarbs.
  ///
  /// In en, this message translates to:
  /// **'Carbohydrates (g)'**
  String get formFieldCarbs;

  /// No description provided for @formFieldFat.
  ///
  /// In en, this message translates to:
  /// **'Fat (g)'**
  String get formFieldFat;

  /// No description provided for @formSectionOptionalNutrients.
  ///
  /// In en, this message translates to:
  /// **'Additional Nutrients (optional, per 100g)'**
  String get formSectionOptionalNutrients;

  /// No description provided for @formFieldSugar.
  ///
  /// In en, this message translates to:
  /// **'Of which sugars (g)'**
  String get formFieldSugar;

  /// No description provided for @formFieldFiber.
  ///
  /// In en, this message translates to:
  /// **'Fiber (g)'**
  String get formFieldFiber;

  /// No description provided for @formFieldKj.
  ///
  /// In en, this message translates to:
  /// **'Kilojoules (kJ)'**
  String get formFieldKj;

  /// No description provided for @formFieldSalt.
  ///
  /// In en, this message translates to:
  /// **'Salt (g)'**
  String get formFieldSalt;

  /// No description provided for @formFieldSodium.
  ///
  /// In en, this message translates to:
  /// **'Sodium (mg)'**
  String get formFieldSodium;

  /// No description provided for @formFieldCalcium.
  ///
  /// In en, this message translates to:
  /// **'Calcium (mg)'**
  String get formFieldCalcium;

  /// No description provided for @buttonSave.
  ///
  /// In en, this message translates to:
  /// **'Save'**
  String get buttonSave;

  /// No description provided for @validatorPleaseEnterName.
  ///
  /// In en, this message translates to:
  /// **'Please enter a name.'**
  String get validatorPleaseEnterName;

  /// No description provided for @validatorPleaseEnterNumber.
  ///
  /// In en, this message translates to:
  /// **'Please enter a valid number.'**
  String get validatorPleaseEnterNumber;

  /// No description provided for @snackbarSaveSuccess.
  ///
  /// In en, this message translates to:
  /// **'{foodName} was saved successfully.'**
  String snackbarSaveSuccess(String foodName);

  /// No description provided for @foodDetailSegmentPortion.
  ///
  /// In en, this message translates to:
  /// **'Portion'**
  String get foodDetailSegmentPortion;

  /// No description provided for @foodDetailSegment100g.
  ///
  /// In en, this message translates to:
  /// **'100g'**
  String get foodDetailSegment100g;

  /// No description provided for @sugar.
  ///
  /// In en, this message translates to:
  /// **'Sugar'**
  String get sugar;

  /// No description provided for @fiber.
  ///
  /// In en, this message translates to:
  /// **'Fiber'**
  String get fiber;

  /// No description provided for @salt.
  ///
  /// In en, this message translates to:
  /// **'Salt'**
  String get salt;

  /// No description provided for @explorerScreenTitle.
  ///
  /// In en, this message translates to:
  /// **'Food Explorer'**
  String get explorerScreenTitle;

  /// No description provided for @nutritionScreenTitle.
  ///
  /// In en, this message translates to:
  /// **'Nutrition Analysis'**
  String get nutritionScreenTitle;

  /// No description provided for @entriesForDateRangeLabel.
  ///
  /// In en, this message translates to:
  /// **'Entries for'**
  String get entriesForDateRangeLabel;

  /// No description provided for @noEntriesForPeriod.
  ///
  /// In en, this message translates to:
  /// **'No entries for this period yet.'**
  String get noEntriesForPeriod;

  /// No description provided for @waterEntryTitle.
  ///
  /// In en, this message translates to:
  /// **'Water'**
  String get waterEntryTitle;

  /// No description provided for @profileScreenTitle.
  ///
  /// In en, this message translates to:
  /// **'Profile'**
  String get profileScreenTitle;

  /// No description provided for @profileDailyGoals.
  ///
  /// In en, this message translates to:
  /// **'Daily Goals'**
  String get profileDailyGoals;

  /// No description provided for @profileDailyGoalsCL.
  ///
  /// In en, this message translates to:
  /// **'DAILY GOALS'**
  String get profileDailyGoalsCL;

  /// No description provided for @snackbarGoalsSaved.
  ///
  /// In en, this message translates to:
  /// **'Goals saved successfully!'**
  String get snackbarGoalsSaved;

  /// No description provided for @measurementsScreenTitle.
  ///
  /// In en, this message translates to:
  /// **'Measurements'**
  String get measurementsScreenTitle;

  /// No description provided for @measurementsEmptyState.
  ///
  /// In en, this message translates to:
  /// **'No measurements recorded yet.\nStart with the \'+\' button.'**
  String get measurementsEmptyState;

  /// No description provided for @addMeasurementDialogTitle.
  ///
  /// In en, this message translates to:
  /// **'Add New Measurement'**
  String get addMeasurementDialogTitle;

  /// No description provided for @formFieldMeasurementType.
  ///
  /// In en, this message translates to:
  /// **'Type of Measurement'**
  String get formFieldMeasurementType;

  /// No description provided for @formFieldMeasurementValue.
  ///
  /// In en, this message translates to:
  /// **'Value ({unit})'**
  String formFieldMeasurementValue(Object unit);

  /// No description provided for @validatorPleaseEnterValue.
  ///
  /// In en, this message translates to:
  /// **'Please enter a value'**
  String get validatorPleaseEnterValue;

  /// No description provided for @measurementWeight.
  ///
  /// In en, this message translates to:
  /// **'Body Weight'**
  String get measurementWeight;

  /// No description provided for @measurementFatPercent.
  ///
  /// In en, this message translates to:
  /// **'Body Fat'**
  String get measurementFatPercent;

  /// No description provided for @measurementNeck.
  ///
  /// In en, this message translates to:
  /// **'Neck'**
  String get measurementNeck;

  /// No description provided for @measurementShoulder.
  ///
  /// In en, this message translates to:
  /// **'Shoulder'**
  String get measurementShoulder;

  /// No description provided for @measurementChest.
  ///
  /// In en, this message translates to:
  /// **'Chest'**
  String get measurementChest;

  /// No description provided for @measurementLeftBicep.
  ///
  /// In en, this message translates to:
  /// **'Left Bicep'**
  String get measurementLeftBicep;

  /// No description provided for @measurementRightBicep.
  ///
  /// In en, this message translates to:
  /// **'Right Bicep'**
  String get measurementRightBicep;

  /// No description provided for @measurementLeftForearm.
  ///
  /// In en, this message translates to:
  /// **'Left Forearm'**
  String get measurementLeftForearm;

  /// No description provided for @measurementRightForearm.
  ///
  /// In en, this message translates to:
  /// **'Right Forearm'**
  String get measurementRightForearm;

  /// No description provided for @measurementAbdomen.
  ///
  /// In en, this message translates to:
  /// **'Abdomen'**
  String get measurementAbdomen;

  /// No description provided for @measurementWaist.
  ///
  /// In en, this message translates to:
  /// **'Waist'**
  String get measurementWaist;

  /// No description provided for @measurementHips.
  ///
  /// In en, this message translates to:
  /// **'Hips'**
  String get measurementHips;

  /// No description provided for @measurementLeftThigh.
  ///
  /// In en, this message translates to:
  /// **'Left Thigh'**
  String get measurementLeftThigh;

  /// No description provided for @measurementRightThigh.
  ///
  /// In en, this message translates to:
  /// **'Right Thigh'**
  String get measurementRightThigh;

  /// No description provided for @measurementLeftCalf.
  ///
  /// In en, this message translates to:
  /// **'Left Calf'**
  String get measurementLeftCalf;

  /// No description provided for @measurementRightCalf.
  ///
  /// In en, this message translates to:
  /// **'Right Calf'**
  String get measurementRightCalf;

  /// No description provided for @drawerMenuTitle.
  ///
  /// In en, this message translates to:
  /// **'Hypertrack Menu'**
  String get drawerMenuTitle;

  /// No description provided for @drawerDashboard.
  ///
  /// In en, this message translates to:
  /// **'Dashboard'**
  String get drawerDashboard;

  /// No description provided for @drawerFoodExplorer.
  ///
  /// In en, this message translates to:
  /// **'Food Explorer'**
  String get drawerFoodExplorer;

  /// No description provided for @drawerDataManagement.
  ///
  /// In en, this message translates to:
  /// **'Data Backup'**
  String get drawerDataManagement;

  /// No description provided for @drawerMeasurements.
  ///
  /// In en, this message translates to:
  /// **'Measurements'**
  String get drawerMeasurements;

  /// No description provided for @dataManagementTitle.
  ///
  /// In en, this message translates to:
  /// **'Data Backup'**
  String get dataManagementTitle;

  /// No description provided for @exportCardTitle.
  ///
  /// In en, this message translates to:
  /// **'Export Data'**
  String get exportCardTitle;

  /// No description provided for @exportCardDescription.
  ///
  /// In en, this message translates to:
  /// **'Saves all your journal entries, favorites, and custom foods into a single backup file.'**
  String get exportCardDescription;

  /// No description provided for @exportCardButton.
  ///
  /// In en, this message translates to:
  /// **'Create Backup'**
  String get exportCardButton;

  /// No description provided for @importCardTitle.
  ///
  /// In en, this message translates to:
  /// **'Import Data'**
  String get importCardTitle;

  /// No description provided for @importCardDescription.
  ///
  /// In en, this message translates to:
  /// **'Restores your data from a previously created backup file. WARNING: All data currently stored in the app will be overwritten!'**
  String get importCardDescription;

  /// No description provided for @importCardButton.
  ///
  /// In en, this message translates to:
  /// **'Restore Backup'**
  String get importCardButton;

  /// No description provided for @recommendationDefault.
  ///
  /// In en, this message translates to:
  /// **'Track your first meal!'**
  String get recommendationDefault;

  /// No description provided for @recommendationOverTarget.
  ///
  /// In en, this message translates to:
  /// **'Last {count} days: +{difference} kcal over target'**
  String recommendationOverTarget(Object count, Object difference);

  /// No description provided for @recommendationUnderTarget.
  ///
  /// In en, this message translates to:
  /// **'Last {count} days: {difference} kcal under target'**
  String recommendationUnderTarget(Object count, Object difference);

  /// No description provided for @recommendationOnTarget.
  ///
  /// In en, this message translates to:
  /// **'Last {count} days: Target achieved ✅'**
  String recommendationOnTarget(Object count);

  /// No description provided for @recommendationFirstEntry.
  ///
  /// In en, this message translates to:
  /// **'Great, your first entry is logged!'**
  String get recommendationFirstEntry;

  /// No description provided for @dialogConfirmTitle.
  ///
  /// In en, this message translates to:
  /// **'Confirmation Required'**
  String get dialogConfirmTitle;

  /// No description provided for @dialogConfirmImportContent.
  ///
  /// In en, this message translates to:
  /// **'Do you really want to restore data from this backup?\n\nWARNING: All your current entries, favorites, and custom foods will be permanently deleted and replaced.'**
  String get dialogConfirmImportContent;

  /// No description provided for @dialogButtonCancel.
  ///
  /// In en, this message translates to:
  /// **'Cancel'**
  String get dialogButtonCancel;

  /// No description provided for @dialogButtonOverwrite.
  ///
  /// In en, this message translates to:
  /// **'Yes, overwrite all'**
  String get dialogButtonOverwrite;

  /// No description provided for @snackbarNoFileSelected.
  ///
  /// In en, this message translates to:
  /// **'No file selected.'**
  String get snackbarNoFileSelected;

  /// No description provided for @snackbarImportSuccessTitle.
  ///
  /// In en, this message translates to:
  /// **'Import successful!'**
  String get snackbarImportSuccessTitle;

  /// No description provided for @snackbarImportSuccessContent.
  ///
  /// In en, this message translates to:
  /// **'Your data has been restored. It is recommended to restart the app for a correct display.'**
  String get snackbarImportSuccessContent;

  /// No description provided for @snackbarButtonOK.
  ///
  /// In en, this message translates to:
  /// **'OK'**
  String get snackbarButtonOK;

  /// No description provided for @snackbarImportError.
  ///
  /// In en, this message translates to:
  /// **'Error while importing data.'**
  String get snackbarImportError;

  /// No description provided for @snackbarExportSuccess.
  ///
  /// In en, this message translates to:
  /// **'Backup file has been passed to the system. Please choose a location to save.'**
  String get snackbarExportSuccess;

  /// No description provided for @snackbarExportFailed.
  ///
  /// In en, this message translates to:
  /// **'Export canceled or failed.'**
  String get snackbarExportFailed;

  /// No description provided for @profileUserHeight.
  ///
  /// In en, this message translates to:
  /// **'Height (cm)'**
  String get profileUserHeight;

  /// No description provided for @workoutRoutinesTitle.
  ///
  /// In en, this message translates to:
  /// **'Routines'**
  String get workoutRoutinesTitle;

  /// No description provided for @workoutHistoryTitle.
  ///
  /// In en, this message translates to:
  /// **'Workout History'**
  String get workoutHistoryTitle;

  /// No description provided for @workoutHistoryButton.
  ///
  /// In en, this message translates to:
  /// **'History'**
  String get workoutHistoryButton;

  /// No description provided for @emptyRoutinesTitle.
  ///
  /// In en, this message translates to:
  /// **'No Routines Found'**
  String get emptyRoutinesTitle;

  /// No description provided for @emptyRoutinesSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Create your first routine or start a blank workout.'**
  String get emptyRoutinesSubtitle;

  /// No description provided for @createFirstRoutineButton.
  ///
  /// In en, this message translates to:
  /// **'Create First Routine'**
  String get createFirstRoutineButton;

  /// No description provided for @startEmptyWorkoutButton.
  ///
  /// In en, this message translates to:
  /// **'Free Workout'**
  String get startEmptyWorkoutButton;

  /// No description provided for @editRoutineSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Tap to edit, or start the workout.'**
  String get editRoutineSubtitle;

  /// No description provided for @startButton.
  ///
  /// In en, this message translates to:
  /// **'Start'**
  String get startButton;

  /// No description provided for @addRoutineButton.
  ///
  /// In en, this message translates to:
  /// **'New Routine'**
  String get addRoutineButton;

  /// No description provided for @freeWorkoutTitle.
  ///
  /// In en, this message translates to:
  /// **'Free Workout'**
  String get freeWorkoutTitle;

  /// No description provided for @finishWorkoutButton.
  ///
  /// In en, this message translates to:
  /// **'Finish'**
  String get finishWorkoutButton;

  /// No description provided for @addSetButton.
  ///
  /// In en, this message translates to:
  /// **'Add Set'**
  String get addSetButton;

  /// No description provided for @addExerciseToWorkoutButton.
  ///
  /// In en, this message translates to:
  /// **'Add Exercise to Workout'**
  String get addExerciseToWorkoutButton;

  /// No description provided for @lastTimeLabel.
  ///
  /// In en, this message translates to:
  /// **'Last Time'**
  String get lastTimeLabel;

  /// No description provided for @setLabel.
  ///
  /// In en, this message translates to:
  /// **'Set'**
  String get setLabel;

  /// No description provided for @kgLabel.
  ///
  /// In en, this message translates to:
  /// **'Weight (kg)'**
  String get kgLabel;

  /// No description provided for @repsLabel.
  ///
  /// In en, this message translates to:
  /// **'Reps'**
  String get repsLabel;

  /// No description provided for @restTimerLabel.
  ///
  /// In en, this message translates to:
  /// **'Rest'**
  String get restTimerLabel;

  /// No description provided for @skipButton.
  ///
  /// In en, this message translates to:
  /// **'Skip'**
  String get skipButton;

  /// No description provided for @emptyHistory.
  ///
  /// In en, this message translates to:
  /// **'No completed workouts yet.'**
  String get emptyHistory;

  /// No description provided for @workoutDetailsTitle.
  ///
  /// In en, this message translates to:
  /// **'Workout Details'**
  String get workoutDetailsTitle;

  /// No description provided for @workoutNotFound.
  ///
  /// In en, this message translates to:
  /// **'Workout not found.'**
  String get workoutNotFound;

  /// No description provided for @totalVolumeLabel.
  ///
  /// In en, this message translates to:
  /// **'Total Volume'**
  String get totalVolumeLabel;

  /// No description provided for @notesLabel.
  ///
  /// In en, this message translates to:
  /// **'Notes'**
  String get notesLabel;

  /// No description provided for @hevyImportTitle.
  ///
  /// In en, this message translates to:
  /// **'Hevy Import'**
  String get hevyImportTitle;

  /// No description provided for @hevyImportDescription.
  ///
  /// In en, this message translates to:
  /// **'Import your entire training history from a Hevy CSV export file.'**
  String get hevyImportDescription;

  /// No description provided for @hevyImportButton.
  ///
  /// In en, this message translates to:
  /// **'Import Hevy Data'**
  String get hevyImportButton;

  /// No description provided for @hevyImportSuccess.
  ///
  /// In en, this message translates to:
  /// **'Successfully imported {count} workouts!'**
  String hevyImportSuccess(Object count);

  /// No description provided for @hevyImportFailed.
  ///
  /// In en, this message translates to:
  /// **'Import failed. Please check the file.'**
  String get hevyImportFailed;

  /// No description provided for @startWorkout.
  ///
  /// In en, this message translates to:
  /// **'Start Workout'**
  String get startWorkout;

  /// No description provided for @addMeasurement.
  ///
  /// In en, this message translates to:
  /// **'Add Measurement'**
  String get addMeasurement;

  /// No description provided for @filterToday.
  ///
  /// In en, this message translates to:
  /// **'Today'**
  String get filterToday;

  /// No description provided for @filter7Days.
  ///
  /// In en, this message translates to:
  /// **'7 Days'**
  String get filter7Days;

  /// No description provided for @filter30Days.
  ///
  /// In en, this message translates to:
  /// **'30 Days'**
  String get filter30Days;

  /// No description provided for @filterAll.
  ///
  /// In en, this message translates to:
  /// **'All'**
  String get filterAll;

  /// No description provided for @showLess.
  ///
  /// In en, this message translates to:
  /// **'Show less'**
  String get showLess;

  /// No description provided for @showMoreDetails.
  ///
  /// In en, this message translates to:
  /// **'Show more details'**
  String get showMoreDetails;

  /// No description provided for @deleteConfirmTitle.
  ///
  /// In en, this message translates to:
  /// **'Confirm Deletion'**
  String get deleteConfirmTitle;

  /// No description provided for @deleteConfirmContent.
  ///
  /// In en, this message translates to:
  /// **'Do you really want to delete this entry?'**
  String get deleteConfirmContent;

  /// No description provided for @cancel.
  ///
  /// In en, this message translates to:
  /// **'Cancel'**
  String get cancel;

  /// No description provided for @delete.
  ///
  /// In en, this message translates to:
  /// **'Delete'**
  String get delete;

  /// No description provided for @save.
  ///
  /// In en, this message translates to:
  /// **'Save'**
  String get save;

  /// No description provided for @tabBaseFoods.
  ///
  /// In en, this message translates to:
  /// **'Base Foods'**
  String get tabBaseFoods;

  /// No description provided for @baseFoodsEmptyState.
  ///
  /// In en, this message translates to:
  /// **'This section will soon be filled with a curated list of base foods like fruits, vegetables, and more.'**
  String get baseFoodsEmptyState;

  /// No description provided for @noBrand.
  ///
  /// In en, this message translates to:
  /// **'No Brand'**
  String get noBrand;

  /// No description provided for @unknown.
  ///
  /// In en, this message translates to:
  /// **'Unknown'**
  String get unknown;

  /// No description provided for @backupFileSubject.
  ///
  /// In en, this message translates to:
  /// **'Hypertrack App Backup - {timestamp}'**
  String backupFileSubject(String timestamp);

  /// No description provided for @foodItemSubtitle.
  ///
  /// In en, this message translates to:
  /// **'{brand} - {calories} kcal / 100g'**
  String foodItemSubtitle(String brand, int calories);

  /// No description provided for @foodListSubtitle.
  ///
  /// In en, this message translates to:
  /// **'{grams}g - {time}'**
  String foodListSubtitle(int grams, String time);

  /// No description provided for @foodListTrailingKcal.
  ///
  /// In en, this message translates to:
  /// **'{calories} kcal'**
  String foodListTrailingKcal(int calories);

  /// No description provided for @waterListTrailingMl.
  ///
  /// In en, this message translates to:
  /// **'{milliliters} ml'**
  String waterListTrailingMl(int milliliters);

  /// No description provided for @exerciseCatalogTitle.
  ///
  /// In en, this message translates to:
  /// **'Exercise Catalog'**
  String get exerciseCatalogTitle;

  /// No description provided for @filterByMuscle.
  ///
  /// In en, this message translates to:
  /// **'Filter by muscle group'**
  String get filterByMuscle;

  /// No description provided for @noExercisesFound.
  ///
  /// In en, this message translates to:
  /// **'No exercises found.'**
  String get noExercisesFound;

  /// No description provided for @noDescriptionAvailable.
  ///
  /// In en, this message translates to:
  /// **'No description available.'**
  String get noDescriptionAvailable;

  /// No description provided for @filterByCategory.
  ///
  /// In en, this message translates to:
  /// **'Filter by category'**
  String get filterByCategory;

  /// No description provided for @edit.
  ///
  /// In en, this message translates to:
  /// **'Edit'**
  String get edit;

  /// No description provided for @repsLabelShort.
  ///
  /// In en, this message translates to:
  /// **'reps'**
  String get repsLabelShort;

  /// No description provided for @titleNewRoutine.
  ///
  /// In en, this message translates to:
  /// **'New Routine'**
  String get titleNewRoutine;

  /// No description provided for @titleEditRoutine.
  ///
  /// In en, this message translates to:
  /// **'Edit Routine'**
  String get titleEditRoutine;

  /// No description provided for @validatorPleaseEnterRoutineName.
  ///
  /// In en, this message translates to:
  /// **'Please enter a name for the routine.'**
  String get validatorPleaseEnterRoutineName;

  /// No description provided for @snackbarRoutineCreated.
  ///
  /// In en, this message translates to:
  /// **'Routine created. Now add some exercises.'**
  String get snackbarRoutineCreated;

  /// No description provided for @snackbarRoutineSaved.
  ///
  /// In en, this message translates to:
  /// **'Routine saved.'**
  String get snackbarRoutineSaved;

  /// No description provided for @formFieldRoutineName.
  ///
  /// In en, this message translates to:
  /// **'Name of the routine'**
  String get formFieldRoutineName;

  /// No description provided for @emptyStateAddFirstExercise.
  ///
  /// In en, this message translates to:
  /// **'Add your first exercise.'**
  String get emptyStateAddFirstExercise;

  /// No description provided for @setCount.
  ///
  /// In en, this message translates to:
  /// **'{count,plural, =1{1 set}other{{count} sets}}'**
  String setCount(int count);

  /// No description provided for @fabAddExercise.
  ///
  /// In en, this message translates to:
  /// **'Add Exercise'**
  String get fabAddExercise;

  /// No description provided for @kgLabelShort.
  ///
  /// In en, this message translates to:
  /// **'kg'**
  String get kgLabelShort;

  /// No description provided for @drawerExerciseCatalog.
  ///
  /// In en, this message translates to:
  /// **'Exercise Catalog'**
  String get drawerExerciseCatalog;

  /// No description provided for @lastWorkoutTitle.
  ///
  /// In en, this message translates to:
  /// **'Last Workout'**
  String get lastWorkoutTitle;

  /// No description provided for @repeatButton.
  ///
  /// In en, this message translates to:
  /// **'Repeat'**
  String get repeatButton;

  /// No description provided for @weightHistoryTitle.
  ///
  /// In en, this message translates to:
  /// **'Weight History'**
  String get weightHistoryTitle;

  /// No description provided for @hideSummary.
  ///
  /// In en, this message translates to:
  /// **'Hide Summary'**
  String get hideSummary;

  /// No description provided for @showSummary.
  ///
  /// In en, this message translates to:
  /// **'Show Summary'**
  String get showSummary;

  /// No description provided for @exerciseDataAttribution.
  ///
  /// In en, this message translates to:
  /// **'Exercise data from wger'**
  String get exerciseDataAttribution;

  /// No description provided for @duplicate.
  ///
  /// In en, this message translates to:
  /// **'Duplicate'**
  String get duplicate;

  /// No description provided for @deleteRoutineConfirmContent.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to permanently delete the routine \'{routineName}\'?'**
  String deleteRoutineConfirmContent(String routineName);

  /// No description provided for @editPauseTimeTitle.
  ///
  /// In en, this message translates to:
  /// **'Edit Pause Duration'**
  String get editPauseTimeTitle;

  /// No description provided for @pauseInSeconds.
  ///
  /// In en, this message translates to:
  /// **'Pause in seconds'**
  String get pauseInSeconds;

  /// No description provided for @editPauseTime.
  ///
  /// In en, this message translates to:
  /// **'Edit Pause'**
  String get editPauseTime;

  /// No description provided for @pauseDuration.
  ///
  /// In en, this message translates to:
  /// **'{seconds} second pause'**
  String pauseDuration(int seconds);

  /// No description provided for @maxPauseDuration.
  ///
  /// In en, this message translates to:
  /// **'Pauses up to {seconds}s'**
  String maxPauseDuration(int seconds);

  /// No description provided for @deleteWorkoutConfirmContent.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to permanently delete this workout log?'**
  String get deleteWorkoutConfirmContent;

  /// No description provided for @removeExercise.
  ///
  /// In en, this message translates to:
  /// **'Remove Exercise'**
  String get removeExercise;

  /// No description provided for @deleteExerciseConfirmTitle.
  ///
  /// In en, this message translates to:
  /// **'Remove Exercise?'**
  String get deleteExerciseConfirmTitle;

  /// No description provided for @deleteExerciseConfirmContent.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to remove \'{exerciseName}\' from this routine?'**
  String deleteExerciseConfirmContent(String exerciseName);

  /// No description provided for @doneButtonLabel.
  ///
  /// In en, this message translates to:
  /// **'Done'**
  String get doneButtonLabel;

  /// No description provided for @setRestTimeButton.
  ///
  /// In en, this message translates to:
  /// **'Set rest time'**
  String get setRestTimeButton;

  /// No description provided for @deleteExerciseButton.
  ///
  /// In en, this message translates to:
  /// **'Delete exercise'**
  String get deleteExerciseButton;

  /// No description provided for @restOverLabel.
  ///
  /// In en, this message translates to:
  /// **'Pause is over'**
  String get restOverLabel;

  /// No description provided for @workoutRunningLabel.
  ///
  /// In en, this message translates to:
  /// **'Workout is active …'**
  String get workoutRunningLabel;

  /// No description provided for @continueButton.
  ///
  /// In en, this message translates to:
  /// **'Continue'**
  String get continueButton;

  /// No description provided for @discardButton.
  ///
  /// In en, this message translates to:
  /// **'Discard'**
  String get discardButton;

  /// No description provided for @workoutStatsTitle.
  ///
  /// In en, this message translates to:
  /// **'Training (7 days)'**
  String get workoutStatsTitle;

  /// No description provided for @workoutsLabel.
  ///
  /// In en, this message translates to:
  /// **'Workouts'**
  String get workoutsLabel;

  /// Label for workout duration summary
  ///
  /// In en, this message translates to:
  /// **'Duration'**
  String get durationLabel;

  /// No description provided for @volumeLabel.
  ///
  /// In en, this message translates to:
  /// **'Volume'**
  String get volumeLabel;

  /// Label for number of sets summary
  ///
  /// In en, this message translates to:
  /// **'Sets'**
  String get setsLabel;

  /// Label for muscle split bar chart
  ///
  /// In en, this message translates to:
  /// **'Muscle Split'**
  String get muscleSplitLabel;

  /// No description provided for @snackbar_could_not_open_open_link.
  ///
  /// In en, this message translates to:
  /// **'Konnte Link nicht öffnen'**
  String get snackbar_could_not_open_open_link;

  /// No description provided for @chart_no_data_for_period.
  ///
  /// In en, this message translates to:
  /// **'No chart data for this period'**
  String get chart_no_data_for_period;

  /// No description provided for @amount_in_milliliters.
  ///
  /// In en, this message translates to:
  /// **'Menge in Millilitern'**
  String get amount_in_milliliters;

  /// No description provided for @amount_in_grams.
  ///
  /// In en, this message translates to:
  /// **'Menge in Gramm'**
  String get amount_in_grams;

  /// No description provided for @meal_label.
  ///
  /// In en, this message translates to:
  /// **'Mahlzeit'**
  String get meal_label;

  /// No description provided for @add_to_water_intake.
  ///
  /// In en, this message translates to:
  /// **'Zur Trinkmenge hinzufügen'**
  String get add_to_water_intake;

  /// No description provided for @create_exercise_screen_title.
  ///
  /// In en, this message translates to:
  /// **'Eigene Übung erstellen'**
  String get create_exercise_screen_title;

  /// No description provided for @exercise_name_label.
  ///
  /// In en, this message translates to:
  /// **'Name der Übung'**
  String get exercise_name_label;

  /// No description provided for @category_label.
  ///
  /// In en, this message translates to:
  /// **'Kategorie'**
  String get category_label;

  /// No description provided for @description_optional_label.
  ///
  /// In en, this message translates to:
  /// **'Beschreibung (optional)'**
  String get description_optional_label;

  /// No description provided for @primary_muscles_label.
  ///
  /// In en, this message translates to:
  /// **'Primäre Muskeln'**
  String get primary_muscles_label;

  /// No description provided for @primary_muscles_hint.
  ///
  /// In en, this message translates to:
  /// **'z.B. Brust, Trizeps'**
  String get primary_muscles_hint;

  /// No description provided for @secondary_muscles_label.
  ///
  /// In en, this message translates to:
  /// **'Sekundäre Muskeln (optional)'**
  String get secondary_muscles_label;

  /// No description provided for @secondary_muscles_hint.
  ///
  /// In en, this message translates to:
  /// **'z.B. Schultern'**
  String get secondary_muscles_hint;

  /// No description provided for @set_type_normal.
  ///
  /// In en, this message translates to:
  /// **'Normal'**
  String get set_type_normal;

  /// No description provided for @set_type_warmup.
  ///
  /// In en, this message translates to:
  /// **'Warmup'**
  String get set_type_warmup;

  /// No description provided for @set_type_failure.
  ///
  /// In en, this message translates to:
  /// **'Failure'**
  String get set_type_failure;

  /// No description provided for @set_type_dropset.
  ///
  /// In en, this message translates to:
  /// **'Dropset'**
  String get set_type_dropset;

  /// No description provided for @set_reps_hint.
  ///
  /// In en, this message translates to:
  /// **'8-12'**
  String get set_reps_hint;

  /// No description provided for @data_export_button.
  ///
  /// In en, this message translates to:
  /// **'Export'**
  String get data_export_button;

  /// No description provided for @data_import_button.
  ///
  /// In en, this message translates to:
  /// **'Import'**
  String get data_import_button;

  /// No description provided for @snackbar_button_ok.
  ///
  /// In en, this message translates to:
  /// **'OK'**
  String get snackbar_button_ok;

  /// No description provided for @measurement_session_detail_view.
  ///
  /// In en, this message translates to:
  /// **'Detailview of measurement session'**
  String get measurement_session_detail_view;

  /// No description provided for @unit_grams.
  ///
  /// In en, this message translates to:
  /// **'g'**
  String get unit_grams;

  /// No description provided for @unit_kcal.
  ///
  /// In en, this message translates to:
  /// **'kcal'**
  String get unit_kcal;

  /// No description provided for @delete_profile_picture_button.
  ///
  /// In en, this message translates to:
  /// **'Delete profile picture'**
  String get delete_profile_picture_button;

  /// No description provided for @attribution_title.
  ///
  /// In en, this message translates to:
  /// **'Attribution'**
  String get attribution_title;

  /// No description provided for @add_liquid_title.
  ///
  /// In en, this message translates to:
  /// **'Add fluid'**
  String get add_liquid_title;

  /// No description provided for @add_button.
  ///
  /// In en, this message translates to:
  /// **'Add'**
  String get add_button;

  /// No description provided for @discard_button.
  ///
  /// In en, this message translates to:
  /// **'Discard'**
  String get discard_button;

  /// No description provided for @continue_workout_button.
  ///
  /// In en, this message translates to:
  /// **'Continue'**
  String get continue_workout_button;

  /// No description provided for @soon_available_snackbar.
  ///
  /// In en, this message translates to:
  /// **'This screen will be available soon'**
  String get soon_available_snackbar;

  /// No description provided for @start_button.
  ///
  /// In en, this message translates to:
  /// **'Start'**
  String get start_button;

  /// No description provided for @today_overview_text.
  ///
  /// In en, this message translates to:
  /// **'TODAY IN FOCUS'**
  String get today_overview_text;

  /// No description provided for @quick_add_text.
  ///
  /// In en, this message translates to:
  /// **'QUICK ADD'**
  String get quick_add_text;

  /// No description provided for @scann_barcode_capslock.
  ///
  /// In en, this message translates to:
  /// **'Scan barcode'**
  String get scann_barcode_capslock;

  /// No description provided for @protocol_today_capslock.
  ///
  /// In en, this message translates to:
  /// **'TODAY\'S PROTOCOL'**
  String get protocol_today_capslock;

  /// No description provided for @my_plans_capslock.
  ///
  /// In en, this message translates to:
  /// **'MY PLANS'**
  String get my_plans_capslock;

  /// No description provided for @overview_capslock.
  ///
  /// In en, this message translates to:
  /// **'OVERVIEW'**
  String get overview_capslock;

  /// No description provided for @manage_all_plans.
  ///
  /// In en, this message translates to:
  /// **'Manage all plans'**
  String get manage_all_plans;

  /// No description provided for @free_training.
  ///
  /// In en, this message translates to:
  /// **'free training'**
  String get free_training;

  /// No description provided for @my_consistency.
  ///
  /// In en, this message translates to:
  /// **'MY CONSISTENCY'**
  String get my_consistency;

  /// No description provided for @calendar_currently_not_available.
  ///
  /// In en, this message translates to:
  /// **'The calendar view will be available soon.'**
  String get calendar_currently_not_available;

  /// No description provided for @in_depth_analysis.
  ///
  /// In en, this message translates to:
  /// **'IN-DEPTH ANALYSIS'**
  String get in_depth_analysis;

  /// No description provided for @body_measurements.
  ///
  /// In en, this message translates to:
  /// **'Body measurements'**
  String get body_measurements;

  /// No description provided for @measurements_description.
  ///
  /// In en, this message translates to:
  /// **'Analyze weight, body fat percentage and circumference.'**
  String get measurements_description;

  /// No description provided for @nutrition_description.
  ///
  /// In en, this message translates to:
  /// **'Evaluate macros, calories and trends.'**
  String get nutrition_description;

  /// No description provided for @training_analysis.
  ///
  /// In en, this message translates to:
  /// **'Training analysis'**
  String get training_analysis;

  /// No description provided for @training_analysis_description.
  ///
  /// In en, this message translates to:
  /// **'Track volume, strength and progression.'**
  String get training_analysis_description;

  /// No description provided for @load_dots.
  ///
  /// In en, this message translates to:
  /// **'loading...'**
  String get load_dots;

  /// No description provided for @profile_capslock.
  ///
  /// In en, this message translates to:
  /// **'PROFILE'**
  String get profile_capslock;

  /// No description provided for @settings_capslock.
  ///
  /// In en, this message translates to:
  /// **'SETTINGS'**
  String get settings_capslock;

  /// No description provided for @settingsTitle.
  ///
  /// In en, this message translates to:
  /// **'Settings'**
  String get settingsTitle;

  /// No description provided for @my_goals.
  ///
  /// In en, this message translates to:
  /// **'My goals'**
  String get my_goals;

  /// No description provided for @my_goals_description.
  ///
  /// In en, this message translates to:
  /// **'Adjust calories, macros and water.'**
  String get my_goals_description;

  /// No description provided for @backup_and_import.
  ///
  /// In en, this message translates to:
  /// **'Data backup & import'**
  String get backup_and_import;

  /// No description provided for @backup_and_import_description.
  ///
  /// In en, this message translates to:
  /// **'Create backups, restore, and import data.'**
  String get backup_and_import_description;

  /// No description provided for @about_and_legal_capslock.
  ///
  /// In en, this message translates to:
  /// **'ABOUT & LEGAL'**
  String get about_and_legal_capslock;

  /// No description provided for @attribution_and_license.
  ///
  /// In en, this message translates to:
  /// **'Attribution & Licenses'**
  String get attribution_and_license;

  /// No description provided for @data_from_off_and_wger.
  ///
  /// In en, this message translates to:
  /// **'Data from Open Food Facts and wger.'**
  String get data_from_off_and_wger;

  /// No description provided for @app_version.
  ///
  /// In en, this message translates to:
  /// **'App version'**
  String get app_version;

  /// No description provided for @all_measurements.
  ///
  /// In en, this message translates to:
  /// **'ALL MEASUREMENTS'**
  String get all_measurements;

  /// No description provided for @date_and_time_of_measurement.
  ///
  /// In en, this message translates to:
  /// **'Date & time of measurement'**
  String get date_and_time_of_measurement;

  /// Onboarding slide 1 title
  ///
  /// In en, this message translates to:
  /// **'Welcome to Hypertrack'**
  String get onbWelcomeTitle;

  /// Onboarding slide 1 description
  ///
  /// In en, this message translates to:
  /// **'Let’s start by setting personal goals to guide training and nutrition.'**
  String get onbWelcomeBody;

  /// Onboarding slide 2 title
  ///
  /// In en, this message translates to:
  /// **'Track everything'**
  String get onbTrackTitle;

  /// Onboarding slide 2 description
  ///
  /// In en, this message translates to:
  /// **'Log nutrition, workouts, and measurements — all in one place.'**
  String get onbTrackBody;

  /// Onboarding slide 3 title
  ///
  /// In en, this message translates to:
  /// **'Offline-first & privacy'**
  String get onbPrivacyTitle;

  /// Onboarding slide 3 description
  ///
  /// In en, this message translates to:
  /// **'Your data stays on the device. No cloud accounts, no background sync.'**
  String get onbPrivacyBody;

  /// Onboarding final slide title
  ///
  /// In en, this message translates to:
  /// **'All set'**
  String get onbFinishTitle;

  /// Onboarding final slide description
  ///
  /// In en, this message translates to:
  /// **'You’re ready to explore the app. You can adjust settings anytime.'**
  String get onbFinishBody;

  /// Final button label to finish onboarding
  ///
  /// In en, this message translates to:
  /// **'Let’s go!'**
  String get onbFinishCta;

  /// Settings item to reopen onboarding
  ///
  /// In en, this message translates to:
  /// **'Show tutorial again'**
  String get onbShowTutorialAgain;

  /// Optional CTA linking to Goals screen from onboarding
  ///
  /// In en, this message translates to:
  /// **'Set goals'**
  String get onbSetGoalsCta;

  /// Onboarding header title
  ///
  /// In en, this message translates to:
  /// **'Tutorial'**
  String get onbHeaderTitle;

  /// Skip button label in onboarding header
  ///
  /// In en, this message translates to:
  /// **'Skip'**
  String get onbHeaderSkip;

  /// Back button in onboarding footer
  ///
  /// In en, this message translates to:
  /// **'Back'**
  String get onbBack;

  /// Next button in onboarding footer
  ///
  /// In en, this message translates to:
  /// **'Next'**
  String get onbNext;

  /// Guide banner title in onboarding
  ///
  /// In en, this message translates to:
  /// **'How this tutorial works'**
  String get onbGuideTitle;

  /// Guide banner description in onboarding
  ///
  /// In en, this message translates to:
  /// **'Swipe between slides or use Next. Tap the buttons on each slide to try features. You can finish anytime with Skip.'**
  String get onbGuideBody;

  /// CTA to open nutrition tracking from onboarding
  ///
  /// In en, this message translates to:
  /// **'Open nutrition'**
  String get onbCtaOpenNutrition;

  /// CTA to learn more about privacy/offline
  ///
  /// In en, this message translates to:
  /// **'Learn more'**
  String get onbCtaLearnMore;

  /// Badge label shown after completing CTA
  ///
  /// In en, this message translates to:
  /// **'Done'**
  String get onbBadgeDone;

  /// Hint text on goals slide
  ///
  /// In en, this message translates to:
  /// **'Tip: adjust targets first'**
  String get onbTipSetGoals;

  /// Hint text on nutrition slide
  ///
  /// In en, this message translates to:
  /// **'Tip: add one entry today'**
  String get onbTipAddEntry;

  /// Hint on privacy slide about local data control
  ///
  /// In en, this message translates to:
  /// **'You control all data locally'**
  String get onbTipLocalControl;

  /// Onboarding slide 2 replacement body: step-by-step nutrition logging instructions
  ///
  /// In en, this message translates to:
  /// **'How to log nutrition:\n• Open the Food tab.\n• Tap the + button.\n• Search products or scan a barcode.\n• Adjust portion and time.\n• Save to your diary.'**
  String get onbTrackHowBody;

  /// Onboarding slide title for measurements
  ///
  /// In en, this message translates to:
  /// **'Track measurements'**
  String get onbMeasureTitle;

  /// Step-by-step instructions for adding measurements
  ///
  /// In en, this message translates to:
  /// **'How to add measurements:\n• Open the Stats tab.\n• Tap the + button.\n• Choose a metric (e.g., weight, waist, body fat).\n• Enter value and time.\n• Save to your history.'**
  String get onbMeasureBody;

  /// Hint for measurements slide
  ///
  /// In en, this message translates to:
  /// **'Tip: add today’s weight to start your graph'**
  String get onbTipMeasureToday;

  /// Onboarding slide title for training routines
  ///
  /// In en, this message translates to:
  /// **'Train with routines'**
  String get onbTrainTitle;

  /// Instructions for creating a routine and starting a workout
  ///
  /// In en, this message translates to:
  /// **'Create a routine and start a workout:\n• Open the Train tab.\n• Tap Create routine to add exercises and sets.\n• Save the routine.\n• Tap Start to begin, or use “Start empty workout”.'**
  String get onbTrainBody;

  /// Hint for training slide
  ///
  /// In en, this message translates to:
  /// **'Tip: start an empty workout to log a quick session'**
  String get onbTipStartWorkout;

  /// No description provided for @unitsSection.
  ///
  /// In en, this message translates to:
  /// **'units'**
  String get unitsSection;

  /// No description provided for @weightUnit.
  ///
  /// In en, this message translates to:
  /// **'Weight units'**
  String get weightUnit;

  /// No description provided for @lengthUnit.
  ///
  /// In en, this message translates to:
  /// **'unit of length'**
  String get lengthUnit;

  /// No description provided for @comingSoon.
  ///
  /// In en, this message translates to:
  /// **'Coming soon'**
  String get comingSoon;

  /// No description provided for @noFavorites.
  ///
  /// In en, this message translates to:
  /// **'No Favorites'**
  String get noFavorites;

  /// No description provided for @nothingTrackedYet.
  ///
  /// In en, this message translates to:
  /// **'Nothing tracked yet'**
  String get nothingTrackedYet;

  /// No description provided for @snackbarBarcodeNotFound.
  ///
  /// In en, this message translates to:
  /// **'No product found for barcode \"{barcode}\".'**
  String snackbarBarcodeNotFound(String barcode);

  /// No description provided for @categoryHint.
  ///
  /// In en, this message translates to:
  /// **'e.g. Chest, Back, Legs...'**
  String get categoryHint;

  /// No description provided for @validatorPleaseEnterCategory.
  ///
  /// In en, this message translates to:
  /// **'Please enter a category.'**
  String get validatorPleaseEnterCategory;

  /// No description provided for @dialogEnterPasswordImport.
  ///
  /// In en, this message translates to:
  /// **'Enter password to import backup'**
  String get dialogEnterPasswordImport;

  /// No description provided for @dataManagementBackupTitle.
  ///
  /// In en, this message translates to:
  /// **'Lightweight Data Backup'**
  String get dataManagementBackupTitle;

  /// No description provided for @dataManagementBackupDescription.
  ///
  /// In en, this message translates to:
  /// **'Back up or restore all your app data. Ideal for changing devices.'**
  String get dataManagementBackupDescription;

  /// No description provided for @exportEncrypted.
  ///
  /// In en, this message translates to:
  /// **'Export Encrypted'**
  String get exportEncrypted;

  /// No description provided for @dialogPasswordForExport.
  ///
  /// In en, this message translates to:
  /// **'Password for encrypted export'**
  String get dialogPasswordForExport;

  /// No description provided for @snackbarEncryptedBackupShared.
  ///
  /// In en, this message translates to:
  /// **'Encrypted backup shared.'**
  String get snackbarEncryptedBackupShared;

  /// No description provided for @exportFailed.
  ///
  /// In en, this message translates to:
  /// **'Export failed.'**
  String get exportFailed;

  /// No description provided for @csvExportTitle.
  ///
  /// In en, this message translates to:
  /// **'Data Export (CSV)'**
  String get csvExportTitle;

  /// No description provided for @csvExportDescription.
  ///
  /// In en, this message translates to:
  /// **'Export parts of your data as a CSV file for analysis in other programs.'**
  String get csvExportDescription;

  /// No description provided for @snackbarSharingNutrition.
  ///
  /// In en, this message translates to:
  /// **'Sharing nutrition diary...'**
  String get snackbarSharingNutrition;

  /// No description provided for @snackbarExportFailedNoEntries.
  ///
  /// In en, this message translates to:
  /// **'Export failed. There may be no entries yet.'**
  String get snackbarExportFailedNoEntries;

  /// No description provided for @snackbarSharingMeasurements.
  ///
  /// In en, this message translates to:
  /// **'Sharing measurements...'**
  String get snackbarSharingMeasurements;

  /// No description provided for @snackbarSharingWorkouts.
  ///
  /// In en, this message translates to:
  /// **'Sharing workout history...'**
  String get snackbarSharingWorkouts;

  /// No description provided for @mapExercisesTitle.
  ///
  /// In en, this message translates to:
  /// **'Map Exercises'**
  String get mapExercisesTitle;

  /// No description provided for @mapExercisesDescription.
  ///
  /// In en, this message translates to:
  /// **'Map unknown names from logs to wger exercises.'**
  String get mapExercisesDescription;

  /// No description provided for @mapExercisesButton.
  ///
  /// In en, this message translates to:
  /// **'Start Mapping'**
  String get mapExercisesButton;

  /// No description provided for @autoBackupTitle.
  ///
  /// In en, this message translates to:
  /// **'Automatic Backups'**
  String get autoBackupTitle;

  /// No description provided for @autoBackupDescription.
  ///
  /// In en, this message translates to:
  /// **'Periodically saves a backup in the folder. Current folder:'**
  String get autoBackupDescription;

  /// No description provided for @autoBackupDefaultFolder.
  ///
  /// In en, this message translates to:
  /// **'App-Documents/Backups (Default)'**
  String get autoBackupDefaultFolder;

  /// No description provided for @autoBackupChooseFolder.
  ///
  /// In en, this message translates to:
  /// **'Choose Folder'**
  String get autoBackupChooseFolder;

  /// No description provided for @autoBackupCopyPath.
  ///
  /// In en, this message translates to:
  /// **'Copy Path'**
  String get autoBackupCopyPath;

  /// No description provided for @autoBackupRunNow.
  ///
  /// In en, this message translates to:
  /// **'Check & Run Auto-Backup Now'**
  String get autoBackupRunNow;

  /// No description provided for @snackbarAutoBackupSuccess.
  ///
  /// In en, this message translates to:
  /// **'Auto-Backup completed.'**
  String get snackbarAutoBackupSuccess;

  /// No description provided for @snackbarAutoBackupFailed.
  ///
  /// In en, this message translates to:
  /// **'Auto-Backup failed or was canceled.'**
  String get snackbarAutoBackupFailed;

  /// No description provided for @noUnknownExercisesFound.
  ///
  /// In en, this message translates to:
  /// **'No unknown exercises found'**
  String get noUnknownExercisesFound;

  /// No description provided for @snackbarAutoBackupFolderSet.
  ///
  /// In en, this message translates to:
  /// **'Auto-backup folder set:\n{path}'**
  String snackbarAutoBackupFolderSet(String path);

  /// No description provided for @snackbarPathCopied.
  ///
  /// In en, this message translates to:
  /// **'Path copied'**
  String get snackbarPathCopied;

  /// No description provided for @passwordLabel.
  ///
  /// In en, this message translates to:
  /// **'Password'**
  String get passwordLabel;

  /// No description provided for @descriptionLabel.
  ///
  /// In en, this message translates to:
  /// **'Description'**
  String get descriptionLabel;

  /// No description provided for @involvedMuscles.
  ///
  /// In en, this message translates to:
  /// **'Involved Muscles'**
  String get involvedMuscles;

  /// No description provided for @primaryLabel.
  ///
  /// In en, this message translates to:
  /// **'Primary:'**
  String get primaryLabel;

  /// No description provided for @secondaryLabel.
  ///
  /// In en, this message translates to:
  /// **'Secondary:'**
  String get secondaryLabel;

  /// No description provided for @noMusclesSpecified.
  ///
  /// In en, this message translates to:
  /// **'No muscles specified.'**
  String get noMusclesSpecified;

  /// No description provided for @noSelection.
  ///
  /// In en, this message translates to:
  /// **'No selection'**
  String get noSelection;

  /// No description provided for @selectButton.
  ///
  /// In en, this message translates to:
  /// **'Select'**
  String get selectButton;

  /// No description provided for @applyingChanges.
  ///
  /// In en, this message translates to:
  /// **'Applying changes...'**
  String get applyingChanges;

  /// No description provided for @applyMapping.
  ///
  /// In en, this message translates to:
  /// **'Apply Mapping'**
  String get applyMapping;

  /// No description provided for @personalData.
  ///
  /// In en, this message translates to:
  /// **'Personal Data'**
  String get personalData;

  /// No description provided for @personalDataCL.
  ///
  /// In en, this message translates to:
  /// **'PERSONAL DATA'**
  String get personalDataCL;

  /// No description provided for @macroDistribution.
  ///
  /// In en, this message translates to:
  /// **'Macronutrient Distribution'**
  String get macroDistribution;

  /// No description provided for @dialogFinishWorkoutBody.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to finish this workout?'**
  String get dialogFinishWorkoutBody;

  /// No description provided for @attributionText.
  ///
  /// In en, this message translates to:
  /// **'This app uses data from external sources:\n\n● Exercise data and images from wger (wger.de), licensed under CC-BY-SA 4.0.\n\n● Food database from Open Food Facts (openfoodfacts.org), available under the Open Database License (ODbL).'**
  String get attributionText;

  /// No description provided for @errorRoutineNotFound.
  ///
  /// In en, this message translates to:
  /// **'Routine not found'**
  String get errorRoutineNotFound;

  /// No description provided for @workoutHistoryEmptyTitle.
  ///
  /// In en, this message translates to:
  /// **'Your history is empty'**
  String get workoutHistoryEmptyTitle;

  /// No description provided for @workoutSummaryTitle.
  ///
  /// In en, this message translates to:
  /// **'Workout Complete'**
  String get workoutSummaryTitle;

  /// No description provided for @workoutSummaryExerciseOverview.
  ///
  /// In en, this message translates to:
  /// **'Exercise Overview'**
  String get workoutSummaryExerciseOverview;

  /// No description provided for @nutritionDiary.
  ///
  /// In en, this message translates to:
  /// **'Diary'**
  String get nutritionDiary;

  /// No description provided for @detailedNutrientGoals.
  ///
  /// In en, this message translates to:
  /// **'Detailed Nutrients'**
  String get detailedNutrientGoals;

  /// No description provided for @detailedNutrientGoalsCL.
  ///
  /// In en, this message translates to:
  /// **'DETAILED NUTRIENTS'**
  String get detailedNutrientGoalsCL;

  /// No description provided for @supplementTrackerTitle.
  ///
  /// In en, this message translates to:
  /// **'Supplement Tracker'**
  String get supplementTrackerTitle;

  /// No description provided for @supplementTrackerDescription.
  ///
  /// In en, this message translates to:
  /// **'Track goals, limits, and intake.'**
  String get supplementTrackerDescription;

  /// No description provided for @createSupplementTitle.
  ///
  /// In en, this message translates to:
  /// **'Create Supplement'**
  String get createSupplementTitle;

  /// No description provided for @supplementNameLabel.
  ///
  /// In en, this message translates to:
  /// **'Supplement Name'**
  String get supplementNameLabel;

  /// No description provided for @defaultDoseLabel.
  ///
  /// In en, this message translates to:
  /// **'Default Dose'**
  String get defaultDoseLabel;

  /// No description provided for @unitLabel.
  ///
  /// In en, this message translates to:
  /// **'Unit'**
  String get unitLabel;

  /// No description provided for @dailyGoalLabel.
  ///
  /// In en, this message translates to:
  /// **'Daily Goal (optional)'**
  String get dailyGoalLabel;

  /// No description provided for @dailyLimitLabel.
  ///
  /// In en, this message translates to:
  /// **'Daily Limit (optional)'**
  String get dailyLimitLabel;

  /// No description provided for @dailyProgressTitle.
  ///
  /// In en, this message translates to:
  /// **'Daily Progress'**
  String get dailyProgressTitle;

  /// No description provided for @todaysLogTitle.
  ///
  /// In en, this message translates to:
  /// **'Today\'s Log'**
  String get todaysLogTitle;

  /// No description provided for @logIntakeTitle.
  ///
  /// In en, this message translates to:
  /// **'Log Intake'**
  String get logIntakeTitle;

  /// No description provided for @emptySupplementGoals.
  ///
  /// In en, this message translates to:
  /// **'Set goals or limits for supplements to see your progress here.'**
  String get emptySupplementGoals;

  /// No description provided for @emptySupplementLogs.
  ///
  /// In en, this message translates to:
  /// **'No intake logged for today yet.'**
  String get emptySupplementLogs;

  /// No description provided for @doseLabel.
  ///
  /// In en, this message translates to:
  /// **'Dose'**
  String get doseLabel;

  /// No description provided for @settingsDescription.
  ///
  /// In en, this message translates to:
  /// **'Theme, units, data and more'**
  String get settingsDescription;

  /// No description provided for @settingsAppearance.
  ///
  /// In en, this message translates to:
  /// **'Appearance'**
  String get settingsAppearance;

  /// No description provided for @themeSystem.
  ///
  /// In en, this message translates to:
  /// **'System'**
  String get themeSystem;

  /// No description provided for @themeLight.
  ///
  /// In en, this message translates to:
  /// **'Light'**
  String get themeLight;

  /// No description provided for @themeDark.
  ///
  /// In en, this message translates to:
  /// **'Dark'**
  String get themeDark;

  /// No description provided for @caffeinePrompt.
  ///
  /// In en, this message translates to:
  /// **'Caffeine (optional)'**
  String get caffeinePrompt;

  /// No description provided for @caffeineUnit.
  ///
  /// In en, this message translates to:
  /// **'mg per 100ml'**
  String get caffeineUnit;

  /// No description provided for @profile.
  ///
  /// In en, this message translates to:
  /// **'Profile'**
  String get profile;

  /// No description provided for @measurementWeightCapslock.
  ///
  /// In en, this message translates to:
  /// **'BODY WEIGHT'**
  String get measurementWeightCapslock;

  /// No description provided for @diary.
  ///
  /// In en, this message translates to:
  /// **'Diary'**
  String get diary;

  /// No description provided for @analysis.
  ///
  /// In en, this message translates to:
  /// **'Analysis'**
  String get analysis;

  /// No description provided for @yesterday.
  ///
  /// In en, this message translates to:
  /// **'Yesterday'**
  String get yesterday;

  /// No description provided for @dayBeforeYesterday.
  ///
  /// In en, this message translates to:
  /// **'Two days ago'**
  String get dayBeforeYesterday;

  /// No description provided for @statistics.
  ///
  /// In en, this message translates to:
  /// **'Statistics'**
  String get statistics;

  /// No description provided for @workout.
  ///
  /// In en, this message translates to:
  /// **'Workout'**
  String get workout;

  /// No description provided for @addFoodTitle.
  ///
  /// In en, this message translates to:
  /// **'add food'**
  String get addFoodTitle;

  /// No description provided for @nutritionExplorerTitle.
  ///
  /// In en, this message translates to:
  /// **'Nutrition Explorer'**
  String get nutritionExplorerTitle;

  /// No description provided for @myMeals.
  ///
  /// In en, this message translates to:
  /// **'My Meals'**
  String get myMeals;

  /// No description provided for @myMealsCL.
  ///
  /// In en, this message translates to:
  /// **'MY MEALS'**
  String get myMealsCL;

  /// No description provided for @supplement_caffeine.
  ///
  /// In en, this message translates to:
  /// **'Caffeine'**
  String get supplement_caffeine;

  /// No description provided for @supplement_creatine_monohydrate.
  ///
  /// In en, this message translates to:
  /// **'Creatine Monohydrate'**
  String get supplement_creatine_monohydrate;

  /// No description provided for @manageSupplementsTitle.
  ///
  /// In en, this message translates to:
  /// **'Manage supplements'**
  String get manageSupplementsTitle;

  /// No description provided for @deleted.
  ///
  /// In en, this message translates to:
  /// **'deleted'**
  String get deleted;

  /// No description provided for @operationNotAllowed.
  ///
  /// In en, this message translates to:
  /// **'This operation isn\'t allowed'**
  String get operationNotAllowed;

  /// No description provided for @emptySupplements.
  ///
  /// In en, this message translates to:
  /// **'No supplements available'**
  String get emptySupplements;

  /// No description provided for @undo.
  ///
  /// In en, this message translates to:
  /// **'Rückgängig'**
  String get undo;

  /// No description provided for @deleteSupplementConfirm.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to delete this supplement? All related entries will be removed.'**
  String get deleteSupplementConfirm;

  /// No description provided for @fieldRequired.
  ///
  /// In en, this message translates to:
  /// **'Required'**
  String get fieldRequired;

  /// No description provided for @unitNotSupported.
  ///
  /// In en, this message translates to:
  /// **'Unit not supported.'**
  String get unitNotSupported;

  /// No description provided for @caffeineUnitLocked.
  ///
  /// In en, this message translates to:
  /// **'For caffeine the unit is fixed: mg.'**
  String get caffeineUnitLocked;

  /// No description provided for @caffeineMustBeMg.
  ///
  /// In en, this message translates to:
  /// **'Caffeine must be recorded in mg.'**
  String get caffeineMustBeMg;

  /// No description provided for @tabCatalogSearch.
  ///
  /// In en, this message translates to:
  /// **'Catalog'**
  String get tabCatalogSearch;

  /// No description provided for @tabMeals.
  ///
  /// In en, this message translates to:
  /// **'Meals'**
  String get tabMeals;

  /// No description provided for @emptyCategory.
  ///
  /// In en, this message translates to:
  /// **'No entries'**
  String get emptyCategory;

  /// No description provided for @searchSectionBase.
  ///
  /// In en, this message translates to:
  /// **'Base foods'**
  String get searchSectionBase;

  /// No description provided for @searchSectionOther.
  ///
  /// In en, this message translates to:
  /// **'Other results'**
  String get searchSectionOther;

  /// No description provided for @mealsComingSoonTitle.
  ///
  /// In en, this message translates to:
  /// **'Meals (coming soon)'**
  String get mealsComingSoonTitle;

  /// No description provided for @mealsComingSoonBody.
  ///
  /// In en, this message translates to:
  /// **'Soon you will be able to create your own meals from multiple foods.'**
  String get mealsComingSoonBody;

  /// No description provided for @mealsEmptyTitle.
  ///
  /// In en, this message translates to:
  /// **'No meals yet'**
  String get mealsEmptyTitle;

  /// No description provided for @mealsEmptyBody.
  ///
  /// In en, this message translates to:
  /// **'Create meals to quickly log multiple foods at once.'**
  String get mealsEmptyBody;

  /// No description provided for @mealsCreate.
  ///
  /// In en, this message translates to:
  /// **'Create meal'**
  String get mealsCreate;

  /// No description provided for @mealsEdit.
  ///
  /// In en, this message translates to:
  /// **'Edit meal'**
  String get mealsEdit;

  /// No description provided for @mealsDelete.
  ///
  /// In en, this message translates to:
  /// **'Delete meal'**
  String get mealsDelete;

  /// No description provided for @mealsAddToDiary.
  ///
  /// In en, this message translates to:
  /// **'Add to diary'**
  String get mealsAddToDiary;

  /// No description provided for @mealNameLabel.
  ///
  /// In en, this message translates to:
  /// **'Meal name'**
  String get mealNameLabel;

  /// No description provided for @mealNotesLabel.
  ///
  /// In en, this message translates to:
  /// **'Notes'**
  String get mealNotesLabel;

  /// No description provided for @mealIngredientsTitle.
  ///
  /// In en, this message translates to:
  /// **'Ingredients'**
  String get mealIngredientsTitle;

  /// No description provided for @mealAddIngredient.
  ///
  /// In en, this message translates to:
  /// **'Add ingredient'**
  String get mealAddIngredient;

  /// No description provided for @mealIngredientAmountLabel.
  ///
  /// In en, this message translates to:
  /// **'Amount'**
  String get mealIngredientAmountLabel;

  /// No description provided for @mealDeleteConfirmTitle.
  ///
  /// In en, this message translates to:
  /// **'Delete meal'**
  String get mealDeleteConfirmTitle;

  /// No description provided for @mealDeleteConfirmBody.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to delete the meal \'{name}\'? All its ingredients will also be removed.'**
  String mealDeleteConfirmBody(Object name);

  /// No description provided for @mealAddedToDiary.
  ///
  /// In en, this message translates to:
  /// **'Meal \'{name}\' has been added to your diary.'**
  String mealAddedToDiary(Object name);

  /// No description provided for @mealSaved.
  ///
  /// In en, this message translates to:
  /// **'Meal saved.'**
  String get mealSaved;

  /// No description provided for @mealDeleted.
  ///
  /// In en, this message translates to:
  /// **'Meal deleted.'**
  String get mealDeleted;

  /// No description provided for @confirm.
  ///
  /// In en, this message translates to:
  /// **'Confirm'**
  String get confirm;

  /// No description provided for @addMealToDiaryTitle.
  ///
  /// In en, this message translates to:
  /// **'Add to diary'**
  String get addMealToDiaryTitle;

  /// No description provided for @mealTypeLabel.
  ///
  /// In en, this message translates to:
  /// **'Meal'**
  String get mealTypeLabel;

  /// No description provided for @amountLabel.
  ///
  /// In en, this message translates to:
  /// **'Amount'**
  String get amountLabel;

  /// No description provided for @mealAddedToDiarySuccess.
  ///
  /// In en, this message translates to:
  /// **'Meal added to diary'**
  String get mealAddedToDiarySuccess;

  /// No description provided for @error.
  ///
  /// In en, this message translates to:
  /// **'Error'**
  String get error;

  /// No description provided for @mealsViewTitle.
  ///
  /// In en, this message translates to:
  /// **'mealsViewTitle'**
  String get mealsViewTitle;

  /// No description provided for @noNotes.
  ///
  /// In en, this message translates to:
  /// **'No notes'**
  String get noNotes;

  /// No description provided for @ingredientsCapsLock.
  ///
  /// In en, this message translates to:
  /// **'INGREDIENTS'**
  String get ingredientsCapsLock;

  /// No description provided for @nutritionSectionLabel.
  ///
  /// In en, this message translates to:
  /// **'NUTRITION FACTS'**
  String get nutritionSectionLabel;

  /// No description provided for @nutritionCalculatedForCurrentAmounts.
  ///
  /// In en, this message translates to:
  /// **'for current quantities'**
  String get nutritionCalculatedForCurrentAmounts;

  /// No description provided for @startCapsLock.
  ///
  /// In en, this message translates to:
  /// **'START'**
  String get startCapsLock;

  /// No description provided for @nutritionHubSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Discover insights, track meals, and plan your nutrition here soon.'**
  String get nutritionHubSubtitle;

  /// No description provided for @nutritionHubTitle.
  ///
  /// In en, this message translates to:
  /// **'Nutrition'**
  String get nutritionHubTitle;

  /// No description provided for @nutrition.
  ///
  /// In en, this message translates to:
  /// **'nutrition'**
  String get nutrition;

  /// No description provided for @changeSetTypTitle.
  ///
  /// In en, this message translates to:
  /// **'Change set type'**
  String get changeSetTypTitle;

  /// No description provided for @settingsVisualStyleTitle.
  ///
  /// In en, this message translates to:
  /// **'Visual Style'**
  String get settingsVisualStyleTitle;

  /// No description provided for @settingsVisualStyleStandard.
  ///
  /// In en, this message translates to:
  /// **'Standard (Glass)'**
  String get settingsVisualStyleStandard;

  /// No description provided for @settingsVisualStyleLiquid.
  ///
  /// In en, this message translates to:
  /// **'Fluid (Liquid Glass)'**
  String get settingsVisualStyleLiquid;

  /// No description provided for @settingsVisualStyleLiquidDesc.
  ///
  /// In en, this message translates to:
  /// **'Rounded, floating UI elements'**
  String get settingsVisualStyleLiquidDesc;

  /// No description provided for @searchBaseFoodHint.
  ///
  /// In en, this message translates to:
  /// **'Search base foods'**
  String get searchBaseFoodHint;

  /// No description provided for @searchNoHits.
  ///
  /// In en, this message translates to:
  /// **'No hits.'**
  String get searchNoHits;

  /// No description provided for @onbSubtitleWelcome.
  ///
  /// In en, this message translates to:
  /// **'Your central tool for fitness, nutrition & progress.'**
  String get onbSubtitleWelcome;

  /// No description provided for @onbBodyWelcome.
  ///
  /// In en, this message translates to:
  /// **'We help you set and track your goals. Efficiently log workouts, nutrition, supplements, and body measurements.'**
  String get onbBodyWelcome;

  /// No description provided for @onbBodyNutritionVisual.
  ///
  /// In en, this message translates to:
  /// **'Log meals with just a few clicks. Keep an eye on calories, macros, and water to effortlessly track your goal.'**
  String get onbBodyNutritionVisual;

  /// No description provided for @onbBodyMeasurementsVisual.
  ///
  /// In en, this message translates to:
  /// **'Visualize your progress. The weight and circumference chart makes your success visible and keeps you motivated.'**
  String get onbBodyMeasurementsVisual;

  /// No description provided for @onbBodyWorkoutVisual.
  ///
  /// In en, this message translates to:
  /// **'Create routines and start your training in seconds. Log sets, weights, and rests for maximum progression.'**
  String get onbBodyWorkoutVisual;

  /// No description provided for @onbTitleAppLayout.
  ///
  /// In en, this message translates to:
  /// **'Navigation & Quick-Add'**
  String get onbTitleAppLayout;

  /// No description provided for @onbBodyAppLayout.
  ///
  /// In en, this message translates to:
  /// **'The bottom bar allows quick switching between areas. Use the large [+] button to log everything instantly.'**
  String get onbBodyAppLayout;

  /// No description provided for @dataHubTitle.
  ///
  /// In en, this message translates to:
  /// **'Data Hub'**
  String get dataHubTitle;

  /// No description provided for @resumeButton.
  ///
  /// In en, this message translates to:
  /// **'Resume'**
  String get resumeButton;
}

class _AppLocalizationsDelegate
    extends LocalizationsDelegate<AppLocalizations> {
  const _AppLocalizationsDelegate();

  @override
  Future<AppLocalizations> load(Locale locale) {
    return SynchronousFuture<AppLocalizations>(lookupAppLocalizations(locale));
  }

  @override
  bool isSupported(Locale locale) =>
      <String>['de', 'en'].contains(locale.languageCode);

  @override
  bool shouldReload(_AppLocalizationsDelegate old) => false;
}

AppLocalizations lookupAppLocalizations(Locale locale) {
  // Lookup logic when only language code is specified.
  switch (locale.languageCode) {
    case 'de':
      return AppLocalizationsDe();
    case 'en':
      return AppLocalizationsEn();
  }

  throw FlutterError(
      'AppLocalizations.delegate failed to load unsupported locale "$locale". This is likely '
      'an issue with the localizations generation tool. Please file an issue '
      'on GitHub with a reproducible sample app and the gen-l10n configuration '
      'that was used.');
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/generated/app_localizations_de.dart =====

// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for German (`de`).
class AppLocalizationsDe extends AppLocalizations {
  AppLocalizationsDe([String locale = 'de']) : super(locale);

  @override
  String get appTitle => 'Hypertrack';

  @override
  String get bannerText => 'Empfehlung / Aktuelles Workout';

  @override
  String get calories => 'Kalorien';

  @override
  String get water => 'Wasser';

  @override
  String get protein => 'Protein';

  @override
  String get carbs => 'Kohlenhydrate';

  @override
  String get fat => 'Fett';

  @override
  String get daily => 'Täglich';

  @override
  String get today => 'Heute';

  @override
  String get workoutSection => 'Workout-Bereich - noch nicht implementiert';

  @override
  String get addMenuTitle => 'Was möchtest du hinzufügen?';

  @override
  String get addFoodOption => 'Lebensmittel hinzufügen';

  @override
  String get addLiquidOption => 'Flüssigkeit hinzufügen';

  @override
  String get searchHintText => 'Suchen...';

  @override
  String get mealtypeBreakfast => 'Frühstück';

  @override
  String get mealtypeLunch => 'Mittagessen';

  @override
  String get mealtypeDinner => 'Abendessen';

  @override
  String get mealtypeSnack => 'Snack';

  @override
  String get waterHeader => 'Wasser & Getränke';

  @override
  String get openFoodFactsSource => 'Daten von Open Food Facts';

  @override
  String get tabRecent => 'Zuletzt';

  @override
  String get tabSearch => 'Suchen';

  @override
  String get tabFavorites => 'Favoriten';

  @override
  String get fabCreateOwnFood => 'Eigenes Lebensmittel';

  @override
  String get recentEmptyState =>
      'Deine zuletzt verwendeten Lebensmittel\nerscheinen hier.';

  @override
  String get favoritesEmptyState =>
      'Du hast noch keine Favoriten.\nMarkiere ein Lebensmittel mit dem Herz-Icon, um es hier zu sehen.';

  @override
  String get searchInitialHint => 'Bitte gib einen Suchbegriff ein.';

  @override
  String get searchNoResults => 'Keine Ergebnisse gefunden.';

  @override
  String get createFoodScreenTitle => 'Eigenes Lebensmittel erstellen';

  @override
  String get formFieldName => 'Name des Lebensmittels';

  @override
  String get formFieldBrand => 'Marke (optional)';

  @override
  String get formSectionMainNutrients => 'Haupt-Nährwerte (pro 100g)';

  @override
  String get formFieldCalories => 'Kalorien (kcal)';

  @override
  String get formFieldProtein => 'Protein (g)';

  @override
  String get formFieldCarbs => 'Kohlenhydrate (g)';

  @override
  String get formFieldFat => 'Fett (g)';

  @override
  String get formSectionOptionalNutrients =>
      'Weitere Nährwerte (optional, pro 100g)';

  @override
  String get formFieldSugar => 'Davon Zucker (g)';

  @override
  String get formFieldFiber => 'Ballaststoffe (g)';

  @override
  String get formFieldKj => 'Kilojoule (kJ)';

  @override
  String get formFieldSalt => 'Salz (g)';

  @override
  String get formFieldSodium => 'Natrium (mg)';

  @override
  String get formFieldCalcium => 'Kalzium (mg)';

  @override
  String get buttonSave => 'Speichern';

  @override
  String get validatorPleaseEnterName => 'Bitte gib einen Namen ein.';

  @override
  String get validatorPleaseEnterNumber => 'Bitte gib eine gültige Zahl ein.';

  @override
  String snackbarSaveSuccess(String foodName) {
    return '$foodName wurde erfolgreich gespeichert.';
  }

  @override
  String get foodDetailSegmentPortion => 'Portion';

  @override
  String get foodDetailSegment100g => '100g';

  @override
  String get sugar => 'Zucker';

  @override
  String get fiber => 'Ballaststoffe';

  @override
  String get salt => 'Salz';

  @override
  String get explorerScreenTitle => 'Lebensmittel-Explorer';

  @override
  String get nutritionScreenTitle => 'Ernährungsanalyse';

  @override
  String get entriesForDateRangeLabel => 'Einträge für';

  @override
  String get noEntriesForPeriod => 'Noch keine Einträge für diesen Zeitraum.';

  @override
  String get waterEntryTitle => 'Wasser';

  @override
  String get profileScreenTitle => 'Profil';

  @override
  String get profileDailyGoals => 'Tägliche Ziele';

  @override
  String get profileDailyGoalsCL => 'TÄGLICHE ZIELE';

  @override
  String get snackbarGoalsSaved => 'Ziele erfolgreich gespeichert!';

  @override
  String get measurementsScreenTitle => 'Messwerte';

  @override
  String get measurementsEmptyState =>
      'Noch keine Messwerte erfasst.\nBeginne mit dem \'+\' Button.';

  @override
  String get addMeasurementDialogTitle => 'Neuer Messwert';

  @override
  String get formFieldMeasurementType => 'Art der Messung';

  @override
  String formFieldMeasurementValue(Object unit) {
    return 'Wert ($unit)';
  }

  @override
  String get validatorPleaseEnterValue => 'Bitte Wert eingeben';

  @override
  String get measurementWeight => 'Körpergewicht';

  @override
  String get measurementFatPercent => 'Körperfett';

  @override
  String get measurementNeck => 'Nacken';

  @override
  String get measurementShoulder => 'Schulter';

  @override
  String get measurementChest => 'Brust';

  @override
  String get measurementLeftBicep => 'Linker Bizeps';

  @override
  String get measurementRightBicep => 'Rechter Bizeps';

  @override
  String get measurementLeftForearm => 'Linker Unterarm';

  @override
  String get measurementRightForearm => 'Rechter Unterarm';

  @override
  String get measurementAbdomen => 'Bauch';

  @override
  String get measurementWaist => 'Taille';

  @override
  String get measurementHips => 'Hüfte';

  @override
  String get measurementLeftThigh => 'Linker Oberschenkel';

  @override
  String get measurementRightThigh => 'Rechter Oberschenkel';

  @override
  String get measurementLeftCalf => 'Linke Wade';

  @override
  String get measurementRightCalf => 'Rechte Wade';

  @override
  String get drawerMenuTitle => 'Hypertrack Menü';

  @override
  String get drawerDashboard => 'Dashboard';

  @override
  String get drawerFoodExplorer => 'Lebensmittel-Explorer';

  @override
  String get drawerDataManagement => 'Datensicherung';

  @override
  String get drawerMeasurements => 'Messwerte';

  @override
  String get dataManagementTitle => 'Datensicherung';

  @override
  String get exportCardTitle => 'Daten exportieren';

  @override
  String get exportCardDescription =>
      'Sichert alle deine Tagebucheinträge, Favoriten und eigenen Lebensmittel in einer einzigen Backup-Datei.';

  @override
  String get exportCardButton => 'Backup erstellen';

  @override
  String get importCardTitle => 'Daten importieren';

  @override
  String get importCardDescription =>
      'Stellt deine Daten aus einer zuvor erstellten Backup-Datei wieder her. ACHTUNG: Alle aktuell in der App gespeicherten Daten werden dabei überschrieben!';

  @override
  String get importCardButton => 'Backup wiederherstellen';

  @override
  String get recommendationDefault => 'Tracke deine erste Mahlzeit!';

  @override
  String recommendationOverTarget(Object count, Object difference) {
    return 'Letzte $count Tage: +$difference kcal über dem Ziel';
  }

  @override
  String recommendationUnderTarget(Object count, Object difference) {
    return 'Letzte $count Tage: $difference kcal unter dem Ziel';
  }

  @override
  String recommendationOnTarget(Object count) {
    return 'Letzte $count Tage: Ziel erreicht ✅';
  }

  @override
  String get recommendationFirstEntry =>
      'Super, dein erster Eintrag ist gemacht!';

  @override
  String get dialogConfirmTitle => 'Bestätigung erforderlich';

  @override
  String get dialogConfirmImportContent =>
      'Möchtest du wirklich die Daten aus diesem Backup wiederherstellen?\n\nACHTUNG: Alle deine aktuellen Einträge, Favoriten und eigenen Lebensmittel werden unwiderruflich gelöscht und ersetzt.';

  @override
  String get dialogButtonCancel => 'Abbrechen';

  @override
  String get dialogButtonOverwrite => 'Ja, alles überschreiben';

  @override
  String get snackbarNoFileSelected => 'Keine Datei ausgewählt.';

  @override
  String get snackbarImportSuccessTitle => 'Import erfolgreich!';

  @override
  String get snackbarImportSuccessContent =>
      'Deine Daten wurden wiederhergestellt. Für eine korrekte Anzeige wird empfohlen, die App jetzt neu zu starten.';

  @override
  String get snackbarButtonOK => 'OK';

  @override
  String get snackbarImportError => 'Fehler beim Importieren der Daten.';

  @override
  String get snackbarExportSuccess =>
      'Backup-Datei wurde an das System übergeben. Bitte wähle einen Speicherort.';

  @override
  String get snackbarExportFailed => 'Export abgebrochen oder fehlgeschlagen.';

  @override
  String get profileUserHeight => 'Körpergröße (cm)';

  @override
  String get workoutRoutinesTitle => 'Trainingspläne';

  @override
  String get workoutHistoryTitle => 'Workout-Verlauf';

  @override
  String get workoutHistoryButton => 'Verlauf';

  @override
  String get emptyRoutinesTitle => 'Keine Trainingspläne gefunden';

  @override
  String get emptyRoutinesSubtitle =>
      'Erstelle deinen ersten Trainingsplan oder starte ein freies Training.';

  @override
  String get createFirstRoutineButton => 'Ersten Plan erstellen';

  @override
  String get startEmptyWorkoutButton => 'Freies Training';

  @override
  String get editRoutineSubtitle =>
      'Tippen zum Bearbeiten, oder starte das Training.';

  @override
  String get startButton => 'Start';

  @override
  String get addRoutineButton => 'Neue Routine';

  @override
  String get freeWorkoutTitle => 'Freies Training';

  @override
  String get finishWorkoutButton => 'Beenden';

  @override
  String get addSetButton => 'Satz hinzufügen';

  @override
  String get addExerciseToWorkoutButton => 'Übung zum Workout hinzufügen';

  @override
  String get lastTimeLabel => 'Letztes Mal';

  @override
  String get setLabel => 'Satz';

  @override
  String get kgLabel => 'Gewicht (kg)';

  @override
  String get repsLabel => 'Wdh';

  @override
  String get restTimerLabel => 'Pause';

  @override
  String get skipButton => 'Überspringen';

  @override
  String get emptyHistory => 'Noch keine Workouts abgeschlossen.';

  @override
  String get workoutDetailsTitle => 'Workout-Details';

  @override
  String get workoutNotFound => 'Workout nicht gefunden.';

  @override
  String get totalVolumeLabel => 'Gesamtvolumen';

  @override
  String get notesLabel => 'Notizen';

  @override
  String get hevyImportTitle => 'Hevy Import';

  @override
  String get hevyImportDescription =>
      'Importiere deine gesamte Trainings-Historie aus einer Hevy CSV-Exportdatei.';

  @override
  String get hevyImportButton => 'Hevy-Daten importieren';

  @override
  String hevyImportSuccess(Object count) {
    return '$count Workouts erfolgreich importiert!';
  }

  @override
  String get hevyImportFailed =>
      'Import fehlgeschlagen. Bitte überprüfe die Datei.';

  @override
  String get startWorkout => 'Workout starten';

  @override
  String get addMeasurement => 'Messwert hinzufügen';

  @override
  String get filterToday => 'Heute';

  @override
  String get filter7Days => '7 Tage';

  @override
  String get filter30Days => '30 Tage';

  @override
  String get filterAll => 'Alle';

  @override
  String get showLess => 'Weniger anzeigen';

  @override
  String get showMoreDetails => 'Mehr Details anzeigen';

  @override
  String get deleteConfirmTitle => 'Löschen bestätigen';

  @override
  String get deleteConfirmContent =>
      'Möchtest du diesen Eintrag wirklich löschen?';

  @override
  String get cancel => 'Abbrechen';

  @override
  String get delete => 'Löschen';

  @override
  String get save => 'Speichern';

  @override
  String get tabBaseFoods => 'Grundnahrungsmittel';

  @override
  String get baseFoodsEmptyState =>
      'Dieser Bereich wird bald mit einer kuratierten Liste von Grundnahrungsmitteln wie Obst, Gemüse und mehr gefüllt sein.';

  @override
  String get noBrand => 'Keine Marke';

  @override
  String get unknown => 'Unbekannt';

  @override
  String backupFileSubject(String timestamp) {
    return 'Hypertrack App Backup - $timestamp';
  }

  @override
  String foodItemSubtitle(String brand, int calories) {
    return '$brand - $calories kcal / 100g';
  }

  @override
  String foodListSubtitle(int grams, String time) {
    return '${grams}g - $time';
  }

  @override
  String foodListTrailingKcal(int calories) {
    return '$calories kcal';
  }

  @override
  String waterListTrailingMl(int milliliters) {
    return '$milliliters ml';
  }

  @override
  String get exerciseCatalogTitle => 'Übungskatalog';

  @override
  String get filterByMuscle => 'Nach Muskelgruppe filtern';

  @override
  String get noExercisesFound => 'Keine Übungen gefunden.';

  @override
  String get noDescriptionAvailable => 'Keine Beschreibung verfügbar.';

  @override
  String get filterByCategory => 'Nach Kategorie filtern';

  @override
  String get edit => 'Bearbeiten';

  @override
  String get repsLabelShort => 'Wdh';

  @override
  String get titleNewRoutine => 'Neue Routine';

  @override
  String get titleEditRoutine => 'Routine bearbeiten';

  @override
  String get validatorPleaseEnterRoutineName =>
      'Bitte gib der Routine einen Namen.';

  @override
  String get snackbarRoutineCreated =>
      'Routine erstellt. Füge nun Übungen hinzu.';

  @override
  String get snackbarRoutineSaved => 'Routine gespeichert.';

  @override
  String get formFieldRoutineName => 'Name der Routine';

  @override
  String get emptyStateAddFirstExercise => 'Füge deine erste Übung hinzu.';

  @override
  String setCount(int count) {
    String _temp0 = intl.Intl.pluralLogic(
      count,
      locale: localeName,
      other: '$count Sätze',
      one: '1 Satz',
    );
    return '$_temp0';
  }

  @override
  String get fabAddExercise => 'Übung hinzufügen';

  @override
  String get kgLabelShort => 'kg';

  @override
  String get drawerExerciseCatalog => 'Übungskatalog';

  @override
  String get lastWorkoutTitle => 'Letztes Workout';

  @override
  String get repeatButton => 'Wiederholen';

  @override
  String get weightHistoryTitle => 'Gewichtsverlauf';

  @override
  String get hideSummary => 'Übersicht ausblenden';

  @override
  String get showSummary => 'Übersicht einblenden';

  @override
  String get exerciseDataAttribution => 'Übungsdaten von wger';

  @override
  String get duplicate => 'Duplizieren';

  @override
  String deleteRoutineConfirmContent(String routineName) {
    return 'Möchtest du den Trainingsplan \'$routineName\' wirklich unwiderruflich löschen?';
  }

  @override
  String get editPauseTimeTitle => 'Pausendauer bearbeiten';

  @override
  String get pauseInSeconds => 'Pause in Sekunden';

  @override
  String get editPauseTime => 'Pause bearbeiten';

  @override
  String pauseDuration(int seconds) {
    return '$seconds Sekunden Pause';
  }

  @override
  String maxPauseDuration(int seconds) {
    return 'Pausen bis zu ${seconds}s';
  }

  @override
  String get deleteWorkoutConfirmContent =>
      'Möchtest du dieses protokollierte Workout wirklich unwiderruflich löschen?';

  @override
  String get removeExercise => 'Übung entfernen';

  @override
  String get deleteExerciseConfirmTitle => 'Übung entfernen?';

  @override
  String deleteExerciseConfirmContent(String exerciseName) {
    return 'Möchtest du \'$exerciseName\' wirklich aus diesem Trainingsplan entfernen?';
  }

  @override
  String get doneButtonLabel => 'Fertig';

  @override
  String get setRestTimeButton => 'Pause einstellen';

  @override
  String get deleteExerciseButton => 'Übung löschen';

  @override
  String get restOverLabel => 'Pause vorbei';

  @override
  String get workoutRunningLabel => 'Workout läuft …';

  @override
  String get continueButton => 'Weiter';

  @override
  String get discardButton => 'Verwerfen';

  @override
  String get workoutStatsTitle => 'Training (7 Tage)';

  @override
  String get workoutsLabel => 'Workouts';

  @override
  String get durationLabel => 'Dauer';

  @override
  String get volumeLabel => 'Volumen';

  @override
  String get setsLabel => 'Sätze';

  @override
  String get muscleSplitLabel => 'Muskel-Split';

  @override
  String get snackbar_could_not_open_open_link => 'Konnte Link nicht öffnen';

  @override
  String get chart_no_data_for_period => 'Keine Daten für diesen Zeitraum.';

  @override
  String get amount_in_milliliters => 'Menge in Millilitern';

  @override
  String get amount_in_grams => 'Menge in Gramm';

  @override
  String get meal_label => 'Mahlzeit';

  @override
  String get add_to_water_intake => 'Zur Trinkmenge hinzufügen';

  @override
  String get create_exercise_screen_title => 'Eigene Übung erstellen';

  @override
  String get exercise_name_label => 'Name der Übung';

  @override
  String get category_label => 'Kategorie';

  @override
  String get description_optional_label => 'Beschreibung (optional)';

  @override
  String get primary_muscles_label => 'Primäre Muskeln';

  @override
  String get primary_muscles_hint => 'z.B. Brust, Trizeps';

  @override
  String get secondary_muscles_label => 'Sekundäre Muskeln (optional)';

  @override
  String get secondary_muscles_hint => 'z.B. Schultern';

  @override
  String get set_type_normal => 'Normal';

  @override
  String get set_type_warmup => 'Warmup';

  @override
  String get set_type_failure => 'Failure';

  @override
  String get set_type_dropset => 'Dropset';

  @override
  String get set_reps_hint => '8-12';

  @override
  String get data_export_button => 'Exportieren';

  @override
  String get data_import_button => 'Importieren';

  @override
  String get snackbar_button_ok => 'OK';

  @override
  String get measurement_session_detail_view =>
      'Detailansicht der Messsession.';

  @override
  String get unit_grams => 'g';

  @override
  String get unit_kcal => 'kcal';

  @override
  String get delete_profile_picture_button => 'Profilbild löschen';

  @override
  String get attribution_title => 'Attribution';

  @override
  String get add_liquid_title => 'Flüssigkeit hinzufügen';

  @override
  String get add_button => 'Hinzufügen';

  @override
  String get discard_button => 'Verwerfen';

  @override
  String get continue_workout_button => 'Fortsetzen';

  @override
  String get soon_available_snackbar =>
      'Dieser Screen wird bald verfügbar sein!';

  @override
  String get start_button => 'Start';

  @override
  String get today_overview_text => 'HEUTE IM BLICK';

  @override
  String get quick_add_text => 'SCHNELLES HINZUFÜGEN';

  @override
  String get scann_barcode_capslock => 'Barcode scannen';

  @override
  String get protocol_today_capslock => 'HEUTIGES PROTOKOLL';

  @override
  String get my_plans_capslock => 'MEINE PLÄNE';

  @override
  String get overview_capslock => 'ÜBERBLICK';

  @override
  String get manage_all_plans => 'Alle Pläne verwalten';

  @override
  String get free_training => 'Freies Training';

  @override
  String get my_consistency => 'MEINE KONSISTENZ';

  @override
  String get calendar_currently_not_available =>
      'Die Kalender-Ansicht ist in Kürze verfügbar.';

  @override
  String get in_depth_analysis => 'TIEFEN-ANALYSE';

  @override
  String get body_measurements => 'Körpermaße';

  @override
  String get measurements_description =>
      'Gewicht, KFA und Umfänge analysieren.';

  @override
  String get nutrition_description => 'Makros, Kalorien und Trends auswerten.';

  @override
  String get training_analysis => 'Trainings-Analyse';

  @override
  String get training_analysis_description =>
      'Volumen, Kraft und Progression verfolgen.';

  @override
  String get load_dots => 'lade...';

  @override
  String get profile_capslock => 'PROFIL';

  @override
  String get settings_capslock => 'EINSTELLUNGEN';

  @override
  String get settingsTitle => 'Einstellungen';

  @override
  String get my_goals => 'Meine Ziele';

  @override
  String get my_goals_description => 'Kalorien, Makros und Wasser anpassen.';

  @override
  String get backup_and_import => 'Datensicherung & Import';

  @override
  String get backup_and_import_description =>
      'Backups erstellen, wiederherstellen und Daten importieren.';

  @override
  String get about_and_legal_capslock => 'ÜBER & RECHTLICHES';

  @override
  String get attribution_and_license => 'Attribution & Lizenzen';

  @override
  String get data_from_off_and_wger => 'Daten von Open Food Facts und wger.';

  @override
  String get app_version => 'App Version';

  @override
  String get all_measurements => 'ALLE MESSWERTE';

  @override
  String get date_and_time_of_measurement => 'Datum & Uhrzeit der Messung';

  @override
  String get onbWelcomeTitle => 'Willkommen bei Hypertrack';

  @override
  String get onbWelcomeBody =>
      'Starte mit deinen persönlichen Zielen für Training und Ernährung.';

  @override
  String get onbTrackTitle => 'Alles tracken';

  @override
  String get onbTrackBody =>
      'Erfasse Ernährung, Workouts und Messwerte — alles an einem Ort.';

  @override
  String get onbPrivacyTitle => 'Offline-first & Privatsphäre';

  @override
  String get onbPrivacyBody =>
      'Deine Daten bleiben auf dem Gerät. Keine Cloud-Konten, kein Hintergrund-Sync.';

  @override
  String get onbFinishTitle => 'Alles bereit';

  @override
  String get onbFinishBody =>
      'Du kannst loslegen. Einstellungen lassen sich jederzeit anpassen.';

  @override
  String get onbFinishCta => 'Los geht’s!';

  @override
  String get onbShowTutorialAgain => 'Tutorial erneut anzeigen';

  @override
  String get onbSetGoalsCta => 'Ziele festlegen';

  @override
  String get onbHeaderTitle => 'Tutorial';

  @override
  String get onbHeaderSkip => 'Überspringen';

  @override
  String get onbBack => 'Zurück';

  @override
  String get onbNext => 'Weiter';

  @override
  String get onbGuideTitle => 'So funktioniert das Tutorial';

  @override
  String get onbGuideBody =>
      'Wische zwischen den Folien oder nutze Weiter. Tippe die Buttons auf jeder Folie, um Funktionen auszuprobieren. Du kannst jederzeit über Überspringen beenden.';

  @override
  String get onbCtaOpenNutrition => 'Ernährung öffnen';

  @override
  String get onbCtaLearnMore => 'Mehr erfahren';

  @override
  String get onbBadgeDone => 'Erledigt';

  @override
  String get onbTipSetGoals => 'Tipp: Lege zuerst deine Ziele fest';

  @override
  String get onbTipAddEntry => 'Tipp: Füge heute einen Eintrag hinzu';

  @override
  String get onbTipLocalControl => 'Du kontrollierst alle Daten lokal';

  @override
  String get onbTrackHowBody =>
      'So erfasst du Ernährung:\n• Öffne den Tab „Food“.\n• Tippe auf das + Symbol.\n• Suche Produkte oder scanne einen Barcode.\n• Passe Portion und Uhrzeit an.\n• Speichere in deinem Tagebuch.';

  @override
  String get onbMeasureTitle => 'Messwerte erfassen';

  @override
  String get onbMeasureBody =>
      'So fügst du Messungen hinzu:\n• Öffne den Tab „Stats“.\n• Tippe auf das + Symbol.\n• Wähle eine Messgröße (z. B. Gewicht, Taille, KFA).\n• Gib Wert und Uhrzeit ein.\n• Speichere deinen Eintrag.';

  @override
  String get onbTipMeasureToday =>
      'Tipp: Trage dein heutiges Gewicht ein, um den Graphen zu starten';

  @override
  String get onbTrainTitle => 'Trainieren mit Routinen';

  @override
  String get onbTrainBody =>
      'Routine erstellen und Workout starten:\n• Öffne den Tab „Train“.\n• Tippe auf Routine erstellen und füge Übungen und Sätze hinzu.\n• Speichere die Routine.\n• Tippe auf Start, um zu beginnen – oder nutze „Freies Training starten“.';

  @override
  String get onbTipStartWorkout =>
      'Tipp: Starte ein freies Training für eine schnelle Einheit';

  @override
  String get unitsSection => 'Einheiten';

  @override
  String get weightUnit => 'Gewichtseinheit';

  @override
  String get lengthUnit => 'Längeneinheit';

  @override
  String get comingSoon => 'In Kürze verfügbar';

  @override
  String get noFavorites => 'Keine Favoriten';

  @override
  String get nothingTrackedYet => 'Noch nichts erfasst';

  @override
  String snackbarBarcodeNotFound(String barcode) {
    return 'Kein Produkt für Barcode \"$barcode\" gefunden.';
  }

  @override
  String get categoryHint => 'z.B. Brust, Rücken, Beine...';

  @override
  String get validatorPleaseEnterCategory => 'Bitte eine Kategorie angeben.';

  @override
  String get dialogEnterPasswordImport => 'Passwort für den Import eingeben';

  @override
  String get dataManagementBackupTitle => 'Hypertrack Datensicherung';

  @override
  String get dataManagementBackupDescription =>
      'Sichere oder wiederherstelle alle deine App-Daten. Ideal für einen Gerätewechsel.';

  @override
  String get exportEncrypted => 'Verschlüsselt exportieren';

  @override
  String get dialogPasswordForExport => 'Passwort für verschlüsselten Export';

  @override
  String get snackbarEncryptedBackupShared => 'Verschlüsseltes Backup geteilt.';

  @override
  String get exportFailed => 'Export fehlgeschlagen.';

  @override
  String get csvExportTitle => 'Daten-Export (CSV)';

  @override
  String get csvExportDescription =>
      'Exportiere Teile deiner Daten als CSV-Datei zur Analyse in anderen Programmen.';

  @override
  String get snackbarSharingNutrition => 'Ernährungstagebuch wird geteilt...';

  @override
  String get snackbarExportFailedNoEntries =>
      'Export fehlgeschlagen. Eventuell existieren noch keine Einträge.';

  @override
  String get snackbarSharingMeasurements => 'Messwerte werden geteilt...';

  @override
  String get snackbarSharingWorkouts => 'Trainingsverlauf wird geteilt...';

  @override
  String get mapExercisesTitle => 'Übungen zuordnen';

  @override
  String get mapExercisesDescription =>
      'Unbekannte Namen aus Logs auf wger-Übungen mappen.';

  @override
  String get mapExercisesButton => 'Mapping starten';

  @override
  String get autoBackupTitle => 'Automatische Backups';

  @override
  String get autoBackupDescription =>
      'Legt periodisch eine Sicherung im Ordner ab. Derzeitiger Ordner:';

  @override
  String get autoBackupDefaultFolder => 'App-Dokumente/Backups (Standard)';

  @override
  String get autoBackupChooseFolder => 'Ordner wählen';

  @override
  String get autoBackupCopyPath => 'Pfad kopieren';

  @override
  String get autoBackupRunNow => 'Jetzt Auto-Backup prüfen & ausführen';

  @override
  String get snackbarAutoBackupSuccess => 'Auto-Backup durchgeführt.';

  @override
  String get snackbarAutoBackupFailed =>
      'Auto-Backup fehlgeschlagen oder abgebrochen.';

  @override
  String get noUnknownExercisesFound => 'Keine unbekannten Übungen gefunden';

  @override
  String snackbarAutoBackupFolderSet(String path) {
    return 'Auto-Backup-Ordner gesetzt:\n$path';
  }

  @override
  String get snackbarPathCopied => 'Pfad kopiert';

  @override
  String get passwordLabel => 'Passwort';

  @override
  String get descriptionLabel => 'Beschreibung';

  @override
  String get involvedMuscles => 'Involvierte Muskeln';

  @override
  String get primaryLabel => 'Primär:';

  @override
  String get secondaryLabel => 'Sekundär:';

  @override
  String get noMusclesSpecified => 'Keine Muskeln angegeben.';

  @override
  String get noSelection => 'Keine Auswahl';

  @override
  String get selectButton => 'Auswählen';

  @override
  String get applyingChanges => 'Wird angewendet...';

  @override
  String get applyMapping => 'Zuordnung anwenden';

  @override
  String get personalData => 'Persönliche Daten';

  @override
  String get personalDataCL => 'PERSÖNLICHE DATEN';

  @override
  String get macroDistribution => 'Makronährstoff-Verteilung';

  @override
  String get dialogFinishWorkoutBody =>
      'Möchtest du dieses Workout wirklich abschließen?';

  @override
  String get attributionText =>
      'Diese App verwendet Daten von externen Quellen:\n\n● Übungsdaten und Bilder von wger (wger.de), lizenziert unter der CC-BY-SA 4.0 Lizenz.\n\n● Lebensmittel-Datenbank von Open Food Facts (openfoodfacts.org), verfügbar unter der Open Database License (ODbL).';

  @override
  String get errorRoutineNotFound => 'Routine nicht gefunden';

  @override
  String get workoutHistoryEmptyTitle => 'Dein Verlauf ist leer';

  @override
  String get workoutSummaryTitle => 'Workout Abgeschlossen';

  @override
  String get workoutSummaryExerciseOverview => 'Übersicht der Übungen';

  @override
  String get nutritionDiary => 'Ernährungstagebuch';

  @override
  String get detailedNutrientGoals => 'Detail-Nährwerte';

  @override
  String get detailedNutrientGoalsCL => 'DETAIL-NÄHRWERTE';

  @override
  String get supplementTrackerTitle => 'Supplement-Tracker';

  @override
  String get supplementTrackerDescription =>
      'Ziele, Limits und Einnahmen verfolgen.';

  @override
  String get createSupplementTitle => 'Supplement erstellen';

  @override
  String get supplementNameLabel => 'Name des Supplements';

  @override
  String get defaultDoseLabel => 'Standard-Dosis';

  @override
  String get unitLabel => 'Einheit';

  @override
  String get dailyGoalLabel => 'Tagesziel (optional)';

  @override
  String get dailyLimitLabel => 'Tageslimit (optional)';

  @override
  String get dailyProgressTitle => 'Tagesfortschritt';

  @override
  String get todaysLogTitle => 'Heutiges Protokoll';

  @override
  String get logIntakeTitle => 'Einnahme protokollieren';

  @override
  String get emptySupplementGoals =>
      'Lege Ziele oder Limits für Supplements fest, um deinen Fortschritt hier zu sehen.';

  @override
  String get emptySupplementLogs =>
      'Noch keine Einnahmen für heute protokolliert.';

  @override
  String get doseLabel => 'Dosis';

  @override
  String get settingsDescription => 'Thema, Einheiten, Daten und mehr';

  @override
  String get settingsAppearance => 'Erscheinungsbild';

  @override
  String get themeSystem => 'System';

  @override
  String get themeLight => 'Hell';

  @override
  String get themeDark => 'Dunkel';

  @override
  String get caffeinePrompt => 'Koffein (optional)';

  @override
  String get caffeineUnit => 'mg pro 100ml';

  @override
  String get profile => 'Profil';

  @override
  String get measurementWeightCapslock => 'KÖRPERGEWICHT';

  @override
  String get diary => 'Tagebuch';

  @override
  String get analysis => 'Analyse';

  @override
  String get yesterday => 'Gestern';

  @override
  String get dayBeforeYesterday => 'Vorgestern';

  @override
  String get statistics => 'Statistiken';

  @override
  String get workout => 'Workout';

  @override
  String get addFoodTitle => 'Lebensmittel hinzufügen';

  @override
  String get nutritionExplorerTitle => 'Lebensmittel Explorer';

  @override
  String get myMeals => 'Meine Mahlzeiten';

  @override
  String get myMealsCL => 'MEINE MAHLZEITEN';

  @override
  String get supplement_caffeine => 'Koffein';

  @override
  String get supplement_creatine_monohydrate => 'Kreatin Monohydrat';

  @override
  String get manageSupplementsTitle => 'Supplements verwalten';

  @override
  String get deleted => 'Gelöscht';

  @override
  String get operationNotAllowed => 'Diese Aktion nicht erlaubt.';

  @override
  String get emptySupplements => 'Noch keine Supplements vorhanden';

  @override
  String get undo => 'Rückgängig';

  @override
  String get deleteSupplementConfirm =>
      'Supplement wirklich löschen? Alle zugehörigen Einträge werden entfernt.';

  @override
  String get fieldRequired => 'Pflichtfeld';

  @override
  String get unitNotSupported => 'Einheit wird nicht unterstützt.';

  @override
  String get caffeineUnitLocked => 'Bei Koffein ist die Einheit fest: mg.';

  @override
  String get caffeineMustBeMg => 'Koffein muss in mg erfasst werden.';

  @override
  String get tabCatalogSearch => 'Katalog';

  @override
  String get tabMeals => 'Mahlzeiten';

  @override
  String get emptyCategory => 'Keine Einträge';

  @override
  String get searchSectionBase => 'Grundnahrungsmittel';

  @override
  String get searchSectionOther => 'Weitere Treffer';

  @override
  String get mealsComingSoonTitle => 'Mahlzeiten (in Vorbereitung)';

  @override
  String get mealsComingSoonBody =>
      'Bald kannst du eigene Mahlzeiten aus mehreren Lebensmitteln zusammenstellen.';

  @override
  String get mealsEmptyTitle => 'Noch keine Mahlzeiten';

  @override
  String get mealsEmptyBody =>
      'Lege Mahlzeiten an, um mehrere Lebensmittel mit einem Klick einzutragen.';

  @override
  String get mealsCreate => 'Mahlzeit erstellen';

  @override
  String get mealsEdit => 'Mahlzeit bearbeiten';

  @override
  String get mealsDelete => 'Mahlzeit löschen';

  @override
  String get mealsAddToDiary => 'Zum Tagebuch hinzufügen';

  @override
  String get mealNameLabel => 'Name der Mahlzeit';

  @override
  String get mealNotesLabel => 'Notizen';

  @override
  String get mealIngredientsTitle => 'Zutaten';

  @override
  String get mealAddIngredient => 'Zutat hinzufügen';

  @override
  String get mealIngredientAmountLabel => 'Menge';

  @override
  String get mealDeleteConfirmTitle => 'Mahlzeit löschen';

  @override
  String mealDeleteConfirmBody(Object name) {
    return 'Möchtest du die Mahlzeit \'$name\' wirklich löschen? Alle Zutaten werden ebenfalls entfernt.';
  }

  @override
  String mealAddedToDiary(Object name) {
    return 'Mahlzeit \'$name\' wurde ins Tagebuch übernommen.';
  }

  @override
  String get mealSaved => 'Mahlzeit gespeichert.';

  @override
  String get mealDeleted => 'Mahlzeit gelöscht.';

  @override
  String get confirm => 'bestätigen';

  @override
  String get addMealToDiaryTitle => 'Zum Tagebuch hinzufügen';

  @override
  String get mealTypeLabel => 'Mahlzeit';

  @override
  String get amountLabel => 'Menge';

  @override
  String get mealAddedToDiarySuccess => 'Mahlzeit zum Tagebuch hinzugefügt';

  @override
  String get error => 'Fehler';

  @override
  String get mealsViewTitle => 'mealsViewTitle';

  @override
  String get noNotes => 'Keine Notizen';

  @override
  String get ingredientsCapsLock => 'ZUTATEN';

  @override
  String get nutritionSectionLabel => 'NÄHRWERTE';

  @override
  String get nutritionCalculatedForCurrentAmounts => 'für aktuelle Mengen';

  @override
  String get startCapsLock => 'START';

  @override
  String get nutritionHubSubtitle =>
      'Entdecke Einblicke, verfolge Mahlzeiten und erstelle hier bald deinen Ernährungsplan.';

  @override
  String get nutritionHubTitle => 'Ernährung';

  @override
  String get nutrition => 'Ernährung';

  @override
  String get changeSetTypTitle => 'Satztyp ändern';

  @override
  String get settingsVisualStyleTitle => 'Visueller Stil';

  @override
  String get settingsVisualStyleStandard => 'Standard (Glas)';

  @override
  String get settingsVisualStyleLiquid => 'Flüssig (Liquid Glass)';

  @override
  String get settingsVisualStyleLiquidDesc => 'Runde, schwebende UI-Elemente';

  @override
  String get searchBaseFoodHint => 'Suche Grundnahrungsmittel';

  @override
  String get searchNoHits => 'Keine Treffer.';

  @override
  String get onbSubtitleWelcome =>
      'Dein zentrales Werkzeug für Fitness, Ernährung & Fortschritt.';

  @override
  String get onbBodyWelcome =>
      'Wir helfen dir, deine Ziele zu setzen und zu verfolgen. Du kannst Workouts, Ernährung, Supps und Körpermaße effizient protokollieren.';

  @override
  String get onbBodyNutritionVisual =>
      'Erfasse Mahlzeiten mit wenigen Klicks. Behalte Kalorien, Makros und Wasser im Blick, um dein Ziel mühelos zu verfolgen.';

  @override
  String get onbBodyMeasurementsVisual =>
      'Visualisiere deinen Fortschritt. Der Gewichts- und Umfangsverlauf macht deinen Erfolg sichtbar und motiviert dich.';

  @override
  String get onbBodyWorkoutVisual =>
      'Erstelle Routinen und starte dein Training in Sekunden. Protokolliere Sätze, Gewichte und Pausen für maximale Progression.';

  @override
  String get onbTitleAppLayout => 'Navigation & Quick-Add';

  @override
  String get onbBodyAppLayout =>
      'Die Bottom Bar ermöglicht den schnellen Wechsel zwischen den Bereichen. Mit dem großen [+] Button kannst du sofort alles protokollieren.';

  @override
  String get dataHubTitle => 'Data Hub';

  @override
  String get resumeButton => 'Fortsetzen';
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/generated/app_localizations_en.dart =====

// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for English (`en`).
class AppLocalizationsEn extends AppLocalizations {
  AppLocalizationsEn([String locale = 'en']) : super(locale);

  @override
  String get appTitle => 'Hypertrack';

  @override
  String get bannerText => 'Recommendation / Current Workout';

  @override
  String get calories => 'Calories';

  @override
  String get water => 'Water';

  @override
  String get protein => 'Protein';

  @override
  String get carbs => 'Carbs';

  @override
  String get fat => 'Fat';

  @override
  String get daily => 'Daily';

  @override
  String get today => 'Today';

  @override
  String get workoutSection => 'Workout section - not yet implemented';

  @override
  String get addMenuTitle => 'What do you want to add?';

  @override
  String get addFoodOption => 'add Food';

  @override
  String get addLiquidOption => 'add Liquid';

  @override
  String get searchHintText => 'Search...';

  @override
  String get mealtypeBreakfast => 'Breakfast';

  @override
  String get mealtypeLunch => 'Lunch';

  @override
  String get mealtypeDinner => 'Dinner';

  @override
  String get mealtypeSnack => 'Snack';

  @override
  String get waterHeader => 'Water & Drinks';

  @override
  String get openFoodFactsSource => 'Data from Open Food Facts';

  @override
  String get tabRecent => 'Recent';

  @override
  String get tabSearch => 'Search';

  @override
  String get tabFavorites => 'Favorites';

  @override
  String get fabCreateOwnFood => 'Custom Food';

  @override
  String get recentEmptyState =>
      'Your recently used food items\nwill appear here.';

  @override
  String get favoritesEmptyState =>
      'You don\'t have any favorites yet.\nMark a food with the heart icon to see it here.';

  @override
  String get searchInitialHint => 'Please enter a search term.';

  @override
  String get searchNoResults => 'No results found.';

  @override
  String get createFoodScreenTitle => 'Create Custom Food';

  @override
  String get formFieldName => 'Name of the food';

  @override
  String get formFieldBrand => 'Brand (optional)';

  @override
  String get formSectionMainNutrients => 'Main Nutrients (per 100g)';

  @override
  String get formFieldCalories => 'Calories (kcal)';

  @override
  String get formFieldProtein => 'Protein (g)';

  @override
  String get formFieldCarbs => 'Carbohydrates (g)';

  @override
  String get formFieldFat => 'Fat (g)';

  @override
  String get formSectionOptionalNutrients =>
      'Additional Nutrients (optional, per 100g)';

  @override
  String get formFieldSugar => 'Of which sugars (g)';

  @override
  String get formFieldFiber => 'Fiber (g)';

  @override
  String get formFieldKj => 'Kilojoules (kJ)';

  @override
  String get formFieldSalt => 'Salt (g)';

  @override
  String get formFieldSodium => 'Sodium (mg)';

  @override
  String get formFieldCalcium => 'Calcium (mg)';

  @override
  String get buttonSave => 'Save';

  @override
  String get validatorPleaseEnterName => 'Please enter a name.';

  @override
  String get validatorPleaseEnterNumber => 'Please enter a valid number.';

  @override
  String snackbarSaveSuccess(String foodName) {
    return '$foodName was saved successfully.';
  }

  @override
  String get foodDetailSegmentPortion => 'Portion';

  @override
  String get foodDetailSegment100g => '100g';

  @override
  String get sugar => 'Sugar';

  @override
  String get fiber => 'Fiber';

  @override
  String get salt => 'Salt';

  @override
  String get explorerScreenTitle => 'Food Explorer';

  @override
  String get nutritionScreenTitle => 'Nutrition Analysis';

  @override
  String get entriesForDateRangeLabel => 'Entries for';

  @override
  String get noEntriesForPeriod => 'No entries for this period yet.';

  @override
  String get waterEntryTitle => 'Water';

  @override
  String get profileScreenTitle => 'Profile';

  @override
  String get profileDailyGoals => 'Daily Goals';

  @override
  String get profileDailyGoalsCL => 'DAILY GOALS';

  @override
  String get snackbarGoalsSaved => 'Goals saved successfully!';

  @override
  String get measurementsScreenTitle => 'Measurements';

  @override
  String get measurementsEmptyState =>
      'No measurements recorded yet.\nStart with the \'+\' button.';

  @override
  String get addMeasurementDialogTitle => 'Add New Measurement';

  @override
  String get formFieldMeasurementType => 'Type of Measurement';

  @override
  String formFieldMeasurementValue(Object unit) {
    return 'Value ($unit)';
  }

  @override
  String get validatorPleaseEnterValue => 'Please enter a value';

  @override
  String get measurementWeight => 'Body Weight';

  @override
  String get measurementFatPercent => 'Body Fat';

  @override
  String get measurementNeck => 'Neck';

  @override
  String get measurementShoulder => 'Shoulder';

  @override
  String get measurementChest => 'Chest';

  @override
  String get measurementLeftBicep => 'Left Bicep';

  @override
  String get measurementRightBicep => 'Right Bicep';

  @override
  String get measurementLeftForearm => 'Left Forearm';

  @override
  String get measurementRightForearm => 'Right Forearm';

  @override
  String get measurementAbdomen => 'Abdomen';

  @override
  String get measurementWaist => 'Waist';

  @override
  String get measurementHips => 'Hips';

  @override
  String get measurementLeftThigh => 'Left Thigh';

  @override
  String get measurementRightThigh => 'Right Thigh';

  @override
  String get measurementLeftCalf => 'Left Calf';

  @override
  String get measurementRightCalf => 'Right Calf';

  @override
  String get drawerMenuTitle => 'Hypertrack Menu';

  @override
  String get drawerDashboard => 'Dashboard';

  @override
  String get drawerFoodExplorer => 'Food Explorer';

  @override
  String get drawerDataManagement => 'Data Backup';

  @override
  String get drawerMeasurements => 'Measurements';

  @override
  String get dataManagementTitle => 'Data Backup';

  @override
  String get exportCardTitle => 'Export Data';

  @override
  String get exportCardDescription =>
      'Saves all your journal entries, favorites, and custom foods into a single backup file.';

  @override
  String get exportCardButton => 'Create Backup';

  @override
  String get importCardTitle => 'Import Data';

  @override
  String get importCardDescription =>
      'Restores your data from a previously created backup file. WARNING: All data currently stored in the app will be overwritten!';

  @override
  String get importCardButton => 'Restore Backup';

  @override
  String get recommendationDefault => 'Track your first meal!';

  @override
  String recommendationOverTarget(Object count, Object difference) {
    return 'Last $count days: +$difference kcal over target';
  }

  @override
  String recommendationUnderTarget(Object count, Object difference) {
    return 'Last $count days: $difference kcal under target';
  }

  @override
  String recommendationOnTarget(Object count) {
    return 'Last $count days: Target achieved ✅';
  }

  @override
  String get recommendationFirstEntry => 'Great, your first entry is logged!';

  @override
  String get dialogConfirmTitle => 'Confirmation Required';

  @override
  String get dialogConfirmImportContent =>
      'Do you really want to restore data from this backup?\n\nWARNING: All your current entries, favorites, and custom foods will be permanently deleted and replaced.';

  @override
  String get dialogButtonCancel => 'Cancel';

  @override
  String get dialogButtonOverwrite => 'Yes, overwrite all';

  @override
  String get snackbarNoFileSelected => 'No file selected.';

  @override
  String get snackbarImportSuccessTitle => 'Import successful!';

  @override
  String get snackbarImportSuccessContent =>
      'Your data has been restored. It is recommended to restart the app for a correct display.';

  @override
  String get snackbarButtonOK => 'OK';

  @override
  String get snackbarImportError => 'Error while importing data.';

  @override
  String get snackbarExportSuccess =>
      'Backup file has been passed to the system. Please choose a location to save.';

  @override
  String get snackbarExportFailed => 'Export canceled or failed.';

  @override
  String get profileUserHeight => 'Height (cm)';

  @override
  String get workoutRoutinesTitle => 'Routines';

  @override
  String get workoutHistoryTitle => 'Workout History';

  @override
  String get workoutHistoryButton => 'History';

  @override
  String get emptyRoutinesTitle => 'No Routines Found';

  @override
  String get emptyRoutinesSubtitle =>
      'Create your first routine or start a blank workout.';

  @override
  String get createFirstRoutineButton => 'Create First Routine';

  @override
  String get startEmptyWorkoutButton => 'Free Workout';

  @override
  String get editRoutineSubtitle => 'Tap to edit, or start the workout.';

  @override
  String get startButton => 'Start';

  @override
  String get addRoutineButton => 'New Routine';

  @override
  String get freeWorkoutTitle => 'Free Workout';

  @override
  String get finishWorkoutButton => 'Finish';

  @override
  String get addSetButton => 'Add Set';

  @override
  String get addExerciseToWorkoutButton => 'Add Exercise to Workout';

  @override
  String get lastTimeLabel => 'Last Time';

  @override
  String get setLabel => 'Set';

  @override
  String get kgLabel => 'Weight (kg)';

  @override
  String get repsLabel => 'Reps';

  @override
  String get restTimerLabel => 'Rest';

  @override
  String get skipButton => 'Skip';

  @override
  String get emptyHistory => 'No completed workouts yet.';

  @override
  String get workoutDetailsTitle => 'Workout Details';

  @override
  String get workoutNotFound => 'Workout not found.';

  @override
  String get totalVolumeLabel => 'Total Volume';

  @override
  String get notesLabel => 'Notes';

  @override
  String get hevyImportTitle => 'Hevy Import';

  @override
  String get hevyImportDescription =>
      'Import your entire training history from a Hevy CSV export file.';

  @override
  String get hevyImportButton => 'Import Hevy Data';

  @override
  String hevyImportSuccess(Object count) {
    return 'Successfully imported $count workouts!';
  }

  @override
  String get hevyImportFailed => 'Import failed. Please check the file.';

  @override
  String get startWorkout => 'Start Workout';

  @override
  String get addMeasurement => 'Add Measurement';

  @override
  String get filterToday => 'Today';

  @override
  String get filter7Days => '7 Days';

  @override
  String get filter30Days => '30 Days';

  @override
  String get filterAll => 'All';

  @override
  String get showLess => 'Show less';

  @override
  String get showMoreDetails => 'Show more details';

  @override
  String get deleteConfirmTitle => 'Confirm Deletion';

  @override
  String get deleteConfirmContent => 'Do you really want to delete this entry?';

  @override
  String get cancel => 'Cancel';

  @override
  String get delete => 'Delete';

  @override
  String get save => 'Save';

  @override
  String get tabBaseFoods => 'Base Foods';

  @override
  String get baseFoodsEmptyState =>
      'This section will soon be filled with a curated list of base foods like fruits, vegetables, and more.';

  @override
  String get noBrand => 'No Brand';

  @override
  String get unknown => 'Unknown';

  @override
  String backupFileSubject(String timestamp) {
    return 'Hypertrack App Backup - $timestamp';
  }

  @override
  String foodItemSubtitle(String brand, int calories) {
    return '$brand - $calories kcal / 100g';
  }

  @override
  String foodListSubtitle(int grams, String time) {
    return '${grams}g - $time';
  }

  @override
  String foodListTrailingKcal(int calories) {
    return '$calories kcal';
  }

  @override
  String waterListTrailingMl(int milliliters) {
    return '$milliliters ml';
  }

  @override
  String get exerciseCatalogTitle => 'Exercise Catalog';

  @override
  String get filterByMuscle => 'Filter by muscle group';

  @override
  String get noExercisesFound => 'No exercises found.';

  @override
  String get noDescriptionAvailable => 'No description available.';

  @override
  String get filterByCategory => 'Filter by category';

  @override
  String get edit => 'Edit';

  @override
  String get repsLabelShort => 'reps';

  @override
  String get titleNewRoutine => 'New Routine';

  @override
  String get titleEditRoutine => 'Edit Routine';

  @override
  String get validatorPleaseEnterRoutineName =>
      'Please enter a name for the routine.';

  @override
  String get snackbarRoutineCreated =>
      'Routine created. Now add some exercises.';

  @override
  String get snackbarRoutineSaved => 'Routine saved.';

  @override
  String get formFieldRoutineName => 'Name of the routine';

  @override
  String get emptyStateAddFirstExercise => 'Add your first exercise.';

  @override
  String setCount(int count) {
    String _temp0 = intl.Intl.pluralLogic(
      count,
      locale: localeName,
      other: '$count sets',
      one: '1 set',
    );
    return '$_temp0';
  }

  @override
  String get fabAddExercise => 'Add Exercise';

  @override
  String get kgLabelShort => 'kg';

  @override
  String get drawerExerciseCatalog => 'Exercise Catalog';

  @override
  String get lastWorkoutTitle => 'Last Workout';

  @override
  String get repeatButton => 'Repeat';

  @override
  String get weightHistoryTitle => 'Weight History';

  @override
  String get hideSummary => 'Hide Summary';

  @override
  String get showSummary => 'Show Summary';

  @override
  String get exerciseDataAttribution => 'Exercise data from wger';

  @override
  String get duplicate => 'Duplicate';

  @override
  String deleteRoutineConfirmContent(String routineName) {
    return 'Are you sure you want to permanently delete the routine \'$routineName\'?';
  }

  @override
  String get editPauseTimeTitle => 'Edit Pause Duration';

  @override
  String get pauseInSeconds => 'Pause in seconds';

  @override
  String get editPauseTime => 'Edit Pause';

  @override
  String pauseDuration(int seconds) {
    return '$seconds second pause';
  }

  @override
  String maxPauseDuration(int seconds) {
    return 'Pauses up to ${seconds}s';
  }

  @override
  String get deleteWorkoutConfirmContent =>
      'Are you sure you want to permanently delete this workout log?';

  @override
  String get removeExercise => 'Remove Exercise';

  @override
  String get deleteExerciseConfirmTitle => 'Remove Exercise?';

  @override
  String deleteExerciseConfirmContent(String exerciseName) {
    return 'Are you sure you want to remove \'$exerciseName\' from this routine?';
  }

  @override
  String get doneButtonLabel => 'Done';

  @override
  String get setRestTimeButton => 'Set rest time';

  @override
  String get deleteExerciseButton => 'Delete exercise';

  @override
  String get restOverLabel => 'Pause is over';

  @override
  String get workoutRunningLabel => 'Workout is active …';

  @override
  String get continueButton => 'Continue';

  @override
  String get discardButton => 'Discard';

  @override
  String get workoutStatsTitle => 'Training (7 days)';

  @override
  String get workoutsLabel => 'Workouts';

  @override
  String get durationLabel => 'Duration';

  @override
  String get volumeLabel => 'Volume';

  @override
  String get setsLabel => 'Sets';

  @override
  String get muscleSplitLabel => 'Muscle Split';

  @override
  String get snackbar_could_not_open_open_link => 'Konnte Link nicht öffnen';

  @override
  String get chart_no_data_for_period => 'No chart data for this period';

  @override
  String get amount_in_milliliters => 'Menge in Millilitern';

  @override
  String get amount_in_grams => 'Menge in Gramm';

  @override
  String get meal_label => 'Mahlzeit';

  @override
  String get add_to_water_intake => 'Zur Trinkmenge hinzufügen';

  @override
  String get create_exercise_screen_title => 'Eigene Übung erstellen';

  @override
  String get exercise_name_label => 'Name der Übung';

  @override
  String get category_label => 'Kategorie';

  @override
  String get description_optional_label => 'Beschreibung (optional)';

  @override
  String get primary_muscles_label => 'Primäre Muskeln';

  @override
  String get primary_muscles_hint => 'z.B. Brust, Trizeps';

  @override
  String get secondary_muscles_label => 'Sekundäre Muskeln (optional)';

  @override
  String get secondary_muscles_hint => 'z.B. Schultern';

  @override
  String get set_type_normal => 'Normal';

  @override
  String get set_type_warmup => 'Warmup';

  @override
  String get set_type_failure => 'Failure';

  @override
  String get set_type_dropset => 'Dropset';

  @override
  String get set_reps_hint => '8-12';

  @override
  String get data_export_button => 'Export';

  @override
  String get data_import_button => 'Import';

  @override
  String get snackbar_button_ok => 'OK';

  @override
  String get measurement_session_detail_view =>
      'Detailview of measurement session';

  @override
  String get unit_grams => 'g';

  @override
  String get unit_kcal => 'kcal';

  @override
  String get delete_profile_picture_button => 'Delete profile picture';

  @override
  String get attribution_title => 'Attribution';

  @override
  String get add_liquid_title => 'Add fluid';

  @override
  String get add_button => 'Add';

  @override
  String get discard_button => 'Discard';

  @override
  String get continue_workout_button => 'Continue';

  @override
  String get soon_available_snackbar => 'This screen will be available soon';

  @override
  String get start_button => 'Start';

  @override
  String get today_overview_text => 'TODAY IN FOCUS';

  @override
  String get quick_add_text => 'QUICK ADD';

  @override
  String get scann_barcode_capslock => 'Scan barcode';

  @override
  String get protocol_today_capslock => 'TODAY\'S PROTOCOL';

  @override
  String get my_plans_capslock => 'MY PLANS';

  @override
  String get overview_capslock => 'OVERVIEW';

  @override
  String get manage_all_plans => 'Manage all plans';

  @override
  String get free_training => 'free training';

  @override
  String get my_consistency => 'MY CONSISTENCY';

  @override
  String get calendar_currently_not_available =>
      'The calendar view will be available soon.';

  @override
  String get in_depth_analysis => 'IN-DEPTH ANALYSIS';

  @override
  String get body_measurements => 'Body measurements';

  @override
  String get measurements_description =>
      'Analyze weight, body fat percentage and circumference.';

  @override
  String get nutrition_description => 'Evaluate macros, calories and trends.';

  @override
  String get training_analysis => 'Training analysis';

  @override
  String get training_analysis_description =>
      'Track volume, strength and progression.';

  @override
  String get load_dots => 'loading...';

  @override
  String get profile_capslock => 'PROFILE';

  @override
  String get settings_capslock => 'SETTINGS';

  @override
  String get settingsTitle => 'Settings';

  @override
  String get my_goals => 'My goals';

  @override
  String get my_goals_description => 'Adjust calories, macros and water.';

  @override
  String get backup_and_import => 'Data backup & import';

  @override
  String get backup_and_import_description =>
      'Create backups, restore, and import data.';

  @override
  String get about_and_legal_capslock => 'ABOUT & LEGAL';

  @override
  String get attribution_and_license => 'Attribution & Licenses';

  @override
  String get data_from_off_and_wger => 'Data from Open Food Facts and wger.';

  @override
  String get app_version => 'App version';

  @override
  String get all_measurements => 'ALL MEASUREMENTS';

  @override
  String get date_and_time_of_measurement => 'Date & time of measurement';

  @override
  String get onbWelcomeTitle => 'Welcome to Hypertrack';

  @override
  String get onbWelcomeBody =>
      'Let’s start by setting personal goals to guide training and nutrition.';

  @override
  String get onbTrackTitle => 'Track everything';

  @override
  String get onbTrackBody =>
      'Log nutrition, workouts, and measurements — all in one place.';

  @override
  String get onbPrivacyTitle => 'Offline-first & privacy';

  @override
  String get onbPrivacyBody =>
      'Your data stays on the device. No cloud accounts, no background sync.';

  @override
  String get onbFinishTitle => 'All set';

  @override
  String get onbFinishBody =>
      'You’re ready to explore the app. You can adjust settings anytime.';

  @override
  String get onbFinishCta => 'Let’s go!';

  @override
  String get onbShowTutorialAgain => 'Show tutorial again';

  @override
  String get onbSetGoalsCta => 'Set goals';

  @override
  String get onbHeaderTitle => 'Tutorial';

  @override
  String get onbHeaderSkip => 'Skip';

  @override
  String get onbBack => 'Back';

  @override
  String get onbNext => 'Next';

  @override
  String get onbGuideTitle => 'How this tutorial works';

  @override
  String get onbGuideBody =>
      'Swipe between slides or use Next. Tap the buttons on each slide to try features. You can finish anytime with Skip.';

  @override
  String get onbCtaOpenNutrition => 'Open nutrition';

  @override
  String get onbCtaLearnMore => 'Learn more';

  @override
  String get onbBadgeDone => 'Done';

  @override
  String get onbTipSetGoals => 'Tip: adjust targets first';

  @override
  String get onbTipAddEntry => 'Tip: add one entry today';

  @override
  String get onbTipLocalControl => 'You control all data locally';

  @override
  String get onbTrackHowBody =>
      'How to log nutrition:\n• Open the Food tab.\n• Tap the + button.\n• Search products or scan a barcode.\n• Adjust portion and time.\n• Save to your diary.';

  @override
  String get onbMeasureTitle => 'Track measurements';

  @override
  String get onbMeasureBody =>
      'How to add measurements:\n• Open the Stats tab.\n• Tap the + button.\n• Choose a metric (e.g., weight, waist, body fat).\n• Enter value and time.\n• Save to your history.';

  @override
  String get onbTipMeasureToday =>
      'Tip: add today’s weight to start your graph';

  @override
  String get onbTrainTitle => 'Train with routines';

  @override
  String get onbTrainBody =>
      'Create a routine and start a workout:\n• Open the Train tab.\n• Tap Create routine to add exercises and sets.\n• Save the routine.\n• Tap Start to begin, or use “Start empty workout”.';

  @override
  String get onbTipStartWorkout =>
      'Tip: start an empty workout to log a quick session';

  @override
  String get unitsSection => 'units';

  @override
  String get weightUnit => 'Weight units';

  @override
  String get lengthUnit => 'unit of length';

  @override
  String get comingSoon => 'Coming soon';

  @override
  String get noFavorites => 'No Favorites';

  @override
  String get nothingTrackedYet => 'Nothing tracked yet';

  @override
  String snackbarBarcodeNotFound(String barcode) {
    return 'No product found for barcode \"$barcode\".';
  }

  @override
  String get categoryHint => 'e.g. Chest, Back, Legs...';

  @override
  String get validatorPleaseEnterCategory => 'Please enter a category.';

  @override
  String get dialogEnterPasswordImport => 'Enter password to import backup';

  @override
  String get dataManagementBackupTitle => 'Lightweight Data Backup';

  @override
  String get dataManagementBackupDescription =>
      'Back up or restore all your app data. Ideal for changing devices.';

  @override
  String get exportEncrypted => 'Export Encrypted';

  @override
  String get dialogPasswordForExport => 'Password for encrypted export';

  @override
  String get snackbarEncryptedBackupShared => 'Encrypted backup shared.';

  @override
  String get exportFailed => 'Export failed.';

  @override
  String get csvExportTitle => 'Data Export (CSV)';

  @override
  String get csvExportDescription =>
      'Export parts of your data as a CSV file for analysis in other programs.';

  @override
  String get snackbarSharingNutrition => 'Sharing nutrition diary...';

  @override
  String get snackbarExportFailedNoEntries =>
      'Export failed. There may be no entries yet.';

  @override
  String get snackbarSharingMeasurements => 'Sharing measurements...';

  @override
  String get snackbarSharingWorkouts => 'Sharing workout history...';

  @override
  String get mapExercisesTitle => 'Map Exercises';

  @override
  String get mapExercisesDescription =>
      'Map unknown names from logs to wger exercises.';

  @override
  String get mapExercisesButton => 'Start Mapping';

  @override
  String get autoBackupTitle => 'Automatic Backups';

  @override
  String get autoBackupDescription =>
      'Periodically saves a backup in the folder. Current folder:';

  @override
  String get autoBackupDefaultFolder => 'App-Documents/Backups (Default)';

  @override
  String get autoBackupChooseFolder => 'Choose Folder';

  @override
  String get autoBackupCopyPath => 'Copy Path';

  @override
  String get autoBackupRunNow => 'Check & Run Auto-Backup Now';

  @override
  String get snackbarAutoBackupSuccess => 'Auto-Backup completed.';

  @override
  String get snackbarAutoBackupFailed => 'Auto-Backup failed or was canceled.';

  @override
  String get noUnknownExercisesFound => 'No unknown exercises found';

  @override
  String snackbarAutoBackupFolderSet(String path) {
    return 'Auto-backup folder set:\n$path';
  }

  @override
  String get snackbarPathCopied => 'Path copied';

  @override
  String get passwordLabel => 'Password';

  @override
  String get descriptionLabel => 'Description';

  @override
  String get involvedMuscles => 'Involved Muscles';

  @override
  String get primaryLabel => 'Primary:';

  @override
  String get secondaryLabel => 'Secondary:';

  @override
  String get noMusclesSpecified => 'No muscles specified.';

  @override
  String get noSelection => 'No selection';

  @override
  String get selectButton => 'Select';

  @override
  String get applyingChanges => 'Applying changes...';

  @override
  String get applyMapping => 'Apply Mapping';

  @override
  String get personalData => 'Personal Data';

  @override
  String get personalDataCL => 'PERSONAL DATA';

  @override
  String get macroDistribution => 'Macronutrient Distribution';

  @override
  String get dialogFinishWorkoutBody =>
      'Are you sure you want to finish this workout?';

  @override
  String get attributionText =>
      'This app uses data from external sources:\n\n● Exercise data and images from wger (wger.de), licensed under CC-BY-SA 4.0.\n\n● Food database from Open Food Facts (openfoodfacts.org), available under the Open Database License (ODbL).';

  @override
  String get errorRoutineNotFound => 'Routine not found';

  @override
  String get workoutHistoryEmptyTitle => 'Your history is empty';

  @override
  String get workoutSummaryTitle => 'Workout Complete';

  @override
  String get workoutSummaryExerciseOverview => 'Exercise Overview';

  @override
  String get nutritionDiary => 'Diary';

  @override
  String get detailedNutrientGoals => 'Detailed Nutrients';

  @override
  String get detailedNutrientGoalsCL => 'DETAILED NUTRIENTS';

  @override
  String get supplementTrackerTitle => 'Supplement Tracker';

  @override
  String get supplementTrackerDescription => 'Track goals, limits, and intake.';

  @override
  String get createSupplementTitle => 'Create Supplement';

  @override
  String get supplementNameLabel => 'Supplement Name';

  @override
  String get defaultDoseLabel => 'Default Dose';

  @override
  String get unitLabel => 'Unit';

  @override
  String get dailyGoalLabel => 'Daily Goal (optional)';

  @override
  String get dailyLimitLabel => 'Daily Limit (optional)';

  @override
  String get dailyProgressTitle => 'Daily Progress';

  @override
  String get todaysLogTitle => 'Today\'s Log';

  @override
  String get logIntakeTitle => 'Log Intake';

  @override
  String get emptySupplementGoals =>
      'Set goals or limits for supplements to see your progress here.';

  @override
  String get emptySupplementLogs => 'No intake logged for today yet.';

  @override
  String get doseLabel => 'Dose';

  @override
  String get settingsDescription => 'Theme, units, data and more';

  @override
  String get settingsAppearance => 'Appearance';

  @override
  String get themeSystem => 'System';

  @override
  String get themeLight => 'Light';

  @override
  String get themeDark => 'Dark';

  @override
  String get caffeinePrompt => 'Caffeine (optional)';

  @override
  String get caffeineUnit => 'mg per 100ml';

  @override
  String get profile => 'Profile';

  @override
  String get measurementWeightCapslock => 'BODY WEIGHT';

  @override
  String get diary => 'Diary';

  @override
  String get analysis => 'Analysis';

  @override
  String get yesterday => 'Yesterday';

  @override
  String get dayBeforeYesterday => 'Two days ago';

  @override
  String get statistics => 'Statistics';

  @override
  String get workout => 'Workout';

  @override
  String get addFoodTitle => 'add food';

  @override
  String get nutritionExplorerTitle => 'Nutrition Explorer';

  @override
  String get myMeals => 'My Meals';

  @override
  String get myMealsCL => 'MY MEALS';

  @override
  String get supplement_caffeine => 'Caffeine';

  @override
  String get supplement_creatine_monohydrate => 'Creatine Monohydrate';

  @override
  String get manageSupplementsTitle => 'Manage supplements';

  @override
  String get deleted => 'deleted';

  @override
  String get operationNotAllowed => 'This operation isn\'t allowed';

  @override
  String get emptySupplements => 'No supplements available';

  @override
  String get undo => 'Rückgängig';

  @override
  String get deleteSupplementConfirm =>
      'Are you sure you want to delete this supplement? All related entries will be removed.';

  @override
  String get fieldRequired => 'Required';

  @override
  String get unitNotSupported => 'Unit not supported.';

  @override
  String get caffeineUnitLocked => 'For caffeine the unit is fixed: mg.';

  @override
  String get caffeineMustBeMg => 'Caffeine must be recorded in mg.';

  @override
  String get tabCatalogSearch => 'Catalog';

  @override
  String get tabMeals => 'Meals';

  @override
  String get emptyCategory => 'No entries';

  @override
  String get searchSectionBase => 'Base foods';

  @override
  String get searchSectionOther => 'Other results';

  @override
  String get mealsComingSoonTitle => 'Meals (coming soon)';

  @override
  String get mealsComingSoonBody =>
      'Soon you will be able to create your own meals from multiple foods.';

  @override
  String get mealsEmptyTitle => 'No meals yet';

  @override
  String get mealsEmptyBody =>
      'Create meals to quickly log multiple foods at once.';

  @override
  String get mealsCreate => 'Create meal';

  @override
  String get mealsEdit => 'Edit meal';

  @override
  String get mealsDelete => 'Delete meal';

  @override
  String get mealsAddToDiary => 'Add to diary';

  @override
  String get mealNameLabel => 'Meal name';

  @override
  String get mealNotesLabel => 'Notes';

  @override
  String get mealIngredientsTitle => 'Ingredients';

  @override
  String get mealAddIngredient => 'Add ingredient';

  @override
  String get mealIngredientAmountLabel => 'Amount';

  @override
  String get mealDeleteConfirmTitle => 'Delete meal';

  @override
  String mealDeleteConfirmBody(Object name) {
    return 'Are you sure you want to delete the meal \'$name\'? All its ingredients will also be removed.';
  }

  @override
  String mealAddedToDiary(Object name) {
    return 'Meal \'$name\' has been added to your diary.';
  }

  @override
  String get mealSaved => 'Meal saved.';

  @override
  String get mealDeleted => 'Meal deleted.';

  @override
  String get confirm => 'Confirm';

  @override
  String get addMealToDiaryTitle => 'Add to diary';

  @override
  String get mealTypeLabel => 'Meal';

  @override
  String get amountLabel => 'Amount';

  @override
  String get mealAddedToDiarySuccess => 'Meal added to diary';

  @override
  String get error => 'Error';

  @override
  String get mealsViewTitle => 'mealsViewTitle';

  @override
  String get noNotes => 'No notes';

  @override
  String get ingredientsCapsLock => 'INGREDIENTS';

  @override
  String get nutritionSectionLabel => 'NUTRITION FACTS';

  @override
  String get nutritionCalculatedForCurrentAmounts => 'for current quantities';

  @override
  String get startCapsLock => 'START';

  @override
  String get nutritionHubSubtitle =>
      'Discover insights, track meals, and plan your nutrition here soon.';

  @override
  String get nutritionHubTitle => 'Nutrition';

  @override
  String get nutrition => 'nutrition';

  @override
  String get changeSetTypTitle => 'Change set type';

  @override
  String get settingsVisualStyleTitle => 'Visual Style';

  @override
  String get settingsVisualStyleStandard => 'Standard (Glass)';

  @override
  String get settingsVisualStyleLiquid => 'Fluid (Liquid Glass)';

  @override
  String get settingsVisualStyleLiquidDesc => 'Rounded, floating UI elements';

  @override
  String get searchBaseFoodHint => 'Search base foods';

  @override
  String get searchNoHits => 'No hits.';

  @override
  String get onbSubtitleWelcome =>
      'Your central tool for fitness, nutrition & progress.';

  @override
  String get onbBodyWelcome =>
      'We help you set and track your goals. Efficiently log workouts, nutrition, supplements, and body measurements.';

  @override
  String get onbBodyNutritionVisual =>
      'Log meals with just a few clicks. Keep an eye on calories, macros, and water to effortlessly track your goal.';

  @override
  String get onbBodyMeasurementsVisual =>
      'Visualize your progress. The weight and circumference chart makes your success visible and keeps you motivated.';

  @override
  String get onbBodyWorkoutVisual =>
      'Create routines and start your training in seconds. Log sets, weights, and rests for maximum progression.';

  @override
  String get onbTitleAppLayout => 'Navigation & Quick-Add';

  @override
  String get onbBodyAppLayout =>
      'The bottom bar allows quick switching between areas. Use the large [+] button to log everything instantly.';

  @override
  String get dataHubTitle => 'Data Hub';

  @override
  String get resumeButton => 'Resume';
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/time_util.dart =====

// lib/util/time_util.dart

/// Formatiert eine Duration in einen String wie "HH:MM:SS" oder "MM:SS".
String formatDuration(Duration d) {
  // .abs() stellt sicher, dass wir keine negativen Werte anzeigen,
  // falls es zu kleinen Zeit-Inkonsistenzen kommt.
  d = d.abs();

  var seconds = d.inSeconds;
  final hours = seconds ~/ Duration.secondsPerHour;
  seconds -= hours * Duration.secondsPerHour;
  final minutes = seconds ~/ Duration.secondsPerMinute;
  seconds -= minutes * Duration.secondsPerMinute;

  final hoursString = hours > 0 ? '${hours.toString()}:' : '';
  final minutesString = minutes.toString().padLeft(2, '0');
  final secondsString = seconds.toString().padLeft(2, '0');

  return '$hoursString$minutesString:$secondsString';
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/encryption_util.dart =====

// lib/util/encryption_util.dart
import 'dart:convert';
import 'dart:math';
import 'package:cryptography/cryptography.dart';

class EncryptionUtil {
  static final _algo = AesGcm.with256bits();
  static const wrapperVersion = 'LWENC-1';

  static Future<Map<String, dynamic>> encryptString(
    String plaintext,
    String passphrase,
  ) async {
    final salt = _randomBytes(16);
    final nonce = _randomBytes(12);
    final key = await _deriveKey(passphrase, salt);
    final box = await _algo.encrypt(
      utf8.encode(plaintext),
      secretKey: key,
      nonce: nonce,
    );
    return {
      'enc': wrapperVersion,
      'salt': base64Encode(salt),
      'nonce': base64Encode(nonce),
      'cipher': base64Encode(box.cipherText),
      'mac': base64Encode(box.mac.bytes),
    };
  }

  static Future<String> decryptToString(
    Map<String, dynamic> wrapper,
    String passphrase,
  ) async {
    if (wrapper['enc'] != wrapperVersion) {
      throw ArgumentError('Unknown encryption wrapper');
    }
    final salt = base64Decode(wrapper['salt'] as String);
    final nonce = base64Decode(wrapper['nonce'] as String);
    final cipher = base64Decode(wrapper['cipher'] as String);
    final mac = Mac(base64Decode(wrapper['mac'] as String));
    final key = await _deriveKey(passphrase, salt);
    final clear = await _algo.decrypt(
      SecretBox(cipher, nonce: nonce, mac: mac),
      secretKey: key,
    );
    return utf8.decode(clear);
  }

  static Future<SecretKey> _deriveKey(String passphrase, List<int> salt) async {
    final pbkdf2 = Pbkdf2(
      macAlgorithm: Hmac.sha256(),
      iterations: 150000,
      bits: 256,
    );
    return await pbkdf2.deriveKey(
      secretKey: SecretKey(utf8.encode(passphrase)),
      nonce: salt,
    );
  }

  static List<int> _randomBytes(int length) {
    final rnd = Random.secure();
    return List<int>.generate(length, (_) => rnd.nextInt(256));
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/util_convert.dart =====

// lib/util/unit_convert.dart
double convert(double value, String from, String to) {
  if (from == to) return value;
  if (from == 'g' && to == 'mg') return value * 1000.0;
  if (from == 'mg' && to == 'g') return value / 1000.0;
  if (from == 'l' && to == 'ml') return value * 1000.0;
  if (from == 'ml' && to == 'l') return value / 1000.0;
  // sonst keine Konvertierung
  return value;
}

// Empfehlungs-Liste zulässiger Einheiten:
const allowedUnits = <String>['mg', 'g', 'IU', 'ml', 'l'];


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/date_util.dart =====

// lib/util/date_util.dart

extension DateOnlyCompare on DateTime {
  bool isSameDate(DateTime other) {
    return year == other.year && month == other.month && day == other.day;
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/l10n_ext.dart =====

// lib/util/l10n_ext.dart
import 'package:flutter/widgets.dart';
import 'package:lightweight/generated/app_localizations.dart';

// Bestehende Extension für den BuildContext
extension L10nX on BuildContext {
  AppLocalizations get l10n => AppLocalizations.of(this)!;
}

// NEU: Extension für die AppLocalizations-Klasse
extension AppLocalizationsX on AppLocalizations {
  String getLocalizedMeasurementName(String key) {
    switch (key) {
      case 'weight':
        return measurementWeight;
      case 'fat_percent':
        return measurementFatPercent;
      case 'neck':
        return measurementNeck;
      case 'shoulder':
        return measurementShoulder;
      case 'chest':
        return measurementChest;
      case 'left_bicep':
        return measurementLeftBicep;
      case 'right_bicep':
        return measurementRightBicep;
      case 'left_forearm':
        return measurementLeftForearm;
      case 'right_forearm':
        return measurementRightForearm;
      case 'abdomen':
        return measurementAbdomen;
      case 'waist':
        return measurementWaist;
      case 'hips':
        return measurementHips;
      case 'left_thigh':
        return measurementLeftThigh;
      case 'right_thigh':
        return measurementRightThigh;
      case 'left_calf':
        return measurementLeftCalf;
      case 'right_calf':
        return measurementRightCalf;
      default:
        return key;
    }
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/design_constants.dart =====

// lib/util/design_constants.dart
import 'package:flutter/material.dart';

class DesignConstants {
  // === SPACING ===
  // Card Padding
  static const double cardPaddingInternal = 16.0; // Innenabstand von Cards
  static const double cardPaddingExternal = 8.0; // Außenabstand zwischen Cards

  // General Spacing
  static const double spacingXS = 4.0; // Sehr kleine Abstände
  static const double spacingS = 8.0; // Kleine Abstände
  static const double spacingM = 12.0; // Mittlere Abstände
  static const double spacingL = 16.0; // Standard-Abstände
  static const double spacingXL = 24.0; // Große Abstände
  static const double spacingXXL = 32.0; // Sehr große Abstände
  static const double bottomContentSpacer = 80.0; // Platz für FAB etc.

  // Screen Padding
  static const double screenPaddingHorizontal = 16.0;
  static const double screenPaddingVertical = 8.0;

  // === BORDER RADIUS ===
  static const double borderRadiusS = 8.0; // Kleine Rundung
  static const double borderRadiusM = 12.0; // Standard Rundung
  static const double borderRadiusL = 16.0; // Große Rundung

  // === LIST SPACING ===
  static const double listItemSpacing = 8.0;
  static const double listSectionSpacing = 24.0;

  // === BUTTON SPACING ===
  static const double buttonPadding = 16.0;
  static const double buttonSpacing = 12.0;

  // === ICON SIZES ===
  static const double iconSizeS = 16.0;
  static const double iconSizeM = 20.0;
  static const double iconSizeL = 24.0;
  static const double iconSizeXL = 32.0;

  // === EDGE INSETS SHORTCUTS ===
  static const EdgeInsets cardPadding = EdgeInsets.all(cardPaddingInternal);
  static const EdgeInsets cardMargin = EdgeInsets.symmetric(
    vertical: cardPaddingExternal,
  );
  static const EdgeInsets screenPadding = EdgeInsets.symmetric(
    horizontal: screenPaddingHorizontal,
    vertical: screenPaddingVertical,
  );
  static const EdgeInsets listPadding = EdgeInsets.all(spacingL);
  static const EdgeInsets buttonContentPadding = EdgeInsets.symmetric(
    horizontal: buttonPadding,
    vertical: spacingM,
  );
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/supplement_l10n.dart =====

// lib/util/supplement_l10n.dart
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/supplement.dart';

String localizeSupplementName(Supplement s, AppLocalizations l10n) {
  switch (s.code) {
    case 'caffeine':
      return l10n.supplement_caffeine;
    case 'creatine_monohydrate':
      return l10n.supplement_creatine_monohydrate;
    default:
      return s.name;
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/util/mapping_prefs.dart =====

// lib/util/mapping_prefs.dart
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';

class MappingPrefs {
  static const _kKey = 'exercise_name_mappings_v1';

  // Lädt Map<externalName, targetName> (case-insensitive Lookup via normalize).
  static Future<Map<String, String>> load() async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_kKey);
    if (raw == null || raw.isEmpty) return {};
    try {
      final Map<String, dynamic> m = jsonDecode(raw);
      return m.map((k, v) => MapEntry(_norm(k), (v as String?)?.trim() ?? ''));
    } catch (_) {
      return {};
    }
  }

  // Fügt/aktualisiert Einträge und speichert als JSON-String.
  static Future<void> upsert(Map<String, String> entries) async {
    if (entries.isEmpty) return;
    final prefs = await SharedPreferences.getInstance();
    final current = await load();
    entries.forEach((k, v) {
      final key = _norm(k);
      final val = (v).trim();
      if (val.isNotEmpty) current[key] = val;
    });
    await prefs.setString(_kKey, jsonEncode(current));
  }

  // Holt eine Zielzuordnung, falls vorhanden.
  static Future<String?> lookup(String externalName) async {
    final m = await load();
    return m[_norm(externalName)];
  }

  static String _norm(String s) => s.trim().toLowerCase();
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/config/dev_flags.dart =====

//import 'package:flutter/material.dart';

const bool kDevEditEnabled = true;


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/repositories/exercise_repository.dart =====

import 'package:lightweight/models/exercise.dart';
// VON DIESEM IMPORT WECHSELN:
// import 'package:lightweight/services/db_service.dart';
// ZU DIESEM IMPORT:
import 'package:lightweight/data/workout_database_helper.dart';

class ExerciseRepository {
  // ÄNDERE DIESE ZEILE:
  final _db = WorkoutDatabaseHelper.instance.database;

  Future<List<Exercise>> getAll({int limit = 200, int offset = 0}) async {
    final db = await _db;
    // Der Rest der Datei bleibt unverändert...
    final rows = await db.query(
      'exercises_flat',
      columns: [
        'id',
        'name_de',
        'name_en',
        'description_de',
        'description_en',
        'category_name',
        'image_path',
        'primaryMuscles_json_de',
        'primaryMuscles_json_en',
        'secondaryMuscles_json_de',
        'secondaryMuscles_json_en',
        'primaryMuscles',
        'secondaryMuscles',
      ],
      orderBy: 'name_en COLLATE NOCASE',
      limit: limit,
      offset: offset,
    );
    return rows.map((m) => Exercise.fromMap(m)).toList(growable: false);
  }

  Future<Exercise?> getById(int id) async {
    final db = await _db;
    final rows = await db.query(
      'exercises_flat',
      columns: [
        'id',
        'name_de',
        'name_en',
        'description_de',
        'description_en',
        'category_name',
        'image_path',
        'primaryMuscles_json_de',
        'primaryMuscles_json_en',
        'secondaryMuscles_json_de',
        'secondaryMuscles_json_en',
        'primaryMuscles',
        'secondaryMuscles',
      ],
      where: 'id = ?',
      whereArgs: [id],
      limit: 1,
    );
    if (rows.isEmpty) return null;
    return Exercise.fromMap(rows.first);
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/exercise.dart =====

// lib/models/exercise.dart
import 'dart:convert' show jsonDecode, jsonEncode;

class Exercise {
  final int? id; // optional für neu angelegte Datensätze
  final String nameDe;
  final String nameEn;
  final String descriptionDe;
  final String descriptionEn;
  final String categoryName;
  final String? imagePath;

  /// sauber getrennt
  final List<String> primaryMuscles;
  final List<String> secondaryMuscles;

  const Exercise({
    this.id,
    required this.nameDe,
    required this.nameEn,
    required this.descriptionDe,
    required this.descriptionEn,
    required this.categoryName,
    required this.primaryMuscles,
    required this.secondaryMuscles,
    this.imagePath,
  });

  // ---------- Parsing helpers ----------
  static List<String> _parseMuscleList(dynamic raw) {
    if (raw == null) return const [];
    final s = raw.toString().trim();
    if (s.isEmpty) return const [];

    // JSON-Array?
    if (s.startsWith('[')) {
      try {
        final data = jsonDecode(s);
        if (data is List) {
          return data
              .map((e) => (e ?? '').toString().trim())
              .where((e) => e.isNotEmpty)
              .cast<String>()
              .toList(growable: false);
        }
      } catch (_) {
        // fällt auf CSV zurück
      }
    }

    // CSV (GROUP_CONCAT)
    return s
        .split(',')
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .toList(growable: false);
  }

  // ---------- Factory: DB -> Model ----------
  factory Exercise.fromMap(Map<String, Object?> m) {
    final primRaw = m['primaryMuscles_json_de'] ??
        m['primaryMuscles_json_en'] ??
        m['primaryMuscles'];
    final secRaw = m['secondaryMuscles_json_de'] ??
        m['secondaryMuscles_json_en'] ??
        m['secondaryMuscles'];

    return Exercise(
      id: (m['id'] is num) ? (m['id'] as num).toInt() : m['id'] as int?,
      nameDe: (m['name_de'] ?? '') as String,
      nameEn: (m['name_en'] ?? '') as String,
      descriptionDe: (m['description_de'] ?? '') as String,
      descriptionEn: (m['description_en'] ?? '') as String,
      categoryName: (m['category_name'] ?? '') as String,
      imagePath: m['image_path'] as String?,
      primaryMuscles: _parseMuscleList(primRaw),
      secondaryMuscles: _parseMuscleList(secRaw),
    );
  }

  // ---------- Model -> DB (für Inserts/Updates) ----------
  //
  // Achtung: Wir serialisieren Muskulatur als CSV, weil dein Insert
  // in workout_database_helper aktuell CSV erwartet.
  Map<String, Object?> toMap() {
    return <String, Object?>{
      if (id != null) 'id': id,
      'name_de': nameDe,
      'name_en': nameEn,
      'description_de': descriptionDe,
      'description_en': descriptionEn,
      'category_name': categoryName,
      'image_path': imagePath,
      'primaryMuscles': jsonEncode(primaryMuscles),
      'secondaryMuscles': jsonEncode(secondaryMuscles),
    };
  }

  // ---------- convenient ----------
  Exercise copyWith({
    int? id,
    String? nameDe,
    String? nameEn,
    String? descriptionDe,
    String? descriptionEn,
    String? categoryName,
    String? imagePath,
    List<String>? primaryMuscles,
    List<String>? secondaryMuscles,
  }) {
    return Exercise(
      id: id ?? this.id,
      nameDe: nameDe ?? this.nameDe,
      nameEn: nameEn ?? this.nameEn,
      descriptionDe: descriptionDe ?? this.descriptionDe,
      descriptionEn: descriptionEn ?? this.descriptionEn,
      categoryName: categoryName ?? this.categoryName,
      imagePath: imagePath ?? this.imagePath,
      primaryMuscles: primaryMuscles ?? this.primaryMuscles,
      secondaryMuscles: secondaryMuscles ?? this.secondaryMuscles,
    );
  }

  // Optional hilfreich im UI:
  String getLocalizedName(context) => nameDe.isNotEmpty ? nameDe : nameEn;
  String getLocalizedDescription(context) =>
      descriptionDe.isNotEmpty ? descriptionDe : descriptionEn;
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/lightweight_backup.dart =====

// lib/models/lightweight_backup.dart

import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/measurement.dart';
import 'package:lightweight/models/measurement_session.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/models/routine_exercise.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/set_template.dart';
import 'package:lightweight/models/fluid_entry.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';

class LightweightBackup {
  final int schemaVersion;
  final List<FoodEntry> foodEntries;
  final List<FluidEntry> fluidEntries;
  final List<String> favoriteBarcodes;
  final List<FoodItem> customFoodItems;
  final List<MeasurementSession> measurementSessions;
  final List<Routine> routines;
  final List<WorkoutLog> workoutLogs;
  // HINZUGEFÜGT: Ein Feld für die Benutzereinstellungen
  final Map<String, dynamic> userPreferences;
  final List<Supplement> supplements;
  final List<SupplementLog> supplementLogs;
  final List<Exercise> customExercises;

  LightweightBackup({
    required this.schemaVersion,
    required this.foodEntries,
    required this.fluidEntries,
    required this.favoriteBarcodes,
    required this.customFoodItems,
    required this.measurementSessions,
    required this.routines,
    required this.workoutLogs,
    required this.userPreferences, // HINZUGEFÜGT
    required this.supplements, // NEU
    required this.supplementLogs, // NEU
    required this.customExercises,
  });

  // KORRIGIERTE VERSION
  factory LightweightBackup.fromJson(Map<String, dynamic> json) {
    return LightweightBackup(
      schemaVersion: json['schemaVersion'] as int? ?? 1,
      foodEntries: (json['foodEntries'] as List<dynamic>?)
              ?.map(
                (e) => FoodEntry(
                  id: e['id'],
                  barcode: e['barcode'],
                  timestamp: DateTime.parse(e['timestamp']),
                  quantityInGrams: e['quantity_in_grams'],
                  mealType: e['meal_type'],
                ),
              )
              .toList() ??
          [],
      fluidEntries: (json['fluidEntries'] as List<dynamic>?)
              ?.map((e) => FluidEntry.fromMap(e as Map<String, dynamic>))
              .toList() ??
          [],
      favoriteBarcodes: List<String>.from(json['favoriteBarcodes'] ?? []),
      customFoodItems: (json['customFoodItems'] as List<dynamic>?)
              ?.map(
                (e) => FoodItem.fromMap(
                  e as Map<String, dynamic>,
                  source: FoodItemSource.user,
                ),
              )
              .toList() ??
          [],
      measurementSessions: (json['measurementSessions'] as List<dynamic>?)
              ?.map((s) {
            final sessionMap = s as Map<String, dynamic>;
            final measurements = (sessionMap['measurements'] as List<dynamic>?)
                    ?.map((m) => Measurement.fromMap(m as Map<String, dynamic>))
                    .toList() ??
                [];
            return MeasurementSession(
              id: sessionMap['id'],
              timestamp: DateTime.parse(sessionMap['timestamp']),
              measurements: measurements,
            );
          }).toList() ??
          [],

      // KORRIGIERT: Detaillierte Deserialisierung für Routinen
      routines: (json['routines'] as List<dynamic>?)?.map((r) {
            final routineMap = r as Map<String, dynamic>;
            return Routine(
              id: routineMap['id'],
              name: routineMap['name'],
              exercises: (routineMap['exercises'] as List<dynamic>?)?.map((re) {
                    final reMap = re as Map<String, dynamic>;
                    return RoutineExercise(
                      id: reMap['id'],
                      // Rekursiver Aufruf der .fromMap Konstruktoren
                      exercise: Exercise.fromMap(
                        reMap['exercise'] as Map<String, dynamic>,
                      ),
                      setTemplates: (reMap['setTemplates'] as List<dynamic>?)
                              ?.map(
                                (st) => SetTemplate.fromMap(
                                  st as Map<String, dynamic>,
                                ),
                              )
                              .toList() ??
                          [],
                      pauseSeconds: reMap['pause_seconds'],
                    );
                  }).toList() ??
                  [],
            );
          }).toList() ??
          [],

      workoutLogs: (json['workoutLogs'] as List<dynamic>?)?.map((log) {
            final logMap = log as Map<String, dynamic>;
            final sets = (logMap['sets'] as List<dynamic>?)
                    ?.map((set) => SetLog.fromMap(set as Map<String, dynamic>))
                    .toList() ??
                [];
            return WorkoutLog.fromMap(logMap, sets: sets);
          }).toList() ??
          [],
      userPreferences: Map<String, dynamic>.from(json['userPreferences'] ?? {}),
      supplements: (json['supplements'] as List<dynamic>?)
              ?.map((e) => Supplement.fromMap(e as Map<String, dynamic>))
              .toList() ??
          [],
      supplementLogs: (json['supplementLogs'] as List<dynamic>?)
              ?.map((e) => SupplementLog.fromMap(e as Map<String, dynamic>))
              .toList() ??
          [],
      customExercises: (json['customExercises'] as List<dynamic>?)
              ?.map((e) => Exercise.fromMap(e as Map<String, dynamic>))
              .toList() ??
          [],
    );
  }

  // Diese Methode nutzt jetzt die .toMap() Methoden deiner Modelle
  Map<String, dynamic> toJson() {
    return {
      'schemaVersion': schemaVersion,
      'foodEntries': foodEntries.map((e) => e.toMap()).toList(),
      'fluidEntries': fluidEntries.map((e) => e.toMap()).toList(),
      'favoriteBarcodes': favoriteBarcodes,
      'customFoodItems': customFoodItems.map((e) => e.toMap()).toList(),
      'measurementSessions': measurementSessions
          .map(
            (s) => {
              'id': s.id,
              'timestamp': s.timestamp.toIso8601String(),
              'measurements': s.measurements.map((m) => m.toMap()).toList(),
            },
          )
          .toList(),
      // Platzhalter für die komplexe Serialisierung von Routinen
      'routines': routines.map((r) => r.toMap()).toList(),
      'workoutLogs': workoutLogs
          .map(
            (log) => {
              ...log.toMap(), // Nutzt die existierende toMap-Methode
              'sets':
                  log.sets.map((s) => s.toMap()).toList(), // Hängt die Sets an
            },
          )
          .toList(),
      'userPreferences': userPreferences,
      'supplements': supplements.map((e) => e.toMap()).toList(),
      'supplementLogs': supplementLogs.map((e) => e.toMap()).toList(),
      'customExercises': customExercises.map((e) => e.toMap()).toList(),
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/workout_log.dart =====

// lib/models/workout_log.dart

import 'package:lightweight/models/set_log.dart';

class WorkoutLog {
  final int? id;
  final String? routineName;
  final DateTime startTime;
  final DateTime? endTime;
  final String? notes;
  final List<SetLog> sets;

  WorkoutLog({
    this.id,
    this.routineName,
    required this.startTime,
    this.endTime,
    this.notes,
    this.sets = const [],
  });

  factory WorkoutLog.fromMap(
    Map<String, dynamic> map, {
    List<SetLog> sets = const [],
  }) {
    return WorkoutLog(
      id: map['id'],
      routineName: map['routine_name'],
      startTime: DateTime.parse(map['start_time'] as String),
      endTime: map['end_time'] != null
          ? DateTime.parse(map['end_time'] as String)
          : null,
      notes: map['notes'],
      sets: sets,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'routine_name': routineName,
      'start_time': startTime.toIso8601String(),
      'end_time': endTime?.toIso8601String(),
      'notes': notes,
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/food_entry.dart =====

// lib/models/food_entry.dart

class FoodEntry {
  final int? id;
  final String barcode;
  final DateTime timestamp;
  final int quantityInGrams;
  final String mealType;

  FoodEntry({
    this.id,
    required this.barcode,
    required this.timestamp,
    required this.quantityInGrams,
    required this.mealType,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'barcode': barcode,
      'timestamp': timestamp.toIso8601String(),
      'quantity_in_grams': quantityInGrams,
      'meal_type': mealType,
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/daily_nutrition.dart =====

// lib/models/daily_nutrition.dart

class DailyNutrition {
  // Verbrauchte Nährwerte
  int calories;
  int water;
  int protein;
  int carbs;
  int fat;
  double fiber;
  double sugar;
  double salt;
  double caffeine;

  // Ziele
  int targetCalories;
  int targetWater;
  int targetProtein;
  int targetCarbs;
  int targetFat;

  // DOC: NEUE ZIELFELDER
  int targetSugar;
  int targetFiber;
  int targetSalt;
  int targetCaffeine;

  DailyNutrition({
    this.calories = 0,
    this.water = 0,
    this.protein = 0,
    this.carbs = 0,
    this.fat = 0,
    this.fiber = 0.0,
    this.sugar = 0.0,
    this.salt = 0.0,
    this.caffeine = 0.0,
    this.targetCalories = 0,
    this.targetWater = 0,
    this.targetProtein = 0,
    this.targetCarbs = 0,
    this.targetFat = 0,

    // DOC: Initialisierung der neuen Ziele
    this.targetSugar = 0,
    this.targetFiber = 0,
    this.targetSalt = 0,
    this.targetCaffeine = 0,
  });
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/water_entry.dart =====

class WaterEntry {
  final int? id;
  final DateTime timestamp;
  final int quantityInMl;

  WaterEntry({this.id, required this.timestamp, required this.quantityInMl});

  factory WaterEntry.fromMap(Map<String, dynamic> map) {
    return WaterEntry(
      id: map['id'],
      timestamp: DateTime.parse(map['timestamp']),
      quantityInMl: map['quantity_in_ml'],
    );
  }
  // DOC: DIESE METHODE HINZUFÜGEN
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'timestamp': timestamp.toIso8601String(),
      'quantity_in_ml': quantityInMl,
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/supplement_log.dart =====

// lib/models/supplement_log.dart

class SupplementLog {
  final int? id;
  final int supplementId;
  final double dose;
  final String unit;
  final DateTime timestamp;
  // --- KORREKTUR START ---
  final int? source_food_entry_id;
  final int? source_fluid_entry_id;

  SupplementLog({
    this.id,
    required this.supplementId,
    required this.dose,
    required this.unit,
    required this.timestamp,
    this.source_food_entry_id, // Jetzt als optionaler Parameter verfügbar
    this.source_fluid_entry_id, // Jetzt als optionaler Parameter verfügbar
  });
  // --- KORREKTUR ENDE ---

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'supplement_id': supplementId,
      'dose': dose,
      'unit': unit,
      'timestamp': timestamp.toIso8601String(),
      // --- KORREKTUR START ---
      'source_food_entry_id': source_food_entry_id,
      'source_fluid_entry_id': source_fluid_entry_id,
      // --- KORREKTUR ENDE ---
    };
  }

  factory SupplementLog.fromMap(Map<String, dynamic> map) {
    return SupplementLog(
      id: map['id'],
      supplementId: map['supplement_id'],
      dose: map['dose'],
      unit: map['unit'],
      timestamp: DateTime.parse(map['timestamp']),
      // --- KORREKTUR START ---
      source_food_entry_id: map['source_food_entry_id'],
      source_fluid_entry_id: map['source_fluid_entry_id'],
      // --- KORREKTUR ENDE ---
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/tracked_supplement.dart =====

// lib/models/tracked_supplement.dart
import 'package:lightweight/models/supplement.dart';

class TrackedSupplement {
  final Supplement supplement;
  final double totalDosedToday;

  const TrackedSupplement({
    required this.supplement,
    required this.totalDosedToday,
  });
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/measurement_session.dart =====

// lib/models/measurement_session.dart
import 'package:lightweight/models/measurement.dart';

class MeasurementSession {
  final int? id;
  final DateTime timestamp;
  final List<Measurement> measurements; // Hält die Detailwerte

  MeasurementSession({
    this.id,
    required this.timestamp,
    this.measurements = const [],
  });
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/routine_exercise.dart =====

// lib/models/routine_exercise.dart

import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/set_template.dart';

class RoutineExercise {
  final int? id;
  final Exercise exercise;
  List<SetTemplate> setTemplates;
  final int? pauseSeconds; // NEUES FELD

  RoutineExercise({
    this.id,
    required this.exercise,
    this.setTemplates = const [],
    this.pauseSeconds, // NEUES FELD
  });

  // BITTE DIESE METHODE HINZUFÜGEN ODER ERSETZEN
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'exercise': exercise.toMap(), // Annahme: Exercise hat eine toMap-Methode
      'setTemplates': setTemplates.map((st) => st.toMap()).toList(),
      'pause_seconds': pauseSeconds,
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/chart_data_point.dart =====

// lib/models/chart_data_point.dart

class ChartDataPoint {
  final DateTime date;
  final double value;

  ChartDataPoint({required this.date, required this.value});
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/measurement.dart =====

// lib/models/measurement.dart

class Measurement {
  final int? id;
  final int sessionId;
  final String type;
  final double value;
  final String unit;

  Measurement({
    this.id,
    required this.sessionId,
    required this.type,
    required this.value,
    required this.unit,
  });

  factory Measurement.fromMap(Map<String, dynamic> map) {
    return Measurement(
      id: map['id'],
      sessionId: map['session_id'],
      type: map['type'],
      value: map['value'],
      unit: map['unit'],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'session_id': sessionId,
      'type': type,
      'value': value,
      'unit': unit,
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/fluid_entry.dart =====

// lib/models/fluid_entry.dart

class FluidEntry {
  final int? id;
  final DateTime timestamp;
  final int quantityInMl;
  final String name;
  final int? kcal;
  final double? sugarPer100ml;
  final double? carbsPer100ml;
  final double? caffeinePer100ml;
  final int? linked_food_entry_id; // *** NEU ***

  FluidEntry({
    this.id,
    required this.timestamp,
    required this.quantityInMl,
    required this.name,
    this.kcal,
    this.sugarPer100ml,
    this.carbsPer100ml,
    this.caffeinePer100ml,
    this.linked_food_entry_id, // *** NEU ***
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'timestamp': timestamp.toIso8601String(),
      'quantity_in_ml': quantityInMl,
      'name': name,
      'kcal': kcal,
      'sugar_per_100ml': sugarPer100ml,
      'carbs_per_100ml': carbsPer100ml,
      'caffeine_per_100ml': caffeinePer100ml,
      'linked_food_entry_id': linked_food_entry_id, // *** NEU ***
    };
  }

  static FluidEntry fromMap(Map<String, dynamic> map) {
    return FluidEntry(
      id: map['id'],
      timestamp: DateTime.parse(map['timestamp']),
      quantityInMl: map['quantity_in_ml'],
      name: map['name'],
      kcal: map['kcal'],
      sugarPer100ml: map['sugar_per_100ml'],
      carbsPer100ml: map['carbs_per_100ml'],
      caffeinePer100ml: map['caffeine_per_100ml'],
      linked_food_entry_id: map['linked_food_entry_id'], // *** NEU ***
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/supplement.dart =====

// lib/models/supplement.dart
class Supplement {
  final int? id;
  final String? code; // <— NEU, optional
  final String name;
  final double defaultDose;
  final String unit;
  final double? dailyGoal;
  final double? dailyLimit;
  final String? notes;
  final bool isBuiltin; // <— NEU

  Supplement({
    this.id,
    this.code,
    required this.name,
    required this.defaultDose,
    required this.unit,
    this.dailyGoal,
    this.dailyLimit,
    this.notes,
    this.isBuiltin = false,
  });

  factory Supplement.fromMap(Map<String, dynamic> map) {
    return Supplement(
      id: map['id'] as int?,
      code: map['code'] as String?, // NEU
      name: map['name'] as String,
      defaultDose: (map['default_dose'] as num).toDouble(),
      unit: map['unit'] as String,
      dailyGoal: (map['daily_goal'] as num?)?.toDouble(),
      dailyLimit: (map['daily_limit'] as num?)?.toDouble(),
      notes: map['notes'] as String?,
      isBuiltin: (map['is_builtin'] as int? ?? 0) == 1, // NEU
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'code': code, // NEU
      'name': name,
      'default_dose': defaultDose,
      'unit': unit,
      'daily_goal': dailyGoal,
      'daily_limit': dailyLimit,
      'notes': notes,
      'is_builtin': isBuiltin ? 1 : 0, // NEU
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/set_log.dart =====

// lib/models/set_log.dart
// VOLLSTÄNDIGER CODE

class SetLog {
  final int? id;
  final int workoutLogId;
  final String exerciseName;
  final String setType;
  final double? weightKg;
  final int? reps;
  final int? restTimeSeconds;
  final bool?
      isCompleted; // WAR bool?, ist es schon, perfekt. Keine Änderung nötig.
  final int? log_order;
  final String? notes;
  final double? distanceKm;
  final int? durationSeconds;
  final int? rpe;
  final int? supersetId;

  SetLog({
    this.id,
    required this.workoutLogId,
    required this.exerciseName,
    required this.setType,
    this.weightKg,
    this.reps,
    this.restTimeSeconds,
    this.isCompleted,
    this.log_order,
    this.notes,
    this.distanceKm,
    this.durationSeconds,
    this.rpe,
    this.supersetId,
  });

  factory SetLog.fromMap(Map<String, dynamic> map) {
    return SetLog(
      id: map['id'],
      workoutLogId: map['workout_log_id'],
      exerciseName: map['exercise_name'],
      setType: map['set_type'],
      weightKg: map['weight_kg'],
      reps: map['reps'],
      restTimeSeconds: map['rest_time_seconds'],
      // MODIFIKATION: isCompleted kann null sein, wir mappen 1 zu true, alles andere (0, null) zu false.
      isCompleted: map['is_completed'] == 1,
      log_order: map['log_order'],
      notes: map['notes'],
      distanceKm: map['distance_km'],
      durationSeconds: map['duration_seconds'],
      rpe: map['rpe'],
      supersetId: map['superset_id'],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'workout_log_id': workoutLogId,
      'exercise_name': exerciseName,
      'set_type': setType,
      'weight_kg': weightKg,
      'reps': reps,
      'rest_time_seconds': restTimeSeconds,
      // MODIFIKATION: Speichere true als 1, false/null als 0.
      'is_completed': isCompleted == true ? 1 : 0,
      'log_order': log_order,
      'notes': notes,
      'distance_km': distanceKm,
      'duration_seconds': durationSeconds,
      'rpe': rpe,
      'superset_id': supersetId,
    };
  }

  SetLog copyWith({
    int? id,
    int? workoutLogId,
    String? exerciseName,
    String? setType,
    double? weightKg,
    int? reps,
    int? restTimeSeconds,
    bool? isCompleted,
    int? log_order,
    String? notes,
    double? distanceKm,
    int? durationSeconds,
    int? rpe,
    int? supersetId,
  }) {
    return SetLog(
      id: id ?? this.id,
      workoutLogId: workoutLogId ?? this.workoutLogId,
      exerciseName: exerciseName ?? this.exerciseName,
      setType: setType ?? this.setType,
      weightKg: weightKg ?? this.weightKg,
      reps: reps ?? this.reps,
      restTimeSeconds: restTimeSeconds ?? this.restTimeSeconds,
      isCompleted: isCompleted ?? this.isCompleted,
      log_order: log_order ?? this.log_order,
      notes: notes ?? this.notes,
      distanceKm: distanceKm ?? this.distanceKm,
      durationSeconds: durationSeconds ?? this.durationSeconds,
      rpe: rpe ?? this.rpe,
      supersetId: supersetId ?? this.supersetId,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/timeline_entry.dart =====

// lib/models/timeline_entry.dart

import 'package:lightweight/models/tracked_food_item.dart';
import 'package:lightweight/models/water_entry.dart';

// DOC: Dies ist eine "abstrakte" Klasse. Sie dient als gemeinsame
// Schablone für alle Arten von Einträgen in unserem Tagebuch.
// Jedes Timeline-Item MUSS einen Zeitstempel haben, damit wir es sortieren können.
abstract class TimelineEntry {
  DateTime get timestamp;
}

// Ein Eintrag für ein Lebensmittel
class FoodTimelineEntry extends TimelineEntry {
  final TrackedFoodItem trackedItem;
  FoodTimelineEntry(this.trackedItem);

  @override
  DateTime get timestamp => trackedItem.entry.timestamp;
}

// Ein Eintrag für Wasser
class WaterTimelineEntry extends TimelineEntry {
  final WaterEntry waterEntry;
  WaterTimelineEntry(this.waterEntry);

  @override
  DateTime get timestamp => waterEntry.timestamp;
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/tracked_food_item.dart =====

import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/food_item.dart';

// DOC: Diese Klasse ist ein reines "Anzeige-Modell". Sie kombiniert die Daten
// aus zwei verschiedenen Quellen (unserem Tagebucheintrag und dem Produktkatalog),
// damit die UI sie einfach an einem Ort abgreifen kann.
class TrackedFoodItem {
  final FoodEntry
      entry; // Der eigentliche Tagebucheintrag (mit ID, Menge, Zeit)
  final FoodItem
      item; // Die Details des Lebensmittels (mit Name, Kalorien etc.)

  TrackedFoodItem({required this.entry, required this.item});

  // Eine kleine Helfer-Eigenschaft, um die berechneten Kalorien für diesen Eintrag zu bekommen.
  int get calculatedCalories {
    return (item.calories / 100 * entry.quantityInGrams).round();
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/routine.dart =====

// lib/models/routine.dart
import 'package:lightweight/models/routine_exercise.dart';

class Routine {
  final int? id;
  final String name;
  final List<RoutineExercise> exercises;

  Routine({this.id, required this.name, this.exercises = const []});

  // BITTE DIESE METHODE HINZUFÜGEN
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'exercises': exercises.map((re) => re.toMap()).toList(),
    };
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/set_template.dart =====

// lib/models/set_template.dart

class SetTemplate {
  final int? id;
  final String setType;
  final String? targetReps;
  final double? targetWeight;

  SetTemplate({
    this.id,
    required this.setType,
    this.targetReps,
    this.targetWeight,
  });

  factory SetTemplate.fromMap(Map<String, dynamic> map) {
    return SetTemplate(
      id: map['id'],
      setType: map['set_type'] ?? 'normal',
      targetReps: map['target_reps'],
      targetWeight: map['target_weight'],
    );
  }

  // In lib/models/set_template.dart
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'set_type': setType,
      'target_reps': targetReps,
      'target_weight': targetWeight,
    };
  }

  // NEUE, BENÖTIGTE METHODE
  // Erstellt eine Kopie des Objekts und überschreibt nur die übergebenen Werte.
  SetTemplate copyWith({
    int? id,
    String? setType,
    String? targetReps,
    double? targetWeight,
  }) {
    return SetTemplate(
      id: id ?? this.id,
      setType: setType ?? this.setType,
      targetReps: targetReps ?? this.targetReps,
      targetWeight: targetWeight ?? this.targetWeight,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/models/food_item.dart =====

// lib/models/food_item.dart
import 'package:flutter/widgets.dart'; // HINZUGEFÜGT für BuildContext

enum FoodItemSource {
  off, // Open Food Facts
  base, // Grundnahrungsmittel-DB
  user, // Vom Benutzer erstellt (Standard)
}

class FoodItem {
  final String barcode;
  final String name; // Behalten wir als Fallback
  final String nameDe; // NEU
  final String nameEn; // NEU
  final String brand;
  final int calories; // pro 100g
  final double protein; // pro 100g
  final double carbs; // pro 100g
  final double fat; // pro 100g
  final FoodItemSource source;

  final double? kj;
  final double? fiber;
  final double? sugar;
  final double? salt;
  final double? sodium;
  final double? calcium;
  final bool? isLiquid;
  final double? caffeineMgPer100ml;

  FoodItem({
    required this.barcode,
    required this.name,
    this.nameDe = '', // NEU
    this.nameEn = '', // NEU
    this.brand = '',
    required this.calories,
    required this.protein,
    required this.carbs,
    required this.fat,
    this.source = FoodItemSource.user,
    this.kj,
    this.fiber,
    this.sugar,
    this.salt,
    this.sodium,
    this.calcium,
    this.isLiquid,
    this.caffeineMgPer100ml,
  });

  // NEUE METHODE: Gibt den Namen in der richtigen Sprache zurück
  String getLocalizedName(BuildContext context) {
    final locale = Localizations.localeOf(context).languageCode;
    if (locale == 'de' && nameDe.isNotEmpty) {
      return nameDe;
    }
    // Fallback auf Englisch, wenn 'en' vorhanden ist oder die Sprache nicht Deutsch ist
    if (nameEn.isNotEmpty) {
      return nameEn;
    }
    // Letzter Fallback auf den generischen Namen
    return name;
  }

  factory FoodItem.fromMap(
    Map<String, dynamic> map, {
    required FoodItemSource source,
  }) {
    return FoodItem(
      barcode: map['barcode'] ?? '',
      // KORRIGIERTE LOGIK: Alle Namensvarianten auslesen
      name: map['name'] ?? '',
      nameDe: map['name_de'] ?? '',
      nameEn: map['name_en'] ?? '',
      brand: map['brand'] ?? '',
      calories: (map['calories_100g'] as num?)?.round() ?? 0,
      protein: (map['protein_100g'] as num?)?.toDouble() ?? 0.0,
      carbs: (map['carbs_100g'] as num?)?.toDouble() ?? 0.0,
      fat: (map['fat_100g'] as num?)?.toDouble() ?? 0.0,
      source: source,
      kj: (map['kj_100g'] as num?)?.toDouble(),
      fiber: (map['fiber_100g'] as num?)?.toDouble(),
      sugar: (map['sugar_100g'] as num?)?.toDouble(),
      salt: (map['salt_100g'] as num?)?.toDouble(),
      sodium: (map['sodium_100g'] as num?)?.toDouble(),
      calcium: (map['calcium_100g'] as num?)?.toDouble(),
      isLiquid: _readBool(map['is_liquid']),
      caffeineMgPer100ml: _toDoubleOrNull(map['caffeine_mg_per_100ml']),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'barcode': barcode,
      'name': name,
      'name_de': nameDe, // NEU
      'name_en': nameEn, // NEU
      'brand': brand,
      'calories_100g': calories,
      'protein_100g': protein,
      'carbs_100g': carbs,
      'fat_100g': fat,
      'kj_100g': kj,
      'fiber_100g': fiber,
      'sugar_100g': sugar,
      'salt_100g': salt,
      'sodium_100g': sodium,
      'calcium_100g': calcium,
      'is_liquid': (isLiquid == null) ? null : (isLiquid! ? 1 : 0),
      'caffeine_mg_per_100ml': caffeineMgPer100ml,
    };
  }

  static bool? _readBool(dynamic v) {
    if (v == null) return null;
    if (v is bool) return v;
    if (v is num) return v != 0;
    if (v is String) {
      final s = v.toLowerCase().trim();
      return s == '1' || s == 'true' || s == 'yes';
    }
    return null;
  }

  static double? _toDoubleOrNull(dynamic v) {
    if (v == null) return null;
    if (v is num) return v.toDouble();
    if (v is String) return double.tryParse(v.replaceAll(',', '.'));
    return null;
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/nutrition_screen.dart =====

// lib/screens/nutrition_screen.dart (Final & De-Materialisiert - Endgültige Korrektur)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/dialogs/fluid_dialog_content.dart';
import 'package:lightweight/models/fluid_entry.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/dialogs/quantity_dialog_content.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/tracked_food_item.dart';
import 'package:lightweight/models/timeline_entry.dart';
import 'package:lightweight/services/ui_state_service.dart';
import 'package:lightweight/widgets/nutrition_summary_widget.dart';
import 'package:lightweight/widgets/summary_card.dart';
import './food_detail_screen.dart';
import 'package:lightweight/util/date_util.dart';

class NutritionScreen extends StatefulWidget {
  const NutritionScreen({super.key});

  @override
  State<NutritionScreen> createState() => _NutritionScreenState();
}

class FluidTimelineEntry extends TimelineEntry {
  final FluidEntry fluidEntry;

  FluidTimelineEntry(this.fluidEntry);

  @override
  DateTime get timestamp => fluidEntry.timestamp;
}

class _NutritionScreenState extends State<NutritionScreen> {
  DailyNutrition? _nutritionData;
  List<dynamic> _displayItems = [];
  bool _isLoading = true;
  DateTimeRange _selectedDateRange = DateTime.now().isSameDate(DateTime.now())
      ? DateTimeRange(
          start: DateTime.now(),
          end: DateTime.now(),
        ) // Einzeltag für heute
      : DateTimeRange(
          start: DateTime.now().subtract(const Duration(days: 6)),
          end: DateTime.now(),
        ); // Standard: Letzte 7 Tage
  bool _isSummaryExpanded = UiStateService.instance.isNutritionSummaryExpanded;
  String _selectedRangeKey = '1D';
  bool _isHeaderVisible = true;

  @override
  void initState() {
    super.initState();
    _loadEntriesForDateRange(_selectedDateRange);
  }

  Future<void> _loadEntriesForDateRange(DateTimeRange range) async {
    if (!mounted) return;
    setState(() {
      _isLoading = true;
    });

    final prefs = await SharedPreferences.getInstance();
    final targetCalories = prefs.getInt('targetCalories') ?? 2500;
    final targetProtein = prefs.getInt('targetProtein') ?? 180;
    final targetCarbs = prefs.getInt('targetCarbs') ?? 250;
    final targetFat = prefs.getInt('targetFat') ?? 80;
    final targetWater = prefs.getInt('targetWater') ?? 3000;
    final targetSugar = prefs.getInt('targetSugar') ?? 50;
    final targetFiber = prefs.getInt('targetFiber') ?? 30;
    final targetSalt = prefs.getInt('targetSalt') ?? 6;
    final targetCaffeine = prefs.getInt('targetCaffeine') ?? 400;

    final foodEntries = await DatabaseHelper.instance.getEntriesForDateRange(
      range.start,
      range.end,
    );
    final fluidEntries = await DatabaseHelper.instance
        .getFluidEntriesForDateRange(range.start, range.end);
    final supplementLogs = await DatabaseHelper.instance
        .getAllSupplementLogs(); // Annahme: Methode existiert
    final supplements = await DatabaseHelper.instance.getAllSupplements();

    final caffeineSupplementId =
        supplements.firstWhere((s) => s.code == 'caffeine').id;

    final numberOfDays = range.duration.inDays + 1;
    final newNutritionSummary = DailyNutrition(
      targetCalories: targetCalories * numberOfDays,
      targetProtein: targetProtein * numberOfDays,
      targetCarbs: targetCarbs * numberOfDays,
      targetFat: targetFat * numberOfDays,
      targetWater: targetWater * numberOfDays,
      targetSugar: targetSugar * numberOfDays,
      targetFiber: targetFiber * numberOfDays,
      targetSalt: targetSalt * numberOfDays,
      targetCaffeine: targetCaffeine * numberOfDays,
    );

    final List<FoodTimelineEntry> foodTimeline = [];
    for (final entry in foodEntries) {
      final foodItem = await ProductDatabaseHelper.instance.getProductByBarcode(
        entry.barcode,
      );
      if (foodItem != null) {
        final factor = entry.quantityInGrams / 100.0;
        newNutritionSummary.calories += (foodItem.calories * factor).round();
        newNutritionSummary.protein += (foodItem.protein * factor).round();
        newNutritionSummary.carbs += (foodItem.carbs * factor).round();
        newNutritionSummary.fat += (foodItem.fat * factor).round();
        newNutritionSummary.sugar += (foodItem.sugar ?? 0) * factor;
        newNutritionSummary.fiber += (foodItem.fiber ?? 0) * factor;
        newNutritionSummary.salt += (foodItem.salt ?? 0) * factor;
        foodTimeline.add(
          FoodTimelineEntry(TrackedFoodItem(entry: entry, item: foodItem)),
        );
      }
    }

    // *** KORREKTURBLOCK START ***
    // Nährwerte aus Flüssigkeiten zur Summe addieren
    newNutritionSummary.water = fluidEntries.fold(
      0,
      (sum, entry) => sum + entry.quantityInMl,
    );
    for (final entry in fluidEntries) {
      final factor = entry.quantityInMl / 100.0;
      newNutritionSummary.calories += entry.kcal ?? 0;
      newNutritionSummary.carbs +=
          ((entry.carbsPer100ml ?? 0) * factor).round();
      newNutritionSummary.sugar += (entry.sugarPer100ml ?? 0) * factor;
    }

    // Koffein aus Supplement-Logs berechnen
    if (caffeineSupplementId != null) {
      final relevantLogs = supplementLogs.where(
        (log) =>
            log.supplementId == caffeineSupplementId &&
            log.timestamp.isAfter(range.start) &&
            log.timestamp.isBefore(range.end),
      );
      newNutritionSummary.caffeine = relevantLogs.fold(
        0.0,
        (sum, log) => sum + log.dose,
      );
    }

    final fluidTimeline =
        fluidEntries.map((e) => FluidTimelineEntry(e)).toList();
    // *** KORREKTURBLOCK ENDE ***

    final List<dynamic> finalDisplayList = [];

    if (range.duration.inDays == 0) {
      // ... (Rest der Methode bleibt unverändert)
      final Map<String, List<FoodTimelineEntry>> groupedFood = {};
      for (final entry in foodTimeline) {
        final mealType = entry.trackedItem.entry.mealType;
        if (groupedFood.containsKey(mealType)) {
          groupedFood[mealType]!.add(entry);
        } else {
          groupedFood[mealType] = [entry];
        }
      }

      const mealOrder = [
        "mealtypeBreakfast",
        "mealtypeLunch",
        "mealtypeDinner",
        "mealtypeSnack",
      ];
      for (final mealKey in mealOrder) {
        if (groupedFood.containsKey(mealKey)) {
          finalDisplayList.add(mealKey);
          groupedFood[mealKey]!.sort(
            (a, b) => b.timestamp.compareTo(a.timestamp),
          );
          finalDisplayList.addAll(groupedFood[mealKey]!);
        }
      }

      if (fluidTimeline.isNotEmpty) {
        finalDisplayList.add("fluidsHeader");
        fluidTimeline.sort((a, b) => b.timestamp.compareTo(a.timestamp));
        finalDisplayList.addAll(fluidTimeline);
      }
    } else {
      final List<TimelineEntry> combinedList = [
        ...foodTimeline,
        ...fluidTimeline,
      ];
      combinedList.sort((a, b) => b.timestamp.compareTo(a.timestamp));

      DateTime? lastDate;
      for (final entry in combinedList) {
        final entryDate = entry.timestamp;
        if (lastDate == null || !entryDate.isSameDate(lastDate)) {
          finalDisplayList.add(entryDate);
          lastDate = entryDate;
        }
        finalDisplayList.add(entry);
      }
    }

    if (mounted) {
      setState(() {
        _nutritionData = newNutritionSummary;
        _displayItems = finalDisplayList;
        _isLoading = false;
      });
    }
  }

  void _navigateDay(bool forward) {
    final currentDay = _selectedDateRange.start;
    final newDay = currentDay.add(Duration(days: forward ? 1 : -1));
    // Navigation über den heutigen Tag hinaus verhindern
    if (forward && newDay.isAfter(DateTime.now())) return;

    setState(() {
      _selectedDateRange = DateTimeRange(start: newDay, end: newDay);
      _selectedRangeKey = 'custom'; // De-selektiert die Filter-Chips
    });
    _loadEntriesForDateRange(_selectedDateRange);
  }

  Future<void> _setTimeRange(String key) async {
    setState(() => _selectedRangeKey = key);
    final now = DateTime.now();
    DateTime start;
    DateTime end = DateTime(now.year, now.month, now.day, 23, 59, 59);

    switch (key) {
      case '1W':
        start = now.subtract(const Duration(days: 6));
        break;
      case '1M':
        start = now.subtract(const Duration(days: 29));
        break;
      case 'All':
        final earliest =
            await DatabaseHelper.instance.getEarliestFoodEntryDate();
        start = earliest ?? now;
        break;
      case '1D':
      default:
        start = now;
    }

    final normalizedStart = DateTime(start.year, start.month, start.day);
    setState(
      () =>
          _selectedDateRange = DateTimeRange(start: normalizedStart, end: end),
    );
    _loadEntriesForDateRange(_selectedDateRange);
  }

  Future<void> _deleteFoodEntry(int id) async {
    await DatabaseHelper.instance.deleteFoodEntry(id);
    _loadEntriesForDateRange(_selectedDateRange);
  }

  Future<void> _deleteFluidEntry(int id) async {
    await DatabaseHelper.instance.deleteFluidEntry(id);
    _loadEntriesForDateRange(_selectedDateRange);
  }

  Future<void> _editFoodEntry(TrackedFoodItem trackedItem) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<QuantityDialogContentState> dialogStateKey = GlobalKey();

    final result = await showDialog<(int, DateTime, String, double?)?>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(
            trackedItem.item.name,
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),
          content: QuantityDialogContent(
            key: dialogStateKey,
            item: trackedItem.item,
            initialQuantity: trackedItem.entry.quantityInGrams,
            initialTimestamp: trackedItem.entry.timestamp,
            initialMealType: trackedItem.entry.mealType,
          ),
          actions: [
            TextButton(
              child: Text(l10n.cancel),
              onPressed: () => Navigator.of(context).pop(),
            ),
            FilledButton(
              child: Text(l10n.save),
              onPressed: () {
                final state = dialogStateKey.currentState;
                if (state != null) {
                  final quantity = int.tryParse(state.quantityText);
                  if (quantity != null && quantity > 0) {
                    Navigator.of(context).pop((
                      quantity,
                      state.selectedDateTime,
                      state.selectedMealType,
                      double.tryParse(state.caffeineText.replaceAll(',', '.')),
                    ));
                  }
                }
              },
            ),
          ],
        );
      },
    );

    if (result != null) {
      final updatedEntry = FoodEntry(
        id: trackedItem.entry.id,
        barcode: trackedItem.item.barcode,
        quantityInGrams: result.$1,
        timestamp: result.$2,
        mealType: result.$3,
      );
      await DatabaseHelper.instance.updateFoodEntry(updatedEntry);
      _loadEntriesForDateRange(_selectedDateRange);
    }
  }

  // lib/screens/nutrition_screen.dart - ERSETZE DIE GESAMTE METHODE
  Future<void> _editFluidEntry(FluidEntry fluidEntry) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<FluidDialogContentState> dialogStateKey = GlobalKey();

    final result = await showDialog<(String, int, double?, double?)?>(
      context: context,
      builder: (context) {
        // ... (Dialog-Aufbau bleibt hier ein AlertDialog, da dies der ältere Screen ist,
        // aber wir stellen die Dialoge im DiaryScreen auf BottomSheet um.
        // Um das Problem des Nutzers schnell zu lösen, setzen wir es auf den AlertDialog zurück.
        // Das ist der Kompromiss für diesen Screen, solange er noch existiert.)
        return AlertDialog(
          title: Text(l10n.waterEntryTitle),
          content: FluidDialogContent(
            key: dialogStateKey,
            initialName: fluidEntry.name, // HINZUGEFÜGT
            initialQuantity: fluidEntry.quantityInMl,
            initialTimestamp: fluidEntry.timestamp,
            initialSugar: fluidEntry.sugarPer100ml, // HINZUGEFÜGT
            initialCaffeine: fluidEntry.caffeinePer100ml, // HINZUGEFÜGT
          ),
          actions: [
            TextButton(
              child: Text(l10n.cancel),
              onPressed: () => Navigator.of(context).pop(),
            ),
            FilledButton(
              child: Text(l10n.save),
              onPressed: () {
                final state = dialogStateKey.currentState;
                if (state != null) {
                  final quantity = int.tryParse(state.quantityText);
                  if (quantity != null && quantity > 0) {
                    Navigator.of(context).pop((
                      state.nameText,
                      quantity,
                      double.tryParse(state.sugarText.replaceAll(',', '.')),
                      double.tryParse(state.caffeineText.replaceAll(',', '.')),
                    ));
                  }
                }
              },
            ),
          ],
        );
      },
    );

    if (result != null) {
      final sugarPer100ml = result.$3;
      final quantity = result.$2;
      final kcal = (sugarPer100ml != null)
          ? ((sugarPer100ml / 100) * quantity * 4).round()
          : null;

      final updatedEntry = FluidEntry(
        id: fluidEntry.id,
        name: result.$1,
        quantityInMl: quantity,
        kcal: kcal,
        sugarPer100ml: sugarPer100ml,
        carbsPer100ml: sugarPer100ml, // Spiegeln
        caffeinePer100ml: result.$4,
        timestamp: fluidEntry.timestamp,
        linked_food_entry_id:
            fluidEntry.linked_food_entry_id, // Wichtig: beibehalten
      );
      await DatabaseHelper.instance.updateFluidEntry(updatedEntry);

      // Koffein-Log aktualisieren/löschen
      await _logCaffeineDose(
        (result.$4 ?? 0) * (quantity / 100.0),
        fluidEntry.timestamp,
        fluidEntryId: fluidEntry.id,
      );

      _loadEntriesForDateRange(_selectedDateRange);
    }
  }

  // FÜGE DIE FEHLENDE LOGIK FÜR KOFFEIN HINZU (falls nicht vorhanden)
  Future<void> _logCaffeineDose(double doseMg, DateTime timestamp,
      {int? foodEntryId, int? fluidEntryId}) async {
    if (doseMg <= 0) return;

    final supplements = await DatabaseHelper.instance.getAllSupplements();
    Supplement? caffeineSupplement;
    try {
      caffeineSupplement = supplements.firstWhere((s) => s.code == 'caffeine');
    } catch (e) {
      return;
    }

    if (caffeineSupplement.id == null) return;

    await DatabaseHelper.instance.insertSupplementLog(
      SupplementLog(
        supplementId: caffeineSupplement.id!,
        dose: doseMg,
        unit: 'mg',
        timestamp: timestamp,
        source_food_entry_id: foodEntryId,
        source_fluid_entry_id: fluidEntryId,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    final locale = Localizations.localeOf(context).toString();

    final rangeText = _selectedDateRange.duration.inDays == 0
        ? DateFormat.yMMMMd(locale).format(_selectedDateRange.start)
        : "${DateFormat.yMMMMd(locale).format(_selectedDateRange.start)} - ${DateFormat.yMMMMd(locale).format(_selectedDateRange.end)}";

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          l10n.nutritionScreenTitle,
          style: Theme.of(
            context,
          ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w900),
        ),
      ),
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: SafeArea(
        top: true,
        child: Stack(
          children: [
            Column(
              children: [
                Container(
                  color: Theme.of(context).scaffoldBackgroundColor,
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 16.0,
                      vertical: 0.0,
                    ),
                    //padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 24.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        //SizedBox(height: DesignConstants.spacingL), // <- DIESE ZEILE
                        //SizedBox(height: DesignConstants.spacingXL),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            IconButton(
                              icon: const Icon(Icons.chevron_left),
                              onPressed: () => _navigateDay(false),
                            ),
                            Expanded(
                              child: InkWell(
                                onTap: () async {
                                  final picked = await showDateRangePicker(
                                    context: context,
                                    initialDateRange: _selectedDateRange,
                                    firstDate: DateTime(2020),
                                    lastDate: DateTime.now(),
                                  );
                                  if (picked != null) {
                                    setState(() {
                                      _selectedDateRange = picked;
                                      _selectedRangeKey = 'custom';
                                    });
                                    _loadEntriesForDateRange(picked);
                                  }
                                },
                                child: Text(
                                  rangeText,
                                  style: textTheme.titleMedium?.copyWith(
                                    fontWeight: FontWeight.bold,
                                  ),
                                  textAlign: TextAlign.center,
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ),
                            IconButton(
                              icon: const Icon(Icons.chevron_right),
                              onPressed: _selectedDateRange.end.isSameDate(
                                DateTime.now(),
                              )
                                  ? null
                                  : () => _navigateDay(true),
                            ),
                          ],
                        ),
                        const SizedBox(height: DesignConstants.spacingL),
                        Row(
                          children: [
                            _buildFilterButton(l10n.filterToday, '1D'),
                            _buildFilterButton(l10n.filter7Days, '1W'),
                            _buildFilterButton(l10n.filter30Days, '1M'),
                            _buildFilterButton(l10n.filterAll, 'All'),
                          ],
                        ),
                        const SizedBox(
                          height: DesignConstants.spacingL,
                        ), // <- DIESE ZEILE
                      ],
                    ),
                  ),
                ),
                Divider(
                  height: 1,
                  thickness: 1,
                  color: colorScheme.onSurfaceVariant.withOpacity(0.1),
                ),
                AnimatedSize(
                  duration: const Duration(milliseconds: 300),
                  curve: Curves.easeInOut,
                  child: _isHeaderVisible
                      ? Column(
                          children: [
                            if (_nutritionData != null)
                              Column(
                                children: [
                                  // KORREKTUR: NutritionSummaryWidget in einem Padding, das dem horizontalen ListView-Padding entspricht.
                                  Padding(
                                    padding: const EdgeInsets.symmetric(
                                      horizontal: 16.0,
                                    ), // <- Dieser Padding ist wichtig!
                                    child: NutritionSummaryWidget(
                                      nutritionData: _nutritionData!,
                                      isExpandedView: _isSummaryExpanded,
                                      l10n: l10n,
                                    ),
                                  ),
                                  Row(
                                    mainAxisAlignment:
                                        MainAxisAlignment.spaceEvenly,
                                    children: [
                                      TextButton(
                                        onPressed: () {
                                          setState(() {
                                            _isSummaryExpanded =
                                                !_isSummaryExpanded;
                                            UiStateService.instance
                                                    .isNutritionSummaryExpanded =
                                                _isSummaryExpanded;
                                          });
                                        },
                                        child: Text(
                                          _isSummaryExpanded
                                              ? l10n.showLess
                                              : l10n.showMoreDetails,
                                        ),
                                      ),
                                      TextButton(
                                        onPressed: () => setState(
                                          () => _isHeaderVisible = false,
                                        ),
                                        child: Text(l10n.hideSummary),
                                      ),
                                    ],
                                  ),
                                ],
                              ),
                          ],
                        )
                      : Align(
                          alignment: Alignment.centerRight,
                          child: Padding(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 16.0,
                            ),
                            child: TextButton(
                              onPressed: () =>
                                  setState(() => _isHeaderVisible = true),
                              child: Text(l10n.showSummary),
                            ),
                          ),
                        ),
                ),
                Divider(
                  height: 1,
                  thickness: 1,
                  color: colorScheme.onSurfaceVariant.withOpacity(0.1),
                ),
                Expanded(
                  child: _displayItems.isEmpty
                      ? Center(child: Text(l10n.noEntriesForPeriod))
                      : ListView.separated(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 16.0,
                            vertical: 8.0,
                          ),
                          itemCount: _displayItems.length,
                          separatorBuilder: (context, index) => const SizedBox(
                            height: DesignConstants.spacingM,
                          ), // KORREKTUR: Trenner
                          itemBuilder: (context, index) {
                            final item = _displayItems[index];

                            String getLocalizedMealName(String key) {
                              switch (key) {
                                case "mealtypeBreakfast":
                                  return l10n.mealtypeBreakfast;
                                case "mealtypeLunch":
                                  return l10n.mealtypeLunch;
                                case "mealtypeDinner":
                                  return l10n.mealtypeDinner;
                                case "mealtypeSnack":
                                  return l10n.mealtypeSnack;
                                case "fluidsHeader":
                                  return l10n.waterHeader;
                                default:
                                  return key;
                              }
                            }

                            if (item is DateTime) {
                              return Padding(
                                padding: const EdgeInsets.only(
                                  top: 24.0,
                                  bottom: 8.0,
                                  left: 8.0,
                                ),
                                child: Text(
                                  DateFormat.yMMMMEEEEd(locale).format(item),
                                  style: textTheme.titleLarge?.copyWith(
                                    fontWeight: FontWeight.bold,
                                    color: colorScheme.primary,
                                  ),
                                ),
                              );
                            }

                            if (item is String) {
                              return Padding(
                                padding: const EdgeInsets.only(
                                  top: 24.0,
                                  bottom: 8.0,
                                  left: 8.0,
                                ),
                                child: Text(
                                  getLocalizedMealName(item),
                                  style: textTheme.titleLarge?.copyWith(
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              );
                            }

                            // In lib/screens/nutrition_screen.dart (innerhalb von ListView.separated -> itemBuilder)

                            if (item is FoodTimelineEntry) {
                              final trackedItem = item.trackedItem;
                              return Dismissible(
                                key: Key('food_${trackedItem.entry.id}'),
                                direction: DismissDirection.horizontal,
                                background: const SwipeActionBackground(
                                  color: Colors.blueAccent,
                                  icon: Icons.edit,
                                  alignment: Alignment.centerLeft,
                                ),
                                secondaryBackground:
                                    const SwipeActionBackground(
                                  color: Colors.redAccent,
                                  icon: Icons.delete,
                                  alignment: Alignment.centerRight,
                                ),
                                confirmDismiss: (direction) async {
                                  if (direction ==
                                      DismissDirection.startToEnd) {
                                    _editFoodEntry(trackedItem);
                                    return false;
                                  } else {
                                    // NEU: Verwendung der Helper-Funktion
                                    return await showDeleteConfirmation(
                                        context);
                                  }
                                },
                                onDismissed: (direction) {
                                  if (direction ==
                                      DismissDirection.endToStart) {
                                    _deleteFoodEntry(trackedItem.entry.id!);
                                  }
                                },
                                child: SummaryCard(
                                  child: ListTile(
                                    leading: const Icon(Icons.restaurant),
                                    title: Text(trackedItem.item.name),
                                    subtitle: Text(
                                      l10n.foodListSubtitle(
                                        trackedItem.entry.quantityInGrams,
                                        DateFormat.Hm(
                                          locale,
                                        ).format(trackedItem.entry.timestamp),
                                      ),
                                    ),
                                    trailing: Text(
                                      l10n.foodListTrailingKcal(
                                        trackedItem.calculatedCalories,
                                      ),
                                    ),
                                    onTap: () => Navigator.of(context)
                                        .push(
                                          MaterialPageRoute(
                                            builder: (context) =>
                                                FoodDetailScreen(
                                              trackedItem: trackedItem,
                                            ),
                                          ),
                                        )
                                        .then(
                                          (_) => _loadEntriesForDateRange(
                                            _selectedDateRange,
                                          ),
                                        ),
                                  ),
                                ),
                              );
                            }

                            if (item is FluidTimelineEntry) {
                              final fluidEntry = item.fluidEntry;
                              return Dismissible(
                                key: Key('fluid_${fluidEntry.id}'),
                                direction: DismissDirection.horizontal,
                                background: const SwipeActionBackground(
                                  color: Colors.blueAccent,
                                  icon: Icons.edit,
                                  alignment: Alignment.centerLeft,
                                ),
                                secondaryBackground:
                                    const SwipeActionBackground(
                                  color: Colors.redAccent,
                                  icon: Icons.delete,
                                  alignment: Alignment.centerRight,
                                ),
                                confirmDismiss: (direction) async {
                                  if (direction ==
                                      DismissDirection.startToEnd) {
                                    _editFluidEntry(fluidEntry);
                                    return false;
                                  } else {
                                    // NEU: Verwendung der Helper-Funktion
                                    return await showDeleteConfirmation(
                                        context);
                                  }
                                },
                                onDismissed: (direction) {
                                  if (direction ==
                                      DismissDirection.endToStart) {
                                    _deleteFluidEntry(fluidEntry.id!);
                                  }
                                },
                                child: SummaryCard(
                                  child: ListTile(
                                    leading: Icon(
                                      Icons.local_drink,
                                      color: colorScheme.primary,
                                    ),
                                    title: Text(fluidEntry.name),
                                    subtitle: Text(
                                      DateFormat.Hm(
                                        locale,
                                      ).format(fluidEntry.timestamp),
                                    ),
                                    trailing: Text(
                                      l10n.waterListTrailingMl(
                                        fluidEntry.quantityInMl,
                                      ),
                                      style: const TextStyle(
                                        fontWeight: FontWeight.bold,
                                      ),
                                    ),
                                  ),
                                ),
                              );
                            }

                            if (item is FluidTimelineEntry) {
                              final fluidEntry = item.fluidEntry;
                              return Dismissible(
                                key: Key('fluid_${fluidEntry.id}'),
                                direction: DismissDirection.horizontal,
                                background: const SwipeActionBackground(
                                  color: Colors.blueAccent,
                                  icon: Icons.edit,
                                  alignment: Alignment.centerLeft,
                                ),
                                secondaryBackground:
                                    const SwipeActionBackground(
                                  color: Colors.redAccent,
                                  icon: Icons.delete,
                                  alignment: Alignment.centerRight,
                                ),
                                confirmDismiss: (direction) async {
                                  if (direction ==
                                      DismissDirection.startToEnd) {
                                    _editFluidEntry(fluidEntry);
                                    return false;
                                  } else {
                                    return await showDialog<bool>(
                                          context: context,
                                          builder: (BuildContext context) {
                                            return AlertDialog(
                                              title: Text(
                                                l10n.deleteConfirmTitle,
                                              ),
                                              content: Text(
                                                l10n.deleteConfirmContent,
                                              ),
                                              actions: <Widget>[
                                                TextButton(
                                                  onPressed: () => Navigator.of(
                                                    context,
                                                  ).pop(false),
                                                  child: Text(l10n.cancel),
                                                ),
                                                TextButton(
                                                  onPressed: () => Navigator.of(
                                                    context,
                                                  ).pop(true),
                                                  child: Text(l10n.delete),
                                                ),
                                              ],
                                            );
                                          },
                                        ) ??
                                        false;
                                  }
                                },
                                onDismissed: (direction) {
                                  if (direction ==
                                      DismissDirection.endToStart) {
                                    _deleteFluidEntry(fluidEntry.id!);
                                  }
                                },
                                child: SummaryCard(
                                  //externalMargin: EdgeInsets.zero,
                                  child: ListTile(
                                    leading: Icon(
                                      Icons.local_drink,
                                      color: colorScheme.primary,
                                    ),
                                    title: Text(fluidEntry.name),
                                    subtitle: Text(
                                      DateFormat.Hm(
                                        locale,
                                      ).format(fluidEntry.timestamp),
                                    ),
                                    trailing: Text(
                                      l10n.waterListTrailingMl(
                                        fluidEntry.quantityInMl,
                                      ),
                                      style: const TextStyle(
                                        fontWeight: FontWeight.bold,
                                      ),
                                    ),
                                  ),
                                ),
                              );
                            }
                            return const SizedBox.shrink();
                          },
                        ),
                ),
              ],
            ),
            if (_isLoading)
              Positioned.fill(
                child: Container(
                  color: Colors.black.withOpacity(0.5),
                  child: const Center(child: CircularProgressIndicator()),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildFilterButton(String label, String key) {
    final theme = Theme.of(context);
    final isSelected = _selectedRangeKey == key;
    return Expanded(
      child: GestureDetector(
        onTap: () => _setTimeRange(key),
        child: Container(
          margin: const EdgeInsets.symmetric(horizontal: 4.0),
          padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
          decoration: BoxDecoration(
            color: isSelected
                ? theme.colorScheme.primary
                : theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
            borderRadius: BorderRadius.circular(10.0),
          ),
          child: Text(
            label,
            textAlign: TextAlign.center,
            style: theme.textTheme.labelLarge?.copyWith(
              color: isSelected
                  ? theme.colorScheme.onPrimary
                  : theme.colorScheme.onSurfaceVariant,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/workout_log_detail_screen.dart =====

// lib/screens/workout_log_detail_screen.dart (Final & Korrigiert - Edit Mode - Neu mit WorkoutCard)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/screens/exercise_catalog_screen.dart';
import 'package:lightweight/screens/exercise_detail_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/global_app_bar.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/wger_attribution_widget.dart';
import 'package:lightweight/widgets/workout_summary_bar.dart';
import 'package:lightweight/widgets/workout_card.dart';

class WorkoutLogDetailScreen extends StatefulWidget {
  final int logId;
  const WorkoutLogDetailScreen({super.key, required this.logId});

  @override
  State<WorkoutLogDetailScreen> createState() => _WorkoutLogDetailScreenState();
}

class _WorkoutLogDetailScreenState extends State<WorkoutLogDetailScreen> {
  bool _isLoading = true;
  WorkoutLog? _log;
  Map<String, List<SetLog>> _groupedSets = {};
  Map<String, Exercise> _exerciseDetails = {};
  bool _isEditMode = false;
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _notesController;
  final Map<int, TextEditingController> _weightControllers = {};
  final Map<int, TextEditingController> _repsControllers = {};
  DateTime? _editedStartTime;
  Map<String, double> _categoryVolume = {};

  @override
  void initState() {
    super.initState();
    _notesController = TextEditingController();
    _loadDetails();
  }

  @override
  void dispose() {
    _notesController.dispose();
    _clearControllers();
    super.dispose();
  }

  void _clearControllers() {
    for (var controller in _weightControllers.values) {
      controller.dispose();
    }
    for (var controller in _repsControllers.values) {
      controller.dispose();
    }
    _weightControllers.clear();
    _repsControllers.clear();
  }

  /// Gibt den anzuzeigenden Text für den Set zurück
  String _getSetDisplayText(String setType, int setIndex) {
    switch (setType) {
      case 'warmup':
        return 'W';
      case 'failure':
        return 'F';
      case 'dropset':
        return 'D';
      default:
        return '$setIndex';
    }
  }

  Future<void> _loadDetails({bool preserveEditState = false}) async {
    if (!preserveEditState) {
      setState(() => _isLoading = true);
    }

    final data = await WorkoutDatabaseHelper.instance.getWorkoutLogById(
      widget.logId,
    );
    if (data == null) {
      if (mounted) setState(() => _isLoading = false);
      return;
    }

    final groups = <String, List<SetLog>>{};
    for (var set in data.sets) {
      groups.putIfAbsent(set.exerciseName, () => []).add(set);
    }

    final Map<String, double> categoryVolume = {};
    for (final set in data.sets) {
      final exercise = await WorkoutDatabaseHelper.instance.getExerciseByName(
        set.exerciseName,
      );
      if (exercise != null) {
        final volumeForSet = (set.weightKg ?? 0) * (set.reps ?? 0);
        categoryVolume.update(
          exercise.categoryName,
          (value) => value + volumeForSet,
          ifAbsent: () => volumeForSet,
        );
      }
    }

    final tempExerciseDetails = <String, Exercise>{};
    for (var name in groups.keys) {
      final exercise = await WorkoutDatabaseHelper.instance.getExerciseByName(
        name,
      );
      if (exercise != null) tempExerciseDetails[name] = exercise;
    }

    _notesController.text = data.notes ?? '';
    _editedStartTime = data.startTime;

    _clearControllers();
    for (final setLog in data.sets) {
      _weightControllers[setLog.id!] = TextEditingController(
        text: setLog.weightKg?.toStringAsFixed(1).replaceAll('.0', '') ?? '',
      );
      _repsControllers[setLog.id!] = TextEditingController(
        text: setLog.reps?.toString() ?? '',
      );
    }

    if (!mounted) return;
    setState(() {
      _log = data;
      _groupedSets = groups;
      _exerciseDetails = tempExerciseDetails;
      _categoryVolume = categoryVolume;
      if (!preserveEditState) {
        _isLoading = false;
      }
    });
  }

  void _toggleEditMode() {
    setState(() {
      _isEditMode = !_isEditMode;
      if (_isEditMode) {
        _loadDetails(preserveEditState: true);
      } else {
        _loadDetails();
      }
    });
  }

  Future<void> _pickDateTime() async {
    final date = await showDatePicker(
      context: context,
      initialDate: _editedStartTime ?? DateTime.now(),
      firstDate: DateTime(2020),
      lastDate: DateTime.now().add(const Duration(days: 1)),
    );
    if (date == null) return;

    final time = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(_editedStartTime ?? DateTime.now()),
    );
    if (time == null) return;

    setState(() {
      _editedStartTime = DateTime(
        date.year,
        date.month,
        date.day,
        time.hour,
        time.minute,
      );
    });
  }

  Future<void> _saveChanges() async {
    FocusScope.of(context).unfocus();
    if (!(_formKey.currentState?.validate() ?? false)) return;

    final l10n = AppLocalizations.of(context)!;
    final dbHelper = WorkoutDatabaseHelper.instance;

    final initialSetIds = _log!.sets.map((s) => s.id!).toSet();
    final currentSets = _groupedSets.values.expand((sets) => sets).toList();

    final idsToDelete = initialSetIds
        .difference(currentSets.map((s) => s.id!).toSet())
        .toList();

    final List<SetLog> setsToUpdate = [];
    final List<SetLog> setsToInsert = [];

    for (final setLog in currentSets) {
      final weight = double.tryParse(
            _weightControllers[setLog.id!]?.text.replaceAll(',', '.') ?? '0',
          ) ??
          0.0;
      final reps = int.tryParse(_repsControllers[setLog.id!]?.text ?? '0') ?? 0;

      final updatedSet = setLog.copyWith(weightKg: weight, reps: reps);

      if (initialSetIds.contains(setLog.id)) {
        setsToUpdate.add(updatedSet);
      } else {
        setsToInsert.add(updatedSet);
      }
    }

    await dbHelper.updateWorkoutLogDetails(
      widget.logId,
      _editedStartTime!,
      _notesController.text,
    );
    if (idsToDelete.isNotEmpty) await dbHelper.deleteSetLogs(idsToDelete);
    if (setsToUpdate.isNotEmpty) await dbHelper.updateSetLogs(setsToUpdate);
    for (final set in setsToInsert) {
      await dbHelper.insertSetLog(
        set.copyWith(id: null, workoutLogId: widget.logId),
      );
    }

    if (mounted) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text(l10n.snackbarRoutineSaved)));
    }

    setState(() => _isEditMode = false);
    _loadDetails();
  }

  Widget _buildHeader(String text) => Expanded(
        child: Text(
          text,
          textAlign: TextAlign.center,
          style: TextStyle(
            color: Colors.grey[600],
            fontSize: 12,
            fontWeight: FontWeight.bold,
          ),
        ),
      );

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).toString();
    final textTheme = Theme.of(context).textTheme;
    final colorScheme = Theme.of(context).colorScheme;

    double totalVolume = 0.0;
    if (_log != null) {
      for (final set in _log!.sets) {
        totalVolume += (set.weightKg ?? 0) * (set.reps ?? 0);
      }
    }
    final Duration duration =
        _log?.endTime?.difference(_log!.startTime) ?? Duration.zero;

    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: GlobalAppBar(
        title: l10n.workoutDetailsTitle,
        actions: [
          if (!_isLoading && _log != null)
            _isEditMode
                ? TextButton(
                    onPressed: _saveChanges,
                    child: Text(
                      l10n.save,
                      style: TextStyle(
                        color: colorScheme.primary,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  )
                : IconButton(
                    icon: const Icon(Icons.edit),
                    onPressed: _toggleEditMode,
                  ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _log == null
              ? Center(child: Text(l10n.workoutNotFound))
              : Column(
                  children: [
                    WorkoutSummaryBar(
                      duration: duration,
                      volume: totalVolume,
                      sets: _log!.sets.length,
                      progress: null,
                    ),
                    Divider(
                      height: 1,
                      thickness: 1,
                      color: colorScheme.onSurfaceVariant.withOpacity(0.1),
                    ),
                    Expanded(
                      child: ListView(
                        padding: EdgeInsets.zero,
                        children: [
                          // Header Info Section mit SummaryCard
                          Padding(
                            padding: DesignConstants.cardPadding,
                            child: SummaryCard(
                              child: Padding(
                                padding: const EdgeInsets.all(16.0),
                                child: Form(
                                  key: _formKey,
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      Text(
                                        _log!.routineName ??
                                            l10n.freeWorkoutTitle,
                                        style: textTheme.headlineMedium,
                                      ),
                                      Row(
                                        children: [
                                          Text(
                                            DateFormat.yMMMMd(
                                              locale,
                                            ).add_Hm().format(
                                                  _editedStartTime ??
                                                      _log!.startTime,
                                                ),
                                          ),
                                          if (_isEditMode)
                                            IconButton(
                                              icon: Icon(
                                                Icons.calendar_today,
                                                size: 18,
                                                color: colorScheme.primary,
                                              ),
                                              onPressed: _pickDateTime,
                                            ),
                                        ],
                                      ),
                                      const SizedBox(
                                        height: DesignConstants.spacingM,
                                      ),
                                      _isEditMode
                                          ? TextFormField(
                                              controller: _notesController,
                                              decoration: InputDecoration(
                                                labelText: l10n.notesLabel,
                                              ),
                                              maxLines: 3,
                                            )
                                          : (_log!.notes != null &&
                                                  _log!.notes!.isNotEmpty
                                              ? Text(
                                                  '${l10n.notesLabel}: ${_log!.notes!}',
                                                  style: const TextStyle(
                                                    fontStyle: FontStyle.italic,
                                                  ),
                                                )
                                              : const SizedBox.shrink()),
                                      if (_categoryVolume.isNotEmpty) ...[
                                        const Divider(height: 24),
                                        Text(
                                          l10n.muscleSplitLabel,
                                          style: textTheme.titleMedium,
                                        ),
                                        const SizedBox(
                                          height: DesignConstants.spacingS,
                                        ),
                                        ..._buildCategoryBars(context),
                                      ],
                                    ],
                                  ),
                                ),
                              ),
                            ),
                          ),

                          // Exercise Sets mit WorkoutCard
                          ..._buildSetList(context, l10n),

                          // Add Exercise Button
                          if (_isEditMode)
                            Padding(
                              padding: const EdgeInsets.all(16.0),
                              child: TextButton.icon(
                                onPressed: () async {
                                  final selectedExercise =
                                      await Navigator.of(context)
                                          .push<Exercise>(
                                    MaterialPageRoute(
                                      builder: (context) =>
                                          const ExerciseCatalogScreen(
                                        isSelectionMode: true,
                                      ),
                                    ),
                                  );
                                  if (selectedExercise != null) {
                                    setState(() {
                                      final newSet = SetLog(
                                        id: DateTime.now()
                                            .millisecondsSinceEpoch,
                                        workoutLogId: _log!.id!,
                                        exerciseName: selectedExercise
                                            .getLocalizedName(context),
                                        setType: 'normal',
                                      );
                                      _groupedSets[selectedExercise
                                          .getLocalizedName(context)] = [
                                        newSet,
                                      ];
                                      _weightControllers[newSet.id!] =
                                          TextEditingController();
                                      _repsControllers[newSet.id!] =
                                          TextEditingController();
                                    });
                                  }
                                },
                                icon: const Icon(Icons.add),
                                label: Text(l10n.addExerciseToWorkoutButton),
                              ),
                            ),

                          Padding(
                            padding: const EdgeInsets.fromLTRB(
                              16.0,
                              24.0,
                              16.0,
                              8.0,
                            ),
                            child: WgerAttributionWidget(
                              textStyle: textTheme.bodySmall?.copyWith(
                                color: Colors.grey[600],
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
    );
  }

  List<Widget> _buildCategoryBars(BuildContext context) {
    final total = _categoryVolume.values.fold<double>(0, (a, b) => a + b);
    return _categoryVolume.entries.map((entry) {
      final fraction = total > 0 ? entry.value / total : 0.0;
      return Padding(
        padding: const EdgeInsets.symmetric(vertical: 4.0),
        child: Row(
          children: [
            Expanded(
              flex: 2,
              child: Text(entry.key, style: const TextStyle(fontSize: 12)),
            ),
            Expanded(
              flex: 5,
              child: LinearProgressIndicator(
                value: fraction,
                backgroundColor: Colors.grey.shade300,
                color: Theme.of(context).colorScheme.primary,
                minHeight: 12,
              ),
            ),
            const SizedBox(width: 8),
            Text("${(fraction * 100).toStringAsFixed(0)}%"),
          ],
        ),
      );
    }).toList();
  }

  Widget _buildSetRow(
    SetLog setLog,
    int rowIndex, // Der Index in der Liste der Sätze für DIESE Übung
    int workingSetIndex, // Der "Arbeitssatz"-Index
    String exerciseName,
    AppLocalizations l10n,
  ) {
    final setType = setLog.setType;
    final isLightMode = Theme.of(context).brightness == Brightness.light;

    final bool isColoredRow = rowIndex > 0 && rowIndex.isOdd;
    final Color rowColor;
    if (isColoredRow) {
      rowColor = isLightMode
          ? Colors.grey.withOpacity(0.1)
          // HIER DIE ÄNDERUNG: Erhöhte Opazität für Dark Mode
          : Colors.white.withOpacity(0.1);
    } else {
      rowColor = Colors.transparent;
    }

    return Container(
      color: rowColor,
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 4.0),
        child: Row(
          children: [
            // ... restlicher Code der Methode bleibt unverändert
            Expanded(
              flex: 2,
              child: Center(
                child: Builder(
                  builder: (_) {
                    Color textColor;
                    switch (setType) {
                      case 'warmup':
                        textColor = Colors.orange;
                        break;
                      case 'dropset':
                        textColor = Colors.blue;
                        break;
                      case 'failure':
                        textColor = Colors.red;
                        break;
                      default:
                        textColor = Colors.grey;
                    }
                    return GestureDetector(
                      onTap: () {
                        if (_isEditMode) _showSetTypePicker(setLog.id!);
                      },
                      child: Text(
                        _getSetDisplayText(setType, workingSetIndex),
                        style: TextStyle(
                          color: textColor,
                          fontSize: 20,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    );
                  },
                ),
              ),
            ),
            const Expanded(
              flex: 3,
              child: Center(
                child: Text(
                  "-",
                  textAlign: TextAlign.center,
                  style: TextStyle(color: Colors.grey, fontSize: 12),
                ),
              ),
            ),
            Expanded(
              flex: 2,
              child: _isEditMode
                  ? TextFormField(
                      controller: _weightControllers[setLog.id!],
                      textAlign: TextAlign.center,
                      keyboardType: const TextInputType.numberWithOptions(
                        decimal: true,
                      ),
                      decoration: const InputDecoration(
                        border: InputBorder.none,
                        isDense: true,
                        fillColor: Colors.transparent,
                      ),
                    )
                  : Text(
                      setLog.weightKg
                              ?.toStringAsFixed(1)
                              .replaceAll('.0', '') ??
                          '0',
                      textAlign: TextAlign.center,
                      style: const TextStyle(fontSize: 16),
                    ),
            ),
            const SizedBox(width: 8),
            Expanded(
              flex: 2,
              child: _isEditMode
                  ? TextFormField(
                      controller: _repsControllers[setLog.id!],
                      textAlign: TextAlign.center,
                      keyboardType: TextInputType.number,
                      decoration: const InputDecoration(
                        border: InputBorder.none,
                        isDense: true,
                        fillColor: Colors.transparent,
                      ),
                    )
                  : Text(
                      "${setLog.reps ?? '0'}",
                      textAlign: TextAlign.center,
                      style: const TextStyle(fontSize: 16),
                    ),
            ),
            Padding(
              padding: const EdgeInsets.only(right: 8.0),
              child: SizedBox(
                width: 48,
                child: _isEditMode
                    ? IconButton(
                        icon: const Icon(
                          Icons.delete_outline,
                          color: Colors.redAccent,
                        ),
                        onPressed: () {
                          setState(() {
                            _groupedSets[exerciseName]?.removeWhere(
                              (s) => s.id == setLog.id,
                            );
                            _weightControllers.remove(setLog.id!)?.dispose();
                            _repsControllers.remove(setLog.id!)?.dispose();
                          });
                        },
                      )
                    : const Icon(Icons.check_circle, color: Colors.green),
              ),
            ),
          ],
        ),
      ),
    );
  }

  List<Widget> _buildSetList(BuildContext context, AppLocalizations l10n) {
    final textTheme = Theme.of(context).textTheme;
    final entries = _groupedSets.entries.toList();

    if (!_isEditMode) {
      // Normale Liste ohne Reorder-Funktionalität
      return entries
          .map((entry) => _buildExerciseCard(context, l10n, entry, -1))
          .toList();
    } else {
      // ReorderableListView für Edit-Modus
      return [
        ReorderableListView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          padding: EdgeInsets.zero,
          onReorder: (int oldIndex, int newIndex) {
            setState(() {
              if (newIndex > oldIndex) {
                newIndex -= 1;
              }
              final item = entries.removeAt(oldIndex);
              entries.insert(newIndex, item);

              // Gruppierte Sets Map neu aufbauen
              _groupedSets.clear();
              for (var entry in entries) {
                _groupedSets[entry.key] = entry.value;
              }
            });
          },
          itemCount: entries.length,
          itemBuilder: (context, index) {
            return _buildExerciseCard(context, l10n, entries[index], index);
          },
        ),
      ];
    }
  }

  Widget _buildExerciseCard(
    BuildContext context,
    AppLocalizations l10n,
    MapEntry<String, List<SetLog>> entry,
    int index,
  ) {
    final String exerciseName = entry.key;
    final Exercise? exercise = _exerciseDetails[exerciseName];
    final List<SetLog> sets = entry.value;
    final textTheme = Theme.of(context).textTheme;

    return WorkoutCard(
      key: _isEditMode ? ValueKey(exerciseName) : null,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          ListTile(
            contentPadding: const EdgeInsets.symmetric(
              horizontal: 16.0,
              vertical: 8.0,
            ),
            leading: _isEditMode
                ? ReorderableDragStartListener(
                    index: index,
                    child: const Icon(Icons.drag_handle),
                  )
                : null,
            title: InkWell(
              onTap: () {
                if (exercise != null) {
                  Navigator.of(context).push(
                    MaterialPageRoute(
                      builder: (context) =>
                          ExerciseDetailScreen(exercise: exercise),
                    ),
                  );
                }
              },
              child: Padding(
                padding: const EdgeInsets.symmetric(vertical: 4.0),
                child: Text(
                  exercise?.getLocalizedName(context) ?? exerciseName,
                  style: textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
            trailing: _isEditMode
                ? IconButton(
                    icon: const Icon(
                      Icons.delete_outline,
                      color: Colors.redAccent,
                    ),
                    tooltip: l10n.removeExercise,
                    onPressed: () {
                      setState(() {
                        for (var set in sets) {
                          _weightControllers.remove(set.id!)?.dispose();
                          _repsControllers.remove(set.id!)?.dispose();
                        }
                        _groupedSets.remove(exerciseName);
                      });
                    },
                  )
                : const Icon(Icons.info_outline),
          ),

          // Header Row
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 0.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      flex: 2,
                      child: Center(
                        child: Text(
                          l10n.setLabel,
                          textAlign: TextAlign.center,
                          style: TextStyle(
                            color: Colors.grey[600],
                            fontSize: 12,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                    Expanded(
                      flex: 3,
                      child: Center(
                        child: Text(
                          l10n.lastTimeLabel,
                          textAlign: TextAlign.center,
                          style: TextStyle(
                            color: Colors.grey[600],
                            fontSize: 12,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                    Expanded(
                      flex: 2,
                      child: Center(
                        child: Text(
                          l10n.kgLabel,
                          textAlign: TextAlign.center,
                          style: TextStyle(
                            color: Colors.grey[600],
                            fontSize: 12,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                    Expanded(
                      flex: 2,
                      child: Center(
                        child: Text(
                          l10n.repsLabel,
                          textAlign: TextAlign.center,
                          style: TextStyle(
                            color: Colors.grey[600],
                            fontSize: 12,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(width: 48),
                  ],
                ),

                // Set Rows
                ...sets.asMap().entries.map((setEntry) {
                  final setLog = setEntry.value;
                  final rowIndex = setEntry
                      .key; // Der Index in der Liste der Sätze für DIESE Übung

                  // Normale Sätze zählen (ohne Warmup)
                  int workingSetIndex = 0;
                  for (int i = 0; i <= rowIndex; i++) {
                    if (sets[i].setType != 'warmup') {
                      workingSetIndex++;
                    }
                  }

                  return _buildSetRow(
                    setLog,
                    rowIndex,
                    workingSetIndex,
                    exerciseName,
                    l10n,
                  );
                }),

                // Add Set Button
                if (_isEditMode)
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16.0),
                    child: TextButton.icon(
                      onPressed: () {
                        final newSet = SetLog(
                          id: DateTime.now().millisecondsSinceEpoch,
                          workoutLogId: _log!.id!,
                          exerciseName: exerciseName,
                          setType: 'normal',
                        );
                        setState(() {
                          sets.add(newSet);
                          _weightControllers[newSet.id!] =
                              TextEditingController();
                          _repsControllers[newSet.id!] =
                              TextEditingController();
                        });
                      },
                      icon: const Icon(Icons.add),
                      label: Text(l10n.addSetButton),
                    ),
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  void _changeSetType(int setLogId, String newType) {
    setState(() {
      // Finde den SetLog und ändere den setType
      for (var entry in _groupedSets.entries) {
        for (var setLog in entry.value) {
          if (setLog.id == setLogId) {
            // Erstelle eine neue Instanz mit geändertem setType
            final index = entry.value.indexOf(setLog);
            entry.value[index] = setLog.copyWith(setType: newType);
            break;
          }
        }
      }
    });
    Navigator.pop(context);
  }

  void _showSetTypePicker(int setLogId) {
    showModalBottomSheet(
      context: context,
      builder: (context) {
        return Wrap(
          children: <Widget>[
            ListTile(
              title: const Text('Normal'),
              onTap: () => _changeSetType(setLogId, 'normal'),
            ),
            ListTile(
              title: const Text('Warmup'),
              onTap: () => _changeSetType(setLogId, 'warmup'),
            ),
            ListTile(
              title: const Text('Failure'),
              onTap: () => _changeSetType(setLogId, 'failure'),
            ),
            ListTile(
              title: const Text('Dropset'),
              onTap: () => _changeSetType(setLogId, 'dropset'),
            ),
          ],
        );
      },
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/home.dart =====

// lib/screens/home.dart (Final & SWR-Lade-Logik)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/models/tracked_supplement.dart';
//import 'package:lightweight/screens/supplement_hub_screen.dart';
import 'package:lightweight/screens/supplement_track_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/supplement_summary_widget.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/chart_data_point.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/screens/measurements_screen.dart';
import 'package:lightweight/screens/nutrition_screen.dart';
import 'package:lightweight/widgets/measurement_chart_widget.dart';
import 'package:lightweight/widgets/nutrition_summary_widget.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/util/date_util.dart';

class Home extends StatefulWidget {
  const Home({super.key});

  @override
  HomeState createState() => HomeState();
}

class HomeState extends State<Home> {
  DailyNutrition? _nutritionData;
  String _recommendationText = "";
  // KORREKTUR: _isLoading wird jetzt nur für den ERSTEN Ladevorgang auf true gesetzt
  bool _isLoading = true;

  List<ChartDataPoint> _weightChartData = [];
  DateTimeRange _currentDateRange = DateTimeRange(
    start: DateTime.now().subtract(const Duration(days: 29)),
    end: DateTime.now(),
  );
  final String _chartType = 'weight';
  Map<String, int> _workoutStats = {};
  bool _isFirstLoad = true;
  List<TrackedSupplement> _trackedSupplements = [];

  final List<String> _chartDateRangeKeys = ['30D', '90D', 'All'];
  String _selectedChartRangeKey = '30D';

  @override
  void initState() {
    super.initState();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (_isFirstLoad) {
      loadAllHomeScreenData(
        showLoadingIndicator: true,
      ); // KORREKTUR: Zeige Indikator nur beim ersten Mal
      _isFirstLoad = false;
    }
  }

  Future<void> loadAllHomeScreenData({
    bool showLoadingIndicator = false,
  }) async {
    if (!mounted) return;

    // KORREKTUR: Setze _isLoading nur, wenn der Indikator wirklich gezeigt werden soll
    if (showLoadingIndicator) {
      setState(() => _isLoading = true);
    }

    // --- DATEN HIER LADEN ---
    final l10n = AppLocalizations.of(context)!;
    final dbHelper = DatabaseHelper.instance;
    final prefs = await SharedPreferences.getInstance();
    final targetCalories = prefs.getInt('targetCalories') ?? 2500;
    final targetProtein = prefs.getInt('targetProtein') ?? 180;
    final targetCarbs = prefs.getInt('targetCarbs') ?? 250;
    final targetFat = prefs.getInt('targetFat') ?? 80;
    final targetWater = prefs.getInt('targetWater') ?? 3000;

    final entries = await dbHelper.getEntriesForDate(DateTime.now());
    final fluidEntries = await dbHelper.getFluidEntriesForDate(DateTime.now());
    final waterIntake = fluidEntries.fold<int>(
      0,
      (sum, entry) => sum + entry.quantityInMl,
    );
    final newTodaysNutrition = DailyNutrition(
      targetCalories: targetCalories,
      targetProtein: targetProtein,
      targetCarbs: targetCarbs,
      targetFat: targetFat,
      targetWater: targetWater,
    );
    newTodaysNutrition.water = waterIntake;

    final newWorkoutStats =
        await _getWorkoutStats(); // KORREKTUR: Methode umbenannt
    await _loadChartData(); // Lädt Chart-Daten und setzt _weightChartData

    for (final entry in entries) {
      final foodItem = await ProductDatabaseHelper.instance.getProductByBarcode(
        entry.barcode,
      );
      if (foodItem != null) {
        newTodaysNutrition.calories +=
            (foodItem.calories / 100 * entry.quantityInGrams).round();
        newTodaysNutrition.protein +=
            (foodItem.protein / 100 * entry.quantityInGrams).round();
        newTodaysNutrition.carbs +=
            (foodItem.carbs / 100 * entry.quantityInGrams).round();
        newTodaysNutrition.fat +=
            (foodItem.fat / 100 * entry.quantityInGrams).round();
      }
    }

    final today = DateTime.now();
    final sevenDaysAgo = today.subtract(const Duration(days: 6));
    final recentEntries = await dbHelper.getEntriesForDateRange(
      sevenDaysAgo,
      today,
    );
    String newRecommendation = l10n.recommendationDefault;
    if (recentEntries.isNotEmpty) {
      final uniqueDaysTracked = recentEntries
          .map((e) => DateFormat.yMd().format(e.timestamp))
          .toSet();
      final numberOfTrackedDays = uniqueDaysTracked.length;
      int totalRecentCalories = 0;
      for (final entry in recentEntries) {
        final foodItem = await ProductDatabaseHelper.instance
            .getProductByBarcode(entry.barcode);
        if (foodItem != null) {
          totalRecentCalories +=
              (foodItem.calories / 100 * entry.quantityInGrams).round();
        }
      }
      final totalTargetCalories = targetCalories * numberOfTrackedDays;
      final difference = totalRecentCalories - totalTargetCalories;
      if (numberOfTrackedDays > 1) {
        final tolerance = totalTargetCalories * 0.05;
        if (difference > tolerance) {
          newRecommendation = l10n.recommendationOverTarget(
            numberOfTrackedDays,
            difference.round(),
          );
        } else if (difference < -tolerance) {
          newRecommendation = l10n.recommendationUnderTarget(
            numberOfTrackedDays,
            (-difference).round(),
          );
        } else {
          newRecommendation = l10n.recommendationOnTarget(numberOfTrackedDays);
        }
      } else {
        newRecommendation = l10n.recommendationFirstEntry;
      }
    }

    // NEU: Lade Supplement-Daten
    final allSupplements = await dbHelper.getAllSupplements();
    final todaysSupplementLogs = await dbHelper.getSupplementLogsForDate(
      DateTime.now(),
    );
    final Map<int, double> todaysDoses = {};
    for (final log in todaysSupplementLogs) {
      todaysDoses.update(
        log.supplementId,
        (value) => value + log.dose,
        ifAbsent: () => log.dose,
      );
    }
    final trackedSupps = allSupplements
        .map(
          (s) => TrackedSupplement(
            supplement: s,
            totalDosedToday: todaysDoses[s.id] ?? 0.0,
          ),
        )
        .toList();

    // --- DATEN LADEN ENDE ---

    if (mounted) {
      setState(() {
        _nutritionData = newTodaysNutrition; // Neue Daten
        _recommendationText = newRecommendation; // Neue Daten
        _workoutStats = newWorkoutStats; // Neue Daten
        _trackedSupplements = trackedSupps; // NEU
        _isLoading = false; // Ladezustand beenden
      });
    }
  }

  Future<void> _loadChartData() async {
    // KORRIGIERT: Die Logik zur Berechnung des Zeitraums wird hierher verschoben.
    final now = DateTime.now();
    DateTime start;
    DateTime end = DateTime(now.year, now.month, now.day, 23, 59, 59);

    switch (_selectedChartRangeKey) {
      case '90D':
        start = now.subtract(const Duration(days: 89));
        break;
      case 'All':
        // Für "Alle" holen wir das früheste Datum aus der Datenbank
        final earliest =
            await DatabaseHelper.instance.getEarliestMeasurementDate();
        start = earliest ?? now;
        break;
      case '30D':
      default:
        start = now.subtract(const Duration(days: 29));
    }

    final normalizedStart = DateTime(start.year, start.month, start.day);

    // Wichtig: Den State für den Datumsbereich hier aktualisieren!
    if (!mounted) return;
    setState(() {
      _currentDateRange = DateTimeRange(start: normalizedStart, end: end);
    });

    // Der Rest der Methode bleibt gleich, lädt aber jetzt mit dem korrekten Zeitbereich.
    final sessions = await DatabaseHelper.instance.getMeasurementSessions();
    final points = <ChartDataPoint>[];

    for (final s in sessions) {
      if (s.timestamp.isBefore(normalizedStart) || s.timestamp.isAfter(end)) {
        continue;
      }

      for (final m in s.measurements) {
        if (m.type == _chartType) {
          points.add(
            ChartDataPoint(date: s.timestamp, value: m.value.toDouble()),
          );
        }
      }
    }

    points.sort((a, b) => a.date.compareTo(b.date));

    if (!mounted) return;
    setState(() {
      _weightChartData = points;
    });
  }

  // KORREKTUR: Methode umbenannt, damit sie Daten ZURÜCKGIBT
  Future<Map<String, int>> _getWorkoutStats() async {
    final today = DateTime.now();
    final sevenDaysAgo = today.subtract(const Duration(days: 6));

    final logs = await WorkoutDatabaseHelper.instance
        .getWorkoutLogsForDateRange(sevenDaysAgo, today);

    int count = logs.length;
    int duration = 0;
    int volume = 0;

    for (final log in logs) {
      if (log.endTime != null) {
        duration += log.endTime!.difference(log.startTime).inMinutes;
      }
      for (final set in log.sets) {
        volume += ((set.weightKg ?? 0) * (set.reps ?? 0)).round();
      }
    }
    return {'count': count, 'duration': duration, 'volume': volume};
  }

  void _navigateTimeRange(bool forward) {
    // "All" deckt sowieso alles ab – kein Paging
    if (_selectedChartRangeKey == 'All') return;

    final int days = _selectedChartRangeKey == '90D' ? 90 : 30;
    final delta = Duration(days: days);

    final newStart = forward
        ? _currentDateRange.start.add(delta)
        : _currentDateRange.start.subtract(delta);
    final newEnd = forward
        ? _currentDateRange.end.add(delta)
        : _currentDateRange.end.subtract(delta);

    setState(() {
      _currentDateRange = DateTimeRange(start: newStart, end: newEnd);
    });

    // Daten für die neue Range nachladen
    _loadChartData();
  }

  void _navigateToNutritionScreen() {
    Navigator.of(context)
        .push(MaterialPageRoute(builder: (context) => const NutritionScreen()))
        .then((_) => loadAllHomeScreenData(showLoadingIndicator: false));
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;

    // KORREKTUR: Zeige den Ladeindikator nur, wenn _isLoading true UND keine Daten vorhanden sind
    final showLoadingOverlay = _isLoading && _nutritionData == null;

    return Scaffold(
      body: Stack(
        children: [
          // KORREKTUR: Der RefreshIndicator ist immer da, damit man ziehen kann.
          // Der Inhalt wird immer angezeigt, auch wenn _isLoading true ist (alte Daten).
          RefreshIndicator(
            onRefresh: () => loadAllHomeScreenData(
              showLoadingIndicator: false,
            ), // KORREKTUR: Kein Ladeindikator bei manueller Aktualisierung
            child: ListView(
              padding: DesignConstants.screenPadding,
              children: [
                _buildBannerCard(l10n),
                const SizedBox(height: DesignConstants.spacingS),
                GestureDetector(
                  onTap: _navigateToNutritionScreen,
                  child: _nutritionData != null
                      ? NutritionSummaryWidget(
                          nutritionData: _nutritionData!,
                          isExpandedView: false,
                          l10n: l10n,
                        )
                      : const SizedBox.shrink(),
                ),
                const SizedBox(height: DesignConstants.spacingS),
                SupplementSummaryWidget(
                  trackedSupplements: _trackedSupplements,
                  onTap: () => Navigator.of(context)
                      .push(
                        MaterialPageRoute(
                          builder: (context) => const SupplementTrackScreen(),
                        ),
                      )
                      .then(
                        (_) =>
                            loadAllHomeScreenData(showLoadingIndicator: false),
                      ),
                ),
                if (_weightChartData.isNotEmpty)
                  const SizedBox(height: DesignConstants.spacingS),
                GestureDetector(
                  onTap: () => Navigator.of(context)
                      .push(
                        MaterialPageRoute(
                          builder: (context) => const MeasurementsScreen(),
                        ),
                      )
                      .then((_) => loadAllHomeScreenData()),
                  child: _buildWeightChartCard(context, colorScheme, l10n),
                ),
                const SizedBox(height: DesignConstants.spacingS),
                _buildWorkoutStatsCard(l10n),
              ],
            ),
          ),
          // KORREKTUR: Lade-Overlay nur anzeigen, wenn showLoadingOverlay true ist
          if (showLoadingOverlay)
            Positioned.fill(
              child: Container(
                color: Colors.black.withOpacity(0.5),
                child: const Center(child: CircularProgressIndicator()),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildBannerCard(AppLocalizations l10n) {
    // KORREKTUR: externalMargin wird jetzt gesetzt
    return SummaryCard(
      //internalPadding: const EdgeInsets.symmetric(horizontal: 16.0),
      //externalMargin: EdgeInsets.zero, // Wichtig, da ListView.separated den Abstand steuert
      child: Container(
        height: 100,
        alignment: Alignment.center,
        child: Text(
          _recommendationText,
          textAlign: TextAlign.center,
          style: TextStyle(
            color: Theme.of(context).colorScheme.onSurfaceVariant,
            fontSize: 22,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }

  // In lib/screens/home.dart, innerhalb von HomeState

  Widget _buildWeightChartCard(
    BuildContext context,
    ColorScheme colorScheme,
    AppLocalizations l10n,
  ) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  l10n.weightHistoryTitle,
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                ),
                Expanded(
                  child: Align(
                    alignment: Alignment.centerRight,
                    child: Wrap(
                      spacing: 8.0,
                      alignment: WrapAlignment.end,
                      children: _chartDateRangeKeys
                          .map((key) => _buildFilterButton(key, key))
                          .toList(),
                    ),
                  ),
                ),
              ],
            ),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                IconButton(
                  icon: const Icon(Icons.chevron_left),
                  onPressed: () => _navigateTimeRange(false),
                ),
                Text(
                  "${DateFormat.MMMd().format(_currentDateRange.start)} - ${DateFormat.MMMd().format(_currentDateRange.end)}",
                  style: Theme.of(context).textTheme.bodySmall,
                ),
                IconButton(
                  icon: const Icon(Icons.chevron_right),
                  onPressed: _currentDateRange.end.isSameDate(DateTime.now())
                      ? null
                      : () => _navigateTimeRange(true),
                ),
              ],
            ),
            const SizedBox(height: DesignConstants.spacingL),
            MeasurementChartWidget(
              chartType: _chartType,
              dateRange: _currentDateRange,
              // KORREKTUR: Die folgende Zeile wurde entfernt
              // lineColor: colorScheme.secondary,
              unit: "kg",
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFilterButton(String label, String key) {
    final theme = Theme.of(context);
    final isSelected = _selectedChartRangeKey == key;
    return GestureDetector(
      onTap: () {
        setState(() {
          _selectedChartRangeKey = key;
        });
        _loadChartData();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10.0, vertical: 6.0),
        decoration: BoxDecoration(
          color: isSelected
              ? theme.colorScheme.primary
              : theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
          borderRadius: BorderRadius.circular(8.0),
        ),
        child: Text(
          label,
          style: theme.textTheme.labelSmall?.copyWith(
            color: isSelected
                ? theme.colorScheme.onPrimary
                : theme.colorScheme.onSurfaceVariant,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  Widget _buildWorkoutStatsCard(AppLocalizations l10n) {
    // KORREKTUR: externalMargin wird jetzt gesetzt
    return SummaryCard(
      //externalMargin: EdgeInsets.zero, // Wichtig
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              l10n.workoutStatsTitle,
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: DesignConstants.spacingM),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                Column(
                  children: [
                    const Icon(Icons.fitness_center, size: 28),
                    const SizedBox(height: 4),
                    Text(
                      "${_workoutStats['count'] ?? 0}",
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      l10n.workoutsLabel,
                      style: const TextStyle(fontSize: 12),
                    ),
                  ],
                ),
                Column(
                  children: [
                    const Icon(Icons.timer, size: 28),
                    const SizedBox(height: 4),
                    Text(
                      "${_workoutStats['duration'] ?? 0} min",
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      l10n.durationLabel,
                      style: const TextStyle(fontSize: 12),
                    ),
                  ],
                ),
                Column(
                  children: [
                    const Icon(Icons.monitor_weight, size: 28),
                    const SizedBox(height: 4),
                    Text(
                      "${_workoutStats['volume'] ?? 0} kg",
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      l10n.volumeLabel,
                      style: const TextStyle(fontSize: 12),
                    ),
                  ],
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/supplement_hub_screen.dart =====

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/dialogs/log_supplement_menu.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';
import 'package:lightweight/models/tracked_supplement.dart';
import 'package:lightweight/screens/create_supplement_screen.dart';
import 'package:lightweight/util/date_util.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/global_app_bar.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';

class SupplementHubScreen extends StatefulWidget {
  const SupplementHubScreen({super.key});
  @override
  State<SupplementHubScreen> createState() => _SupplementHubScreenState();
}

class _SupplementHubScreenState extends State<SupplementHubScreen> {
  bool _isLoading = true;
  List<TrackedSupplement> _trackedSupplements = [];
  List<SupplementLog> _todaysLogs = [];
  final Map<int, Supplement> _supplementsById = {};
  DateTime _selectedDate = DateTime.now();

  @override
  void initState() {
    super.initState();
    _loadData(_selectedDate);
  }

  String localizeSupplementName(Supplement s, AppLocalizations l10n) {
    switch (s.code) {
      case 'caffeine':
        return l10n.supplement_caffeine;
      case 'creatine_monohydrate':
        return l10n.supplement_creatine_monohydrate;
      default:
        return s.name;
    }
  }

  Future<void> _loadData(DateTime date) async {
    setState(() => _isLoading = true);
    final db = DatabaseHelper.instance;
    final allSupplements = await db.getAllSupplements();
    final logsForDate = await db.getSupplementLogsForDate(date);
    final Map<int, Supplement> byId = {
      for (final s in allSupplements)
        if (s.id != null) s.id!: s,
    };
    final Map<int, double> todaysDoses = {};
    for (final log in logsForDate) {
      todaysDoses.update(
        log.supplementId,
        (value) => value + log.dose,
        ifAbsent: () => log.dose,
      );
    }
    final tracked = allSupplements.map((s) {
      return TrackedSupplement(
        supplement: s,
        totalDosedToday: todaysDoses[s.id] ?? 0.0,
      );
    }).toList();
    if (!mounted) return;
    setState(() {
      _supplementsById
        ..clear()
        ..addAll(byId);
      _trackedSupplements = tracked;
      _todaysLogs = logsForDate;
      _isLoading = false;
    });
  }

  Future<void> _logSupplement(Supplement supplement) async {
    final l10n = AppLocalizations.of(context)!;

    final result = await showGlassBottomMenu<bool>(
      context: context,
      title: localizeSupplementName(supplement, l10n),
      contentBuilder: (ctx, close) {
        return LogSupplementDoseBody(
          supplement: supplement,
          primaryLabel: l10n.add_button,
          onCancel: close,
          onSubmit: (dose, ts) async {
            await DatabaseHelper.instance.insertSupplementLog(
              SupplementLog(
                supplementId: supplement.id!,
                dose: dose,
                unit: supplement.unit,
                timestamp: ts,
              ),
            );
            close();
            Navigator.of(ctx).pop(true);
          },
        );
      },
    );

    if (result == true) {
      _loadData(_selectedDate);
    }
  }

  Future<void> _editLogEntry(SupplementLog log) async {
    final l10n = AppLocalizations.of(context)!;
    final supplement = _supplementsById[log.supplementId]!;

    final result = await showGlassBottomMenu<(double, DateTime)?>(
      context: context,
      title: localizeSupplementName(supplement, l10n),
      contentBuilder: (ctx, close) {
        return LogSupplementDoseBody(
          supplement: supplement,
          initialDose: log.dose,
          initialTimestamp: log.timestamp,
          primaryLabel: l10n.save,
          onCancel: close,
          onSubmit: (dose, ts) {
            close();
            Navigator.of(ctx).pop((dose, ts));
          },
        );
      },
    );

    if (result != null) {
      final updated = SupplementLog(
        id: log.id,
        supplementId: supplement.id!,
        dose: result.$1,
        unit: supplement.unit,
        timestamp: result.$2,
      );
      await DatabaseHelper.instance.updateSupplementLog(updated);
      _loadData(_selectedDate);
    }
  }

  Future<void> _deleteLogEntry(int logId) async {
    // NEU: Verwendung des standardisierten Helpers
    final confirmed = await showDeleteConfirmation(context);

    if (confirmed) {
      await DatabaseHelper.instance.deleteSupplementLog(logId);
      _loadData(_selectedDate);
    }
  }

  Future<void> _deleteSupplement(Supplement supplement) async {
    final l10n = AppLocalizations.of(context)!;

    // NEU: Verwendung des Helpers mit spezifischem Text
    final confirmed = await showDeleteConfirmation(
      context,
      content: l10n.deleteSupplementConfirm,
    );

    if (confirmed) {
      await DatabaseHelper.instance.deleteSupplement(supplement.id!);
      _loadData(_selectedDate);
    }
  }

  void _navigateDay(bool forward) {
    final newDay = _selectedDate.add(Duration(days: forward ? 1 : -1));
    if (forward && newDay.isAfter(DateTime.now())) return;
    setState(() {
      _selectedDate = newDay;
    });
    _loadData(_selectedDate);
  }

  Future<void> _pickDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (picked != null && picked != _selectedDate) {
      setState(() {
        _selectedDate = picked;
      });
      _loadData(_selectedDate);
    }
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildProgressCard(TrackedSupplement ts) {
    final supplement = ts.supplement;
    final isLimit = supplement.dailyLimit != null;
    final target = (isLimit ? supplement.dailyLimit : supplement.dailyGoal)!;
    final overTarget = isLimit && ts.totalDosedToday > target;
    final hasTarget = target > 0;
    final rawProgress = hasTarget ? (ts.totalDosedToday / target) : 0.0;
    final progress = rawProgress.clamp(0.0, 1.0);
    final progressColor =
        overTarget ? Colors.red.shade400 : Colors.green.shade400;
    final l10n = AppLocalizations.of(context)!;

    return Container(
      height: 60,
      margin: const EdgeInsets.symmetric(vertical: 6.0),
      decoration: BoxDecoration(
        color: Theme.of(
          context,
        ).colorScheme.surfaceContainerHighest.withOpacity(0.3),
        borderRadius: BorderRadius.circular(20),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(20),
        child: Stack(
          fit: StackFit.expand,
          children: [
            Align(
              alignment: Alignment.centerLeft,
              child: FractionallySizedBox(
                widthFactor: progress,
                child: Container(color: progressColor),
              ),
            ),
            Padding(
              padding: const EdgeInsets.symmetric(
                horizontal: 12.0,
                vertical: 4.0,
              ),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  FittedBox(
                    fit: BoxFit.scaleDown,
                    child: Text(
                      localizeSupplementName(supplement, l10n),
                      maxLines: 1,
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    '${ts.totalDosedToday.toStringAsFixed(1)} / ${target.toStringAsFixed(1)} ${supplement.unit}',
                    style: TextStyle(
                      color: Theme.of(
                        context,
                      ).colorScheme.onSurface.withOpacity(0.8),
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildLogEntry(SupplementLog log, AppLocalizations l10n) {
    final s = _supplementsById[log.supplementId];
    final titleText = (s != null) ? localizeSupplementName(s, l10n) : 'Unknown';

    return Dismissible(
      key: Key('log_${log.id}'),
      direction: DismissDirection.horizontal,
      background: const SwipeActionBackground(
        color: Colors.blueAccent,
        icon: Icons.edit,
        alignment: Alignment.centerLeft,
      ),
      secondaryBackground: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      confirmDismiss: (direction) async {
        if (direction == DismissDirection.startToEnd) {
          _editLogEntry(log);
          return false; // Nicht dismissen, da Edit-Dialog aufging
        } else {
          // Für Delete (EndToStart): Wir geben true zurück, damit die Animation läuft,
          // ABER wir rufen die Lösch-Logik erst in onDismissed auf.
          // ODER wir zeigen hier den Dialog. Da Dismissible sofort entfernt, ist Dialog hier besser:

          // Wir rufen unsere _deleteLogEntry Methode auf, die den Dialog zeigt.
          // Aber Dismissible erwartet ein Future<bool>.
          // Einfacherer Weg für Dismissible mit Dialog:

          final l10n = AppLocalizations.of(context)!;
          final confirmed = await showGlassBottomMenu<bool>(
            context: context,
            title: l10n.deleteConfirmTitle,
            contentBuilder: (ctx, close) {
              return Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed: () {
                        close();
                        Navigator.of(ctx).pop(false);
                      },
                      child: Text(l10n.cancel),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: FilledButton(
                      onPressed: () {
                        close();
                        Navigator.of(ctx).pop(true);
                      },
                      child: Text(l10n.delete),
                    ),
                  ),
                ],
              );
            },
          );
          return confirmed ?? false;
        }
      },
      onDismissed: (direction) {
        if (direction == DismissDirection.endToStart) {
          _deleteLogEntry(log.id!);
        }
      },
      child: SummaryCard(
        child: ListTile(
          leading: const Icon(Icons.check_circle, color: Colors.grey),
          title: Text(titleText),
          subtitle: Text(DateFormat.Hm().format(log.timestamp)),
          trailing: Text('${log.dose.toStringAsFixed(1)} ${log.unit}'),
        ),
      ),
    );
  }

  Future<void> _navigateToEditSupplement(Supplement supplement) async {
    final reloaded = await Navigator.of(context).push<bool>(
      MaterialPageRoute(
        builder: (context) =>
            CreateSupplementScreen(supplementToEdit: supplement),
      ),
    );
    if (reloaded == true) {
      _loadData(_selectedDate);
    }
  }

  Widget _buildLogActionCard(Supplement supplement) {
    final l10n = AppLocalizations.of(context)!;
    final isBuiltin = supplement.isBuiltin || supplement.code == 'caffeine';

    if (isBuiltin) {
      return SummaryCard(
        child: ListTile(
          leading: const Icon(Icons.add_circle_outline),
          title: Text(localizeSupplementName(supplement, l10n)),
          onTap: () => _logSupplement(supplement),
        ),
      );
    }

    return Dismissible(
      key: Key('supplement_${supplement.id}'),
      direction: DismissDirection.horizontal,
      background: const SwipeActionBackground(
        color: Colors.blueAccent,
        icon: Icons.edit,
        alignment: Alignment.centerLeft,
      ),
      secondaryBackground: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      confirmDismiss: (direction) async {
        if (direction == DismissDirection.startToEnd) {
          _navigateToEditSupplement(supplement);
          return false;
        } else {
          _deleteSupplement(supplement);
          return false;
        }
      },
      child: SummaryCard(
        child: ListTile(
          leading: const Icon(Icons.add_circle_outline),
          title: Text(localizeSupplementName(supplement, l10n)),
          onTap: () => _logSupplement(supplement),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    // ... (build method remains the same)
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).toString();
    final textTheme = Theme.of(context).textTheme;

    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: GlobalAppBar(
        title: l10n.supplementTrackerTitle,
      ),
      body: Column(
        children: [
          Padding(
            padding: DesignConstants.cardPadding.copyWith(
              top: DesignConstants.cardPadding.top + topPadding,
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                IconButton(
                  icon: const Icon(Icons.chevron_left),
                  onPressed: () => _navigateDay(false),
                ),
                Expanded(
                  child: InkWell(
                    onTap: _pickDate,
                    child: Text(
                      DateFormat.yMMMMd(locale).format(_selectedDate),
                      style: textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                      textAlign: TextAlign.center,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.chevron_right),
                  onPressed: _selectedDate.isSameDate(DateTime.now())
                      ? null
                      : () => _navigateDay(true),
                ),
              ],
            ),
          ),
          Divider(
            height: 1,
            thickness: 1,
            color: Theme.of(
              context,
            ).colorScheme.onSurfaceVariant.withOpacity(0.1),
          ),
          Expanded(
            child: _isLoading
                ? const Center(child: CircularProgressIndicator())
                : RefreshIndicator(
                    onRefresh: () => _loadData(_selectedDate),
                    child: ListView(
                      padding: DesignConstants.cardPadding,
                      children: [
                        _buildSectionTitle(context, l10n.dailyProgressTitle),
                        if (_trackedSupplements
                            .where(
                              (ts) =>
                                  ts.supplement.dailyGoal != null ||
                                  ts.supplement.dailyLimit != null,
                            )
                            .isEmpty)
                          Padding(
                            padding: const EdgeInsets.symmetric(vertical: 8.0),
                            child: Text(
                              l10n.emptySupplementGoals,
                              textAlign: TextAlign.center,
                            ),
                          ),
                        ..._trackedSupplements
                            .where(
                              (ts) =>
                                  ts.supplement.dailyGoal != null ||
                                  ts.supplement.dailyLimit != null,
                            )
                            .map((ts) => _buildProgressCard(ts)),
                        const SizedBox(height: DesignConstants.spacingXL),
                        _buildSectionTitle(context, l10n.logIntakeTitle),
                        ..._trackedSupplements.map(
                          (ts) => _buildLogActionCard(ts.supplement),
                        ),
                        const SizedBox(height: DesignConstants.spacingXL),
                        _buildSectionTitle(context, l10n.todaysLogTitle),
                        if (_todaysLogs.isEmpty)
                          Padding(
                            padding: const EdgeInsets.symmetric(vertical: 8.0),
                            child: Text(
                              l10n.emptySupplementLogs,
                              textAlign: TextAlign.center,
                            ),
                          )
                        else
                          ..._todaysLogs.map(
                            (log) => _buildLogEntry(log, l10n),
                          ),
                      ],
                    ),
                  ),
          ),
        ],
      ),
      floatingActionButton: GlassFab(
        label: l10n.createSupplementTitle,
        onPressed: () async {
          final created = await Navigator.of(context).push<bool>(
            MaterialPageRoute(
              builder: (context) => const CreateSupplementScreen(),
            ),
          );
          if (created == true) {
            _loadData(_selectedDate);
          }
        },
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/food_detail_screen.dart =====

// lib/screens/food_detail_screen.dart (Final & De-Materialisiert - OLED Ready)

import 'package:flutter/material.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/tracked_food_item.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/global_app_bar.dart';
import 'package:lightweight/widgets/off_attribution_widget.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart' as p;
import 'package:share_plus/share_plus.dart';

// Dev-Flag: später einfach auf false setzen oder die Dev-Blöcke entfernen.
const bool kDevEditEnabled = false;

class FoodDetailScreen extends StatefulWidget {
  final TrackedFoodItem? trackedItem;
  final FoodItem? foodItem;

  const FoodDetailScreen({super.key, this.trackedItem, this.foodItem})
      : assert(trackedItem != null || foodItem != null);

  @override
  State<FoodDetailScreen> createState() => _FoodDetailScreenState();
}

class _FoodDetailScreenState extends State<FoodDetailScreen> {
  bool _isFavorite = false;
  bool _showPer100g = false;

  late FoodItem _displayItem;
  int? _trackedQuantity;
  bool get _hasPortionInfo => _trackedQuantity != null;

  // ---------- DEV: Inline-Editing ----------
  bool _devEditing = false; // via Secret-Tap toggeln

  final _deCtrl = TextEditingController();
  final _enCtrl = TextEditingController();
  final _catCtrl = TextEditingController();

  final _calCtrl = TextEditingController();
  final _proCtrl = TextEditingController();
  final _carbCtrl = TextEditingController();
  final _fatCtrl = TextEditingController();
  final _kjCtrl = TextEditingController();
  final _fibCtrl = TextEditingController();
  final _sugCtrl = TextEditingController();
  final _saltCtrl = TextEditingController();
  final _sodCtrl = TextEditingController();
  final _calciumCtrl = TextEditingController();

  void _fillControllers(FoodItem item, {Map<String, dynamic>? rawRow}) {
    _deCtrl.text = (rawRow?['name_de'] as String?) ?? item.name;
    _enCtrl.text = (rawRow?['name_en'] as String?) ?? '';
    _catCtrl.text = (rawRow?['category_key'] as String?) ?? '';

    _calCtrl.text = (item.calories).toString();
    _proCtrl.text = (item.protein).toString();
    _carbCtrl.text = (item.carbs).toString();
    _fatCtrl.text = (item.fat).toString();
    _kjCtrl.text = (rawRow?['kj_100g'] as num?)?.toString() ?? '';
    _fibCtrl.text = (rawRow?['fiber_100g'] as num?)?.toString() ?? '';
    _sugCtrl.text = (rawRow?['sugar_100g'] as num?)?.toString() ?? '';
    _saltCtrl.text = (rawRow?['salt_100g'] as num?)?.toString() ?? '';
    _sodCtrl.text = (rawRow?['sodium_100g'] as num?)?.toString() ?? '';
    _calciumCtrl.text = (rawRow?['calcium_100g'] as num?)?.toString() ?? '';
  }

  @override
  void initState() {
    super.initState();
    if (widget.trackedItem != null) {
      _displayItem = widget.trackedItem!.item;
      _trackedQuantity = widget.trackedItem!.entry.quantityInGrams;
    } else {
      _displayItem = widget.foodItem!;
      _trackedQuantity = null;
      _showPer100g = true;
    }
    _checkIfFavorite();
  }

  @override
  void dispose() {
    _deCtrl.dispose();
    _enCtrl.dispose();
    _catCtrl.dispose();
    _calCtrl.dispose();
    _proCtrl.dispose();
    _carbCtrl.dispose();
    _fatCtrl.dispose();
    _kjCtrl.dispose();
    _fibCtrl.dispose();
    _sugCtrl.dispose();
    _saltCtrl.dispose();
    _sodCtrl.dispose();
    _calciumCtrl.dispose();
    super.dispose();
  }

  // ---------- DEV: Basis-DB Hilfen ----------

  Future<String> _getBaseDbPath() async {
    // Versuche erst den bekannten Namen der Base-DB im App-DB-Verzeichnis
    final dbDir = await getDatabasesPath();
    return p.join(dbDir, 'vita_base_foods.db');
  }

  Future<Database> _openBaseDb({bool readOnly = false}) async {
    final path = await _getBaseDbPath();
    return openDatabase(path, readOnly: readOnly);
  }

  Future<Map<String, dynamic>?> _loadRawRow(String barcode) async {
    final base = await _openBaseDb(readOnly: true);
    try {
      final rows = await base.query(
        'products',
        where: 'barcode = ?',
        whereArgs: [barcode],
        limit: 1,
      );
      return rows.isNotEmpty ? rows.first : null;
    } finally {
      await base.close();
    }
  }

  Future<void> _saveDevEdits() async {
    try {
      final barcode = _displayItem.barcode;
      final Map<String, Object?> fields = {
        // Spiegel beachten: name = name_de
        'name_de': _deCtrl.text.trim(),
        'name_en': _enCtrl.text.trim().isEmpty ? null : _enCtrl.text.trim(),
        'name': _deCtrl.text.trim(),
        'category_key':
            _catCtrl.text.trim().isEmpty ? null : _catCtrl.text.trim(),
        // Nährwerte
        'calories_100g': int.tryParse(_calCtrl.text.trim()),
        'protein_100g': double.tryParse(_proCtrl.text.trim()),
        'carbs_100g': double.tryParse(_carbCtrl.text.trim()),
        'fat_100g': double.tryParse(_fatCtrl.text.trim()),
        'kj_100g': double.tryParse(_kjCtrl.text.trim()),
        'fiber_100g': double.tryParse(_fibCtrl.text.trim()),
        'sugar_100g': double.tryParse(_sugCtrl.text.trim()),
        'salt_100g': double.tryParse(_saltCtrl.text.trim()),
        'sodium_100g': double.tryParse(_sodCtrl.text.trim()),
        'calcium_100g': double.tryParse(_calciumCtrl.text.trim()),
      };

      // leere Strings zu null; 'barcode' niemals überschreiben
      fields.removeWhere((k, v) => v == null);

      final db = await _openBaseDb();
      try {
        await db.update(
          'products',
          fields,
          where: 'barcode = ?',
          whereArgs: [barcode],
          conflictAlgorithm: ConflictAlgorithm.replace,
        );
      } finally {
        await db.close();
      }
      await ProductDatabaseHelper.instance.reloadBaseDb();

      // Für sichtbares Refresh: Eintrag neu aus Base-DB laden
      final baseDb = await _openBaseDb(readOnly: true);
      Map<String, dynamic>? row;
      try {
        final rows = await baseDb.query(
          'products',
          where: 'barcode = ?',
          whereArgs: [barcode],
          limit: 1,
        );
        if (rows.isNotEmpty) row = rows.first;
      } finally {
        await baseDb.close();
      }
      if (row != null) {
        setState(() {
          _displayItem = FoodItem.fromMap(row!, source: FoodItemSource.base);
        });
      }

      if (!mounted) return;
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(const SnackBar(content: Text('Gespeichert (Basis-DB)')));
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text('Fehler: $e')));
    }
  }

  Future<void> _exportBaseDb() async {
    try {
      final path = await _getBaseDbPath();
      final file = XFile(path, name: p.basename(path));
      await Share.shareXFiles([file], subject: 'Export: vita_base_foods.db');
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text('Export-Fehler: $e')));
    }
  }

  // ---------- Favoriten / Anzeige ----------

  Future<void> _checkIfFavorite() async {
    final isFav = await DatabaseHelper.instance.isFavorite(
      _displayItem.barcode,
    );
    if (mounted) setState(() => _isFavorite = isFav);
  }

  Future<void> _toggleFavorite() async {
    if (_isFavorite) {
      await DatabaseHelper.instance.removeFavorite(_displayItem.barcode);
    } else {
      await DatabaseHelper.instance.addFavorite(_displayItem.barcode);
    }
    _checkIfFavorite();
  }

  double _getDisplayValue(double? valuePer100g) {
    if (valuePer100g == null) return 0.0;
    if (_showPer100g || !_hasPortionInfo) {
      return valuePer100g;
    }
    return (valuePer100g / 100 * _trackedQuantity!);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    final displayQuantity =
        _showPer100g || !_hasPortionInfo ? 100 : _trackedQuantity!;

    // KORREKTUR: Explizite Berechnung des oberen Abstands
    // MediaQuery.padding.top = Statusleiste
    // kToolbarHeight = Höhe der AppBar (56.0)
    // + Extra Abstand (DesignConstants.cardPaddingInternal), damit es nicht klebt
    final double topInset = MediaQuery.of(context).padding.top;
    final double totalTopPadding =
        topInset + kToolbarHeight + DesignConstants.cardPaddingInternal;

    return Scaffold(
      extendBodyBehindAppBar: true,
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      floatingActionButton: GlassFab(
        onPressed: () {
          Navigator.of(context).pop(widget.foodItem);
        },
        label: l10n.mealsAddToDiary,
      ),
      appBar: GlobalAppBar(
        title: _displayItem.getLocalizedName(context),
        actions: [
          IconButton(
            icon: Icon(
              _isFavorite ? Icons.favorite : Icons.favorite_border,
              color:
                  _isFavorite ? Colors.redAccent : colorScheme.onSurfaceVariant,
            ),
            onPressed: _toggleFavorite,
          ),
        ],
      ),
      body: SingleChildScrollView(
        // KORREKTUR: Padding direkt setzen statt copyWith, um Fehler zu vermeiden
        padding: EdgeInsets.fromLTRB(
          DesignConstants.cardPaddingInternal,
          totalTopPadding,
          DesignConstants.cardPaddingInternal,
          DesignConstants.cardPaddingInternal + 80.0, // + Platz für FAB unten
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (_displayItem.brand.isNotEmpty)
              Text(
                _displayItem.brand,
                style: textTheme.titleMedium?.copyWith(color: Colors.grey[600]),
              ),
            // Falls Brand leer ist, sorgt dieser Divider für Abstand,
            // aber das Padding oben ist jetzt das Wichtigste.
            Divider(
              height: 32,
              thickness: 1,
              color: colorScheme.onSurfaceVariant.withOpacity(0.1),
            ),
            if (_hasPortionInfo)
              SummaryCard(
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16.0,
                    vertical: 8.0,
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceAround,
                    children: [
                      _buildToggleButton(
                        context,
                        l10n.foodDetailSegmentPortion,
                        false,
                      ),
                      _buildToggleButton(
                        context,
                        l10n.foodDetailSegment100g,
                        true,
                      ),
                    ],
                  ),
                ),
              ),
            if (_hasPortionInfo)
              const SizedBox(height: DesignConstants.spacingL),
            Text(
              "Nährwerte pro ${displayQuantity}g",
              style: textTheme.titleLarge,
            ),
            const SizedBox(height: DesignConstants.spacingS),
            SummaryCard(
              child: Column(
                children: [
                  _buildNutrientRow(
                    l10n.calories,
                    "${_getDisplayValue(_displayItem.calories.toDouble()).round()} kcal",
                  ),
                  _buildNutrientRow(
                    l10n.protein,
                    "${_getDisplayValue(_displayItem.protein).toStringAsFixed(1)} g",
                  ),
                  _buildNutrientRow(
                    l10n.carbs,
                    "${_getDisplayValue(_displayItem.carbs).toStringAsFixed(1)} g",
                  ),
                  _buildNutrientRow(
                    l10n.fat,
                    "${_getDisplayValue(_displayItem.fat).toStringAsFixed(1)} g",
                  ),
                ],
              ),
            ),
            if (_displayItem.sugar != null ||
                _displayItem.fiber != null ||
                _displayItem.salt != null) ...[
              const SizedBox(height: DesignConstants.spacingM),
              SummaryCard(
                child: Column(
                  children: [
                    if (_displayItem.sugar != null)
                      _buildNutrientRow(
                        l10n.sugar,
                        "${_getDisplayValue(_displayItem.sugar).toStringAsFixed(1)} g",
                      ),
                    if (_displayItem.fiber != null)
                      _buildNutrientRow(
                        l10n.fiber,
                        "${_getDisplayValue(_displayItem.fiber).toStringAsFixed(1)} g",
                      ),
                    if (_displayItem.salt != null)
                      _buildNutrientRow(
                        l10n.salt,
                        "${_getDisplayValue(_displayItem.salt).toStringAsFixed(1)} g",
                      ),
                  ],
                ),
              ),
            ],

            // ---------- DEV: Inline-Edit Panel ----------
            if (kDevEditEnabled && _devEditing) ...[
              const SizedBox(height: DesignConstants.spacingM),
              SummaryCard(
                child: Padding(
                  padding: const EdgeInsets.all(12.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'DEV: Eintrag bearbeiten',
                        style: textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 8),
                      _row('Name (DE)', _deCtrl),
                      const SizedBox(height: 8),
                      _row('Name (EN)', _enCtrl),
                      const SizedBox(height: 8),
                      _row('Kategorie-Key', _catCtrl),
                      const SizedBox(height: 12),
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: [
                          _num('kcal/100g', _calCtrl),
                          _num('Protein/100g', _proCtrl),
                          _num('Carbs/100g', _carbCtrl),
                          _num('Fett/100g', _fatCtrl),
                          _num('kJ/100g', _kjCtrl),
                          _num('Ballastst./100g', _fibCtrl),
                          _num('Zucker/100g', _sugCtrl),
                          _num('Salz/100g', _saltCtrl),
                          _num('Natrium/100g', _sodCtrl),
                          _num('Calcium/100g', _calciumCtrl),
                        ],
                      ),
                      const SizedBox(height: 12),
                      Row(
                        children: [
                          ElevatedButton.icon(
                            onPressed: _saveDevEdits,
                            icon: const Icon(Icons.save),
                            label: const Text('Speichern'),
                          ),
                          const SizedBox(width: 12),
                          TextButton.icon(
                            onPressed: () =>
                                setState(() => _devEditing = false),
                            icon: const Icon(Icons.close),
                            label: const Text('Fertig'),
                          ),
                          const Spacer(),
                          IconButton(
                            tooltip: 'Basis-DB exportieren',
                            onPressed: _exportBaseDb,
                            icon: const Icon(Icons.ios_share),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ],

            if (!_displayItem.barcode.startsWith('user_created_'))
              Padding(
                padding: const EdgeInsets.only(top: 24.0, bottom: 8.0),
                child: OffAttributionWidget(
                  textStyle: textTheme.bodySmall?.copyWith(
                    color: Colors.grey[600],
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildToggleButton(
    BuildContext context,
    String label,
    bool is100gOption,
  ) {
    final theme = Theme.of(context);
    final isSelected = _showPer100g == is100gOption;
    return Expanded(
      child: InkWell(
        onTap: () => setState(() => _showPer100g = is100gOption),
        borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM),
        child: Container(
          padding: const EdgeInsets.symmetric(vertical: 12.0, horizontal: 8.0),
          decoration: BoxDecoration(
            color: isSelected
                ? theme.colorScheme.primary.withOpacity(0.2)
                : Colors.transparent,
            borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM),
            border: Border.all(
              color: isSelected
                  ? theme.colorScheme.primary
                  : theme.colorScheme.onSurfaceVariant.withOpacity(0.3),
            ),
          ),
          child: Text(
            label,
            textAlign: TextAlign.center,
            style: theme.textTheme.titleMedium?.copyWith(
              color: isSelected
                  ? theme.colorScheme.primary
                  : theme.colorScheme.onSurface,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildNutrientRow(String label, String value) {
    return ListTile(
      dense: true,
      title: Text(label),
      trailing: Text(
        value,
        style: const TextStyle(fontWeight: FontWeight.bold),
      ),
    );
  }

  // ---------- DEV: kleine Helfer-Inputs ----------

  Widget _row(String label, TextEditingController c) => TextField(
        controller: c,
        decoration: InputDecoration(
          labelText: label,
          border: const OutlineInputBorder(),
          isDense: true,
        ),
      );

  Widget _num(String label, TextEditingController c) => SizedBox(
        width: 160,
        child: TextField(
          controller: c,
          keyboardType: const TextInputType.numberWithOptions(
            decimal: true,
            signed: false,
          ),
          decoration: InputDecoration(
            labelText: label,
            border: const OutlineInputBorder(),
            isDense: true,
          ),
        ),
      );
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/add_food_screen.dart =====

// lib/screens/add_food_screen.dart (Final & De-Materialisiert)

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';
import 'package:lightweight/screens/create_food_screen.dart';
import 'package:lightweight/screens/food_detail_screen.dart';
import 'package:lightweight/screens/meal_screen.dart';
import 'package:lightweight/screens/scanner_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/bottom_content_spacer.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/global_app_bar.dart';
import 'package:lightweight/widgets/off_attribution_widget.dart';
import 'package:lightweight/widgets/summary_card.dart';

// lib/screens/add_food_screen.dart

class AddFoodScreen extends StatefulWidget {
  final int initialTab;
  final DateTime? initialDate; // <--- NEU
  final String? initialMealType; // <--- NEU
  const AddFoodScreen({
    super.key,
    this.initialTab = 0,
    this.initialDate, // <--- NEU
    this.initialMealType, // <--- NEU
  });

  @override
  State<AddFoodScreen> createState() => _AddFoodScreenState();
}

class _AddFoodScreenState extends State<AddFoodScreen>
    with SingleTickerProviderStateMixin {
  List<FoodItem> _foundFoodItems = [];
  bool _isLoadingSearch = false;
  String _searchInitialText = "";
  final _searchController = TextEditingController();

  List<FoodItem> _favoriteFoodItems = [];
  bool _isLoadingFavorites = true;

  List<FoodItem> _recentFoodItems = [];
  bool _isLoadingRecent = true;

  late TabController _tabController;
  final TextEditingController _baseSearchCtrl = TextEditingController();
  String _baseSearch = '';
  Timer? _baseSearchDebounce;

  List<Map<String, dynamic>> _baseCategories = [];
  final Map<String, List<FoodItem>> _catItems = {}; // key -> Produkte
  final Set<String> _loadingCats = {}; // ladeanzeige je Kategorie
  // Meals
  List<Map<String, dynamic>> _meals = [];
  final Map<int, List<Map<String, dynamic>>> _mealItemsCache = {};
  bool _isLoadingMeals = true;
  int _currentTab = 0; // 0=Katalog, 1=Zuletzt, 2=Favoriten, 3=Mahlzeiten
  bool _suspendFab = false;
  static const double _bottomPadding = 100.0;

  Future<void> _loadMeals() async {
    setState(() => _isLoadingMeals = true);
    final rows = await DatabaseHelper.instance.getMeals();
    setState(() {
      _meals = rows;
      _isLoadingMeals = false;
    });
  }

  Future<List<Map<String, dynamic>>> _getMealItems(int mealId) async {
    if (_mealItemsCache.containsKey(mealId)) return _mealItemsCache[mealId]!;
    final rows = await DatabaseHelper.instance.getMealItems(mealId);
    _mealItemsCache[mealId] = rows;
    return rows;
  }

  Future<void> _loadBaseCategories() async {
    _baseCategories = await ProductDatabaseHelper.instance.getBaseCategories();
    if (mounted) setState(() {});
  }

  Future<void> _loadCategoryItems(String key) async {
    if (_catItems.containsKey(key) || _loadingCats.contains(key)) return;
    _loadingCats.add(key);
    if (mounted) setState(() {});
    final items = await ProductDatabaseHelper.instance.getBaseFoods(
      categoryKey: key,
      limit: 500, // großzügig – DB ist lokal
    );
    _catItems[key] = items;
    _loadingCats.remove(key);
    if (mounted) setState(() {});
  }

  void _onBaseSearchChanged(String v) {
    _baseSearchDebounce?.cancel();
    _baseSearchDebounce = Timer(const Duration(milliseconds: 250), () {
      setState(() => _baseSearch = v.trim());
    });
  }

  @override
  void initState() {
    super.initState();
    _tabController =
        TabController(length: 4, vsync: this, initialIndex: widget.initialTab);
    _currentTab = _tabController.index;
    _tabController.addListener(() {
      if (_currentTab != _tabController.index) {
        setState(() {
          _currentTab = _tabController.index;
        });
      }
    });

    _searchController.addListener(() => setState(() {}));
    _loadFavorites();
    _loadRecentItems();
    _baseSearchCtrl.addListener(
      () => _onBaseSearchChanged(_baseSearchCtrl.text),
    );
    _loadBaseCategories();
    _loadMeals();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (_searchInitialText.isEmpty) {
      _searchInitialText = AppLocalizations.of(context)!.searchInitialHint;
    }
  }

  @override
  void dispose() {
    _searchController.dispose();
    _tabController.dispose();
    _baseSearchDebounce?.cancel();
    _baseSearchCtrl.dispose();
    super.dispose();
  }

  void _runFilter(String enteredKeyword) async {
    final l10n = AppLocalizations.of(context)!;
    if (enteredKeyword.isEmpty) {
      setState(() {
        _foundFoodItems = [];
        _searchInitialText = l10n.searchInitialHint;
      });
      return;
    }
    setState(() {
      _isLoadingSearch = true;
    });

    final results = await ProductDatabaseHelper.instance.searchProducts(
      enteredKeyword,
    );

    if (mounted) {
      setState(() {
        _foundFoodItems = results;
        _isLoadingSearch = false;
        if (results.isEmpty) {
          _searchInitialText = l10n.searchNoResults;
        }
      });
    }
  }

  void _navigateAndCreateFood() {
    Navigator.of(context)
        .push(MaterialPageRoute(builder: (context) => const CreateFoodScreen()))
        .then((_) {
      _searchController.clear();
      _runFilter('');
      _loadFavorites();
      _loadRecentItems();
    });
  }

  Future<void> _loadFavorites() async {
    setState(() {
      _isLoadingFavorites = true;
    });
    final results = await ProductDatabaseHelper.instance.getFavoriteProducts();
    if (mounted) {
      setState(() {
        _favoriteFoodItems = results;
        _isLoadingFavorites = false;
      });
    }
  }

  Future<void> _loadRecentItems() async {
    setState(() {
      _isLoadingRecent = true;
    });
    final results = await ProductDatabaseHelper.instance.getRecentProducts();
    if (mounted) {
      setState(() {
        _recentFoodItems = results;
        _isLoadingRecent = false;
      });
    }
  }

  Future<void> _createMealAndOpenEditor(AppLocalizations l10n) async {
    // Solider Default-Name (nicht leer wegen NOT NULL in DB)
    final defaultName = l10n.mealTypeLabel; // z.B. "Mahlzeit" / "Meal"
    final newMealId = await DatabaseHelper.instance.insertMeal(
      name: defaultName,
      notes: '',
    );

    final meal = {'id': newMealId, 'name': defaultName, 'notes': ''};

    await Navigator.of(context).push(
      MaterialPageRoute(
        builder: (_) => MealScreen(meal: meal, startInEdit: true),
      ),
    );

    // Nach Rückkehr Liste aktualisieren
    await _loadMeals();

    // (Optionaler Feinschliff)
    // Wenn Nutzer abbricht und nichts geändert hat: Platzhalter wieder entfernen.
    try {
      final items = await DatabaseHelper.instance.getMealItems(newMealId);
      // Falls noch mit Defaultnamen und ohne Zutaten → löschen
      final created = _meals.firstWhere((m) => m['id'] == newMealId);
      if ((created['name'] as String) == defaultName && items.isEmpty) {
        await DatabaseHelper.instance.deleteMeal(newMealId);
        await _loadMeals();
      }
    } catch (_) {
      /* egal, Cleanup ist optional */
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final isLightMode = Theme.of(context).brightness == Brightness.light;

    // NEU: Top Padding berechnen, da wir extendBodyBehindAppBar nutzen
    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    // FAB Logik (unverändert lassen, nur hier der Vollständigkeit halber angedeutet)
    VoidCallback? fabOnPressed;
    String fabLabel;
    if (_suspendFab) {
      fabOnPressed = null;
      fabLabel = '';
    } else if (_currentTab == 3) {
      fabLabel = l10n.mealsCreate;
      fabOnPressed = () => _createMealAndOpenEditor(l10n);
    } else {
      fabLabel = l10n.fabCreateOwnFood;
      fabOnPressed = _navigateAndCreateFood;
    }

    return Scaffold(
      extendBodyBehindAppBar: true, // WICHTIG: Damit das Glas der AppBar wirkt
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,

      // WICHTIG: GlobalAppBar statt normaler AppBar
      appBar: GlobalAppBar(
        title: l10n.nutritionExplorerTitle,
      ),

      body: Column(
        children: [
          // WICHTIG: Platzhalter oben, damit der Inhalt nicht hinter der AppBar verschwindet
          SizedBox(height: topPadding),

          Padding(
            padding: const EdgeInsets.symmetric(
              horizontal: 16.0,
              vertical: 12.0,
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                TabBar(
                  controller: _tabController,
                  isScrollable: false,
                  indicator: const BoxDecoration(),
                  splashFactory: NoSplash.splashFactory,
                  overlayColor: WidgetStateProperty.all(Colors.transparent),
                  labelPadding: EdgeInsets.zero,
                  labelColor: isLightMode ? Colors.black : Colors.white,
                  unselectedLabelColor: Colors.grey.shade600,
                  labelStyle: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w800,
                  ),
                  unselectedLabelStyle: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w800,
                  ),
                  tabs: [
                    Tab(text: l10n.tabCatalogSearch),
                    Tab(text: l10n.tabRecent),
                    Tab(text: l10n.tabFavorites),
                    Tab(text: l10n.tabMeals),
                  ],
                ),
              ],
            ),
          ),
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildCatalogSearchTab(l10n),
                _buildRecentTab(l10n),
                _buildFavoritesTab(l10n),
                _buildMealsTab(l10n),
              ],
            ),
          ),
        ],
      ),
      floatingActionButton: _suspendFab
          ? null
          : GlassFab(
              label: fabLabel,
              onPressed: fabOnPressed ?? () {},
            ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  Widget _buildSearchTab(AppLocalizations l10n) {
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    return Padding(
      // KORREKTUR 4: Horizontaler Padding hier angepasst, um das Abschneiden zu verhindern
      padding: const EdgeInsets.symmetric(
        horizontal: 16.0,
        vertical: 0,
      ), // Vertikalen Padding auf 0 setzen
      child: Column(
        children: [
          Row(
            children: [
              // Die Suchleiste füllt jetzt den verfügbaren Platz
              Expanded(
                child: TextField(
                  controller: _searchController,
                  onChanged: (value) => _runFilter(value),
                  decoration: InputDecoration(
                    hintText: l10n.searchHintText,
                    prefixIcon: Icon(
                      Icons.search,
                      color: colorScheme.onSurfaceVariant,
                      size: 20,
                    ),
                    suffixIcon: _searchController.text.isNotEmpty
                        ? IconButton(
                            icon: Icon(
                              Icons.clear,
                              color: colorScheme.onSurfaceVariant,
                            ),
                            onPressed: () {
                              _searchController.clear();
                              _runFilter('');
                            },
                          )
                        : null,
                  ),
                ),
              ),
              const SizedBox(width: 8), // Kleiner Abstand
              // Der neue Scanner-Button
              IconButton(
                style: IconButton.styleFrom(
                  backgroundColor: colorScheme.surfaceContainerHighest,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
                icon: Icon(Icons.qr_code_scanner, color: colorScheme.primary),
                onPressed: _scanBarcodeAndPop, // Ruft die neue Methode auf
              ),
            ],
          ),
          const SizedBox(height: 20),
          Expanded(
            child: _isLoadingSearch
                ? const Center(child: CircularProgressIndicator())
                : _foundFoodItems.isNotEmpty
                    ? ListView.builder(
                        itemCount: _foundFoodItems.length,
                        itemBuilder: (context, index) =>
                            _buildFoodListItem(_foundFoodItems[index]),
                      )
                    : Center(
                        child: Text(
                          _searchInitialText,
                          style: textTheme.titleMedium,
                        ),
                      ),
          ),
          if (_foundFoodItems.any((item) => item.source == FoodItemSource.off))
            const OffAttributionWidget(),
        ],
      ),
    );
  }

  Widget _buildBaseFoodsTab(AppLocalizations l10n) {
    // Kopf: Suche
    final searchField = Padding(
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
      child: TextField(
        controller: _baseSearchCtrl,
        textInputAction: TextInputAction.search,
        decoration: InputDecoration(
          // KORREKTUR: Lokalisierter Hint
          hintText: l10n.searchBaseFoodHint, 
          prefixIcon: const Icon(Icons.search),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
          isDense: true,
        ),
      ),
    );

    // Modus 1: mit Suchbegriff → Trefferliste
    if (_baseSearch.isNotEmpty) {
      return Column(
        children: [
          searchField,
          Expanded(
            child: FutureBuilder<List<FoodItem>>(
              future: ProductDatabaseHelper.instance.getBaseFoods(
                search: _baseSearch,
                limit: 200,
              ),
              builder: (context, snap) {
                if (snap.connectionState == ConnectionState.waiting) {
                  return const Center(child: CircularProgressIndicator());
                }
                final items = snap.data ?? [];
                if (items.isEmpty) {
                  // KORREKTUR: Lokalisierter Text
                  return Center(child: Text(l10n.searchNoHits)); 
                }
                return ListView.builder(
                  padding: DesignConstants.cardPadding,
                  itemCount: items.length,
                  itemBuilder: (_, i) => _buildFoodListItem(items[i]),
                );
              },
            ),
          ),
        ],
      );
    }

    // Modus 2: kein Suchbegriff → Kategorien mit Emoji (Accordion)
    return Column(
      children: [
        searchField,
        if (_baseCategories.isEmpty)
          const LinearProgressIndicator(minHeight: 2),
        Expanded(
          child: RefreshIndicator(
            onRefresh: () async {
              _catItems.clear();
              await _loadBaseCategories();
            },
            child: ListView.builder(
              padding: const EdgeInsets.only(bottom: 24),
              itemCount: _baseCategories.length + 1,
              itemBuilder: (context, idx) {
                //if (idx == _baseCategories.length) {
                //return const BottomContentSpacer();
                //}

                final cat = _baseCategories[idx];
                final key = cat['key'] as String;
                final emoji = (cat['emoji'] as String?)?.trim();
                final title =
                    (cat['name_de'] as String?)?.trim().isNotEmpty == true
                        ? cat['name_de'] as String
                        : (cat['name_en'] as String? ?? key);

                final loading = _loadingCats.contains(key);
                final items = _catItems[key];

                return Theme(
                  data: Theme.of(context)
                      .copyWith(dividerColor: Colors.transparent),
                  child: ExpansionTile(
                    leading: Text(
                      emoji?.isNotEmpty == true ? emoji! : '🗂️',
                      style: const TextStyle(fontSize: 20),
                    ),
                    title: Text(title),
                    initiallyExpanded: false,
                    onExpansionChanged: (expanded) {
                      if (expanded) _loadCategoryItems(key);
                    },
                    children: [
                      if (loading)
                        const Padding(
                          padding: EdgeInsets.symmetric(vertical: 12),
                          child: Center(child: CircularProgressIndicator()),
                        )
                      else if (items == null || items.isEmpty)
                        const Padding(
                          padding: EdgeInsets.symmetric(vertical: 12),
                          child: Center(child: Text('Keine Einträge')),
                        )
                      else
                        ListView.builder(
                          shrinkWrap: true,
                          physics: const NeverScrollableScrollPhysics(),
                          padding: DesignConstants.cardPadding.copyWith(top: 0),
                          itemCount: items.length,
                          itemBuilder: (_, i) => _buildFoodListItem(items[i]),
                        ),
                    ],
                  ),
                );
              },
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildFavoritesTab(AppLocalizations l10n) {
    if (_isLoadingFavorites) {
      return const Center(child: CircularProgressIndicator());
    }
    if (_favoriteFoodItems.isEmpty) {
      // NEUER, AUFGEWERTETER EMPTY STATE
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.favorite_border,
                size: 80,
                color: Colors.grey.shade400,
              ),
              const SizedBox(height: DesignConstants.spacingL),
              Text(
                l10n.noFavorites,
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: DesignConstants.spacingS),
              Text(
                l10n.favoritesEmptyState,
                textAlign: TextAlign.center,
                style: Theme.of(
                  context,
                ).textTheme.bodyLarge?.copyWith(color: Colors.grey.shade600),
              ),
            ],
          ),
        ),
      );
    }
    return Column(
      children: [
        Expanded(
          child: ListView.builder(
            padding:
                DesignConstants.cardPadding.copyWith(bottom: _bottomPadding),
            itemCount: _favoriteFoodItems.length,
            itemBuilder: (context, index) =>
                _buildFoodListItem(_favoriteFoodItems[index]),
          ),
        ),
        // const BottomContentSpacer(),
        if (_favoriteFoodItems.any((item) => item.source == FoodItemSource.off))
          const OffAttributionWidget(),
      ],
    );
  }

  Widget _buildRecentTab(AppLocalizations l10n) {
    if (_isLoadingRecent) {
      return const Center(child: CircularProgressIndicator());
    }
    if (_recentFoodItems.isEmpty) {
      // NEUER, AUFGEWERTETER EMPTY STATE
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.history, size: 80, color: Colors.grey.shade400),
              const SizedBox(height: DesignConstants.spacingL),
              Text(
                l10n.nothingTrackedYet,
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: DesignConstants.spacingS),
              Text(
                l10n.recentEmptyState,
                textAlign: TextAlign.center,
                style: Theme.of(
                  context,
                ).textTheme.bodyLarge?.copyWith(color: Colors.grey.shade600),
              ),
            ],
          ),
        ),
      );
    }
    return Column(
      children: [
        Expanded(
          child: ListView.builder(
            padding:
                DesignConstants.cardPadding.copyWith(bottom: _bottomPadding),
            itemCount: _recentFoodItems.length,
            itemBuilder: (context, index) =>
                _buildFoodListItem(_recentFoodItems[index]),
          ),
        ),
        if (_recentFoodItems.any((item) => item.source == FoodItemSource.off))
          const OffAttributionWidget(),
        //const BottomContentSpacer(),
      ],
    );
  }

  Widget _buildFoodListItem(FoodItem item) {
    final colorScheme = Theme.of(context).colorScheme;
    final l10n = AppLocalizations.of(context)!;

    IconData sourceIcon;
    switch (item.source) {
      case FoodItemSource.base:
        sourceIcon = Icons.star;
        break;
      case FoodItemSource.off:
      case FoodItemSource.user:
        sourceIcon = Icons.inventory_2;
        break;
    }

    return SummaryCard(
      child: ListTile(
        leading: Icon(sourceIcon, color: colorScheme.primary),
        // --- HIER IST DIE ÄNDERUNG ---
        title: Text(
          item.getLocalizedName(context).isNotEmpty
              ? item.getLocalizedName(context)
              : l10n.unknown,
          style: const TextStyle(fontWeight: FontWeight.bold),
        ),
        // --- ENDE DER ÄNDERUNG ---
        subtitle: Text(
          l10n.foodItemSubtitle(
            item.brand.isNotEmpty ? item.brand : l10n.noBrand,
            item.calories,
          ),
        ),
        trailing: IconButton(
          icon: Icon(
            Icons.add_circle_outline,
            color: colorScheme.primary,
            size: 28,
          ),
          onPressed: () => Navigator.of(context).pop(item),
        ),
        onTap: () async {
          final result = await Navigator.of(context).push(
            MaterialPageRoute(
              builder: (context) => FoodDetailScreen(foodItem: item),
            ),
          );

          if (result is FoodItem) {
            Navigator.of(context).pop(result);
          } else {
            _loadFavorites();
            _loadRecentItems();
          }
        },
      ),
    );
  }

  // FÜGE DIESE NEUE METHODE HINZU
  void _scanBarcodeAndPop() async {
    final l10n = AppLocalizations.of(context)!;
    // Öffne den Scanner und warte auf einen Barcode (String) als Ergebnis
    final String? barcode = await Navigator.of(context).push<String>(
      MaterialPageRoute(builder: (context) => const ScannerScreen()),
    );

    // Wenn ein Barcode zurückgegeben wurde und der Screen noch existiert...
    if (barcode != null && mounted) {
      // ...suche das Produkt in der Datenbank.
      final foodItem = await ProductDatabaseHelper.instance.getProductByBarcode(
        barcode,
      );

      // Wenn das Produkt gefunden wurde...
      if (foodItem != null) {
        // ...schließe den AddFoodScreen und gib das gefundene Item zurück.
        Navigator.of(context).pop(foodItem);
      } else {
        // Wenn nicht, zeige eine kurze Info-Nachricht.
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(l10n.snackbarBarcodeNotFound(barcode))),
          );
        }
      }
    }
  }

  Widget _buildCatalogSearchTab(AppLocalizations l10n) {
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    // UI: Suchleiste + Scanner-Button (wie in _buildSearchTab)
    final searchRow = Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 0),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: _searchController,
              onChanged: _runFilter, // nutzt deine bestehende Suche
              decoration: InputDecoration(
                hintText: l10n.searchHintText,
                prefixIcon: Icon(
                  Icons.search,
                  color: colorScheme.onSurfaceVariant,
                  size: 20,
                ),
                suffixIcon: _searchController.text.isNotEmpty
                    ? IconButton(
                        icon: Icon(
                          Icons.clear,
                          color: colorScheme.onSurfaceVariant,
                        ),
                        onPressed: () {
                          _searchController.clear();
                          _runFilter('');
                        },
                      )
                    : null,
              ),
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            style: IconButton.styleFrom(
              backgroundColor: colorScheme.surfaceContainerHighest,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
            icon: Icon(Icons.qr_code_scanner, color: colorScheme.primary),
            onPressed: _scanBarcodeAndPop,
          ),
        ],
      ),
    );

    // FALL A: Kein Query → Kategorien/Accordion aus Base-DB (deine vorhandene Logik)

    final String q = _searchController.text.trim();
    if (q.isEmpty) {
      return Column(
        children: [
          const SizedBox(height: 12),
          searchRow,
          const SizedBox(height: 8),
          if (_baseCategories.isEmpty)
            const LinearProgressIndicator(minHeight: 2),
          Expanded(
            child: RefreshIndicator(
              onRefresh: () async {
                _catItems.clear();
                await _loadBaseCategories();
              },
              child: ListView.builder(
                padding: const EdgeInsets.only(bottom: _bottomPadding),
                itemCount: _baseCategories.length + 1,
                itemBuilder: (context, idx) {
                  if (idx == _baseCategories.length) {
                    return const BottomContentSpacer();
                  }

                  final cat = _baseCategories[idx];
                  final key = cat['key'] as String;
                  final emoji = (cat['emoji'] as String?)?.trim();
                  final locale = Localizations.localeOf(context).languageCode;
                  final title = () {
                    final de = (cat['name_de'] as String?)?.trim();
                    final en = (cat['name_en'] as String?)?.trim();
                    if (locale == 'de') {
                      return (de?.isNotEmpty == true)
                          ? de!
                          : (en?.isNotEmpty == true ? en! : key);
                    } else {
                      return (en?.isNotEmpty == true)
                          ? en!
                          : (de?.isNotEmpty == true ? de! : key);
                    }
                  }();

                  final loading = _loadingCats.contains(key);
                  final items = _catItems[key];

                  return Theme(
                    data: Theme.of(context)
                        .copyWith(dividerColor: Colors.transparent),
                    child: ExpansionTile(
                      leading: Text(
                        emoji?.isNotEmpty == true ? emoji! : '🗂️',
                        style: const TextStyle(fontSize: 20),
                      ),
                      title: Text(title),
                      initiallyExpanded: false,
                      onExpansionChanged: (expanded) {
                        if (expanded) _loadCategoryItems(key);
                      },
                      children: [
                        if (loading)
                          const Padding(
                            padding: EdgeInsets.symmetric(vertical: 12),
                            child: Center(child: CircularProgressIndicator()),
                          )
                        else if (items == null || items.isEmpty)
                          Padding(
                            padding: const EdgeInsets.symmetric(vertical: 12),
                            child: Center(child: Text(l10n.emptyCategory)),
                          )
                        else
                          ListView.builder(
                            shrinkWrap: true,
                            physics: const NeverScrollableScrollPhysics(),
                            padding: DesignConstants.cardPadding.copyWith(
                              top: 0,
                            ),
                            itemCount: items.length,
                            itemBuilder: (_, i) => _buildFoodListItem(items[i]),
                          ),
                      ],
                    ),
                  );
                },
              ),
            ),
          ),
        ],
      );
    }

    // FALL B: Mit Query → zuerst Base-Items, dann OFF/User-Items (Priorisierung)
    final baseHits = _foundFoodItems
        .where((it) => it.source == FoodItemSource.base)
        .toList();
    final otherHits = _foundFoodItems
        .where((it) => it.source != FoodItemSource.base)
        .toList();

    return Column(
      children: [
        const SizedBox(height: 12),
        searchRow,
        const SizedBox(height: 12),
        Expanded(
          child: _isLoadingSearch
              ? const Center(child: CircularProgressIndicator())
              : (baseHits.isEmpty && otherHits.isEmpty)
                  ? Center(
                      child: Text(
                        l10n.searchNoResults,
                        style: textTheme.titleMedium,
                      ),
                    )
                  : ListView(
                      padding: DesignConstants.cardPadding
                          .copyWith(bottom: _bottomPadding),
                      children: [
                        if (baseHits.isNotEmpty) ...[
                          Text(
                            l10n.searchSectionBase,
                            style: textTheme.titleMedium,
                          ),
                          const SizedBox(height: 8),
                          ...baseHits.map(_buildFoodListItem),
                          const SizedBox(height: DesignConstants.spacingL),
                        ],
                        if (otherHits.isNotEmpty) ...[
                          Text(
                            l10n.searchSectionOther,
                            style: textTheme.titleMedium,
                          ),
                          const SizedBox(height: 8),
                          ...otherHits.map(_buildFoodListItem),
                        ],
                        if (otherHits
                            .any((i) => i.source == FoodItemSource.off))
                          const Padding(
                            padding: EdgeInsets.only(top: 12),
                            child: OffAttributionWidget(),
                          ),
                        const BottomContentSpacer(),
                      ],
                    ),
        ),
      ],
    );
  }

  Widget _buildMealsTab(AppLocalizations l10n) {
    if (_isLoadingMeals) {
      return const Center(child: CircularProgressIndicator());
    }

    if (_meals.isEmpty) {
      // Empty State: kein Top-Button mehr – Erstellen läuft über den FAB
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.restaurant_menu,
                size: 80,
                color: Colors.grey.shade400,
              ),
              const SizedBox(height: DesignConstants.spacingL),
              Text(
                l10n.mealsEmptyTitle,
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: DesignConstants.spacingS),
              Text(
                l10n.mealsEmptyBody,
                textAlign: TextAlign.center,
                style: Theme.of(
                  context,
                ).textTheme.bodyLarge?.copyWith(color: Colors.grey.shade600),
              ),
            ],
          ),
        ),
      );
    }

    return RefreshIndicator(
      onRefresh: _loadMeals,
      child: ListView.builder(
        padding: DesignConstants.cardPadding.copyWith(bottom: _bottomPadding),
        itemCount: _meals.length, // FIX: +1 entfernt, da Padding genutzt wird
        itemBuilder: (_, i) {
          final meal = _meals[i];
          return _buildMealCard(meal, l10n);
        },
      ),
    );
  }

  Widget _buildMealCard(Map<String, dynamic> meal, AppLocalizations l10n) {
    final color = Theme.of(context).colorScheme;

    Future<Map<String, num>> computeMealTotals(int mealId) async {
      final items = await _getMealItems(mealId);
      int kcal = 0;
      double c = 0, f = 0, p = 0;

      for (final it in items) {
        final bc = it['barcode'] as String;
        final qty = (it['quantity_in_grams'] as num?)?.toDouble() ?? 0.0;
        final fi = await ProductDatabaseHelper.instance.getProductByBarcode(bc);
        if (fi == null) continue;

        final factor = qty / 100.0;
        kcal += ((fi.calories ?? 0) * factor).round();
        c += (fi.carbs ?? 0) * factor;
        f += (fi.fat ?? 0) * factor;
        p += (fi.protein ?? 0) * factor;
      }
      return {'kcal': kcal, 'c': c, 'f': f, 'p': p};
    }

    return SummaryCard(
      child: ListTile(
        leading: Icon(Icons.restaurant, color: color.primary),
        title: Text(meal['name'] as String),
        subtitle: FutureBuilder<Map<String, num>>(
          future: computeMealTotals(meal['id'] as int),
          builder: (_, snap) {
            // Fallback: nur Anzahl Zutaten, falls noch lädt
            if (!snap.hasData) {
              return FutureBuilder<List<Map<String, dynamic>>>(
                future: _getMealItems(meal['id'] as int),
                builder: (_, s2) {
                  final count = s2.data?.length ?? 0;
                  return Text('${l10n.mealIngredientsTitle}: $count');
                },
              );
            }
            final t = snap.data!;
            final c = (t['c'] ?? 0).toDouble();
            final f = (t['f'] ?? 0).toDouble();
            final p = (t['p'] ?? 0).toDouble();
            final kcal = (t['kcal'] ?? 0).toInt();

            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                FutureBuilder<List<Map<String, dynamic>>>(
                  future: _getMealItems(meal['id'] as int),
                  builder: (_, s2) {
                    final count = s2.data?.length ?? 0;
                    return Text('${l10n.mealIngredientsTitle}: $count');
                  },
                ),
                const SizedBox(height: 2),
                Text(
                  '$kcal kcal   •   C ${c.toStringAsFixed(1)} g   •   F ${f.toStringAsFixed(1)} g   •   P ${p.toStringAsFixed(1)} g',
                  style: Theme.of(
                    context,
                  ).textTheme.bodySmall?.copyWith(color: Colors.grey.shade600),
                ),
              ],
            );
          },
        ),
        trailing: Wrap(
          spacing: 4,
          children: [
            IconButton(
              tooltip: l10n.mealsAddToDiary,
              icon: Icon(Icons.add_circle_outline, color: color.primary),
              onPressed: () => _confirmAndLogMeal(meal, l10n),
            ),
            IconButton(
              tooltip: l10n.mealsEdit,
              icon: const Icon(Icons.edit),
              onPressed: () async {
                // Neuer Screen öffnen (View), direkt in Edit wechseln
                await Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (_) => MealScreen(meal: meal, startInEdit: true),
                  ),
                );
                await _loadMeals();
              },
            ),
            IconButton(
              tooltip: l10n.mealsDelete,
              icon: const Icon(Icons.delete_outline),
              onPressed: () => _deleteMeal(meal, l10n),
            ),
          ],
        ),
        onTap: () async {
          // Neuer Detail-Screen (View)
          await Navigator.of(
            context,
          ).push(MaterialPageRoute(builder: (_) => MealScreen(meal: meal)));
          await _loadMeals();
        },
      ),
    );
  }

  Future<void> _openMealEditor(
    AppLocalizations l10n, {
    Map<String, dynamic>? mealToEdit,
  }) async {
    final isEdit = mealToEdit != null;
    final nameCtrl = TextEditingController(
      text: isEdit ? (mealToEdit['name'] as String? ?? '') : '',
    );
    final notesCtrl = TextEditingController(
      text: isEdit ? (mealToEdit['notes'] as String? ?? '') : '',
    );

    List<Map<String, dynamic>> items = isEdit
        ? List<Map<String, dynamic>>.from(
            await _getMealItems(mealToEdit['id'] as int),
          )
        : <Map<String, dynamic>>[];

    setState(() => _suspendFab = true);
    final result = await showModalBottomSheet<bool>(
      context: context,
      useRootNavigator: true, // <- wichtig: über allen Overlays
      isScrollControlled: true,
      backgroundColor: Theme.of(context).colorScheme.surface,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (ctx) {
        return StatefulBuilder(
          builder: (ctx, modalSetState) {
            // verhindert Doppelklicks auf "Speichern"
            bool saving = false;
            Future<void> addIngredient() async {
              final picked = await _pickIngredient(l10n);
              if (picked == null) return;
              final (barcode, grams) = picked;

              // Produkt für den Namen (optional) laden
              final fi = await ProductDatabaseHelper.instance
                  .getProductByBarcode(barcode);
              final displayName =
                  (fi?.name.isNotEmpty ?? false) ? fi!.name : null;
              modalSetState(() {
                items.add({
                  'id': null,
                  'meal_id': mealToEdit?['id'],
                  'barcode': barcode,
                  'quantity_in_grams': grams,
                  'display_name': displayName, // nur Anzeige
                });
              });
            }

            return Padding(
              padding: EdgeInsets.only(
                left: 16,
                right: 16,
                top: 16,
                bottom: MediaQuery.of(ctx).viewInsets.bottom + 16,
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(
                    width: 40,
                    height: 4,
                    decoration: BoxDecoration(
                      color: Colors.grey.shade500,
                      borderRadius: BorderRadius.circular(2),
                    ),
                  ),
                  const SizedBox(height: 12),
                  Text(
                    isEdit ? l10n.mealsEdit : l10n.mealsCreate,
                    style: Theme.of(ctx).textTheme.titleLarge?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                  ),
                  const SizedBox(height: 12),
                  TextField(
                    controller: nameCtrl,
                    decoration: InputDecoration(labelText: l10n.mealNameLabel),
                  ),
                  const SizedBox(height: 8),
                  TextField(
                    controller: notesCtrl,
                    decoration: InputDecoration(labelText: l10n.mealNotesLabel),
                    maxLines: 2,
                  ),
                  const SizedBox(height: 12),
                  Row(
                    children: [
                      // Live-Validierung: Name + mind. 1 Zutat
                      // (keine Listener nötig; wir lesen direkt unten aus nameCtrl/items)
                      // Hinweis: Keine UI-Änderung hier – nur Logik im Save-Handler.
                      // (enabled/disabled steuern wir über onPressed: null)
                      Text(
                        l10n.mealIngredientsTitle,
                        style: Theme.of(ctx).textTheme.titleMedium,
                      ),
                      const Spacer(),
                      TextButton.icon(
                        onPressed: addIngredient,
                        icon: const Icon(Icons.add),
                        label: Text(l10n.mealAddIngredient),
                      ),
                    ],
                  ),
                  const SizedBox(height: 4),
                  Flexible(
                    child: items.isEmpty
                        ? Padding(
                            padding: const EdgeInsets.symmetric(vertical: 16),
                            child: Text(
                              l10n.emptyCategory,
                              textAlign: TextAlign.center,
                            ),
                          )
                        : ListView.builder(
                            shrinkWrap: true,
                            itemCount: items.length,
                            itemBuilder: (_, i) {
                              final it = items[i];
                              final barcode = it['barcode'] as String;

                              return FutureBuilder<FoodItem?>(
                                future: ProductDatabaseHelper.instance
                                    .getProductByBarcode(barcode),
                                builder: (_, snap) {
                                  final fi = snap.data;
                                  final displayName =
                                      (fi?.name.isNotEmpty ?? false)
                                          ? fi!.name
                                          : barcode;
                                  final isLiquid = (fi?.isLiquid == true);
                                  final unit = isLiquid ? 'ml' : 'g';
                                  final amount = it['quantity_in_grams'] ?? 0;

                                  return ListTile(
                                    dense: true,
                                    leading: const Icon(
                                      Icons.drag_indicator,
                                      size: 18,
                                    ),
                                    title: Text(displayName),
                                    subtitle: Text('$amount $unit'),
                                    trailing: IconButton(
                                      icon: const Icon(Icons.close),
                                      onPressed: () => modalSetState(
                                        () => items.removeAt(i),
                                      ), // <—
                                    ),
                                  );
                                },
                              );
                            },
                          ),
                  ),
                  const SizedBox(height: 12),
                  Row(
                    children: [
                      TextButton(
                        onPressed: () => Navigator.of(ctx).pop(),
                        child: Text(l10n.cancel),
                      ),
                      const Spacer(),
                      FilledButton(
                        onPressed: () async {
                          print("save button clicked");
                          final name = nameCtrl.text.trim();
                          if (name.isEmpty) return;
                          try {
                            if (isEdit) {
                              final mealId = mealToEdit['id'] as int;
                              await DatabaseHelper.instance.updateMeal(
                                mealId,
                                name: name,
                                notes: notesCtrl.text.trim(),
                              );
                              await DatabaseHelper.instance.clearMealItems(
                                mealId,
                              );
                              for (final it in items) {
                                await DatabaseHelper.instance.addMealItem(
                                  mealId,
                                  barcode: it['barcode'] as String,
                                  grams: it['quantity_in_grams'] as int,
                                );
                              }
                            } else {
                              final mealId =
                                  await DatabaseHelper.instance.insertMeal(
                                name: name,
                                notes: notesCtrl.text.trim(),
                              );
                              for (final it in items) {
                                await DatabaseHelper.instance.addMealItem(
                                  mealId,
                                  barcode: it['barcode'] as String,
                                  grams: it['quantity_in_grams'] as int,
                                );
                              }
                            }
                            _mealItemsCache.clear();
                            await _loadMeals();
                            if (mounted) Navigator.of(ctx).pop();
                            if (mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(content: Text(l10n.mealSaved)),
                              );
                            }
                          } catch (e) {
                            if (mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(content: Text('${l10n.error}: $e')),
                              );
                            }
                          }
                        },
                        child: Text(l10n.save),
                      ),
                    ],
                  ),
                ],
              ),
            );
          },
        );
      },
    );
    if (mounted) setState(() => _suspendFab = false);
  }

  Future<void> _deleteMeal(
    Map<String, dynamic> meal,
    AppLocalizations l10n,
  ) async {
    // NEU: Helper
    final ok = await showDeleteConfirmation(
      context,
      title: l10n.mealDeleteConfirmTitle,
      content: l10n.mealDeleteConfirmBody(meal['name'] as String),
    );

    if (!ok) return;
    await DatabaseHelper.instance.deleteMeal(meal['id'] as int);
    _mealItemsCache.remove(meal['id'] as int);
    await _loadMeals();
    if (mounted) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text(l10n.mealDeleted)));
    }
  }

  // In lib/screens/add_food_screen.dart

  Future<(String, int)?> _pickIngredient(AppLocalizations l10n) async {
    final searchCtrl = TextEditingController();
    // KORREKTUR: showGlassBottomMenu statt showDialog
    return showGlassBottomMenu<(String, int)?>(
      context: context,
      title: l10n.mealAddIngredient,
      contentBuilder: (ctx, close) {
        // Lokaler State für Suchergebnisse
        List<FoodItem> results = [];
        bool loading = false;
        Timer? debounce; // Timer für Debounce importieren oder lokal definieren

        return StatefulBuilder(
          builder: (context, setStateSB) {
            Future<void> runSearch(String q) async {
              if (q.trim().isEmpty) {
                setStateSB(() => results = []);
                return;
              }
              setStateSB(() => loading = true);
              final res = await ProductDatabaseHelper.instance.searchProducts(
                q.trim(),
              );
              setStateSB(() {
                results = res;
                loading = false;
              });
            }

            return Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextField(
                  controller: searchCtrl,
                  autofocus: true,
                  decoration: InputDecoration(
                    hintText: l10n.searchHintText,
                    prefixIcon: const Icon(Icons.search),
                    filled: true,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                      borderSide: BorderSide.none,
                    ),
                  ),
                  onChanged: (val) {
                    // Einfacher Debounce
                    debounce?.cancel();
                    debounce = Timer(const Duration(milliseconds: 300), () {
                      runSearch(val);
                    });
                  },
                ),
                const SizedBox(height: 12),
                if (loading) const LinearProgressIndicator(minHeight: 2),

                // Begrenzte Höhe für die Ergebnisliste
                ConstrainedBox(
                  constraints: const BoxConstraints(maxHeight: 300),
                  child: results.isEmpty
                      ? Padding(
                          padding: const EdgeInsets.symmetric(vertical: 24),
                          child: Text(searchCtrl.text.isEmpty
                              ? l10n.searchInitialHint
                              : l10n.searchNoResults),
                        )
                      : ListView.separated(
                          shrinkWrap: true,
                          itemCount: results.length,
                          separatorBuilder: (_, __) => const Divider(height: 1),
                          itemBuilder: (_, i) {
                            final fi = results[i];
                            return ListTile(
                              dense: true,
                              title: Text(fi.name),
                              subtitle: Text(fi.brand.isNotEmpty
                                  ? fi.brand
                                  : l10n.noBrand),
                              trailing: IconButton(
                                icon: const Icon(Icons.add_circle_outline),
                                onPressed: () async {
                                  // Menge abfragen (Nested Sheet/Dialog)
                                  // Wir schließen das Such-Sheet und geben den Barcode zurück,
                                  // die Menge wird idealerweise danach im Parent gefragt
                                  // (so wie wir es im MealScreen gefixt hatten).
                                  // Hier vereinfachen wir: Standard 100g, oder wir müssten
                                  // den Quantity-Dialog hier inline öffnen.

                                  // Lösung: Wir geben hier (Barcode, -1) zurück, um dem Caller zu sagen:
                                  // "Bitte frag noch nach der Menge".
                                  // Das erfordert Anpassung in _openMealEditor.

                                  // ABER: Um minimal-invasiv zu bleiben und die Logik von
                                  // _pickIngredient zu behalten:
                                  // Wir zeigen hier einen simplen Dialog für die Menge.

                                  final qtyCtrl =
                                      TextEditingController(text: '100');
                                  final grams = await showDialog<int>(
                                    context: ctx,
                                    builder: (_) => AlertDialog(
                                      title:
                                          Text(l10n.mealIngredientAmountLabel),
                                      content: TextField(
                                        controller: qtyCtrl,
                                        keyboardType: TextInputType.number,
                                        autofocus: true,
                                        decoration: const InputDecoration(
                                            suffixText: 'g/ml'),
                                      ),
                                      actions: [
                                        TextButton(
                                          onPressed: () =>
                                              Navigator.pop(context, null),
                                          child: Text(l10n.cancel),
                                        ),
                                        TextButton(
                                          onPressed: () => Navigator.pop(
                                              context,
                                              int.tryParse(qtyCtrl.text)),
                                          child: Text(l10n.add_button),
                                        ),
                                      ],
                                    ),
                                  );

                                  if (grams != null && grams > 0) {
                                    close();
                                    Navigator.of(ctx).pop((fi.barcode, grams));
                                  }
                                },
                              ),
                            );
                          },
                        ),
                ),
                const SizedBox(height: 12),
                Row(
                  children: [
                    Expanded(
                      child: OutlinedButton(
                        onPressed: () {
                          close();
                          Navigator.of(ctx).pop(null);
                        },
                        child: Text(l10n.cancel),
                      ),
                    ),
                  ],
                ),
              ],
            );
          },
        );
      },
    );
  }

  Future<void> _confirmAndLogMeal(
    Map<String, dynamic> meal,
    AppLocalizations l10n,
  ) async {
    final mealId = meal['id'] as int;
    final rawItems = List<Map<String, dynamic>>.from(
      await _getMealItems(mealId),
    );
    if (rawItems.isEmpty) return;

    final Map<String, FoodItem?> products = {};
    for (final it in rawItems) {
      final bc = it['barcode'] as String;
      products[bc] = await ProductDatabaseHelper.instance.getProductByBarcode(
        bc,
      );
    }

    final Map<String, TextEditingController> qtyCtrls = {
      for (final it in rawItems)
        (it['barcode'] as String): TextEditingController(
          text: '${it['quantity_in_grams']}',
        ),
    };

    const internalTypes = [
      'mealtypeBreakfast',
      'mealtypeLunch',
      'mealtypeDinner',
      'mealtypeSnack',
    ];

    // Initialwerte aus Widget-Parametern oder Defaults
    String selectedMealType = widget.initialMealType ?? internalTypes.first;
    if (!internalTypes.contains(selectedMealType)) {
      selectedMealType = internalTypes.first;
    }

    DateTime selectedDate = widget.initialDate ?? DateTime.now();

    final Map<String, String> mealTypeLabel = {
      'mealtypeBreakfast': l10n.mealtypeBreakfast,
      'mealtypeLunch': l10n.mealtypeLunch,
      'mealtypeDinner': l10n.mealtypeDinner,
      'mealtypeSnack': l10n.mealtypeSnack,
    };

    final ok = await showGlassBottomMenu<bool>(
          context: context,
          title: l10n.mealsAddToDiary,
          contentBuilder: (ctx, close) {
            return StatefulBuilder(
              builder: (ctx, modalSetState) {
                final locale = Localizations.localeOf(ctx).toString();
                final formattedDate =
                    DateFormat.yMd(locale).format(selectedDate);
                final formattedTime =
                    DateFormat.Hm(locale).format(selectedDate);

                return Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      meal['name'] as String,
                      style: Theme.of(ctx).textTheme.titleMedium,
                    ),
                    const SizedBox(height: 12),

                    // Datum & Zeit Auswahl
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        TextButton.icon(
                          icon: const Icon(Icons.calendar_today, size: 18),
                          label: Text(formattedDate),
                          onPressed: () async {
                            final picked = await showDatePicker(
                              context: ctx,
                              initialDate: selectedDate,
                              firstDate: DateTime(2020),
                              lastDate:
                                  DateTime.now().add(const Duration(days: 365)),
                            );
                            if (picked != null) {
                              modalSetState(() {
                                selectedDate = DateTime(
                                  picked.year,
                                  picked.month,
                                  picked.day,
                                  selectedDate.hour,
                                  selectedDate.minute,
                                );
                              });
                            }
                          },
                        ),
                        TextButton.icon(
                          icon: const Icon(Icons.access_time, size: 18),
                          label: Text(formattedTime),
                          onPressed: () async {
                            final picked = await showTimePicker(
                              context: ctx,
                              initialTime: TimeOfDay.fromDateTime(selectedDate),
                            );
                            if (picked != null) {
                              modalSetState(() {
                                selectedDate = DateTime(
                                  selectedDate.year,
                                  selectedDate.month,
                                  selectedDate.day,
                                  picked.hour,
                                  picked.minute,
                                );
                              });
                            }
                          },
                        ),
                      ],
                    ),
                    const SizedBox(height: 8),

                    DropdownButtonFormField<String>(
                      initialValue: selectedMealType,
                      decoration: InputDecoration(
                        labelText: l10n.mealTypeLabel,
                        border: const OutlineInputBorder(),
                        isDense: true,
                        filled: true,
                        fillColor:
                            Theme.of(context).brightness == Brightness.dark
                                ? Colors.white.withOpacity(0.05)
                                : Colors.black.withOpacity(0.05),
                      ),
                      items: internalTypes
                          .map(
                            (key) => DropdownMenuItem(
                              value: key,
                              child: Text(mealTypeLabel[key] ?? key),
                            ),
                          )
                          .toList(),
                      onChanged: (v) {
                        if (v != null) {
                          modalSetState(() => selectedMealType = v);
                        }
                      },
                    ),

                    const SizedBox(height: 12),

                    ConstrainedBox(
                      constraints: const BoxConstraints(maxHeight: 300),
                      child: ListView.separated(
                        shrinkWrap: true,
                        itemCount: rawItems.length,
                        separatorBuilder: (_, __) => const SizedBox(height: 10),
                        itemBuilder: (_, i) {
                          final it = rawItems[i];
                          final bc = it['barcode'] as String;
                          final fi = products[bc];
                          final displayName =
                              (fi?.name.isNotEmpty ?? false) ? fi!.name : bc;
                          final unit = (fi?.isLiquid == true) ? 'ml' : 'g';

                          return Row(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              const Padding(
                                padding: EdgeInsets.only(top: 18),
                                child: Icon(Icons.lunch_dining, size: 20),
                              ),
                              const SizedBox(width: 12),
                              Expanded(
                                child: TextFormField(
                                  controller: qtyCtrls[bc],
                                  keyboardType:
                                      const TextInputType.numberWithOptions(
                                    decimal: true,
                                  ),
                                  decoration: InputDecoration(
                                    labelText: displayName,
                                    suffixText: unit,
                                    filled: true,
                                    fillColor: Theme.of(context).brightness ==
                                            Brightness.dark
                                        ? Colors.white.withOpacity(0.05)
                                        : Colors.black.withOpacity(0.05),
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                      borderSide: BorderSide.none,
                                    ),
                                    contentPadding: const EdgeInsets.symmetric(
                                        horizontal: 12, vertical: 14),
                                  ),
                                ),
                              ),
                            ],
                          );
                        },
                      ),
                    ),

                    const SizedBox(height: 24),

                    Row(
                      children: [
                        Expanded(
                          child: OutlinedButton(
                            onPressed: () {
                              close();
                              Navigator.of(ctx).pop(false);
                            },
                            child: Text(l10n.cancel),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: FilledButton(
                            onPressed: () {
                              close();
                              Navigator.of(ctx).pop(true);
                            },
                            child: Text(l10n.save),
                          ),
                        ),
                      ],
                    ),
                  ],
                );
              },
            );
          },
        ) ??
        false;

    if (!ok) return;

    // Nutze das ausgewählte Datum (selectedDate) statt DateTime.now()
    for (final it in rawItems) {
      final bc = it['barcode'] as String;
      final ctrl = qtyCtrls[bc]!;
      final qty =
          int.tryParse(ctrl.text.trim()) ?? (it['quantity_in_grams'] as int);

      await DatabaseHelper.instance.insertFoodEntry(
        FoodEntry(
          barcode: bc,
          timestamp: selectedDate, // <--- VERWENDUNG
          quantityInGrams: qty,
          mealType: selectedMealType,
        ),
      );

      final fi = products[bc];
      if (fi != null) {
        final c100 = fi.caffeineMgPer100ml;
        if (fi.isLiquid == true && c100 != null && c100 > 0) {
          await _logCaffeineDose(
              c100 * (qty / 100.0), selectedDate); // <--- VERWENDUNG
        }
      }
    }

    if (mounted) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text(l10n.mealAddedToDiarySuccess)));
    }
  }

  Future<void> _logCaffeineDose(double doseMg, DateTime timestamp) async {
    if (doseMg <= 0) return;

    // Caffeine-Supplement suchen/anlegen
    final supplements = await DatabaseHelper.instance.getAllSupplements();
    final caffeine = supplements.firstWhere(
      (s) => (s.code == 'caffeine') || s.name.toLowerCase() == 'caffeine',
      orElse: () => Supplement(
        name: 'Caffeine',
        defaultDose: 100,
        unit: 'mg',
        dailyLimit: 400,
        code: 'caffeine',
        isBuiltin: true,
      ),
    );

    final caffeineId = caffeine.id ??
        (await DatabaseHelper.instance.insertSupplement(caffeine)).id!;

    await DatabaseHelper.instance.insertSupplementLog(
      SupplementLog(
        supplementId: caffeineId,
        dose: doseMg,
        unit: 'mg',
        timestamp: timestamp,
        // source_food_entry_id: hier könnten wir verlinken, wenn wir die neue FoodEntry-ID hätten –
        // in diesem Flow buchen wir mehrere; Verlinkung kannst du später erweitern.
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/add_measurement_screen.dart =====

// lib/screens/add_measurement_screen.dart (Final & De-Materialisiert - Korrigiert)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/measurement.dart';
import 'package:lightweight/models/measurement_session.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/global_app_bar.dart';
import 'package:lightweight/widgets/summary_card.dart'; // HINZUGEFÜGT

class AddMeasurementScreen extends StatefulWidget {
  final DateTime? initialDate;
  const AddMeasurementScreen({super.key, this.initialDate});

  @override
  State<AddMeasurementScreen> createState() => _AddMeasurementScreenState();
}

class _AddMeasurementScreenState extends State<AddMeasurementScreen> {
  final _formKey = GlobalKey<FormState>();
  final Map<String, TextEditingController> _controllers = {};
  late DateTime _selectedDateTime;

  final Map<String, String> _measurementTypes = {
    'weight': 'kg',
    'fat_percent': '%',
    'waist': 'cm',
    'abdomen': 'cm',
    'hips': 'cm',
    'neck': 'cm',
    'shoulder': 'cm',
    'chest': 'cm',
    'left_bicep': 'cm',
    'right_bicep': 'cm',
    'left_forearm': 'cm',
    'right_forearm': 'cm',
    'left_thigh': 'cm',
    'right_thigh': 'cm',
    'left_calf': 'cm',
    'right_calf': 'cm',
  };

  @override
  void initState() {
    super.initState();
    _selectedDateTime = widget.initialDate ?? DateTime.now();
    for (var key in _measurementTypes.keys) {
      _controllers[key] = TextEditingController();
    }
  }

  @override
  void dispose() {
    _controllers.forEach((key, controller) => controller.dispose());
    super.dispose();
  }

  void _saveSession() async {
    final List<Measurement> measurements = [];
    _controllers.forEach((key, controller) {
      if (controller.text.isNotEmpty) {
        final value = double.tryParse(controller.text.replaceAll(',', '.'));
        if (value != null) {
          measurements.add(
            Measurement(
              sessionId: 0,
              type: key,
              value: value,
              unit: _measurementTypes[key]!,
            ),
          );
        }
      }
    });

    if (measurements.isNotEmpty) {
      final session = MeasurementSession(
        timestamp: _selectedDateTime,
        measurements: measurements,
      );
      await DatabaseHelper.instance.insertMeasurementSession(session);
      if (mounted) {
        Navigator.of(context).pop(true);
      }
    } else {
      if (mounted) Navigator.of(context).pop(false);
    }
  }

  String _getLocalizedMeasurementName(String key, AppLocalizations l10n) {
    switch (key) {
      case 'weight':
        return l10n.measurementWeight;
      case 'fat_percent':
        return l10n.measurementFatPercent;
      case 'neck':
        return l10n.measurementNeck;
      case 'shoulder':
        return l10n.measurementShoulder;
      case 'chest':
        return l10n.measurementChest;
      case 'left_bicep':
        return l10n.measurementLeftBicep;
      case 'right_bicep':
        return l10n.measurementRightBicep;
      case 'left_forearm':
        return l10n.measurementLeftForearm;
      case 'right_forearm':
        return l10n.measurementRightForearm;
      case 'abdomen':
        return l10n.measurementAbdomen;
      case 'waist':
        return l10n.measurementWaist;
      case 'hips':
        return l10n.measurementHips;
      case 'left_thigh':
        return l10n.measurementLeftThigh;
      case 'right_thigh':
        return l10n.measurementRightThigh;
      case 'left_calf':
        return l10n.measurementLeftCalf;
      case 'right_calf':
        return l10n.measurementRightCalf;
      default:
        return key;
    }
  }

  Future<void> _selectDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDateTime,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (picked != null && picked != _selectedDateTime) {
      setState(() {
        _selectedDateTime = DateTime(
          picked.year,
          picked.month,
          picked.day,
          _selectedDateTime.hour,
          _selectedDateTime.minute,
        );
      });
    }
  }

  Future<void> _selectTime() async {
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(_selectedDateTime),
    );
    if (picked != null) {
      setState(() {
        _selectedDateTime = DateTime(
          _selectedDateTime.year,
          _selectedDateTime.month,
          _selectedDateTime.day,
          picked.hour,
          picked.minute,
        );
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final textTheme = Theme.of(context).textTheme;

    final formattedDate = DateFormat('dd.MM.yyyy').format(_selectedDateTime);
    final formattedTime = DateFormat.Hm().format(_selectedDateTime);
    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: GlobalAppBar(
        title: l10n.addMeasurementDialogTitle, // or whatever your l10n key is

        actions: [
          TextButton(
            onPressed: _saveSession,
            style: TextButton.styleFrom(
              foregroundColor: Theme.of(context).appBarTheme.foregroundColor,
            ),
            child: Text(l10n.save),
          ),
        ],
      ),
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: SingleChildScrollView(
        padding: DesignConstants.cardPadding.copyWith(
          top: DesignConstants.cardPadding.top + topPadding,
        ),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Datum & Uhrzeit Sektion
              Text(
                l10n.date_and_time_of_measurement,
                style: textTheme.titleMedium,
              ),
              const SizedBox(height: DesignConstants.spacingS),
              SummaryCard(
                // KORREKTUR 2: Datum/Uhrzeit in SummaryCard
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16.0,
                    vertical: 8.0,
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      InkWell(
                        onTap: _selectDate,
                        child: Row(
                          children: [
                            const Icon(Icons.calendar_today, size: 20),
                            const SizedBox(width: 8),
                            Text(
                              formattedDate,
                              style: const TextStyle(fontSize: 16),
                            ),
                          ],
                        ),
                      ),
                      InkWell(
                        onTap: _selectTime,
                        child: Row(
                          children: [
                            const Icon(Icons.access_time, size: 20),
                            const SizedBox(width: 8),
                            Text(
                              formattedTime,
                              style: const TextStyle(fontSize: 16),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(
                height: DesignConstants.spacingXL,
              ), // KORREKTUR 3: Abstand angepasst
              // Messwerte-Sektion
              Text(
                l10n.drawerMeasurements,
                style: textTheme.titleMedium,
              ), // TODO: Lokalisieren
              const SizedBox(height: DesignConstants.spacingS),
              ..._measurementTypes.keys.map((key) {
                return Padding(
                  padding: const EdgeInsets.only(
                    bottom: 12.0,
                  ), // KORREKTUR 4: Padding angepasst
                  child: TextFormField(
                    controller: _controllers[key],
                    decoration: InputDecoration(
                      labelText: _getLocalizedMeasurementName(key, l10n),
                      suffixText: _measurementTypes[key],
                    ),
                    keyboardType: const TextInputType.numberWithOptions(
                      decimal: true,
                    ),
                    validator: (value) {
                      // Nur validieren, wenn etwas eingegeben wurde
                      if (value != null &&
                          value.isNotEmpty &&
                          double.tryParse(value.replaceAll(',', '.')) == null) {
                        return l10n.validatorPleaseEnterNumber;
                      }
                      return null;
                    },
                  ),
                );
              }),
              const SizedBox(
                height: DesignConstants.spacingL,
              ), // Abstand zum Ende
            ],
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/scanner_screen.dart =====

// lib/screens/scanner_screen.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import 'package:lightweight/widgets/global_app_bar.dart';

class ScannerScreen extends StatefulWidget {
  const ScannerScreen({super.key});

  @override
  State<ScannerScreen> createState() => _ScannerScreenState();
}

class _ScannerScreenState extends State<ScannerScreen> {
  final MobileScannerController _controller = MobileScannerController(
    detectionSpeed: DetectionSpeed.normal,
    facing: CameraFacing.back,
  );
  bool _isDone = false;

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final size = MediaQuery.of(context).size;
    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    final scanWindow = Rect.fromCenter(
      center: size.center(const Offset(0, kToolbarHeight / 2)),
      width: 250,
      height: 250,
    );

    return Scaffold(
      extendBodyBehindAppBar: true,
      backgroundColor: Colors.black,
      appBar: GlobalAppBar(
        title: l10n.scann_barcode_capslock,
      ),
      body: Padding(
        padding: EdgeInsets.only(top: topPadding),
        child: Stack(
          fit: StackFit.expand,
          children: [
            MobileScanner(
              controller: _controller,
              scanWindow: scanWindow,
              onDetect: (capture) {
                if (!_isDone) {
                  final String? code = capture.barcodes.first.rawValue;
                  if (code != null) {
                    setState(() {
                      _isDone = true;
                    });
                    Navigator.of(context).pop(code);
                  }
                }
              },
            ),
            CustomPaint(painter: ScannerOverlay(scanWindow: scanWindow)),
          ],
        ),
      ),
    );
  }
}

class ScannerOverlay extends CustomPainter {
  final Rect scanWindow;
  ScannerOverlay({required this.scanWindow});

  @override
  void paint(Canvas canvas, Size size) {
    final backgroundPath = Path()..addRect(Rect.largest);
    final cutoutPath = Path()..addRect(scanWindow);
    final backgroundPaint = Paint()
      ..color = Colors.black.withOpacity(0.5)
      ..style = PaintingStyle.fill
      ..blendMode = BlendMode.dstOut;

    final backgroundWithCutout = Path.combine(
      PathOperation.difference,
      backgroundPath,
      cutoutPath,
    );
    canvas.drawPath(backgroundWithCutout, backgroundPaint);

    final borderPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2;
    canvas.drawRect(scanWindow, borderPaint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/diary_screen.dart =====

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/dialogs/fluid_dialog_content.dart';
import 'package:lightweight/dialogs/quantity_dialog_content.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/models/fluid_entry.dart';
import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';
import 'package:lightweight/models/tracked_food_item.dart';
import 'package:lightweight/screens/add_food_screen.dart';
import 'package:lightweight/screens/food_detail_screen.dart';
import 'package:lightweight/screens/supplement_track_screen.dart';
import 'package:lightweight/util/date_util.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/bottom_content_spacer.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
import 'package:lightweight/widgets/measurement_chart_widget.dart';
import 'package:lightweight/widgets/nutrition_summary_widget.dart';
import 'package:lightweight/widgets/supplement_summary_widget.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/tracked_supplement.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/screens/workout_history_screen.dart';
import 'package:lightweight/widgets/todays_workout_summary_card.dart';

class DiaryScreen extends StatefulWidget {
  const DiaryScreen({super.key});

  @override
  State<DiaryScreen> createState() => DiaryScreenState();
}

class DiaryScreenState extends State<DiaryScreen> {
  bool _isLoading = true;
  final ValueNotifier<DateTime> selectedDateNotifier = ValueNotifier(
    DateTime.now(),
  );
  DateTime get _selectedDate => selectedDateNotifier.value;
  DailyNutrition? _dailyNutrition;
  Map<String, List<TrackedFoodItem>> _entriesByMeal = {};
  List<FluidEntry> _fluidEntries = [];
  List<TrackedSupplement> _trackedSupplements = [];

  // NEUE STATE-VARIABLE
  Map<String, dynamic>? _workoutSummary;

  String _selectedChartRangeKey = '30D';
  final Map<String, bool> _mealExpanded = {
    "mealtypeBreakfast": false,
    "mealtypeLunch": false,
    "mealtypeDinner": false,
    "mealtypeSnack": false,
    "fluids": false,
  };

  @override
  void initState() {
    super.initState();
    loadDataForDate(_selectedDate);
  }

  @override
  void dispose() {
    selectedDateNotifier.dispose();
    super.dispose();
  }

  // lib/screens/diary_screen.dart

  // ... (Rest der Datei bleibt unverändert)

  // ERSETZEN SIE DIESE METHODE
  Future<void> loadDataForDate(DateTime date) async {
    if (!mounted) return;
    setState(() => _isLoading = true);

    final prefs = await SharedPreferences.getInstance();
    final targetCalories = prefs.getInt('targetCalories') ?? 2500;
    final targetProtein = prefs.getInt('targetProtein') ?? 180;
    final targetCarbs = prefs.getInt('targetCarbs') ?? 250;
    final targetFat = prefs.getInt('targetFat') ?? 80;
    final targetWater = prefs.getInt('targetWater') ?? 3000;
    final targetCaffeine = prefs.getInt('targetCaffeine') ?? 400;

    final foodEntries = await DatabaseHelper.instance.getEntriesForDate(date);
    final fluidEntries = await DatabaseHelper.instance.getFluidEntriesForDate(
      date,
    );
    final waterIntake = fluidEntries.fold<int>(
      0,
      (sum, entry) => sum + entry.quantityInMl,
    );

    final summary = DailyNutrition(
      targetCalories: targetCalories,
      targetProtein: targetProtein,
      targetCarbs: targetCarbs,
      targetFat: targetFat,
      targetWater: targetWater,
      targetCaffeine: targetCaffeine,
    );
    summary.water = waterIntake;

    for (final entry in fluidEntries) {
      summary.calories += entry.kcal ?? 0;
      final factor = entry.quantityInMl / 100.0;
      summary.sugar += (entry.sugarPer100ml ?? 0) * factor;
      summary.carbs += ((entry.carbsPer100ml ?? 0) * factor).round();
    }

    final Map<String, List<TrackedFoodItem>> groupedEntries = {
      'mealtypeBreakfast': [],
      'mealtypeLunch': [],
      'mealtypeDinner': [],
      'mealtypeSnack': [],
    };

    for (final entry in foodEntries) {
      final foodItem = await ProductDatabaseHelper.instance.getProductByBarcode(
        entry.barcode,
      );
      if (foodItem != null) {
        summary.calories +=
            (foodItem.calories / 100 * entry.quantityInGrams).round();
        summary.protein +=
            (foodItem.protein / 100 * entry.quantityInGrams).round();
        summary.carbs += (foodItem.carbs / 100 * entry.quantityInGrams).round();
        summary.fat += (foodItem.fat / 100 * entry.quantityInGrams).round();

        final trackedItem = TrackedFoodItem(entry: entry, item: foodItem);
        groupedEntries[entry.mealType]?.add(trackedItem);
      }
    }

    for (var meal in groupedEntries.values) {
      meal.sort((a, b) => b.entry.timestamp.compareTo(a.entry.timestamp));
    }

    final allSupplements = await DatabaseHelper.instance.getAllSupplements();
    final todaysSupplementLogs =
        await DatabaseHelper.instance.getSupplementLogsForDate(date);

    final Map<int, double> todaysDoses = {};
    for (final log in todaysSupplementLogs) {
      todaysDoses.update(
        log.supplementId,
        (value) => value + log.dose,
        ifAbsent: () => log.dose,
      );
    }

    Supplement? caffeineSupplement;
    try {
      caffeineSupplement = allSupplements.firstWhere(
        (s) => s.code == 'caffeine',
      );
    } catch (e) {
      caffeineSupplement = null;
    }

    if (caffeineSupplement != null && caffeineSupplement.id != null) {
      summary.caffeine = todaysDoses[caffeineSupplement.id] ?? 0.0;
    }

    final trackedSupps = allSupplements
        .map(
          (s) => TrackedSupplement(
            supplement: s,
            totalDosedToday: todaysDoses[s.id] ?? 0.0,
          ),
        )
        .toList();

    final workoutLogs = await WorkoutDatabaseHelper.instance
        .getWorkoutLogsForDateRange(date, date);
    final completedLogs =
        workoutLogs.where((log) => log.endTime != null).toList();
    Map<String, dynamic>? workoutSummary;

    if (completedLogs.isNotEmpty) {
      // --- KORREKTUR START ---
      Duration totalDuration = Duration.zero;
      double totalVolume = 0.0;
      int totalSets = 0;

      for (final log in completedLogs) {
        totalDuration +=
            log.endTime!.difference(log.startTime); // Addiert die volle Dauer
        totalSets += log.sets.length;
        for (final set in log.sets) {
          totalVolume += (set.weightKg ?? 0) * (set.reps ?? 0);
        }
      }

      workoutSummary = {
        'duration': totalDuration, // Verwendet die korrekte Summe
        'volume': totalVolume,
        'sets': totalSets,
        'count': completedLogs.length,
      };
      // --- KORREKTUR ENDE ---
    }

    if (mounted) {
      setState(() {
        selectedDateNotifier.value = date;
        _dailyNutrition = summary;
        _entriesByMeal = groupedEntries;
        _fluidEntries = fluidEntries;
        _trackedSupplements = trackedSupps;
        _workoutSummary = workoutSummary;
        _isLoading = false;
      });
    }
  }

  Future<void> _deleteFoodEntry(int id) async {
    await DatabaseHelper.instance.deleteFoodEntry(id);
    loadDataForDate(_selectedDate);
  }

  Future<void> _deleteFluidEntry(int id) async {
    await DatabaseHelper.instance.deleteFluidEntry(id);
    loadDataForDate(_selectedDate);
  }

  // lib/screens/diary_screen.dart - ERSETZE DIE GESAMTE METHODE
  Future<void> _editFoodEntry(TrackedFoodItem trackedItem) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<QuantityDialogContentState> dialogStateKey = GlobalKey();

    final result = await showGlassBottomMenu<
        ({
          int quantity,
          DateTime timestamp,
          String mealType,
          bool isLiquid,
          double? sugarPer100ml,
          double? caffeinePer100ml,
        })?>(
      context: context,
      title: trackedItem.item.getLocalizedName(context),
      contentBuilder: (ctx, close) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Der Inhalt des Dialogs (jetzt als Bottom-Sheet-Inhalt)
            QuantityDialogContent(
              key: dialogStateKey,
              item: trackedItem.item,
              initialQuantity: trackedItem.entry.quantityInGrams,
              initialTimestamp: trackedItem.entry.timestamp,
              initialMealType: trackedItem.entry.mealType,
              // Die aktuellen Nährwerte des Eintrags als Initial-Werte
              // Annahme: Wenn der Eintrag existiert, sind die Nährwerte fix.
              // Wir setzen nur die Liquid-Status, falls nötig.
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: close,
                    child: Text(l10n.cancel),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton(
                    onPressed: () {
                      final state = dialogStateKey.currentState;
                      if (state != null) {
                        final quantity = int.tryParse(state.quantityText);
                        final caffeine = double.tryParse(
                          state.caffeineText.replaceAll(',', '.'),
                        );
                        final sugar = double.tryParse(
                          state.sugarText.replaceAll(',', '.'),
                        );

                        if (quantity != null && quantity > 0) {
                          close();
                          // Hier geben wir das korrekte, anonyme Tupel zurück
                          Navigator.of(ctx).pop((
                            quantity: quantity,
                            timestamp: state.selectedDateTime,
                            mealType: state.selectedMealType,
                            isLiquid: state.isLiquid,
                            sugarPer100ml: sugar,
                            caffeinePer100ml: caffeine,
                          ));
                        }
                      }
                    },
                    child: Text(l10n.save),
                  ),
                ),
              ],
            ),
          ],
        );
      },
    );

    // Weiterhin die Daten aus dem Ergebnis verarbeiten
    if (result != null) {
      final updatedEntry = FoodEntry(
        id: trackedItem.entry.id,
        barcode: trackedItem.item.barcode,
        quantityInGrams: result.quantity,
        timestamp: result.timestamp,
        mealType: result.mealType,
      );
      await DatabaseHelper.instance.updateFoodEntry(updatedEntry);

      // 1. FluidEntry löschen (falls verknüpft)
      if (trackedItem.entry.id != null) {
        await DatabaseHelper.instance.deleteFluidEntryByLinkedFoodId(
          trackedItem.entry.id!,
        );
      }
      // 2. FluidEntry neu erstellen (falls jetzt flüssig)
      if (result.isLiquid) {
        final newFluidEntry = FluidEntry(
          timestamp: result.timestamp,
          quantityInMl: result.quantity,
          name: trackedItem.item.name,
          kcal: null,
          sugarPer100ml: result.sugarPer100ml,
          carbsPer100ml: result.sugarPer100ml, // Spiegeln
          caffeinePer100ml: result.caffeinePer100ml,
          linked_food_entry_id: trackedItem.entry.id, // Verknüpfung beibehalten
        );
        await DatabaseHelper.instance.insertFluidEntry(newFluidEntry);
      }

      // 3. Koffein-Log aktualisieren/löschen (in jedem Fall)
      await _logCaffeineDose(
        (result.caffeinePer100ml ?? 0) * (result.quantity / 100.0),
        result.timestamp,
        foodEntryId: trackedItem.entry.id,
      );

      loadDataForDate(_selectedDate);
    }
  }

// Auch die Methode für FluidEntry Edit muss angepasst werden, um den AlertDialog zu vermeiden.

  Future<void> _editFluidEntry(FluidEntry fluidEntry) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<FluidDialogContentState> dialogStateKey = GlobalKey();

    // Wir ersetzen showDialog durch showGlassBottomMenu
    final result = await showGlassBottomMenu<
        (
          String name,
          int quantity,
          double? sugarPer100ml,
          double? caffeinePer100ml
        )?>(
      context: context,
      title: l10n.waterEntryTitle,
      contentBuilder: (ctx, close) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            FluidDialogContent(
              key: dialogStateKey,
              initialName: fluidEntry.name,
              initialQuantity: fluidEntry.quantityInMl,
              initialTimestamp: fluidEntry.timestamp,
              initialSugar: fluidEntry.sugarPer100ml,
              initialCaffeine: fluidEntry.caffeinePer100ml,
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: close,
                    child: Text(l10n.cancel),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton(
                    child: Text(l10n.save),
                    onPressed: () {
                      final state = dialogStateKey.currentState;
                      if (state != null) {
                        final quantity = int.tryParse(state.quantityText);
                        if (quantity != null && quantity > 0) {
                          close();
                          Navigator.of(ctx).pop((
                            state.nameText,
                            quantity,
                            double.tryParse(
                              state.sugarText.replaceAll(',', '.'),
                            ),
                            double.tryParse(
                              state.caffeineText.replaceAll(',', '.'),
                            ),
                          ));
                        }
                      }
                    },
                  ),
                ),
              ],
            ),
          ],
        );
      },
    );

    if (result != null) {
      final sugarPer100ml = result.$3;
      final quantity = result.$2;
      final kcal = (sugarPer100ml != null)
          ? ((sugarPer100ml / 100) * quantity * 4).round()
          : null;

      final updatedEntry = FluidEntry(
        id: fluidEntry.id,
        name: result.$1,
        quantityInMl: quantity,
        kcal: kcal,
        sugarPer100ml: sugarPer100ml,
        carbsPer100ml: sugarPer100ml, // Spiegeln
        caffeinePer100ml: result.$4,
        timestamp: fluidEntry.timestamp,
        linked_food_entry_id: fluidEntry.linked_food_entry_id,
      );
      await DatabaseHelper.instance.updateFluidEntry(updatedEntry);

      // Koffein-Log aktualisieren/löschen
      await _logCaffeineDose(
        (result.$4 ?? 0) * (quantity / 100.0),
        fluidEntry.timestamp,
        fluidEntryId: fluidEntry.id,
      );

      loadDataForDate(_selectedDate);
    }
  }

// In lib/screens/diary_screen.dart

  Future<void> _addFoodToMeal(String mealType) async {
    final FoodItem? selectedFoodItem =
        await Navigator.of(context).push<FoodItem>(
      MaterialPageRoute(
        builder: (context) => AddFoodScreen(
          initialDate: _selectedDate, // <--- ÜBERGABE
          initialMealType: mealType, // <--- ÜBERGABE
        ),
      ),
    );

    if (selectedFoodItem == null || !mounted) return;

    // FIX: Datum an das Hilfs-Menü übergeben
    final result = await _showQuantityMenu(selectedFoodItem, mealType,
        initialDate: _selectedDate // <--- Parameter hinzufügen (siehe Punkt C)
        );

    if (result == null || !mounted) return;

    // ... (Rest der Logik bleibt gleich, nutzt result.timestamp) ...
    final int quantity = result.quantity;
    final DateTime timestamp = result.timestamp;
    final String resultMealType = result.mealType;
    final bool isLiquid = result.isLiquid;
    final double? caffeinePer100 = result.caffeinePer100ml;

    final newFoodEntry = FoodEntry(
      barcode: selectedFoodItem.barcode,
      timestamp: timestamp,
      quantityInGrams: quantity,
      mealType: resultMealType,
    );
    final newFoodEntryId =
        await DatabaseHelper.instance.insertFoodEntry(newFoodEntry);

    if (isLiquid) {
      final newFluidEntry = FluidEntry(
        timestamp: timestamp,
        quantityInMl: quantity,
        name: selectedFoodItem.name,
        kcal: null,
        sugarPer100ml: null,
        carbsPer100ml: null,
        caffeinePer100ml: null,
        linked_food_entry_id: newFoodEntryId,
      );
      await DatabaseHelper.instance.insertFluidEntry(newFluidEntry);
    }

    if (isLiquid && caffeinePer100 != null && caffeinePer100 > 0) {
      final totalCaffeine = (caffeinePer100 / 100.0) * quantity;
      await _logCaffeineDose(totalCaffeine, timestamp,
          foodEntryId: newFoodEntryId);
    }

    loadDataForDate(_selectedDate);
  }

  // FÜGEN SIE DIESE ZWEI NEUEN METHODEN ZUR KLASSE HINZU
  // In lib/screens/diary_screen.dart

  Future<
          ({
            int quantity,
            DateTime timestamp,
            String mealType,
            bool isLiquid,
            double? sugarPer100ml,
            double? caffeinePer100ml,
          })?>
      _showQuantityMenu(FoodItem item, String mealType,
          {DateTime? initialDate} // <--- NEUER PARAMETER
          ) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<QuantityDialogContentState> dialogStateKey = GlobalKey();

    return showGlassBottomMenu(
      context: context,
      title: item.name,
      contentBuilder: (ctx, close) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            QuantityDialogContent(
              key: dialogStateKey,
              item: item,
              initialMealType: mealType,
              initialTimestamp: initialDate ??
                  _selectedDate, // <--- FIX: Nutze Parameter oder Fallback
            ),
            // ... (Rest der Methode: Buttons etc. bleibt gleich) ...
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () {
                      close();
                      Navigator.of(ctx).pop(null);
                    },
                    child: Text(l10n.cancel),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton(
                    onPressed: () {
                      final state = dialogStateKey.currentState;
                      if (state != null) {
                        final quantity = int.tryParse(state.quantityText);
                        // ... parsing ...
                        final sugar = double.tryParse(
                            state.sugarText.replaceAll(',', '.'));
                        final caffeine = double.tryParse(
                            state.caffeineText.replaceAll(',', '.'));

                        if (quantity != null && quantity > 0) {
                          close();
                          Navigator.of(ctx).pop((
                            quantity: quantity,
                            timestamp: state.selectedDateTime,
                            mealType: state.selectedMealType,
                            isLiquid: state.isLiquid,
                            sugarPer100ml: sugar,
                            caffeinePer100ml: caffeine,
                          ));
                        }
                      }
                    },
                    child: Text(l10n.add_button),
                  ),
                ),
              ],
            ),
          ],
        );
      },
    );
  }

  Future<void> _logCaffeineDose(
    double doseMg,
    DateTime timestamp, {
    int? foodEntryId,
    int? fluidEntryId,
  }) async {
    if (doseMg <= 0) return;

    final supplements = await DatabaseHelper.instance.getAllSupplements();
    Supplement? caffeineSupplement;
    try {
      caffeineSupplement = supplements.firstWhere((s) => s.code == 'caffeine');
    } catch (e) {
      return;
    }

    if (caffeineSupplement.id == null) return;

    await DatabaseHelper.instance.insertSupplementLog(
      SupplementLog(
        supplementId: caffeineSupplement.id!,
        dose: doseMg,
        unit: 'mg',
        timestamp: timestamp,
        source_food_entry_id: foodEntryId,
        source_fluid_entry_id: fluidEntryId,
      ),
    );
  }

  Future<void> pickDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2020),
      // Erlaube Auswahl in der Zukunft, z.B. für Vorausplanung
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );
    if (picked != null && picked != _selectedDate) {
      loadDataForDate(picked);
    }
  }

  String _getAppBarTitle(AppLocalizations l10n) {
    final today = DateTime.now();
    final yesterday = today.subtract(const Duration(days: 1));
    final dayBeforeYesterday = today.subtract(const Duration(days: 2));

    if (_selectedDate.isSameDate(today)) {
      return l10n.today;
    } else if (_selectedDate.isSameDate(yesterday)) {
      return l10n.yesterday; // ← NEW
    } else if (_selectedDate.isSameDate(dayBeforeYesterday)) {
      return l10n.dayBeforeYesterday; // ← NEW
    } else {
      return DateFormat.yMMMMd(
        Localizations.localeOf(context).toString(),
      ).format(_selectedDate);
    }
  }

  void navigateDay(bool forward) {
    final newDay = _selectedDate.add(Duration(days: forward ? 1 : -1));
    // Im Gegensatz zum NutritionScreen erlauben wir hier die Navigation in die Zukunft
    // if (forward && newDay.isAfter(DateTime.now())) return;

    loadDataForDate(newDay);
  }

  Widget _buildWeightChartCard(
    BuildContext context,
    ColorScheme colorScheme,
    AppLocalizations l10n,
  ) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  l10n.weightHistoryTitle,
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                ),
                Expanded(
                  child: Align(
                    alignment: Alignment.centerRight,
                    child: Wrap(
                      spacing: 8.0,
                      alignment: WrapAlignment.end,
                      children: [
                        '30D',
                        '90D',
                        'All',
                      ].map((key) => _buildFilterButton(key, key)).toList(),
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: DesignConstants.spacingL),
            MeasurementChartWidget(
              chartType: 'weight',
              dateRange: _calculateDateRange(),
              unit: "kg",
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFilterButton(String label, String key) {
    final theme = Theme.of(context);
    final isSelected = _selectedChartRangeKey == key;
    return GestureDetector(
      onTap: () {
        setState(() {
          _selectedChartRangeKey = key;
        });
        // Chart wird durch setState im MeasurementChartWidget neu geladen
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10.0, vertical: 6.0),
        decoration: BoxDecoration(
          color: isSelected
              ? theme.colorScheme.primary
              : theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
          borderRadius: BorderRadius.circular(8.0),
        ),
        child: Text(
          label,
          style: theme.textTheme.labelSmall?.copyWith(
            color: isSelected
                ? theme.colorScheme.onPrimary
                : theme.colorScheme.onSurfaceVariant,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  DateTimeRange _calculateDateRange() {
    final now = DateTime.now();
    DateTime start;
    switch (_selectedChartRangeKey) {
      case '90D':
        start = now.subtract(const Duration(days: 89));
        break;
      case 'All':
        // Für "Alle" setzen wir ein sehr frühes Datum,
        // der Chart wird die Daten entsprechend laden
        start = DateTime(2020);
        break;
      case '30D':
      default:
        start = now.subtract(const Duration(days: 29));
    }
    return DateTimeRange(start: start, end: now);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final hasEntries = _entriesByMeal.values.any((list) => list.isNotEmpty);
    final double appBarHeight =
        MediaQuery.of(context).padding.top; // + kToolbarHeight;

    // 2. Get your base padding from your design constants
    const EdgeInsets basePadding =
        DesignConstants.cardPadding; // This is EdgeInsets.all(16.0)

    // 3. Create the final combined padding
    final EdgeInsets finalPadding = basePadding.copyWith(
      // Take the original top value (16.0) and add the app bar height
      top: basePadding.top + appBarHeight,
    );

    return _isLoading
        ? const Center(child: CircularProgressIndicator())
        : RefreshIndicator(
            onRefresh: () => loadDataForDate(_selectedDate),
            child: ListView(
              padding: finalPadding,
              children: [
                const SizedBox(height: DesignConstants.spacingL),
                _buildSectionTitle(context, l10n.today_overview_text),
                if (_dailyNutrition != null)
                  NutritionSummaryWidget(
                    nutritionData: _dailyNutrition!,
                    l10n: l10n,
                    isExpandedView: false,
                  ),

                const SizedBox(height: DesignConstants.spacingXS),
                SupplementSummaryWidget(
                  trackedSupplements: _trackedSupplements,
                  onTap: () => Navigator.of(context)
                      .push(
                        MaterialPageRoute(
                          // FIX #65: Datum weiterreichen
                          builder: (context) => SupplementTrackScreen(
                            initialDate: _selectedDate,
                          ),
                        ),
                      )
                      .then((_) => loadDataForDate(_selectedDate)),
                ),
                // NEUER TEIL: Workout-Zusammenfassung hier einfügen
                if (_workoutSummary != null) ...[
                  //const SizedBox(height: DesignConstants.spacingXS),
                  TodaysWorkoutSummaryCard(
                    duration: _workoutSummary!['duration'] as Duration,
                    volume: _workoutSummary!['volume'] as double,
                    sets: _workoutSummary!['sets'] as int,
                    workoutCount: _workoutSummary!['count'] as int,
                    onTap: () {
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (context) => const WorkoutHistoryScreen(),
                        ),
                      );
                    },
                  ),
                ],
                const SizedBox(height: DesignConstants.spacingXL),
                _buildSectionTitle(context, l10n.protocol_today_capslock),
                _buildTodaysLog(l10n),
                const SizedBox(height: DesignConstants.spacingXL),
                _buildSectionTitle(context, l10n.measurementWeightCapslock),
                _buildWeightChartCard(
                  context,
                  Theme.of(context).colorScheme,
                  l10n,
                ),
                const BottomContentSpacer(),
              ],
            ),
          );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildMealCard(
    String title,
    String mealKey,
    List<TrackedFoodItem> items,
    _MealMacros macros,
    AppLocalizations l10n,
  ) {
    final isOpen = _mealExpanded[mealKey] ?? false;
    final theme = Theme.of(context);
    final titleStyle = theme.textTheme.titleLarge; // Inter, fett wie im Rest

    return SummaryCard(
      padding: const EdgeInsets.all(12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // Header (Tippen toggelt)
          InkWell(
            onTap: () => setState(() {
              _mealExpanded[mealKey] = !isOpen;
            }),
            child: Row(
              children: [
                Expanded(child: Text(title, style: titleStyle)),
                Icon(isOpen ? Icons.expand_less : Icons.expand_more),
                const SizedBox(width: 4),
                IconButton(
                  icon: const Icon(Icons.add_circle),
                  color: theme.colorScheme.primary,
                  onPressed: () => _addFoodToMeal(mealKey),
                  tooltip: l10n.addFoodOption,
                ),
              ],
            ),
          ),

          // <<< NEU: Makro-Zeile unter dem Titel (eigene Zeile, linksbündig)
          if (items.isNotEmpty) ...[
            const SizedBox(height: 4),
            Align(
              alignment: Alignment.centerLeft,
              child: Text(
                '${macros.calories} kcal · '
                '${macros.protein}g P · '
                '${macros.carbs}g C · '
                '${macros.fat}g F',
                style: theme.textTheme.bodySmall?.copyWith(
                  color: Colors.grey[600],
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ],

          // Inhalt (animiert ein-/ausklappen)
          AnimatedCrossFade(
            crossFadeState:
                isOpen ? CrossFadeState.showFirst : CrossFadeState.showSecond,
            duration: const Duration(milliseconds: 180),
            firstChild: Column(
              children: [
                if (items.isNotEmpty) const Divider(height: 16),
                ...items.map((item) => _buildFoodEntryTile(l10n, item)),
              ],
            ),
            secondChild: const SizedBox.shrink(),
          ),
        ],
      ),
    );
  }
// lib/screens/diary_screen.dart
// In lib/screens/diary_screen.dart

  Future<void> _showAddFluidMenu() async {
    final l10n = AppLocalizations.of(context)!;
    final key = GlobalKey<FluidDialogContentState>();

    await showGlassBottomMenu(
      context: context,
      title: l10n.add_liquid_title,
      contentBuilder: (ctx, close) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            FluidDialogContent(
              key: key,
              initialTimestamp: _selectedDate, // <--- FIX: Datum übergeben
            ),
            const SizedBox(height: 12),
            // ... (Rest der Methode bleibt gleich: Buttons Row etc.)
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: close,
                    child: Text(l10n.cancel),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton(
                    onPressed: () async {
                      final state = key.currentState;
                      if (state == null) return;
                      final quantity = int.tryParse(state.quantityText);
                      if (quantity == null || quantity <= 0) return;

                      final name = state.nameText;
                      final sugarPer100ml =
                          double.tryParse(state.sugarText.replaceAll(',', '.'));
                      final caffeinePer100ml = double.tryParse(
                          state.caffeineText.replaceAll(',', '.'));
                      final kcal = (sugarPer100ml != null)
                          ? ((sugarPer100ml / 100) * quantity * 4).round()
                          : null;

                      final newEntry = FluidEntry(
                        timestamp: state
                            .selectedDateTime, // Das ist jetzt korrekt initialisiert
                        quantityInMl: quantity,
                        name: name,
                        kcal: kcal,
                        sugarPer100ml: sugarPer100ml,
                        carbsPer100ml: sugarPer100ml,
                        caffeinePer100ml: caffeinePer100ml,
                      );

                      final newId = await DatabaseHelper.instance
                          .insertFluidEntry(newEntry);

                      if (caffeinePer100ml != null && caffeinePer100ml > 0) {
                        final totalCaffeine =
                            (caffeinePer100ml / 100.0) * quantity;
                        await _logCaffeineDose(
                          totalCaffeine,
                          state.selectedDateTime,
                          fluidEntryId: newId,
                        );
                      }

                      close();
                      loadDataForDate(_selectedDate);
                    },
                    child: Text(l10n.add_button),
                  ),
                ),
              ],
            ),
          ],
        );
      },
    );
  }

  Widget _buildTodaysLog(AppLocalizations l10n) {
    const mealOrder = [
      "fluids", // AN ERSTER STELLE
      "mealtypeBreakfast",
      "mealtypeLunch",
      "mealtypeDinner",
      "mealtypeSnack",
    ];

    return Column(
      children: [
        ...mealOrder.map((mealKey) {
          if (mealKey == "fluids") {
            return _buildFluidsCard(l10n);
          }

          final entries = _entriesByMeal[mealKey] ?? [];
          final mealMacros = _MealMacros();
          for (var item in entries) {
            final factor = item.entry.quantityInGrams / 100.0;
            mealMacros.calories += (item.item.calories * factor).round();
            mealMacros.protein += (item.item.protein * factor).round();
            mealMacros.carbs += (item.item.carbs * factor).round();
            mealMacros.fat += (item.item.fat * factor).round();
          }

          return _buildMealCard(
            _getLocalizedMealName(l10n, mealKey),
            mealKey,
            entries,
            mealMacros,
            l10n,
          );
        }),
      ],
    );
  }

  Widget _buildFluidsCard(AppLocalizations l10n) {
    final isOpen = _mealExpanded['fluids'] ?? false;
    final theme = Theme.of(context);
    final titleStyle = theme.textTheme.titleLarge;

    return SummaryCard(
      padding: const EdgeInsets.all(12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          InkWell(
            onTap: () => setState(() {
              _mealExpanded['fluids'] = !isOpen;
            }),
            child: Row(
              children: [
                Icon(Icons.local_drink_outlined,
                    color: theme.colorScheme.primary),
                const SizedBox(width: 12),
                Expanded(child: Text(l10n.waterHeader, style: titleStyle)),
                Icon(isOpen ? Icons.expand_less : Icons.expand_more),
                const SizedBox(width: 4),
                IconButton(
                  icon: const Icon(Icons.add_circle),
                  color: theme.colorScheme.primary,
                  onPressed: _showAddFluidMenu,
                  tooltip: l10n.addLiquidOption,
                ),
              ],
            ),
          ),
          AnimatedCrossFade(
            crossFadeState:
                isOpen ? CrossFadeState.showFirst : CrossFadeState.showSecond,
            duration: const Duration(milliseconds: 180),
            firstChild: Column(
              children: [
                if (_fluidEntries.isNotEmpty) const Divider(height: 16),
                ..._fluidEntries.map(
                  (entry) => _buildFluidEntryTile(l10n, entry),
                ),
              ],
            ),
            secondChild: const SizedBox.shrink(),
          ),
        ],
      ),
    );
  }

  Widget _buildFluidEntryTile(AppLocalizations l10n, FluidEntry entry) {
    final totalSugar = (entry.sugarPer100ml != null)
        ? (entry.sugarPer100ml! / 100 * entry.quantityInMl).toStringAsFixed(1)
        : '0';
    final totalCaffeine = (entry.caffeinePer100ml != null)
        ? (entry.caffeinePer100ml! / 100 * entry.quantityInMl).toStringAsFixed(
            1,
          )
        : '0';

    return Dismissible(
      key: Key('fluid_entry_${entry.id}'),
      background: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      direction: DismissDirection.endToStart,
      confirmDismiss: (direction) async {
        // NEU: Helper
        return await showDeleteConfirmation(context);
      },
      onDismissed: (direction) {
        _deleteFluidEntry(entry.id!);
      },
      child: SummaryCard(
        child: ListTile(
          title: Text(entry.name),
          subtitle: Text(
            "${entry.quantityInMl}ml · Sugar: ${totalSugar}g · Caffeine: ${totalCaffeine}mg",
          ),
          trailing: Text("${entry.kcal ?? 0} kcal"),
        ),
      ),
    );
  }

  Widget _buildFoodEntryTile(
    AppLocalizations l10n,
    TrackedFoodItem trackedItem,
  ) {
    return Dismissible(
      key: Key('food_hub_entry_${trackedItem.entry.id}'),
      background: const SwipeActionBackground(
        color: Colors.blueAccent,
        icon: Icons.edit,
        alignment: Alignment.centerLeft,
      ),
      secondaryBackground: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      confirmDismiss: (direction) async {
        if (direction == DismissDirection.startToEnd) {
          _editFoodEntry(trackedItem);
          return false;
        } else {
          // NEU: Helper
          return await showDeleteConfirmation(context);
        }
      },
      onDismissed: (direction) {
        if (direction == DismissDirection.endToStart) {
          _deleteFoodEntry(trackedItem.entry.id!);
        }
      },
      child: SummaryCard(
        child: ListTile(
          title: Text(trackedItem.item.name),
          subtitle: Text("${trackedItem.entry.quantityInGrams}g"),
          trailing: Text("${trackedItem.calculatedCalories} kcal"),
          onTap: () {
            Navigator.of(context)
                .push(
                  MaterialPageRoute(
                    builder: (context) =>
                        FoodDetailScreen(trackedItem: trackedItem),
                  ),
                )
                .then((_) => loadDataForDate(_selectedDate));
          },
        ),
      ),
    );
  }

  Widget _buildMacroText(String text) {
    return Text(
      text,
      style: TextStyle(
        color: Colors.grey[600],
        fontSize: 12,
        fontWeight: FontWeight.w600,
      ),
    );
  }

  Widget _buildEmptyLogState(AppLocalizations l10n) {
    return SummaryCard(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Text(
          l10n.noEntriesForPeriod,
          textAlign: TextAlign.center,
          style: Theme.of(context).textTheme.bodyLarge,
        ),
      ),
    );
  }

  String _getLocalizedMealName(AppLocalizations l10n, String key) {
    switch (key) {
      case "mealtypeBreakfast":
        return l10n.mealtypeBreakfast;
      case "mealtypeLunch":
        return l10n.mealtypeLunch;
      case "mealtypeDinner":
        return l10n.mealtypeDinner;
      case "mealtypeSnack":
        return l10n.mealtypeSnack;
      default:
        return key;
    }
  }
}

class _MealMacros {
  int calories = 0;
  int protein = 0;
  int carbs = 0;
  int fat = 0;
}

class DiaryAppBar extends StatelessWidget {
  final ValueNotifier<DateTime>? selectedDateNotifier;
  const DiaryAppBar({super.key, required this.selectedDateNotifier});

  String _getAppBarTitle(
    BuildContext context,
    AppLocalizations l10n,
    DateTime selectedDate,
  ) {
    final today = DateTime.now();
    final yesterday = today.subtract(const Duration(days: 1));
    final dayBeforeYesterday = today.subtract(const Duration(days: 2));

    if (selectedDate.isSameDate(today)) {
      return l10n.today;
    } else if (selectedDate.isSameDate(yesterday)) {
      return l10n.yesterday; // ← NEW
    } else if (selectedDate.isSameDate(dayBeforeYesterday)) {
      return l10n.dayBeforeYesterday; // ← NEW
    } else {
      return DateFormat.yMMMMd(
        Localizations.localeOf(context).toString(),
      ).format(selectedDate);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    // Gracefully handle the case where the notifier might be null during the first frame
    if (selectedDateNotifier == null) {
      return Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0),
        child: Text(
          l10n.today, // Default to 'Today'
          style: Theme.of(
            context,
          ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w900),
        ),
      );
    }

    return ValueListenableBuilder<DateTime>(
      valueListenable: selectedDateNotifier!,
      builder: (context, selectedDate, child) {
        final title = _getAppBarTitle(context, l10n, selectedDate);
        return Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0),
          child: Text(
            title,
            style: Theme.of(
              context,
            ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w900),
          ),
        );
      },
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/nutrition_hub_screen.dart =====

// lib/screens/nutrition_hub_screen.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/add_food_screen.dart';
import 'package:lightweight/screens/meal_screen.dart';
import 'package:lightweight/screens/goals_screen.dart';
import 'package:lightweight/screens/supplement_track_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/bottom_content_spacer.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:shared_preferences/shared_preferences.dart';

class NutritionHubScreen extends StatefulWidget {
  const NutritionHubScreen({super.key});

  @override
  State<NutritionHubScreen> createState() => _NutritionHubScreenState();
}

class _NutritionHubScreenState extends State<NutritionHubScreen> {
  Future<Map<String, dynamic>>? _hubDataFuture;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Lade die Daten nur beim ersten Mal.
    _hubDataFuture ??= _loadHubData();
  }

  Future<void> _refreshData() async {
    // Wird vom RefreshIndicator aufgerufen, um die Daten neu zu laden.
    setState(() {
      _hubDataFuture = _loadHubData();
    });
  }

  Future<Map<String, dynamic>> _loadHubData() async {
    final l10n = AppLocalizations.of(context)!;
    final prefs = await SharedPreferences.getInstance();

    final meals = await DatabaseHelper.instance.getMeals();
    final targetCalories = prefs.getInt('targetCalories') ?? 2500;
    final today = DateTime.now();
    final sevenDaysAgo = today.subtract(const Duration(days: 6));
    final recentEntries = await DatabaseHelper.instance.getEntriesForDateRange(
      sevenDaysAgo,
      today,
    );

    String recommendation;
    if (recentEntries.isEmpty) {
      recommendation = l10n.recommendationDefault;
    } else {
      final uniqueDaysTracked = recentEntries
          .map((e) => DateFormat.yMd().format(e.timestamp))
          .toSet();
      final numberOfTrackedDays = uniqueDaysTracked.length;
      int totalRecentCalories = 0;
      for (final entry in recentEntries) {
        final foodItem = await ProductDatabaseHelper.instance
            .getProductByBarcode(entry.barcode);
        if (foodItem != null) {
          totalRecentCalories +=
              (foodItem.calories / 100 * entry.quantityInGrams).round();
        }
      }

      final totalTargetCalories = targetCalories * numberOfTrackedDays;
      final difference = totalRecentCalories - totalTargetCalories;
      final tolerance = totalTargetCalories * 0.05;

      if (numberOfTrackedDays > 1) {
        if (difference > tolerance) {
          recommendation = l10n.recommendationOverTarget(
              numberOfTrackedDays, difference.round());
        } else if (difference < -tolerance) {
          recommendation = l10n.recommendationUnderTarget(
              numberOfTrackedDays, (-difference).round());
        } else {
          recommendation = l10n.recommendationOnTarget(numberOfTrackedDays);
        }
      } else {
        recommendation = l10n.recommendationFirstEntry;
      }
    }

    return {
      'meals': meals,
      'recommendation': recommendation,
      'targetCalories': targetCalories,
    };
  }

  Future<void> _createMealAndOpenEditor() async {
    final l10n = AppLocalizations.of(context)!;
    final defaultName = l10n.mealNameLabel;
    final newMealId =
        await DatabaseHelper.instance.insertMeal(name: defaultName, notes: '');
    final meal = {'id': newMealId, 'name': defaultName, 'notes': ''};

    if (!mounted) return;
    await Navigator.of(context).push(
      MaterialPageRoute(
        builder: (_) => MealScreen(meal: meal, startInEdit: true),
      ),
    );

    final items = await DatabaseHelper.instance.getMealItems(newMealId);
    final createdMeals = await DatabaseHelper.instance.getMeals();
    final createdMeal =
        createdMeals.firstWhere((m) => m['id'] == newMealId, orElse: () => {});

    if (createdMeal.isNotEmpty &&
        (createdMeal['name'] as String) == defaultName &&
        items.isEmpty) {
      await DatabaseHelper.instance.deleteMeal(newMealId);
    }

    _refreshData();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final double appBarHeight =
        MediaQuery.of(context).padding.top; // + kToolbarHeight;

    // 2. Get your base padding from your design constants
    const EdgeInsets basePadding =
        DesignConstants.cardPadding; // This is EdgeInsets.all(16.0)

    // 3. Create the final combined padding
    final EdgeInsets finalPadding = basePadding.copyWith(
      // Take the original top value (16.0) and add the app bar height
      top: basePadding.top + appBarHeight,
    );

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: FutureBuilder<Map<String, dynamic>>(
        future: _hubDataFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError || !snapshot.hasData) {
            return Center(child: Text(l10n.error));
          }

          final data = snapshot.data!;
          final meals = data['meals'] as List<Map<String, dynamic>>;
          final recommendationText = data['recommendation'] as String;
          final targetCalories = data['targetCalories'] as int;

          return RefreshIndicator(
            onRefresh: _refreshData,
            child: ListView(
              padding: finalPadding,
              children: [
                _buildSectionTitle(context, l10n.today_overview_text),
                _buildGoalsAndRecommendationCard(
                    context, recommendationText, targetCalories, theme, l10n),
                const SizedBox(height: DesignConstants.spacingXL),
                _buildSectionTitle(context, l10n.myMealsCL),
                meals.isEmpty
                    ? _buildEmptyMealsCard(context, l10n)
                    : SizedBox(
                        height: 150,
                        child: ListView.builder(
                          scrollDirection: Axis.horizontal,
                          clipBehavior: Clip.none,
                          itemCount: meals.length + 1,
                          itemBuilder: (context, index) {
                            if (index == 0) {
                              return _buildCreateMealCard(context, l10n);
                            }
                            return _buildMealCard(context, meals[index - 1]);
                          },
                        ),
                      ),
                const SizedBox(height: DesignConstants.spacingXL),
                _buildSectionTitle(context, l10n.overview_capslock),
                _buildNavigationCard(
                  context: context,
                  icon: Icons.restaurant_menu_outlined,
                  title:
                      l10n.manage_all_plans.replaceAll('Pläne', 'Mahlzeiten'),
                  subtitle: l10n.mealsEmptyBody,
                  onTap: () {
                    Navigator.of(context)
                        .push(
                          MaterialPageRoute(
                              builder: (_) => const AddFoodScreen()),
                        )
                        .then((_) => _refreshData());
                  },
                ),
                //const SizedBox(height: DesignConstants.spacingM),
                _buildNavigationCard(
                  context: context,
                  icon: Icons.medication_outlined,
                  title: l10n.supplementTrackerTitle,
                  subtitle: l10n.supplementTrackerDescription,
                  onTap: () {
                    Navigator.of(context).push(MaterialPageRoute(
                      builder: (_) => const SupplementTrackScreen(),
                    ));
                  },
                ),
                //const SizedBox(height: DesignConstants.spacingM),
                _buildNavigationCard(
                  context: context,
                  icon: Icons.search,
                  title: l10n.drawerFoodExplorer,
                  subtitle: l10n.data_from_off_and_wger,
                  onTap: () {
                    Navigator.of(context).push(
                      MaterialPageRoute(builder: (_) => const AddFoodScreen()),
                    );
                  },
                ),
                const BottomContentSpacer(),
              ],
            ),
          );
        },
      ),
    );
  }

  Widget _buildGoalsAndRecommendationCard(
      BuildContext context,
      String recommendationText,
      int targetCalories,
      ThemeData theme,
      AppLocalizations l10n) {
    return SummaryCard(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            Text(
              recommendationText,
              textAlign: TextAlign.center,
              style: TextStyle(
                color: theme.colorScheme.onSurfaceVariant,
                fontSize: 18,
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: 16),
            Text(
              '${l10n.profileDailyGoals}: $targetCalories kcal',
              style: theme.textTheme.titleMedium,
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () {
                Navigator.of(context).push(
                    MaterialPageRoute(builder: (_) => const GoalsScreen()));
              },
              child: Text(l10n.my_goals),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildCreateMealCard(BuildContext context, AppLocalizations l10n) {
    final screenWidth = MediaQuery.of(context).size.width;
    final cardWidth = (screenWidth - 32 - 12) / 2.5;
    return SizedBox(
      width: cardWidth,
      child: Padding(
        padding: const EdgeInsets.only(right: 12.0),
        child: SummaryCard(
          child: InkWell(
            onTap: _createMealAndOpenEditor,
            borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM),
            child: Padding(
              padding: DesignConstants.cardPadding,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.add_circle_outline,
                      size: 40, color: Theme.of(context).colorScheme.primary),
                  const SizedBox(height: 8),
                  Text(l10n.mealsCreate, textAlign: TextAlign.center),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildMealCard(BuildContext context, Map<String, dynamic> meal) {
    final screenWidth = MediaQuery.of(context).size.width;
    final cardWidth = (screenWidth - 32 - 12) / 2;
    final l10n = AppLocalizations.of(context)!;
    return SizedBox(
      width: cardWidth,
      child: Padding(
        padding: const EdgeInsets.only(right: 12.0),
        child: SummaryCard(
          child: InkWell(
            onTap: () => Navigator.of(context)
                .push(MaterialPageRoute(builder: (_) => MealScreen(meal: meal)))
                .then((_) => _refreshData()),
            borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM),
            child: Padding(
              padding: DesignConstants.cardPadding,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    meal['name'] as String,
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  ElevatedButton(
                    onPressed: () => Navigator.of(context)
                        .push(MaterialPageRoute(
                            builder: (_) => MealScreen(meal: meal)))
                        .then((_) => _refreshData()),
                    child: Text(l10n.edit),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildEmptyMealsCard(BuildContext context, AppLocalizations l10n) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          children: [
            Text(
              l10n.mealsEmptyTitle,
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: DesignConstants.spacingS),
            Text(
              l10n.mealsEmptyBody,
              textAlign: TextAlign.center,
              style: Theme.of(context).textTheme.bodySmall,
            ),
            const SizedBox(height: DesignConstants.spacingL),
            TextButton.icon(
              onPressed: _createMealAndOpenEditor,
              icon: const Icon(Icons.add),
              label: Text(l10n.mealsCreate),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNavigationCard({
    required BuildContext context,
    required IconData icon,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
  }) {
    return SummaryCard(
      child: ListTile(
        contentPadding: const EdgeInsets.symmetric(
          vertical: 12.0,
          horizontal: 16.0,
        ),
        leading: Icon(
          icon,
          size: 40,
          color: Theme.of(context).colorScheme.primary,
        ),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Text(subtitle),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/settings_screen.dart =====

// lib/screens/settings_screen.dart
import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/data_management_screen.dart';
import 'package:lightweight/services/profile_service.dart';
import 'package:lightweight/services/theme_service.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:provider/provider.dart';
import 'package:lightweight/widgets/global_app_bar.dart';

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  String _appVersion = '';

  @override
  void initState() {
    super.initState();
    _loadAppVersion();
  }

  Future<void> _loadAppVersion() async {
    final packageInfo = await PackageInfo.fromPlatform();
    if (mounted) {
      setState(() {
        _appVersion = "${packageInfo.version} (${packageInfo.buildNumber})";
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final themeService = Provider.of<ThemeService>(context);
    // profileService wird hier aktuell nicht genutzt, aber stört auch nicht
    // final profileService = Provider.of<ProfileService>(context); 
    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: GlobalAppBar(
        title: l10n.settingsTitle,
      ),
      body: ListView(
        padding: DesignConstants.cardPadding.copyWith(
          top: DesignConstants.cardPadding.top + topPadding,
        ),
        children: [
          _buildSectionTitle(context, l10n.settingsAppearance),
          SummaryCard(
            child: Column(
              children: [
                RadioListTile<ThemeMode>(
                  title: Text(l10n.themeSystem),
                  value: ThemeMode.system,
                  groupValue: themeService.themeMode,
                  onChanged: (value) => themeService.setThemeMode(value!),
                ),
                RadioListTile<ThemeMode>(
                  title: Text(l10n.themeLight),
                  value: ThemeMode.light,
                  groupValue: themeService.themeMode,
                  onChanged: (value) => themeService.setThemeMode(value!),
                ),
                RadioListTile<ThemeMode>(
                  title: Text(l10n.themeDark),
                  value: ThemeMode.dark,
                  groupValue: themeService.themeMode,
                  onChanged: (value) => themeService.setThemeMode(value!),
                ),
                const Divider(height: 1),
                Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Padding(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 16,
                          vertical: 8,
                        ),
                        child: Text(
                          l10n.settingsVisualStyleTitle,
                          style: Theme.of(context).textTheme.labelLarge?.copyWith(
                                color: Colors.grey,
                                fontWeight: FontWeight.bold,
                              ),
                        ),
                      ),
                      RadioListTile<int>(
                        title: Text(l10n.settingsVisualStyleStandard), // LOKALISIERT
                        value: 0,
                        groupValue: themeService.visualStyle,
                        onChanged: (value) =>
                            themeService.setVisualStyle(value!),
                      ),
                      RadioListTile<int>(
                        title: Text(l10n.settingsVisualStyleLiquid), // LOKALISIERT
                        subtitle: Text(l10n.settingsVisualStyleLiquidDesc), // LOKALISIERT
                        value: 1,
                        groupValue: themeService.visualStyle,
                        onChanged: (value) =>
                            themeService.setVisualStyle(value!),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: DesignConstants.spacingXL),
          _buildSectionTitle(context, l10n.backup_and_import),
          _buildNavigationCard(
            context: context,
            icon: Icons.import_export_rounded,
            title: l10n.backup_and_import,
            subtitle: l10n.backup_and_import_description,
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => const DataManagementScreen(),
                ),
              );
            },
          ),
          const SizedBox(height: DesignConstants.spacingXL),
          _buildSectionTitle(context, l10n.about_and_legal_capslock),
          _buildNavigationCard(
            context: context,
            icon: Icons.info_outline_rounded,
            title: l10n.attribution_and_license,
            subtitle: l10n.data_from_off_and_wger,
            onTap: () {
              showDialog(
                context: context,
                builder: (context) => AlertDialog(
                  title: Text(l10n.attribution_title),
                  content: SingleChildScrollView(
                    child: Text(l10n.attributionText),
                  ),
                  actions: [
                    TextButton(
                      onPressed: () => Navigator.of(context).pop(),
                      child: Text(l10n.snackbar_button_ok),
                    ),
                  ],
                ),
              );
            },
          ),
          const SizedBox(height: DesignConstants.spacingM),
          SummaryCard(
            child: ListTile(
              leading: const Icon(Icons.code_rounded),
              title: Text(
                l10n.app_version,
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),
              subtitle: Text(_appVersion),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title.toUpperCase(),
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildNavigationCard({
    required BuildContext context,
    required IconData icon,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
  }) {
    return SummaryCard(
      child: ListTile(
        contentPadding: const EdgeInsets.symmetric(
          vertical: 8.0,
          horizontal: 16.0,
        ),
        leading: Icon(
          icon,
          size: 36,
          color: Theme.of(context).colorScheme.primary,
        ),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Text(subtitle),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(24.0),
        ),
      ),
    );
  }
}

===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/food_explorer_screen.dart =====

// lib/screens/food_explorer_screen.dart (Final & De-Materialisiert)

import 'package:flutter/material.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/screens/create_food_screen.dart';
import 'package:lightweight/screens/food_detail_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/off_attribution_widget.dart';
import 'package:lightweight/widgets/summary_card.dart'; // HINZUGEFÜGT

class FoodExplorerScreen extends StatefulWidget {
  const FoodExplorerScreen({super.key});

  @override
  State<FoodExplorerScreen> createState() => _FoodExplorerScreenState();
}

class _FoodExplorerScreenState extends State<FoodExplorerScreen>
    with SingleTickerProviderStateMixin {
  List<FoodItem> _foundFoodItems = [];
  bool _isLoadingSearch = false;
  String _searchInitialText = "";
  final _searchController = TextEditingController();

  List<FoodItem> _favoriteFoodItems = [];
  bool _isLoadingFavorites = true;

  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _searchController.addListener(() => setState(() {}));
    _loadFavorites();
  }

  @override
  void dispose() {
    _searchController.dispose();
    _tabController.dispose();
    super.dispose();
  }

  void _runFilter(String enteredKeyword) async {
    final l10n = AppLocalizations.of(context)!;

    if (enteredKeyword.isEmpty) {
      setState(() {
        _foundFoodItems = [];
        _searchInitialText = l10n.searchInitialHint;
      });
      return;
    }
    setState(() {
      _isLoadingSearch = true;
    });
    final results = await ProductDatabaseHelper.instance.searchProducts(
      enteredKeyword,
    );
    if (mounted) {
      setState(() {
        _foundFoodItems = results;
        _isLoadingSearch = false;
        if (results.isEmpty) {
          _searchInitialText = l10n.searchNoResults;
        }
      });
    }
  }

  void _navigateAndCreateFood() {
    Navigator.of(context)
        .push(MaterialPageRoute(builder: (context) => const CreateFoodScreen()))
        .then((_) {
      _searchController.clear();
      _runFilter('');
    });
  }

  Future<void> _loadFavorites() async {
    setState(() {
      _isLoadingFavorites = true;
    });
    final results = await ProductDatabaseHelper.instance.getFavoriteProducts();
    if (mounted) {
      setState(() {
        _favoriteFoodItems = results;
        _isLoadingFavorites = false;
      });
    }
  }

  // lib/screens/food_explorer_screen.dart

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    // KORREKTUR: Direkte Abfrage des Theme-Modus
    final isLightMode = Theme.of(context).brightness == Brightness.light;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(
              horizontal: 16.0,
              vertical: 24.0,
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  l10n.addFoodTitle,
                  style: textTheme.headlineMedium?.copyWith(
                    fontWeight: FontWeight.w900,
                    fontSize: 28,
                  ),
                ),
                const SizedBox(height: DesignConstants.spacingL),
                TabBar(
                  controller: _tabController,
                  isScrollable: false,
                  indicator: const BoxDecoration(),
                  splashFactory: NoSplash.splashFactory,
                  overlayColor: WidgetStateProperty.all(Colors.transparent),
                  dividerColor: Colors.transparent,
                  // KORREKTUR: Dynamische Farbe basierend auf dem Theme-Modus
                  labelColor: isLightMode ? Colors.black : Colors.white,
                  unselectedLabelColor: Colors.grey.shade600,
                  labelStyle: const TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.w900,
                    letterSpacing: 0.0,
                  ),
                  unselectedLabelStyle: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.w800,
                    letterSpacing: 0.0,
                  ),
                  tabs: [
                    Tab(text: l10n.tabSearch),
                    Tab(text: l10n.tabFavorites),
                  ],
                ),
              ],
            ),
          ),
          Divider(
            height: 1,
            thickness: 1,
            color: colorScheme.onSurfaceVariant.withOpacity(0.1),
          ),
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [_buildSearchTab(l10n), _buildFavoritesTab(l10n)],
            ),
          ),
        ],
      ),
      floatingActionButton: GlassFab(
        onPressed: _navigateAndCreateFood,
        label: l10n.createFoodScreenTitle,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  Widget _buildSearchTab(AppLocalizations l10n) {
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    return Padding(
      padding: DesignConstants.cardPadding,
      child: Column(
        children: [
          // KORREKTUR 4: TextField nutzt globale InputDecorationTheme
          TextField(
            controller: _searchController,
            onChanged: (value) => _runFilter(value),
            decoration: InputDecoration(
              hintText: l10n.searchHintText,
              prefixIcon: Icon(
                Icons.search,
                color: colorScheme.onSurfaceVariant,
                size: 20,
              ),
              suffixIcon: _searchController.text.isNotEmpty
                  ? IconButton(
                      icon: Icon(
                        Icons.clear,
                        color: colorScheme.onSurfaceVariant,
                      ),
                      onPressed: () {
                        _searchController.clear();
                        _runFilter('');
                      },
                    )
                  : null,
            ),
          ),
          const SizedBox(height: 20),
          Expanded(
            child: _isLoadingSearch
                ? const Center(child: CircularProgressIndicator())
                : _foundFoodItems.isNotEmpty
                    ? ListView.builder(
                        itemCount: _foundFoodItems.length,
                        itemBuilder: (context, index) =>
                            _buildFoodListItem(_foundFoodItems[index]),
                      )
                    : Center(
                        child: Text(
                          _searchInitialText,
                          style: textTheme.titleMedium,
                        ),
                      ),
          ),
          if (_foundFoodItems.any((item) => item.source == FoodItemSource.off))
            const OffAttributionWidget(),
        ],
      ),
    );
  }

  Widget _buildFavoritesTab(AppLocalizations l10n) {
    if (_isLoadingFavorites) {
      return const Center(child: CircularProgressIndicator());
    }
    if (_favoriteFoodItems.isEmpty) {
      return Center(
        child: Text(
          l10n.favoritesEmptyState,
          textAlign: TextAlign.center,
          style: Theme.of(context).textTheme.titleMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
              ),
        ),
      );
    }
    return Column(
      children: [
        Expanded(
          child: ListView.builder(
            padding: DesignConstants.cardPadding,
            itemCount: _favoriteFoodItems.length,
            itemBuilder: (context, index) =>
                _buildFoodListItem(_favoriteFoodItems[index]),
          ),
        ),
        if (_favoriteFoodItems.any((item) => item.source == FoodItemSource.off))
          const OffAttributionWidget(),
      ],
    );
  }

  // KORREKTUR 5: _buildFoodListItem verwendet jetzt SummaryCard
  Widget _buildFoodListItem(FoodItem item) {
    final colorScheme = Theme.of(context).colorScheme;
    final l10n = AppLocalizations.of(context)!;

    IconData sourceIcon;
    switch (item.source) {
      case FoodItemSource.base:
        sourceIcon = Icons.star;
        break;
      case FoodItemSource.off:
      case FoodItemSource.user:
        sourceIcon = Icons.inventory_2;
        break;
    }

    return SummaryCard(
      // KORREKTUR: Jetzt mit SummaryCard
      child: ListTile(
        leading: Icon(sourceIcon, color: colorScheme.primary),
        title: Text(
          item.name.isNotEmpty ? item.name : l10n.unknown,
          style: const TextStyle(fontWeight: FontWeight.bold),
        ),
        subtitle: Text(
          l10n.foodItemSubtitle(
            item.brand.isNotEmpty ? item.brand : l10n.noBrand,
            item.calories,
          ),
        ),
        trailing: IconButton(
          icon: Icon(
            Icons.add_circle_outline,
            color: colorScheme.primary,
            size: 28,
          ),
          onPressed: () => Navigator.of(context).pop(item),
        ),
        onTap: () => Navigator.of(context)
            .push(
          MaterialPageRoute(
            builder: (context) => FoodDetailScreen(foodItem: item),
          ),
        )
            .then((_) {
          _loadFavorites();
        }),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/workout_history_screen.dart =====

// lib/screens/workout_history_screen.dart (Final & De-Materialisiert mit AppBar)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/screens/workout_log_detail_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/util/time_util.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
import 'package:lightweight/widgets/global_app_bar.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';

class WorkoutHistoryScreen extends StatefulWidget {
  const WorkoutHistoryScreen({super.key});
  @override
  State<WorkoutHistoryScreen> createState() => _WorkoutHistoryScreenState();
}

class _WorkoutHistoryScreenState extends State<WorkoutHistoryScreen> {
  bool _isLoading = true;
  List<WorkoutLog> _logs = [];

  @override
  void initState() {
    super.initState();
    _loadHistory();
  }

  Future<void> _loadHistory() async {
    setState(() => _isLoading = true);
    // KORREKTUR: Wir verwenden getFullWorkoutLogs(), um die Sätze direkt mitzuladen.
    final data = await WorkoutDatabaseHelper.instance.getFullWorkoutLogs();
    if (mounted) {
      setState(() {
        _logs = data;
        _isLoading = false;
      });
    }
  }

  Future<void> _deleteLog(int logId) async {
    await WorkoutDatabaseHelper.instance.deleteWorkoutLog(logId);
    _loadHistory();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).toString();
    final colorScheme = Theme.of(context).colorScheme;

    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: GlobalAppBar(
        title: l10n.workoutHistoryTitle,
      ),
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _logs.isEmpty
              // KORREKTUR: Aufgewerteter "Empty State"
              ? Center(
                  child: Padding(
                    padding: DesignConstants.cardPadding.copyWith(
                      top: DesignConstants.cardPadding.top + topPadding,
                    ),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons.history_toggle_off_outlined,
                          size: 80,
                          color: Colors.grey.shade400,
                        ),
                        const SizedBox(height: DesignConstants.spacingL),
                        Text(
                          l10n.workoutHistoryEmptyTitle,
                          style: Theme.of(context).textTheme.headlineSmall,
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: DesignConstants.spacingS),
                        Text(
                          l10n.emptyHistory,
                          textAlign: TextAlign.center,
                          style:
                              Theme.of(context).textTheme.bodyLarge?.copyWith(
                                    color: Colors.grey.shade600,
                                  ),
                        ),
                      ],
                    ),
                  ),
                )
              : ListView.builder(
                  padding: DesignConstants.cardPadding.copyWith(
                    top: DesignConstants.cardPadding.top + topPadding,
                  ),
                  itemCount: _logs.length,
                  itemBuilder: (context, index) {
                    final log = _logs[index];
                    final duration = log.endTime?.difference(log.startTime);

                    // NEU: Berechne Volumen und Sätze für diesen Log
                    final totalSets = log.sets.length;
                    final totalVolume = log.sets.fold<double>(
                      0,
                      (sum, set) => sum + (set.weightKg ?? 0) * (set.reps ?? 0),
                    );

                    return Dismissible(
                      key: Key('log_${log.id}'),
                      direction: DismissDirection.endToStart,

                      // KORRIGIERT: Nur `secondaryBackground` wird hier benötigt
                      background: const SwipeActionBackground(
                        color: Colors.redAccent,
                        icon: Icons.delete,
                        alignment: Alignment.centerRight,
                      ),
                      confirmDismiss: (direction) async {
                        // NEU: Helper (Textspezifizierung hier nötig)
                        return await showDeleteConfirmation(
                          context,
                          content: l10n.deleteWorkoutConfirmContent,
                        );
                      },
                      onDismissed: (direction) {
                        _deleteLog(log.id!);
                      },
                      child: SummaryCard(
                        child: ListTile(
                          leading: const Icon(Icons.event_note, size: 40),
                          title: Text(
                            log.routineName ?? l10n.freeWorkoutTitle,
                            style: const TextStyle(fontWeight: FontWeight.bold),
                          ),
                          // KORREKTUR: Das Subtitle wird jetzt ein Column mit mehr Infos
                          subtitle: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              const SizedBox(height: 4),
                              Text(
                                DateFormat.yMMMMd(
                                  locale,
                                ).add_Hm().format(log.startTime),
                              ),
                              const SizedBox(height: 8),
                              Row(
                                children: [
                                  Icon(
                                    Icons.monitor_weight_outlined,
                                    size: 14,
                                    color: Colors.grey[600],
                                  ),
                                  const SizedBox(width: 4),
                                  Text(
                                    '${totalVolume.toStringAsFixed(0)} kg',
                                    style: TextStyle(
                                      color: Colors.grey[600],
                                      fontSize: 12,
                                    ),
                                  ),
                                  const SizedBox(width: 12),
                                  Icon(
                                    Icons.replay_circle_filled_outlined,
                                    size: 14,
                                    color: Colors.grey[600],
                                  ),
                                  const SizedBox(width: 4),
                                  Text(
                                    l10n.setCount(
                                      totalSets,
                                    ), // Nutzt die Plural-Funktion
                                    style: TextStyle(
                                      color: Colors.grey[600],
                                      fontSize: 12,
                                    ),
                                  ),
                                ],
                              ),
                            ],
                          ),
                          trailing: duration != null
                              ? Text(
                                  formatDuration(duration),
                                  style: TextStyle(
                                    color: colorScheme.primary,
                                    fontWeight: FontWeight.w500,
                                  ),
                                )
                              : null,
                          onTap: () => Navigator.of(context)
                              .push(
                                MaterialPageRoute(
                                  builder: (context) =>
                                      WorkoutLogDetailScreen(logId: log.id!),
                                ),
                              )
                              .then((_) => _loadHistory()),
                        ),
                      ),
                    );
                  },
                ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/measurement_session_detail_screen.dart =====

// lib/screens/measurement_session_detail_screen.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/measurement_session.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/global_app_bar.dart';

class MeasurementSessionDetailScreen extends StatelessWidget {
  final MeasurementSession session;

  const MeasurementSessionDetailScreen({super.key, required this.session});

  // Wir kopieren die Helfer-Methode hierher, um die Namen zu übersetzen.
  String _getLocalizedMeasurementName(String key, AppLocalizations l10n) {
    switch (key) {
      case 'weight':
        return l10n.measurementWeight;
      case 'fat_percent':
        return l10n.measurementFatPercent;
      case 'neck':
        return l10n.measurementNeck;
      // ... (füge hier alle anderen 'case' Anweisungen aus dem measurements_screen.dart ein)
      case 'right_calf':
        return l10n.measurementRightCalf;
      default:
        return key;
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: GlobalAppBar(
        title: DateFormat.yMMMMd('de_DE').format(session.timestamp),
      ),
      body: ListView(
        padding: DesignConstants.cardPadding.copyWith(
          top: DesignConstants.cardPadding.top + topPadding,
        ),
        children: [
          ...session.measurements.map((measurement) {
            return Card(
              elevation: 2,
              margin: const EdgeInsets.symmetric(vertical: 6),
              child: ListTile(
                title: Text(
                  _getLocalizedMeasurementName(measurement.type, l10n),
                ),
                trailing: Text(
                  "${measurement.value.toStringAsFixed(1)} ${measurement.unit}",
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                ),
              ),
            );
          }),
        ],
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/edit_routine_screen.dart =====

// lib/screens/edit_routine_screen.dart (Final & De-Materialisiert - Endgültig)

import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/models/routine_exercise.dart';
import 'package:lightweight/models/set_template.dart';
import 'package:lightweight/screens/exercise_catalog_screen.dart';
import 'package:lightweight/screens/exercise_detail_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
// Zum Starten der Routine
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/global_app_bar.dart';
import 'package:lightweight/widgets/set_type_chip.dart';
// HINZUGEFÜGT
import 'package:lightweight/widgets/wger_attribution_widget.dart'; // HINZUGEFÜGT
import 'package:lightweight/widgets/workout_card.dart'; // NEUER IMPORT

class EditRoutineScreen extends StatefulWidget {
  final Routine? routine;
  const EditRoutineScreen({super.key, this.routine});

  @override
  State<EditRoutineScreen> createState() => _EditRoutineScreenState();
}

class _EditRoutineScreenState extends State<EditRoutineScreen> {
  final _nameController = TextEditingController();
  List<RoutineExercise> _routineExercises = [];
  bool _isNewRoutine = true;
  int? _routineId;
  String _originalName = '';
  bool _isLoading = false;
  final Map<int, TextEditingController> _repsControllers = {};
  final Map<int, TextEditingController> _weightControllers = {};
  final Map<int, bool> _exerciseExpanded = {};

  @override
  void initState() {
    super.initState();
    if (widget.routine != null) {
      _isNewRoutine = false;
      _routineId = widget.routine!.id;
      _nameController.text = widget.routine!.name;
      _originalName = widget.routine!.name;
      _loadExercisesForRoutine();
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    for (var c in _repsControllers.values) {
      c.dispose();
    }
    for (var c in _weightControllers.values) {
      c.dispose();
    }
    super.dispose();
  }

  Future<void> _loadExercisesForRoutine() async {
    if (_routineId == null) return;
    setState(() => _isLoading = true);
    final routineWithExercises =
        await WorkoutDatabaseHelper.instance.getRoutineById(_routineId!);
    if (mounted && routineWithExercises != null) {
      for (var c in _repsControllers.values) {
        c.dispose();
      }
      for (var c in _weightControllers.values) {
        c.dispose();
      }
      _repsControllers.clear();
      _weightControllers.clear();

      for (var re in routineWithExercises.exercises) {
        for (var st in re.setTemplates) {
          _repsControllers[st.id!] = TextEditingController(text: st.targetReps);
          _weightControllers[st.id!] = TextEditingController(
            text: st.targetWeight?.toString() ?? '',
          );
        }
      }

      setState(() {
        _routineExercises = routineWithExercises.exercises;
        _isLoading = false;
      });
    } else if (mounted) {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _addExercises() async {
    if (_isNewRoutine) {
      final success = await _saveRoutine(isAddingExercise: true);
      if (!success) return;
    }
    if (!mounted) return;
    final selectedExercise = await Navigator.of(context).push<Exercise>(
      MaterialPageRoute(
        builder: (context) =>
            const ExerciseCatalogScreen(isSelectionMode: true),
      ),
    );

    if (selectedExercise != null && _routineId != null) {
      final newRoutineExercise = await WorkoutDatabaseHelper.instance
          .addExerciseToRoutine(_routineId!, selectedExercise.id!);
      if (newRoutineExercise != null) {
        for (var st in newRoutineExercise.setTemplates) {
          _repsControllers[st.id!] = TextEditingController(text: st.targetReps);
          _weightControllers[st.id!] = TextEditingController(
            text: st.targetWeight?.toString() ?? '',
          );
        }
        setState(() {
          // KORREKTUR: Erstelle eine neue Liste, um den Rebuild des Widgets zu erzwingen.
          _routineExercises = [..._routineExercises, newRoutineExercise];
        });
      }
    }
  }

  Future<bool> _saveRoutine({bool isAddingExercise = false}) async {
    final l10n = AppLocalizations.of(context)!;
    FocusScope.of(context).unfocus();

    if (_nameController.text.trim().isEmpty) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(l10n.validatorPleaseEnterRoutineName)),
        );
      }
      return false;
    }

    int? currentRoutineId = _routineId;

    if (_isNewRoutine) {
      final newRoutine = await WorkoutDatabaseHelper.instance.createRoutine(
        _nameController.text.trim(),
      );
      currentRoutineId = newRoutine.id;
      if (mounted) {
        setState(() {
          _routineId = newRoutine.id;
          _isNewRoutine = false;
          _originalName = newRoutine.name;
        });
      }
      if (mounted && !isAddingExercise) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text(l10n.snackbarRoutineCreated)));
      }
    } else {
      if (_nameController.text.trim() != _originalName) {
        await WorkoutDatabaseHelper.instance.updateRoutineName(
          currentRoutineId!,
          _nameController.text.trim(),
        );
      }
    }

    final db = WorkoutDatabaseHelper.instance;
    for (var re in _routineExercises) {
      final List<SetTemplate> currentTemplates = [];
      for (var set in re.setTemplates) {
        currentTemplates.add(
          set.copyWith(
            targetReps: _repsControllers[set.id!]?.text,
            targetWeight: double.tryParse(
              _weightControllers[set.id!]!.text.replaceAll(',', '.'),
            ),
          ),
        );
      }
      await db.replaceSetTemplatesForExercise(re.id!, currentTemplates);
    }

    if (mounted && !isAddingExercise) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text(l10n.snackbarRoutineSaved)));
      Navigator.of(context).pop(true);
    }
    return true;
  }

  void _addSet(RoutineExercise routineExercise) {
    setState(() {
      final newSet = SetTemplate(
        id: DateTime.now().millisecondsSinceEpoch,
        setType: 'normal',
        targetReps: '8-12',
      );

      // --- START FIX ---
      final exerciseIndex = _routineExercises.indexOf(routineExercise);
      if (exerciseIndex == -1) return; // Safety check

      final updatedTemplates = [...routineExercise.setTemplates, newSet];
      final updatedExercise = RoutineExercise(
        id: routineExercise.id,
        exercise: routineExercise.exercise,
        setTemplates: updatedTemplates,
        pauseSeconds: routineExercise.pauseSeconds,
      );
      _routineExercises[exerciseIndex] = updatedExercise;
      // --- END FIX ---

      _repsControllers[newSet.id!] = TextEditingController(
        text: newSet.targetReps,
      );
      _weightControllers[newSet.id!] = TextEditingController();
    });
  }

  void _removeSet(
    RoutineExercise routineExercise,
    int setTemplateId,
    int index,
  ) {
    setState(() {
      // --- START FIX ---
      final exerciseIndex = _routineExercises.indexOf(routineExercise);
      if (exerciseIndex == -1) return;

      final updatedTemplates = [...routineExercise.setTemplates];
      updatedTemplates.removeAt(index);

      final updatedExercise = RoutineExercise(
        id: routineExercise.id,
        exercise: routineExercise.exercise,
        setTemplates: updatedTemplates,
        pauseSeconds: routineExercise.pauseSeconds,
      );
      _routineExercises[exerciseIndex] = updatedExercise;
      // --- END FIX ---

      _repsControllers.remove(setTemplateId)?.dispose();
      _weightControllers.remove(setTemplateId)?.dispose();
    });
  }

  void _changeSetType(SetTemplate setTemplate, String newType) {
    setState(() {
      final reIndex = _routineExercises.indexWhere(
        (re) => re.setTemplates.contains(setTemplate),
      );
      if (reIndex == -1) return;

      final routineExercise = _routineExercises[reIndex];
      final setIndex = routineExercise.setTemplates.indexOf(setTemplate);
      if (setIndex == -1) return;

      final updatedTemplates = [...routineExercise.setTemplates];
      updatedTemplates[setIndex] = setTemplate.copyWith(setType: newType);

      _routineExercises[reIndex] = RoutineExercise(
        id: routineExercise.id,
        exercise: routineExercise.exercise,
        setTemplates: updatedTemplates,
        pauseSeconds: routineExercise.pauseSeconds,
      );
    });
    // Navigator.pop(context); // ENTFERNT: GlassMenu schließt sich selbst
  }

  void _showSetTypePicker(SetTemplate setTemplate) {
    final l10n = AppLocalizations.of(context)!;

    Widget buildSymbol(String char, Color color) {
      return Text(
        char,
        style: TextStyle(
          color: color,
          fontSize: 20,
          fontWeight: FontWeight.bold,
        ),
      );
    }

    final options = [
      {
        'type': 'normal',
        'label': l10n.set_type_normal,
        'symbol': buildSymbol('N', Colors.grey)
      },
      {
        'type': 'warmup',
        'label': l10n.set_type_warmup,
        'symbol': buildSymbol('W', Colors.orange)
      },
      {
        'type': 'failure',
        'label': l10n.set_type_failure,
        'symbol': buildSymbol('F', Colors.red)
      },
      {
        'type': 'dropset',
        'label': l10n.set_type_dropset,
        'symbol': buildSymbol('D', Colors.blue)
      },
    ];

    showGlassBottomMenu(
      context: context,
      title: l10n.changeSetTypTitle,
      actions: options.map((opt) {
        return GlassMenuAction(
          customIcon: opt['symbol'] as Widget,
          label: opt['label'] as String,
          onTap: () => _changeSetType(setTemplate, opt['type'] as String),
        );
      }).toList(),
    );
  }

  // In lib/screens/edit_routine_screen.dart

  void _editPauseTime(RoutineExercise routineExercise) async {
    final l10n = AppLocalizations.of(context)!;
    final controller = TextEditingController(
      text: routineExercise.pauseSeconds?.toString() ?? '',
    );

    // KORREKTUR: showGlassBottomMenu statt showDialog
    final result = await showGlassBottomMenu<int?>(
      context: context,
      title: l10n.editPauseTimeTitle,
      contentBuilder: (ctx, close) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: controller,
              keyboardType: TextInputType.number,
              autofocus: true,
              decoration: InputDecoration(
                labelText: l10n.pauseInSeconds,
                hintText: "z.B. 90",
                suffixText: "s",
                filled: true,
                fillColor: Theme.of(context).brightness == Brightness.dark
                    ? Colors.white.withOpacity(0.05)
                    : Colors.black.withOpacity(0.05),
                border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                    borderSide: BorderSide.none),
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () {
                      close();
                      Navigator.of(ctx).pop(null);
                    },
                    child: Text(l10n.cancel),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton(
                    onPressed: () {
                      final seconds = int.tryParse(controller.text);
                      close();
                      Navigator.of(ctx).pop(seconds);
                    },
                    child: Text(l10n.save),
                  ),
                ),
              ],
            ),
          ],
        );
      },
    );

    if (result != null) {
      await WorkoutDatabaseHelper.instance.updatePauseTime(
        routineExercise.id!,
        result,
      );
      _loadExercisesForRoutine();
    }
  }

  // In lib/screens/edit_routine_screen.dart

  void _deleteSingleExercise(RoutineExercise exerciseToDelete) async {
    final l10n = AppLocalizations.of(context)!;
    // NEU: Helper
    final confirmed = await showDeleteConfirmation(
      context,
      title: l10n.deleteExerciseConfirmTitle,
      content: l10n.deleteExerciseConfirmContent(
        exerciseToDelete.exercise.getLocalizedName(context),
      ),
    );

    if (confirmed && _routineId != null) {
      await WorkoutDatabaseHelper.instance.removeExerciseFromRoutine(
        exerciseToDelete.id!,
      );
      _loadExercisesForRoutine();
    }
  }

  void _onReorder(int oldIndex, int newIndex) {
    setState(() {
      if (newIndex > oldIndex) {
        newIndex -= 1;
      }
      final RoutineExercise item = _routineExercises.removeAt(oldIndex);
      _routineExercises.insert(newIndex, item);
    });
    if (_routineId != null) {
      WorkoutDatabaseHelper.instance.updateExerciseOrder(
        _routineId!,
        _routineExercises,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      extendBodyBehindAppBar: true,
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: GlobalAppBar(
        title: _isNewRoutine ? l10n.titleNewRoutine : l10n.titleEditRoutine,
        actions: [
          TextButton(
            onPressed: () => _saveRoutine(),
            child: Text(
              l10n.save,
              style: TextStyle(
                color: Theme.of(context).colorScheme.primary,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      body: Column(
        children: [
          Padding(
            padding: DesignConstants.cardPadding.copyWith(
              top: DesignConstants.cardPadding.top + topPadding,
            ),
            child: TextFormField(
              controller: _nameController,
              decoration: InputDecoration(labelText: l10n.formFieldRoutineName),
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return l10n.validatorPleaseEnterRoutineName;
                }
                return null;
              },
            ),
          ),
          const SizedBox(height: DesignConstants.spacingM),
          Divider(
            height: 1,
            thickness: 1,
            color: colorScheme.onSurfaceVariant.withOpacity(0.1),
          ),
          Expanded(
            child: _isLoading
                ? const Center(child: CircularProgressIndicator())
                : _routineExercises.isEmpty
                    ? Center(
                        child: Text(
                          l10n.emptyStateAddFirstExercise,
                          style: textTheme.titleMedium,
                        ),
                      )
                    : ReorderableListView.builder(
                        padding: EdgeInsets.zero,
                        itemCount: _routineExercises.length,
                        proxyDecorator: (Widget child, int index,
                            Animation<double> animation) {
                          return Material(
                            elevation: 4.0,
                            color: Theme.of(context).scaffoldBackgroundColor,
                            child: child,
                          );
                        },
                        onReorder: _onReorder,
                        itemBuilder: (context, index) {
                          final routineExercise = _routineExercises[index];

                          return WorkoutCard(
                            key: ValueKey(routineExercise.id),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                ListTile(
                                  contentPadding: const EdgeInsets.symmetric(
                                    horizontal: 16.0,
                                    vertical: 8.0,
                                  ),
                                  title: InkWell(
                                    onTap: () => Navigator.of(context).push(
                                      MaterialPageRoute(
                                        builder: (context) =>
                                            ExerciseDetailScreen(
                                          exercise: routineExercise.exercise,
                                        ),
                                      ),
                                    ),
                                    child: Padding(
                                      padding: const EdgeInsets.symmetric(
                                        vertical: 4.0,
                                      ),
                                      child: Text(
                                        routineExercise.exercise
                                            .getLocalizedName(
                                          context,
                                        ),
                                        style: textTheme.titleLarge?.copyWith(
                                          fontWeight: FontWeight.bold,
                                        ),
                                      ),
                                    ),
                                  ),
                                  leading: ReorderableDragStartListener(
                                    index: index,
                                    child: const Icon(Icons.drag_handle),
                                  ),
                                  trailing: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      // HIER GEÄNDERT: Pause direkt neben Icon anzeigen
                                      if (routineExercise.pauseSeconds !=
                                              null &&
                                          routineExercise.pauseSeconds! > 0)
                                        Padding(
                                          padding: const EdgeInsets.only(
                                            right: 4.0,
                                          ),
                                          child: Text(
                                            "${routineExercise.pauseSeconds}s",
                                            style:
                                                textTheme.bodyMedium?.copyWith(
                                              color: colorScheme.primary,
                                              fontWeight: FontWeight.bold,
                                            ),
                                          ),
                                        ),
                                      IconButton(
                                        icon: const Icon(Icons.timer_outlined),
                                        tooltip: l10n.editPauseTime,
                                        onPressed: () =>
                                            _editPauseTime(routineExercise),
                                      ),
                                      IconButton(
                                        icon: const Icon(
                                          Icons.delete_outline,
                                          color: Colors.redAccent,
                                        ),
                                        tooltip: l10n.removeExercise,
                                        onPressed: () => _deleteSingleExercise(
                                            routineExercise),
                                      ),
                                    ],
                                  ),
                                ),
                                Padding(
                                  padding: const EdgeInsets.symmetric(
                                    horizontal: 0.0,
                                  ),
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      // ALTER ANZEIGE-BLOCK ENTFERNT
                                      Row(
                                        children: [
                                          _buildHeader(l10n.setLabel, flex: 2),
                                          const Spacer(flex: 3),
                                          _buildHeader(l10n.kgLabel, flex: 2),
                                          const SizedBox(width: 8),
                                          _buildHeader(l10n.repsLabel, flex: 2),
                                          const SizedBox(width: 48),
                                        ],
                                      ),
                                      ...routineExercise.setTemplates
                                          .asMap()
                                          .entries
                                          .map((entry) {
                                        final setIndex = entry.key;
                                        final setTemplate = entry.value;

                                        int workingSetIndex = 0;
                                        for (int i = 0; i <= setIndex; i++) {
                                          if (routineExercise
                                                  .setTemplates[i].setType !=
                                              'warmup') {
                                            workingSetIndex++;
                                          }
                                        }

                                        return _buildSetTemplateRow(
                                          workingSetIndex,
                                          setIndex,
                                          routineExercise,
                                          setTemplate,
                                          setIndex,
                                        );
                                      }),
                                      const SizedBox(
                                        height: DesignConstants.spacingS,
                                      ),
                                      Padding(
                                        padding: const EdgeInsets.symmetric(
                                          horizontal: 16.0,
                                        ),
                                        child: TextButton.icon(
                                          onPressed: () =>
                                              _addSet(routineExercise),
                                          icon: const Icon(Icons.add),
                                          label: Text(l10n.addSetButton),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            ),
                          );
                        },
                      ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 24.0, bottom: 8.0),
            child: WgerAttributionWidget(
              textStyle: textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
            ),
          ),
        ],
      ),
      floatingActionButton: GlassFab(
        label: l10n.fabAddExercise,
        onPressed: _addExercises,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  Widget _buildSetTemplateRow(
    int setIndex,
    int rowIndex,
    RoutineExercise re,
    SetTemplate template,
    int listIndex,
  ) {
    final l10n = AppLocalizations.of(context)!;
    final isLightMode = Theme.of(context).brightness == Brightness.light;
    final bool isColoredRow = rowIndex > 0 && rowIndex.isOdd;

    final Color rowColor;
    if (isColoredRow) {
      rowColor = isLightMode
          ? Colors.grey.withOpacity(0.08)
          : Colors.white.withOpacity(0.05);
    } else {
      rowColor = Colors.transparent;
    }

    return Container(
      color: rowColor,
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 4.0),
        child: Row(
          children: [
            Expanded(
              flex: 2,
              child: Center(
                child: SetTypeChip(
                  setType: template.setType,
                  setIndex: (template.setType == 'warmup') ? null : setIndex,
                  onTap: () => _showSetTypePicker(template),
                ),
              ),
            ),
            const Spacer(flex: 3),
            Expanded(
              flex: 2,
              child: TextFormField(
                controller: _weightControllers[template.id!],
                textAlign: TextAlign.center,
                keyboardType: const TextInputType.numberWithOptions(
                  decimal: true,
                ),
                decoration: InputDecoration(
                  border: InputBorder.none,
                  isDense: true,
                  fillColor: Colors.transparent,
                  hintText: l10n.kgLabelShort,
                ),
                validator: (value) {
                  if (value != null &&
                      value.isNotEmpty &&
                      double.tryParse(value.replaceAll(',', '.')) == null) {
                    return "!";
                  }
                  return null;
                },
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              flex: 2,
              child: TextFormField(
                controller: _repsControllers[template.id!],
                textAlign: TextAlign.center,
                keyboardType: TextInputType.number,
                decoration: InputDecoration(
                  border: InputBorder.none,
                  isDense: true,
                  fillColor: Colors.transparent,
                  hintText: l10n.set_reps_hint,
                ),
                validator: (value) {
                  if (value != null &&
                      value.isNotEmpty &&
                      int.tryParse(value) == null) {
                    return "!";
                  }
                  return null;
                },
              ),
            ),
            Padding(
              padding: const EdgeInsets.only(right: 8.0),
              child: SizedBox(
                width: 48,
                child: IconButton(
                  icon: const Icon(
                    Icons.delete_outline,
                    color: Colors.redAccent,
                  ),
                  onPressed: () => _removeSet(re, template.id!, listIndex),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildHeader(String text, {required int flex}) => Expanded(
        flex: flex,
        child: Text(
          text,
          textAlign: TextAlign.center,
          style: TextStyle(
            color: Colors.grey[600],
            fontSize: 12,
            fontWeight: FontWeight.bold,
          ),
        ),
      );
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/data_management_screen.dart =====

// lib/screens/data_management_screen.dart (Final & Vollständig)

import 'package:flutter/material.dart';
import 'package:file_picker/file_picker.dart';
import 'package:lightweight/data/backup_manager.dart';
import 'package:lightweight/data/import_manager.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/exercise_mapping_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/global_app_bar.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:shared_preferences/shared_preferences.dart'; // NEU
import 'package:flutter/services.dart'; // NEU (Clipboard)
import 'package:lightweight/widgets/glass_bottom_menu.dart';

class DataManagementScreen extends StatefulWidget {
  const DataManagementScreen({super.key});

  @override
  State<DataManagementScreen> createState() => _DataManagementScreenState();
}

class _DataManagementScreenState extends State<DataManagementScreen> {
  // Lade-Zustände für die verschiedenen Aktionen
  bool _isFullBackupRunning = false;
  bool _isCsvExportRunning = false;
  bool _isMigrationRunning = false;
  String? _autoBackupDir; // NEU
  @override
  void initState() {
    super.initState();
    _loadAutoBackupDir(); // NEU
  }

  Future<void> _loadAutoBackupDir() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _autoBackupDir = prefs.getString('auto_backup_dir');
    });
  }

  // --- UNVERÄNDERT: Logik für Komplett-Backup ---
  void _performFullExport() async {
    setState(() => _isFullBackupRunning = true);
    final success = await BackupManager().exportFullBackup();
    if (!mounted) return;
    setState(() => _isFullBackupRunning = false);

    final l10n = AppLocalizations.of(context)!;
    if (success) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text(l10n.snackbarExportSuccess)));
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(l10n.snackbarExportFailed),
          backgroundColor: Colors.orange,
        ),
      );
    }
  }

  void _performFullImport() async {
    final result = await FilePicker.platform.pickFiles(
      type: FileType.custom,
      allowedExtensions: ['json'],
    );
    if (result == null || result.files.single.path == null) return;

    final filePath = result.files.single.path!;
    final l10n = AppLocalizations.of(context)!;
    final confirmed = await showDeleteConfirmation(
      context,
      title: l10n.dialogConfirmTitle,
      content: l10n.dialogConfirmImportContent,
      confirmLabel:
          l10n.dialogButtonOverwrite, // Roter Button passt hier gut (Warnung)
    );

    if (confirmed == true) {
      setState(() => _isFullBackupRunning = true);
      bool success = await BackupManager().importFullBackupAuto(filePath);
      if (!success) {
        // Datei könnte verschlüsselt sein – Passwort abfragen (leer = “kein Passwort” versuchen)
        final pw = await _askPassword(title: l10n.dialogEnterPasswordImport);
        if (pw != null) {
          // <-- wichtig: leer zulassen
          success = await BackupManager().importFullBackupAuto(
            filePath,
            passphrase: pw,
          );
        }
      }

      if (!mounted) return;
      setState(() => _isFullBackupRunning = false); // nur einmal

      if (success) {
        // Neu: Unbekannte Übungsnamen ermitteln und ggf. Mapping anbieten
        final unknown =
            await WorkoutDatabaseHelper.instance.findUnknownExerciseNames();
        if (mounted && unknown.isNotEmpty) {
          final bool? changed = await Navigator.of(context).push<bool>(
            MaterialPageRoute(
              builder: (_) => ExerciseMappingScreen(unknownNames: unknown),
            ),
          );
          // Optional: Nach Anwendung erneut prüfen/refreshen, aber keine Pflicht.
        }

        await showDialog(
          context: context,
          barrierDismissible: false,
          builder: (context) => AlertDialog(
            title: Text(l10n.snackbarImportSuccessTitle),
            content: Text(l10n.snackbarImportSuccessContent),
            actions: [
              FilledButton(
                onPressed: () => Navigator.of(context).pop(),
                child: Text(l10n.snackbarButtonOK),
              ),
            ],
          ),
        );
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(l10n.snackbarImportError),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  // --- UNVERÄNDERT: Logik für Hevy-Import ---
  void _performHevyImport() async {
    setState(() => _isMigrationRunning = true);
    final count = await ImportManager().importHevyCsv();
    if (!mounted) return;
    setState(() => _isMigrationRunning = false);

    if (count > 0) {
      final unknown =
          await WorkoutDatabaseHelper.instance.findUnknownExerciseNames();
      if (mounted && unknown.isNotEmpty) {
        await Navigator.of(context).push(
          MaterialPageRoute(
            builder: (_) => ExerciseMappingScreen(unknownNames: unknown),
          ),
        );
      }
    }
    final l10n = AppLocalizations.of(context)!;
    if (count > 0) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text(l10n.hevyImportSuccess(count))));
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(l10n.hevyImportFailed),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  // --- NEU: Helfer-Methode für alle CSV-Exporte ---
  void _exportCsv(
    Future<bool> Function() exportFunction,
    String successMessage,
    String failureMessage,
  ) async {
    setState(() => _isCsvExportRunning = true);
    final success = await exportFunction();
    if (!mounted) return;
    setState(() => _isCsvExportRunning = false);

    if (success) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text(successMessage)));
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(failureMessage), backgroundColor: Colors.orange),
      );
    }
  }
// lib/screens/data_management_screen.dart

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    // Diese Berechnung ist korrekt.
    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: GlobalAppBar(
        // l10n.dataHubTitle wäre hier ideal, aber "Data Hub" ist auch ok
        title: l10n.dataHubTitle,
      ),
      // Das SafeArea-Widget wurde hier entfernt. Der Body ist jetzt direkt der SingleChildScrollView.
      body: SingleChildScrollView(
        // Ihre Padding-Logik ist korrekt und wird beibehalten.
        padding: DesignConstants.cardPadding.copyWith(
          top: DesignConstants.cardPadding.top + topPadding,
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // --- Ihr gesamter Inhalt bleibt hier unverändert ---
            _buildFullBackupCard(context, l10n, theme),
            const SizedBox(height: DesignConstants.spacingL),
            _buildAutoBackupCard(context, l10n, theme),
            const SizedBox(height: DesignConstants.spacingL),
            _buildCsvExportCard(context, l10n, theme),
            const SizedBox(height: DesignConstants.spacingL),
            _buildMigrationCard(context, l10n, theme),
            const SizedBox(height: DesignConstants.spacingL),
            _buildExerciseMappingCard(context, l10n, theme),
          ],
        ),
      ),
    );
  }
  // --- WIDGET BUILDER ---

  Widget _buildFullBackupCard(
    BuildContext context,
    AppLocalizations l10n,
    ThemeData theme,
  ) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              l10n.dataManagementBackupTitle,
              style: theme.textTheme.headlineSmall,
            ),
            const SizedBox(height: DesignConstants.spacingS),
            Text(
              l10n.dataManagementBackupDescription,
              style: theme.textTheme.bodyMedium,
            ),
            const SizedBox(height: DesignConstants.spacingL),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    icon: const Icon(Icons.upload_file),
                    label: Text(l10n.data_export_button),
                    onPressed: _isFullBackupRunning ? null : _performFullExport,
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton.icon(
                    icon: const Icon(Icons.download_for_offline),
                    label: Text(l10n.data_import_button),
                    style: FilledButton.styleFrom(
                      backgroundColor: theme.colorScheme.error,
                    ),
                    onPressed: _isFullBackupRunning ? null : _performFullImport,
                  ),
                ),
              ],
            ),
            const SizedBox(height: DesignConstants.spacingS),
            // NEU: Verschlüsselt exportieren
            SizedBox(
              width: double.infinity,
              child: OutlinedButton.icon(
                icon: const Icon(Icons.lock_outline),
                label: Text(l10n.exportEncrypted),
                onPressed: _isFullBackupRunning
                    ? null
                    : () async {
                        final pw = await _askPassword(
                          title: l10n.dialogPasswordForExport,
                        );
                        if (pw == null || pw.isEmpty) return;
                        setState(() => _isFullBackupRunning = true);
                        final ok =
                            await BackupManager().exportFullBackupEncrypted(pw);
                        if (!mounted) return;
                        setState(() => _isFullBackupRunning = false);
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text(
                              ok
                                  ? l10n.snackbarEncryptedBackupShared
                                  : l10n.exportFailed,
                            ),
                          ),
                        );
                      },
              ),
            ),

            if (_isFullBackupRunning)
              const Padding(
                padding: EdgeInsets.only(top: 16.0),
                child: Center(child: CircularProgressIndicator()),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildCsvExportCard(
    BuildContext context,
    AppLocalizations l10n,
    ThemeData theme,
  ) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.csvExportTitle, style: theme.textTheme.headlineSmall),
            const SizedBox(height: DesignConstants.spacingS),
            Text(l10n.csvExportDescription, style: theme.textTheme.bodyMedium),
            const SizedBox(height: DesignConstants.spacingS),
            _buildExportTile(
              icon: Icons.restaurant_menu,
              title: l10n.nutritionDiary,
              onTap: _isCsvExportRunning
                  ? null
                  : () => _exportCsv(
                        BackupManager().exportNutritionAsCsv,
                        l10n.snackbarSharingNutrition,
                        l10n.snackbarExportFailedNoEntries,
                      ),
            ),
            _buildExportTile(
              icon: Icons.monitor_weight_outlined,
              title: l10n.drawerMeasurements,
              onTap: _isCsvExportRunning
                  ? null
                  : () => _exportCsv(
                        BackupManager().exportMeasurementsAsCsv,
                        l10n.snackbarSharingMeasurements,
                        l10n.snackbarExportFailedNoEntries,
                      ),
            ),
            _buildExportTile(
              icon: Icons.fitness_center,
              title: l10n.workoutHistoryTitle,
              onTap: _isCsvExportRunning
                  ? null
                  : () => _exportCsv(
                        BackupManager().exportWorkoutsAsCsv,
                        l10n.snackbarSharingWorkouts,
                        l10n.snackbarExportFailedNoEntries,
                      ),
            ),
            if (_isCsvExportRunning)
              const Padding(
                padding: EdgeInsets.only(top: 16.0),
                child: Center(child: CircularProgressIndicator()),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildMigrationCard(
    BuildContext context,
    AppLocalizations l10n,
    ThemeData theme,
  ) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.hevyImportTitle, style: theme.textTheme.headlineSmall),
            const SizedBox(height: DesignConstants.spacingS),
            Text(l10n.hevyImportDescription, style: theme.textTheme.bodyMedium),
            const SizedBox(height: DesignConstants.spacingL),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                icon: const Icon(Icons.sync_alt),
                label: Text(l10n.hevyImportButton),
                onPressed: _isMigrationRunning ? null : _performHevyImport,
              ),
            ),
            if (_isMigrationRunning)
              const Padding(
                padding: EdgeInsets.only(top: 16.0),
                child: Center(child: CircularProgressIndicator()),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildExportTile({
    required IconData icon,
    required String title,
    required VoidCallback? onTap,
  }) {
    return ListTile(
      leading: Icon(icon),
      title: Text(title),
      trailing: const Icon(Icons.chevron_right),
      onTap: onTap,
      contentPadding: EdgeInsets.zero,
    );
  }

  Widget _buildExerciseMappingCard(
    BuildContext context,
    AppLocalizations l10n,
    ThemeData theme,
  ) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.mapExercisesTitle, style: theme.textTheme.headlineSmall),
            const SizedBox(height: DesignConstants.spacingS),
            Text(
              l10n.mapExercisesDescription,
              style: theme.textTheme.bodyMedium,
            ),
            const SizedBox(height: DesignConstants.spacingL),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                icon: const Icon(Icons.rule_folder_outlined),
                label: Text(l10n.mapExercisesButton),
                onPressed: _openExerciseMapping,
              ),
            ),
          ],
        ),
      ),
    );
  }

  // lib/screens/data_management_screen.dart – Auszug: neue Card
  Widget _buildAutoBackupCard(
    BuildContext context,
    AppLocalizations l10n,
    ThemeData theme,
  ) {
    return SummaryCard(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.autoBackupTitle, style: theme.textTheme.headlineSmall),
            const SizedBox(height: DesignConstants.spacingS),
            Text(l10n.autoBackupDescription, style: theme.textTheme.bodyMedium),
            const SizedBox(height: DesignConstants.spacingS),
            SelectableText(
              _autoBackupDir ?? l10n.autoBackupDefaultFolder,
              style: theme.textTheme.bodySmall,
            ),
            const SizedBox(height: DesignConstants.spacingM),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    icon: const Icon(Icons.folder_open),
                    label: Text(l10n.autoBackupChooseFolder),
                    onPressed: _pickAutoBackupDirectory,
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: OutlinedButton.icon(
                    icon: const Icon(Icons.copy),
                    label: Text(l10n.autoBackupCopyPath),
                    onPressed:
                        (_autoBackupDir == null || _autoBackupDir!.isEmpty)
                            ? null
                            : _copyAutoBackupPathToClipboard,
                  ),
                ),
              ],
            ),
            const SizedBox(height: DesignConstants.spacingM),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                icon: const Icon(Icons.backup),
                label: Text(l10n.autoBackupRunNow),
                onPressed: () async {
                  final ok = await BackupManager().runAutoBackupIfDue(
                    interval: const Duration(days: 1),
                    encrypted: false,
                    passphrase: null,
                    retention: 7,
                    dirPath: _autoBackupDir,
                    force: true, // NEU: sofort ausführen
                  );
                  if (!mounted) return;
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text(
                        ok
                            ? l10n.snackbarAutoBackupSuccess
                            : l10n.snackbarAutoBackupFailed,
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _openExerciseMapping() async {
    final unknown =
        await WorkoutDatabaseHelper.instance.findUnknownExerciseNames();
    final l10n = AppLocalizations.of(context)!;
    if (!mounted) return;
    if (unknown.isEmpty) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text(l10n.noUnknownExercisesFound)));
      return;
    }
    await Navigator.of(context).push(
      MaterialPageRoute(
        builder: (_) => ExerciseMappingScreen(unknownNames: unknown),
      ),
    );
  }

  Future<void> _pickAutoBackupDirectory() async {
    // Directory-Picker (FilePicker unterstützt getDirectoryPath)
    final l10n = AppLocalizations.of(context)!;
    final path = await FilePicker.platform.getDirectoryPath();
    if (path == null) return;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('auto_backup_dir', path);
    setState(() => _autoBackupDir = path);
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(l10n.snackbarAutoBackupFolderSet(path))),
    );
  }

  Future<void> _copyAutoBackupPathToClipboard() async {
    final path = _autoBackupDir;
    final l10n = AppLocalizations.of(context)!;
    if (path == null || path.isEmpty) return;
    await Clipboard.setData(ClipboardData(text: path));
    if (!mounted) return;
    ScaffoldMessenger.of(
      context,
    ).showSnackBar(SnackBar(content: Text(l10n.snackbarPathCopied)));
  }

  Future<String?> _askPassword({required String title}) async {
    final controller = TextEditingController();
    bool obscure = true;
    final l10n = AppLocalizations.of(context)!;

    return showGlassBottomMenu<String?>(
      context: context,
      title: title,
      contentBuilder: (ctx, close) {
        return StatefulBuilder(
          builder: (ctx, setState) {
            return Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                TextField(
                  controller: controller,
                  obscureText: obscure,
                  decoration: InputDecoration(
                    labelText: l10n.passwordLabel,
                    suffixIcon: IconButton(
                      icon: Icon(
                        obscure ? Icons.visibility_off : Icons.visibility,
                      ),
                      onPressed: () => setState(() => obscure = !obscure),
                    ),
                  ),
                ),
                const SizedBox(height: 16),
                Row(
                  children: [
                    Expanded(
                      child: OutlinedButton(
                        onPressed: () {
                          close();
                          Navigator.of(ctx).pop(null);
                        },
                        child: Text(l10n.dialogButtonCancel),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: FilledButton(
                        onPressed: () {
                          final value = controller.text.trim();
                          close();
                          Navigator.of(ctx).pop(value);
                        },
                        child: Text(l10n.snackbarButtonOK),
                      ),
                    ),
                  ],
                ),
              ],
            );
          },
        );
      },
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/profile_screen.dart =====

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/goals_screen.dart';
import 'package:lightweight/screens/onboarding_screen.dart';
import 'package:lightweight/screens/settings_screen.dart';
import 'package:lightweight/services/profile_service.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/bottom_content_spacer.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:provider/provider.dart';
import 'package:lightweight/widgets/global_app_bar.dart';

class ProfileScreen extends StatefulWidget {
  const ProfileScreen({super.key});

  @override
  State<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends State<ProfileScreen> {
  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final profileService = Provider.of<ProfileService>(context);
    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: GlobalAppBar(
        title: l10n.profileScreenTitle,
      ),
      body: ListView(
        padding: DesignConstants.cardPadding.copyWith(
          top: DesignConstants.cardPadding.top + topPadding,
        ),
        children: [
          // Profilbild-Sektion
          //_buildSectionTitle(l10n.profile_capslock),
          SummaryCard(
            child: Padding(
              padding: DesignConstants.cardPadding,
              child: Column(
                children: [
                  GestureDetector(
                    onTap: () async {
                      await profileService.pickAndSaveProfileImage();
                    },
                    child: CircleAvatar(
                      key: ValueKey(
                        '${profileService.profileImagePath ?? ''}${profileService.cacheBuster}',
                      ),
                      radius: 50,
                      backgroundColor: Theme.of(
                        context,
                      ).colorScheme.primary.withOpacity(0.1),
                      backgroundImage: profileService.profileImagePath != null
                          ? FileImage(File(profileService.profileImagePath!))
                          : null,
                      child: profileService.profileImagePath == null
                          ? Icon(
                              Icons.camera_alt,
                              size: 50,
                              color: Theme.of(context).colorScheme.primary,
                            )
                          : null,
                    ),
                  ),
                  if (profileService.profileImagePath != null)
                    TextButton(
                      onPressed: () async {
                        await profileService.deleteProfileImage();
                      },
                      child: Text(l10n.delete_profile_picture_button),
                    ),
                ],
              ),
            ),
          ),
          //const SizedBox(height: DesignConstants.spacingM),

          // Sektion für Navigation
          // HINWEIS: Der redundante Titel "EINSTELLUNGEN" wurde entfernt.
          _buildNavigationCard(
            icon: Icons.settings_outlined,
            title: l10n.settingsTitle,
            subtitle:
                "Theme, units, data and more", // TODO: Localize this subtitle
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(builder: (context) => const SettingsScreen()),
              );
            },
          ),
          //const SizedBox(height: DesignConstants.spacingM),
          _buildNavigationCard(
            icon: Icons.flag_outlined,
            title: l10n.my_goals,
            subtitle: l10n.my_goals_description,
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(builder: (context) => const GoalsScreen()),
              );
            },
          ),
          //const SizedBox(height: DesignConstants.spacingM),
          _buildOnboardingCard(l10n),
          const BottomContentSpacer(),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildNavigationCard({
    required IconData icon,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
  }) {
    return SummaryCard(
      child: ListTile(
        contentPadding: const EdgeInsets.symmetric(
          vertical: 8.0,
          horizontal: 16.0,
        ),
        leading: Icon(
          icon,
          size: 36,
          color: Theme.of(context).colorScheme.primary,
        ),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Text(subtitle),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(24.0),
        ),
      ),
    );
  }

  Widget _buildOnboardingCard(AppLocalizations l10n) {
    // KORREKTUR: 'theme' wird direkt hier aus dem context geholt.
    final theme = Theme.of(context);

    return SummaryCard(
      child: ListTile(
        leading: Icon(Icons.school_outlined, color: theme.colorScheme.primary),
        title: Text(
          l10n.onbShowTutorialAgain,
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.w700,
          ),
        ),
        subtitle: Text(l10n.onbFinishBody, style: theme.textTheme.bodyMedium),
        trailing: const Icon(Icons.chevron_right),
        onTap: () {
          Navigator.of(
            context,
          ).push(MaterialPageRoute(builder: (_) => const OnboardingScreen()));
        },
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 16,
          vertical: 12,
        ),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/supplement_track_screen.dart =====

// lib/screens/supplement_track_screen.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/dialogs/log_supplement_menu.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';
import 'package:lightweight/models/tracked_supplement.dart';
import 'package:lightweight/screens/create_supplement_screen.dart';
import 'package:lightweight/screens/manage_supplements_screen.dart';
import 'package:lightweight/util/date_util.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/util/supplement_l10n.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/global_app_bar.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';

class SupplementTrackScreen extends StatefulWidget {
  final DateTime? initialDate; // NEU: Optionales Startdatum

  const SupplementTrackScreen({super.key, this.initialDate});

  @override
  State<SupplementTrackScreen> createState() => _SupplementTrackScreenState();
}

class _SupplementTrackScreenState extends State<SupplementTrackScreen> {
  bool _isLoading = true;
  late DateTime _selectedDate; // Spät initialisiert

  final Map<int, Supplement> _supplementsById = {};
  List<TrackedSupplement> _tracked = const [];
  List<SupplementLog> _todaysLogs = const [];

  @override
  void initState() {
    super.initState();
    // Fix #65: Starte mit dem übergebenen Datum oder Heute
    _selectedDate = widget.initialDate ?? DateTime.now();
    _loadData(_selectedDate);
  }

  Future<void> _loadData(DateTime day) async {
    setState(() => _isLoading = true);
    final db = DatabaseHelper.instance;

    final supplements = await db.getAllSupplements();
    final logs = await db.getSupplementLogsForDate(day);

    final byId = <int, Supplement>{
      for (final s in supplements)
        if (s.id != null) s.id!: s,
    };

    final doses = <int, double>{};
    for (final log in logs) {
      doses.update(
        log.supplementId,
        (v) => v + log.dose,
        ifAbsent: () => log.dose,
      );
    }

    final tracked = supplements
        .map(
          (s) => TrackedSupplement(
            supplement: s,
            totalDosedToday: doses[s.id] ?? 0.0,
          ),
        )
        .toList();

    if (!mounted) return;
    setState(() {
      _supplementsById
        ..clear()
        ..addAll(byId);
      _tracked = tracked;
      _todaysLogs = logs;
      _isLoading = false;
    });
  }

  void _navigateDay(bool forward) {
    final newDay = _selectedDate.add(Duration(days: forward ? 1 : -1));
    if (forward && newDay.isAfter(DateTime.now())) return;
    setState(() => _selectedDate = newDay);
    _loadData(_selectedDate);
  }

  Future<void> _pickDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (picked != null && picked != _selectedDate) {
      setState(() => _selectedDate = picked);
      _loadData(_selectedDate);
    }
  }

  Future<void> _logSupplement(Supplement supplement) async {
    final l10n = AppLocalizations.of(context)!;

    final result = await showGlassBottomMenu<(double, DateTime)?>(
      context: context,
      title: localizeSupplementName(supplement, l10n),
      contentBuilder: (ctx, close) {
        return LogSupplementDoseBody(
          supplement: supplement,
          primaryLabel: l10n.add_button,
          initialTimestamp: _selectedDate, // Fix #66: Datum übergeben
          onCancel: close,
          onSubmit: (dose, ts) {
            close();
            Navigator.of(ctx).pop((dose, ts));
          },
        );
      },
    );

    if (result == null) return;

    final log = SupplementLog(
      supplementId: supplement.id!,
      dose: result.$1,
      unit: supplement.unit,
      timestamp: result.$2,
    );
    await DatabaseHelper.instance.insertSupplementLog(log);
    _loadData(_selectedDate);
  }

  // In lib/screens/supplement_track_screen.dart

  Future<void> _editLogEntry(SupplementLog log) async {
    final l10n = AppLocalizations.of(context)!;
    final supplement = _supplementsById[log.supplementId]!;

    // KORREKTUR: showGlassBottomMenu statt showDialog
    // Wir nutzen den wiederverwendbaren LogSupplementDoseBody
    final result = await showGlassBottomMenu<(double, DateTime)?>(
      context: context,
      title: localizeSupplementName(supplement, l10n),
      contentBuilder: (ctx, close) {
        return LogSupplementDoseBody(
          supplement: supplement,
          initialDose: log.dose,
          initialTimestamp: log.timestamp,
          primaryLabel: l10n.save,
          onCancel: close,
          onSubmit: (dose, ts) {
            close();
            Navigator.of(ctx).pop((dose, ts));
          },
        );
      },
    );

    if (result == null) return;

    final updated = SupplementLog(
      id: log.id,
      supplementId: supplement.id!,
      dose: result.$1,
      unit: supplement.unit,
      timestamp: result.$2,
    );
    await DatabaseHelper.instance.updateSupplementLog(updated);
    _loadData(_selectedDate);
  }

  Future<void> _deleteLogEntry(int id) async {
    final deleted = _todaysLogs.firstWhere((l) => l.id == id);

    await DatabaseHelper.instance.deleteSupplementLog(id);
    await _loadData(_selectedDate);

    final l10n = AppLocalizations.of(context)!;
    if (!mounted) return;

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(l10n.deleted),
        action: SnackBarAction(
          label: l10n.undo,
          onPressed: () async {
            final restored = SupplementLog(
              supplementId: deleted.supplementId,
              dose: deleted.dose,
              unit: deleted.unit,
              timestamp: deleted.timestamp,
            );
            await DatabaseHelper.instance.insertSupplementLog(restored);
            _loadData(_selectedDate);
          },
        ),
      ),
    );
  }

  Widget _sectionTitle(String title) => Padding(
        padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
        child: Text(
          title,
          style: Theme.of(context).textTheme.labelLarge?.copyWith(
                color: Colors.grey[600],
                fontWeight: FontWeight.bold,
              ),
        ),
      );

  Widget _progressCard(TrackedSupplement ts) {
    final s = ts.supplement;
    final isLimit = s.dailyLimit != null;
    final target = (isLimit ? s.dailyLimit : s.dailyGoal) ?? 0.0;
    final overTarget = isLimit && ts.totalDosedToday > target;
    final hasTarget = target > 0;
    final progress =
        hasTarget ? (ts.totalDosedToday / target).clamp(0.0, 1.0) : 0.0;
    final color = overTarget ? Colors.red.shade400 : Colors.green.shade400;
    final l10n = AppLocalizations.of(context)!;

    return Container(
      height: 60,
      margin: const EdgeInsets.symmetric(vertical: 6.0),
      decoration: BoxDecoration(
        color: Theme.of(
          context,
        ).colorScheme.surfaceContainerHighest.withOpacity(0.3),
        borderRadius: BorderRadius.circular(20),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(20),
        child: Stack(
          fit: StackFit.expand,
          children: [
            Align(
              alignment: Alignment.centerLeft,
              child: FractionallySizedBox(
                widthFactor: progress,
                child: Container(color: color),
              ),
            ),
            Padding(
              padding: const EdgeInsets.symmetric(
                horizontal: 12.0,
                vertical: 4.0,
              ),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  FittedBox(
                    fit: BoxFit.scaleDown,
                    child: Text(
                      localizeSupplementName(s, l10n),
                      maxLines: 1,
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    hasTarget
                        ? '${ts.totalDosedToday.toStringAsFixed(1)} / ${target.toStringAsFixed(1)} ${s.unit}'
                        : '${ts.totalDosedToday.toStringAsFixed(1)} ${s.unit}',
                    style: TextStyle(
                      color: Theme.of(
                        context,
                      ).colorScheme.onSurface.withOpacity(0.8),
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _logActionTile(Supplement s) {
    final l10n = AppLocalizations.of(context)!;
    return SummaryCard(
      child: ListTile(
        leading: const Icon(Icons.add_circle_outline),
        title: Text(localizeSupplementName(s, l10n)),
        onTap: () => _logSupplement(s),
      ),
    );
  }

  Widget _logEntryTile(SupplementLog log, AppLocalizations l10n) {
    final s = _supplementsById[log.supplementId];
    final titleText = (s == null) ? 'Unknown' : localizeSupplementName(s, l10n);

    return Dismissible(
      key: Key('log_${log.id}'),
      direction: DismissDirection.horizontal,
      background: const SwipeActionBackground(
        color: Colors.blueAccent,
        icon: Icons.edit,
        alignment: Alignment.centerLeft,
      ),
      secondaryBackground: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      confirmDismiss: (direction) async {
        if (direction == DismissDirection.startToEnd) {
          _editLogEntry(log);
          return false;
        }
        // KORREKTUR: Neuer Glas-Dialog statt AlertDialog
        return await showDeleteConfirmation(context);
      },
      onDismissed: (direction) {
        if (direction == DismissDirection.endToStart) _deleteLogEntry(log.id!);
      },
      child: SummaryCard(
        child: ListTile(
          leading: const Icon(Icons.check_circle, color: Colors.grey),
          title: Text(titleText),
          subtitle: Text(DateFormat.Hm().format(log.timestamp)),
          trailing: Text('${log.dose.toStringAsFixed(1)} ${log.unit}'),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).toString();

    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: GlobalAppBar(
        title: l10n.supplementTrackerTitle,
        actions: [
          IconButton(
            tooltip: l10n.manageSupplementsTitle,
            icon: const Icon(Icons.tune),
            onPressed: () async {
              final changed = await Navigator.of(context).push<bool>(
                MaterialPageRoute(
                  builder: (_) => const ManageSupplementsScreen(),
                ),
              );
              if (changed == true) _loadData(_selectedDate);
            },
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : RefreshIndicator(
              onRefresh: () => _loadData(_selectedDate),
              child: ListView(
                padding: DesignConstants.cardPadding.copyWith(
                  top: DesignConstants.cardPadding.top + topPadding,
                ),
                children: [
                  // Date header
                  Padding(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 16.0,
                      vertical: 8.0,
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        IconButton(
                          icon: const Icon(Icons.chevron_left),
                          onPressed: () => _navigateDay(false),
                        ),
                        Expanded(
                          child: InkWell(
                            onTap: _pickDate,
                            child: Text(
                              DateFormat.yMMMMd(locale).format(_selectedDate),
                              textAlign: TextAlign.center,
                              overflow: TextOverflow.ellipsis,
                              style: Theme.of(context)
                                  .textTheme
                                  .titleMedium
                                  ?.copyWith(fontWeight: FontWeight.bold),
                            ),
                          ),
                        ),
                        IconButton(
                          icon: const Icon(Icons.chevron_right),
                          onPressed: _selectedDate.isSameDate(DateTime.now())
                              ? null
                              : () => _navigateDay(true),
                        ),
                      ],
                    ),
                  ),
                  Divider(
                    height: 1,
                    thickness: 1,
                    color: Theme.of(
                      context,
                    ).colorScheme.onSurfaceVariant.withOpacity(0.1),
                  ),
                  const SizedBox(height: DesignConstants.spacingL),

                  // Progress section
                  _sectionTitle(l10n.dailyProgressTitle),
                  if (_tracked
                      .where(
                        (t) =>
                            t.supplement.dailyGoal != null ||
                            t.supplement.dailyLimit != null,
                      )
                      .isEmpty)
                    Padding(
                      padding: const EdgeInsets.symmetric(vertical: 8.0),
                      child: Text(
                        l10n.emptySupplementGoals,
                        textAlign: TextAlign.center,
                      ),
                    ),
                  ..._tracked
                      .where(
                        (t) =>
                            t.supplement.dailyGoal != null ||
                            t.supplement.dailyLimit != null,
                      )
                      .map(_progressCard),

                  const SizedBox(height: DesignConstants.spacingXL),

                  // Log intake
                  _sectionTitle(l10n.logIntakeTitle),
                  ..._tracked.map((t) => _logActionTile(t.supplement)),

                  const SizedBox(height: DesignConstants.spacingXL),

                  // Today's logs
                  _sectionTitle(l10n.todaysLogTitle),
                  if (_todaysLogs.isEmpty)
                    Padding(
                      padding: const EdgeInsets.symmetric(vertical: 8.0),
                      child: Text(
                        l10n.emptySupplementLogs,
                        textAlign: TextAlign.center,
                      ),
                    )
                  else
                    ..._todaysLogs.map((log) => _logEntryTile(log, l10n)),
                ],
              ),
            ),
      floatingActionButton: GlassFab(
        label: l10n.createSupplementTitle,
        onPressed: () async {
          final created = await Navigator.of(context).push<bool>(
            MaterialPageRoute(
              builder: (context) => const CreateSupplementScreen(),
            ),
          );
          if (created == true) {
            _loadData(_selectedDate);
          }
        },
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/onboarding_screen.dart =====

// lib/screens/onboarding_screen.dart
// VOLLSTÄNDIGE DATEI (LOKALISIERT)

import 'package:flutter/material.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/main_screen.dart';
import 'package:lightweight/screens/goals_screen.dart';
import 'package:lightweight/theme/color_constants.dart';

class OnboardingScreen extends StatefulWidget {
  const OnboardingScreen({super.key});
  @override
  State<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenState extends State<OnboardingScreen> {
  final PageController _page = PageController();
  int _index = 0;

  Future<void> _finish() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool('hasSeenOnboarding', true);
    if (!mounted) return;
    // Zurück ins Haupt-UI
    Navigator.of(context).pushAndRemoveUntil(
      MaterialPageRoute(builder: (_) => const MainScreen()),
      (r) => false,
    );
  }

  void _next(int lastIndex) {
    if (_index < lastIndex) {
      _page.animateToPage(
        _index + 1,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    } else {
      _finish();
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    // Wir erstellen die Liste der Folien
    final pages = <Widget>[
      // 1) Welcome/Goals
      _WelcomeSlide(
        title: l10n.appTitle,
        subtitle: l10n.onbSubtitleWelcome,
        body: l10n.onbBodyWelcome,
        primaryCta: _Cta(
          icon: Icons.edit_outlined,
          label: l10n.onbSetGoalsCta,
          onTap: () async {
            await Navigator.of(
              context,
            ).push(MaterialPageRoute(builder: (_) => const GoalsScreen()));
          },
        ),
      ),

      // 2) Nutrition: Visueller Fokus auf Today-Summary
      _VisualSlide(
        title: l10n.nutrition,
        body: l10n.onbBodyNutritionVisual,
        visual: _NutritionDiaryVisual(l10n: l10n),
      ),

      // 3) Measurements: Visueller Fokus auf Chart
      _VisualSlide(
        title: l10n.drawerMeasurements,
        body: l10n.onbBodyMeasurementsVisual,
        visual: _MeasurementChartVisual(l10n: l10n),
      ),

      // 4) Training: Visueller Fokus auf Workout History
      _VisualSlide(
        title: l10n.workout,
        body: l10n.onbBodyWorkoutVisual,
        visual: _WorkoutHistoryVisual(l10n: l10n),
      ),

      // 5) App-Bauplan: Bottom Bar und FAB
      _AppLayoutSlide(
        title: l10n.onbTitleAppLayout,
        body: l10n.onbBodyAppLayout,
      ),

      // 6) Privacy bleibt
      _TextSlide(
        icon: Icons.lock_outline,
        title: l10n.onbPrivacyTitle,
        body: l10n.onbPrivacyBody,
      ),

      // 7) Finish bleibt
      _FinalSlide(
        title: l10n.onbFinishTitle,
        body: l10n.onbFinishBody,
        onFinish: _finish,
      ),
    ];

    final lastIndex = pages.length - 1;

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: SafeArea(
        child: Column(
          children: [
            // Header
            _buildAppBarHeader(context, l10n),

            // Pages
            Expanded(
              child: PageView.builder(
                controller: _page,
                onPageChanged: (i) => setState(() => _index = i),
                itemCount: pages.length,
                itemBuilder: (_, i) => pages[i],
              ),
            ),
            // Dots
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: List.generate(
                pages.length,
                (i) => AnimatedContainer(
                  duration: const Duration(milliseconds: 200),
                  margin: const EdgeInsets.all(6),
                  height: 8,
                  width: _index == i ? 24 : 8,
                  decoration: BoxDecoration(
                    color: _index == i
                        ? theme.colorScheme.primary
                        : theme.disabledColor.withOpacity(0.4),
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
              ),
            ),
            // Bottom bar
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 8, 16, 16),
              child: Row(
                children: [
                  Expanded(
                    child: OutlinedButton.icon(
                      onPressed: _index == 0
                          ? null
                          : () => _page.animateToPage(
                                _index - 1,
                                duration: const Duration(milliseconds: 250),
                                curve: Curves.easeOut,
                              ),
                      icon: const Icon(Icons.chevron_left),
                      label: Text(l10n.onbBack),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton.icon(
                      onPressed: () => _next(lastIndex),
                      icon: Icon(
                        _index < lastIndex ? Icons.chevron_right : Icons.check,
                      ),
                      label: Text(
                        _index < lastIndex ? l10n.onbNext : l10n.onbFinishCta,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAppBarHeader(BuildContext context, AppLocalizations l10n) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 8, 16, 0),
      child: Row(
        children: [
          // App-Name
          Text(l10n.appTitle,
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.w900,
                  )),
        ],
      ),
    );
  }
}

// ----------------------------------------------------
// NEUE/ANGEPASSTE SLIDE-KOMPONENTEN FÜR DAS VISUELLE DESIGN
// ----------------------------------------------------

class _WelcomeSlide extends StatelessWidget {
  final String title;
  final String subtitle;
  final String body;
  final _Cta? primaryCta;
  const _WelcomeSlide({
    required this.title,
    required this.subtitle,
    required this.body,
    this.primaryCta,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.waving_hand, size: 72, color: theme.colorScheme.primary),
          const SizedBox(height: DesignConstants.spacingL),
          Text(
            title,
            style: theme.textTheme.headlineLarge?.copyWith(
              fontWeight: FontWeight.w900,
            ),
            textAlign: TextAlign.center,
          ),
          Text(
            subtitle,
            style: theme.textTheme.titleMedium,
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: DesignConstants.spacingXL),
          Text(
            body,
            textAlign: TextAlign.center,
            style: theme.textTheme.bodyLarge,
          ),
          const SizedBox(height: DesignConstants.spacingXXL),
          if (primaryCta != null)
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: primaryCta!.onTap,
                icon: Icon(primaryCta!.icon),
                label: Text(primaryCta!.label),
              ),
            ),
        ],
      ),
    );
  }
}

// Allgemeine Text-Slide (für Privacy)
class _TextSlide extends StatelessWidget {
  final IconData icon;
  final String title;
  final String body;
  const _TextSlide({
    required this.icon,
    required this.title,
    required this.body,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 72, color: theme.colorScheme.primary),
          const SizedBox(height: DesignConstants.spacingXL),
          Text(
            title,
            style: theme.textTheme.headlineSmall,
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: DesignConstants.spacingS),
          Text(
            body,
            textAlign: TextAlign.center,
            style: theme.textTheme.bodyLarge,
          ),
        ],
      ),
    );
  }
}

// Slide mit Fokus auf eine Visualisierung (für Nutrition/Stats/Training)
class _VisualSlide extends StatelessWidget {
  final String title;
  final String body;
  final Widget visual;
  const _VisualSlide({
    required this.title,
    required this.body,
    required this.visual,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.fromLTRB(24, 24, 24, 0),
      child: SingleChildScrollView(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Visuelle Komponente (Container ohne Border)
            Container(
              height: 240, // Höhe beibehalten
              clipBehavior: Clip.antiAlias,
              decoration: BoxDecoration(
                borderRadius:
                    BorderRadius.circular(DesignConstants.borderRadiusL),
                // Hintergrundfarbe des SummaryCard/Dialogs
                color: theme.brightness == Brightness.dark
                    ? summary_card_dark_mode
                    : summary_card_white_mode,
              ),
              child: visual,
            ),
            const SizedBox(height: DesignConstants.spacingXL),

            // Textlicher Inhalt
            Text(
              title,
              style: theme.textTheme.headlineSmall,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: DesignConstants.spacingS),
            Text(
              body,
              textAlign: TextAlign.center,
              style: theme.textTheme.bodyLarge,
            ),
            const SizedBox(height: 120),
          ],
        ),
      ),
    );
  }
}

// Finale Folie (unverändert)
class _FinalSlide extends StatelessWidget {
  final String title;
  final String body;
  final VoidCallback onFinish;
  const _FinalSlide({
    required this.title,
    required this.body,
    required this.onFinish,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.rocket_launch, size: 72, color: theme.colorScheme.primary),
          const SizedBox(height: DesignConstants.spacingL),
          Text(
            title,
            style: theme.textTheme.headlineSmall,
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: DesignConstants.spacingS),
          Text(
            body,
            textAlign: TextAlign.center,
            style: theme.textTheme.bodyLarge,
          ),
          const SizedBox(height: DesignConstants.spacingXL),
          SizedBox(
            width: double.infinity,
            child: ElevatedButton.icon(
              onPressed: onFinish,
              icon: const Icon(Icons.check),
              label: Text(AppLocalizations.of(context)!.onbFinishCta),
            ),
          ),
        ],
      ),
    );
  }
}

// ----------------------------------------------------
// HILFS-KLASSEN FÜR DIE VISUALISIERUNGEN (SIMULIERT)
// ----------------------------------------------------

class _NutritionDiaryVisual extends StatelessWidget {
  final AppLocalizations l10n;
  const _NutritionDiaryVisual({required this.l10n});

  @override
  Widget build(BuildContext context) {
    // KORRIGIERT: Abstand unten reduziert, um Platz zu sparen
    return Padding(
      padding: const EdgeInsets.all(12.0),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Titel
          Align(
            alignment: Alignment.centerLeft,
            child: Text(l10n.today_overview_text,
                style: Theme.of(context).textTheme.labelLarge?.copyWith(
                    color: Colors.grey.shade600, fontWeight: FontWeight.bold)),
          ),
          const SizedBox(height: 8),
          // 2x2 Makros
          Row(
            children: [
              Expanded(
                child: _SimulatedMacroCard(
                  label: l10n.calories,
                  unit: 'kcal',
                  value: 1853,
                  target: 2500,
                  color: Colors.orange.shade400,
                  height: 50,
                  isPrimary: true,
                ),
              ),
              const SizedBox(width: 8),
              Expanded(
                child: _SimulatedMacroCard(
                  label: l10n.protein,
                  unit: 'g',
                  value: 116,
                  target: 180,
                  color: Colors.red.shade400,
                  height: 50,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Row(
            children: [
              Expanded(
                child: _SimulatedMacroCard(
                  label: l10n.water,
                  unit: 'ml',
                  value: 1400,
                  target: 3000,
                  color: Colors.blue.shade400,
                  height: 50,
                ),
              ),
              const SizedBox(width: 8),
              Expanded(
                child: _SimulatedMacroCard(
                  label: l10n.carbs,
                  unit: 'g',
                  value: 203,
                  target: 250,
                  color: Colors.green.shade400,
                  height: 50,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          // 2x1 Makros + Supps
          Row(
            children: [
              Expanded(
                child: _SimulatedSuppTile(
                  label: l10n.supplement_creatine_monohydrate,
                  value: '5 g',
                  isDone: true,
                  height: 50,
                ),
              ),
              const SizedBox(width: 8),
              Expanded(
                child: _SimulatedMacroCard(
                  label: l10n.supplement_caffeine,
                  unit: 'mg',
                  value: 100,
                  target: 400,
                  color: Colors.orange.shade600,
                  height: 50,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

// NEU: Simuliert eine Makro-Card (Kopie der Logik aus NutritionSummaryWidget)
class _SimulatedMacroCard extends StatelessWidget {
  final String label;
  final String unit;
  final double value;
  final double target;
  final Color color;
  final double height;
  final bool isPrimary;
  const _SimulatedMacroCard({
    required this.label,
    required this.unit,
    required this.value,
    required this.target,
    required this.color,
    this.height = 70.0,
    this.isPrimary = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;
    final hasTarget = target > 0;
    final progress = hasTarget ? (value / target).clamp(0.0, 1.0) : 0.0;
    const borderRadius = 12.0;

    return Container(
      height: height,
      decoration: BoxDecoration(
        color: theme.cardColor,
        borderRadius: BorderRadius.circular(borderRadius),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(borderRadius),
        child: Stack(
          fit: StackFit.expand,
          children: [
            // Progress Bar
            Align(
              alignment: Alignment.centerLeft,
              child: FractionallySizedBox(
                widthFactor: progress,
                child: Container(color: color),
              ),
            ),
            // Content
            Padding(
              padding: const EdgeInsets.symmetric(
                horizontal: 10.0,
                vertical: 4.0,
              ),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    label,
                    maxLines: 1,
                    style: TextStyle(
                      color: isPrimary ? cs.onPrimary : cs.onSurface,
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    hasTarget
                        ? '${value.toStringAsFixed(1).replaceAll('.0', '')} / ${target.toStringAsFixed(0)} $unit'
                        : '${value.toStringAsFixed(1).replaceAll('.0', '')} $unit',
                    style: TextStyle(
                      color: isPrimary
                          ? cs.onPrimary
                          : cs.onSurface.withOpacity(0.8),
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _SimulatedSuppTile extends StatelessWidget {
  final String label;
  final String value;
  final bool isDone;
  final double height;
  const _SimulatedSuppTile({
    required this.label,
    required this.value,
    this.isDone = false,
    this.height = 38,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final bgColor = theme.cardColor;

    return Container(
      height: height,
      padding: const EdgeInsets.symmetric(horizontal: 10),
      decoration: BoxDecoration(
        color: bgColor,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        children: [
          Icon(
            isDone ? Icons.check_circle : Icons.radio_button_unchecked,
            color: isDone ? Colors.green.shade400 : Colors.grey,
            size: 18,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              label,
              style: theme.textTheme.bodySmall
                  ?.copyWith(fontWeight: FontWeight.w600),
            ),
          ),
          Text(value,
              style: theme.textTheme.bodySmall
                  ?.copyWith(fontWeight: FontWeight.bold)),
        ],
      ),
    );
  }
}

// NEU: Simulierte Chart-Ansicht
class _MeasurementChartVisual extends StatelessWidget {
  final AppLocalizations l10n;
  const _MeasurementChartVisual({required this.l10n});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                l10n.weightHistoryTitle,
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const Row(
                children: [
                  _ChartFilterButton(label: '30D', isSelected: false),
                  _ChartFilterButton(label: '90D', isSelected: true),
                  _ChartFilterButton(label: 'All', isSelected: false),
                ],
              ),
            ],
          ),
          const SizedBox(height: 8),
          Expanded(
            child: Row(
              children: [
                // Y-Achse
                SizedBox(
                  width: 30,
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text('80', style: theme.textTheme.bodySmall),
                      Text('75', style: theme.textTheme.bodySmall),
                      Text('70', style: theme.textTheme.bodySmall),
                      Text('65', style: theme.textTheme.bodySmall),
                    ],
                  ),
                ),
                // Chart & Daten
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        '65.0 kg',
                        style: theme.textTheme.headlineSmall?.copyWith(
                          color: cs.onSurface,
                        ),
                      ),
                      Text(
                        'Oct 18, 2025',
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: Colors.grey,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Expanded(
                        child: CustomPaint(
                          painter: _LineChartPainter(
                            lineColor: cs.primary,
                          ),
                          child: Container(),
                        ),
                      ),
                      // X-Achse (Datum)
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text('Aug 7', style: theme.textTheme.bodySmall),
                          Text('Aug 31', style: theme.textTheme.bodySmall),
                          Text('Sep 24', style: theme.textTheme.bodySmall),
                          Text('Oct 18', style: theme.textTheme.bodySmall),
                        ],
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _ChartFilterButton extends StatelessWidget {
  final String label;
  final bool isSelected;
  const _ChartFilterButton({required this.label, required this.isSelected});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.only(left: 4.0),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
        decoration: BoxDecoration(
          color: isSelected
              ? theme.colorScheme.primary
              : theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
          borderRadius: BorderRadius.circular(8.0),
        ),
        child: Text(
          label,
          style: theme.textTheme.labelSmall?.copyWith(
            color: isSelected
                ? theme.colorScheme.onPrimary
                : theme.colorScheme.onSurfaceVariant,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }
}

// NEU: Simuliert den Workout-Verlauf
class _WorkoutHistoryVisual extends StatelessWidget {
  final AppLocalizations l10n;
  const _WorkoutHistoryVisual({required this.l10n});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.all(12.0),
      child: Column(
        children: [
          // Titel
          Align(
            alignment: Alignment.centerLeft,
            child: Text(
              l10n.workoutHistoryTitle,
              style: theme.textTheme.titleLarge,
            ),
          ),
          const SizedBox(height: 16),

          // Log 1
          const _WorkoutLogItem(
            title: 'Backday',
            date: '18. Oktober 2025 16:09',
            volume: '9138 kg',
            sets: '10 Sätze',
            duration: '1:06:34',
          ),
          const SizedBox(height: 8),

          // Log 2
          const _WorkoutLogItem(
            title: 'Legday',
            date: '14. Oktober 2025 12:27',
            volume: '8057 kg',
            sets: '10 Sätze',
            duration: '1:43:34',
          ),
        ],
      ),
    );
  }
}

class _WorkoutLogItem extends StatelessWidget {
  final String title;
  final String date;
  final String volume;
  final String sets;
  final String duration;
  const _WorkoutLogItem({
    required this.title,
    required this.date,
    required this.volume,
    required this.sets,
    required this.duration,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: theme.cardColor,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(Icons.calendar_month,
              size: 40, color: theme.colorScheme.primary),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: theme.textTheme.bodyLarge
                      ?.copyWith(fontWeight: FontWeight.bold),
                ),
                Text(
                  date,
                  style:
                      theme.textTheme.bodySmall?.copyWith(color: Colors.grey),
                ),
                const SizedBox(height: 4),
                Row(
                  children: [
                    Icon(Icons.monitor_weight_outlined,
                        size: 14, color: Colors.grey.shade600),
                    Text(volume,
                        style: theme.textTheme.bodySmall
                            ?.copyWith(color: Colors.grey.shade600)),
                    const SizedBox(width: 8),
                    Icon(Icons.replay_circle_filled_outlined,
                        size: 14, color: Colors.grey.shade600),
                    Text(sets,
                        style: theme.textTheme.bodySmall
                            ?.copyWith(color: Colors.grey.shade600)),
                  ],
                ),
              ],
            ),
          ),
          Text(
            duration,
            style: theme.textTheme.titleMedium
                ?.copyWith(color: theme.colorScheme.primary),
          ),
        ],
      ),
    );
  }
}

// Neue Folie für den App-Bauplan (Bottom Bar + FAB)
class _AppLayoutSlide extends StatelessWidget {
  final String title;
  final String body;
  const _AppLayoutSlide({required this.title, required this.body});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Padding(
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.widgets_outlined,
              size: 72, color: theme.colorScheme.primary),
          const SizedBox(height: DesignConstants.spacingXL),
          Text(
            title,
            style: theme.textTheme.headlineSmall,
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: DesignConstants.spacingS),
          Text(
            body,
            textAlign: TextAlign.center,
            style: theme.textTheme.bodyLarge,
          ),
          const SizedBox(height: DesignConstants.spacingXXL),
          // Simulierte Bottom Bar und FAB
          Container(
            height: 76,
            width: double.infinity,
            decoration: BoxDecoration(
              color: isDark
                  ? summary_card_dark_mode.withOpacity(0.8)
                  : summary_card_white_mode.withOpacity(0.8),
              borderRadius: BorderRadius.circular(20),
              border: Border.all(
                color: theme.colorScheme.onSurfaceVariant.withOpacity(0.1),
              ),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.3),
                  blurRadius: 12,
                  offset: const Offset(0, 6),
                ),
              ],
            ),
            child: const Row(
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Spacer(),
                _NavIcon(
                    icon: Icons.book_outlined,
                    label: "Tagebuch",
                    isSelected: true),
                Spacer(flex: 2),
                _NavIcon(icon: Icons.fitness_center_outlined, label: "Workout"),
                Spacer(flex: 2),
                _NavIcon(icon: Icons.bar_chart_outlined, label: "Stats"),
                Spacer(flex: 2),
                _NavIcon(
                    icon: Icons.restaurant_menu_rounded, label: "Ernährung"),
                Spacer(),
              ],
            ),
          ),
          const SizedBox(height: 12),
          // Simulierte FAB (separat gerendert, da er getrennt ist)
          Container(
            width: 76,
            height: 76,
            decoration: BoxDecoration(
              color: isDark
                  ? summary_card_dark_mode.withOpacity(0.8)
                  : summary_card_white_mode.withOpacity(0.8),
              borderRadius: BorderRadius.circular(20),
              border: Border.all(
                color: theme.colorScheme.onSurfaceVariant.withOpacity(0.1),
              ),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.3),
                  blurRadius: 12,
                  offset: const Offset(0, 6),
                ),
              ],
            ),
            child: Icon(Icons.add,
                color: isDark ? Colors.white : Colors.black, size: 34),
          ),
        ],
      ),
    );
  }
}

class _NavIcon extends StatelessWidget {
  final IconData icon;
  final String label;
  final bool isSelected;
  const _NavIcon(
      {required this.icon, required this.label, this.isSelected = false});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final color = isSelected
        ? theme.colorScheme.primary
        : theme.colorScheme.onSurfaceVariant;
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Icon(icon, color: color, size: 24),
        Text(label, style: theme.textTheme.bodySmall?.copyWith(color: color)),
      ],
    );
  }
}

// ----------------------------------------------------
// HILFS-KLASSEN (unverändert)
// ----------------------------------------------------

class _LineChartPainter extends CustomPainter {
  final Color lineColor;
  _LineChartPainter({required this.lineColor});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = lineColor.withOpacity(0.8)
      ..strokeWidth = 3.0
      ..style = PaintingStyle.stroke;

    // Simulierter Graph (von rechts nach links, wie im Screenshot)
    final path = Path()
      ..moveTo(size.width * 0.9, size.height * 0.9)
      ..lineTo(size.width * 0.7, size.height * 0.6)
      ..lineTo(size.width * 0.5, size.height * 0.8)
      ..lineTo(size.width * 0.3, size.height * 0.4)
      ..lineTo(size.width * 0.1, size.height * 0.1);

    canvas.drawPath(path, paint);

    // Area (subtle fade)
    final areaPaint = Paint()
      ..shader = LinearGradient(
        begin: Alignment.topCenter,
        end: Alignment.bottomCenter,
        colors: [lineColor.withOpacity(0.3), lineColor.withOpacity(0.0)],
      ).createShader(Rect.fromLTWH(0, 0, size.width, size.height));

    final areaPath = Path()
      ..addPath(path, Offset.zero)
      ..lineTo(size.width * 0.1, size.height * 0.95) // Basislinie links
      ..lineTo(size.width * 0.9, size.height * 0.95) // Basislinie rechts
      ..close();

    canvas.drawPath(areaPath, areaPaint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}

class _Cta {
  final IconData icon;
  final String label;
  final Future<void> Function()? onTap;
  const _Cta({required this.icon, required this.label, this.onTap});
}

class _Badge extends StatelessWidget {
  final String text;
  const _Badge({required this.text});
  @override
  Widget build(BuildContext context) {
    final c = Theme.of(context).colorScheme;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        color: c.primary.withOpacity(0.15),
        borderRadius: BorderRadius.circular(999),
        border: Border.all(color: c.primary.withOpacity(0.35)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.check_circle, size: 16, color: c.primary),
          const SizedBox(width: 6),
          Text(
            text,
            style: TextStyle(color: c.primary, fontWeight: FontWeight.w600),
          ),
        ],
      ),
    );
  }
}

class _Hint extends StatelessWidget {
  final String text;
  const _Hint({required this.text});
  @override
  Widget build(BuildContext context) {
    return Text(
      text,
      style: Theme.of(
        context,
      ).textTheme.bodySmall?.copyWith(color: Colors.grey),
    );
  }
}

===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/meals_screen.dart =====

import 'package:flutter/material.dart';
import 'meal_editor_screen.dart';

class MealsScreen extends StatelessWidget {
  const MealsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    // Platzhalter-Liste – später mit echten Meals füllen
    final meals = <String>[];

    return Scaffold(
      appBar: AppBar(title: const Text('Meals')),
      body: meals.isEmpty
          ? const Center(
              child: Text(
                'Noch keine Meals.\nTippe auf das +, um eines zu erstellen.',
                textAlign: TextAlign.center,
              ),
            )
          : ListView.separated(
              itemCount: meals.length,
              separatorBuilder: (_, __) => const Divider(height: 1),
              itemBuilder: (context, i) => ListTile(
                title: Text(meals[i]),
                onTap: () async {
                  final result = await Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (_) => MealEditorScreen(initialName: meals[i]),
                    ),
                  );
                  if (result == true && context.mounted) {
                    // TODO: Liste neu laden (später)
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Meal gespeichert')),
                    );
                  }
                },
              ),
            ),
      floatingActionButton: FloatingActionButton(
        onPressed: () async {
          final result = await Navigator.push(
            context,
            MaterialPageRoute(builder: (_) => const MealEditorScreen()),
          );
          if (result == true && context.mounted) {
            // TODO: Liste neu laden (später)
            ScaffoldMessenger.of(
              context,
            ).showSnackBar(const SnackBar(content: Text('Meal gespeichert')));
          }
        },
        child: const Icon(Icons.add),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/create_food_screen.dart =====

// lib/screens/create_food_screen.dart (Final & De-Materialisiert)

import 'package:flutter/material.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/global_app_bar.dart';

class CreateFoodScreen extends StatefulWidget {
  final FoodItem? foodItemToEdit;
  const CreateFoodScreen({super.key, this.foodItemToEdit});

  @override
  State<CreateFoodScreen> createState() => _CreateFoodScreenState();
}

class _CreateFoodScreenState extends State<CreateFoodScreen> {
  final _formKey = GlobalKey<FormState>();

  final _nameController = TextEditingController();
  final _brandController = TextEditingController();
  final _caloriesController = TextEditingController();
  final _proteinController = TextEditingController();
  final _carbsController = TextEditingController();
  final _fatController = TextEditingController();
  final _sugarController = TextEditingController();
  final _fiberController = TextEditingController();
  final _saltController = TextEditingController();

  bool get _isEditing => widget.foodItemToEdit != null;

  @override
  void initState() {
    super.initState();
    if (_isEditing) {
      final item = widget.foodItemToEdit!;
      _nameController.text = item.name;
      _brandController.text = item.brand;
      _caloriesController.text = item.calories.toString();
      _proteinController.text = item.protein.toString();
      _carbsController.text = item.carbs.toString();
      _fatController.text = item.fat.toString();
      _sugarController.text = item.sugar?.toString() ?? '';
      _fiberController.text = item.fiber?.toString() ?? '';
      _saltController.text = item.salt?.toString() ?? '';
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _brandController.dispose();
    _caloriesController.dispose();
    _proteinController.dispose();
    _carbsController.dispose();
    _fatController.dispose();
    _sugarController.dispose();
    _fiberController.dispose();
    _saltController.dispose();
    super.dispose();
  }

  Future<void> _saveFoodItem() async {
    if (_formKey.currentState?.validate() ?? false) {
      final l10n = AppLocalizations.of(context)!;

      final foodData = FoodItem(
        barcode: _isEditing
            ? widget.foodItemToEdit!.barcode
            : "user_created_${DateTime.now().millisecondsSinceEpoch}",
        name: _nameController.text,
        brand: _brandController.text,
        calories: int.tryParse(_caloriesController.text) ?? 0,
        protein: double.tryParse(_proteinController.text) ?? 0.0,
        carbs: double.tryParse(_carbsController.text) ?? 0.0,
        fat: double.tryParse(_fatController.text) ?? 0.0,
        sugar: double.tryParse(_sugarController.text),
        fiber: double.tryParse(_fiberController.text),
        salt: double.tryParse(_saltController.text),
        source: FoodItemSource.user,
      );

      if (_isEditing) {
        await ProductDatabaseHelper.instance.updateProduct(foodData);
      } else {
        await ProductDatabaseHelper.instance.insertProduct(foodData);
      }

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(l10n.snackbarSaveSuccess(foodData.name))),
        );
        Navigator.of(context).pop(foodData);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      extendBodyBehindAppBar: true,
      // KORREKTUR: Eine AppBar hinzugefügt, die den Titel und den Speicher-Button enthält
      appBar: GlobalAppBar(
        title: l10n.createFoodScreenTitle,
        actions: [
          TextButton(
            onPressed: _saveFoodItem,
            // Hier stellen wir sicher, dass der Text die Primärfarbe nutzt
            style: TextButton.styleFrom(
              foregroundColor: Theme.of(context).colorScheme.primary,
            ),

            child: Text(
              l10n.buttonSave,
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: DesignConstants.cardPadding.copyWith(
          top: DesignConstants.cardPadding.top + topPadding,
        ),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // KORREKTUR: Der alte Header wurde aus dem Body entfernt

              // Formularfelder (unverändert)
              _buildFoodInputField(
                controller: _nameController,
                label: l10n.formFieldName,
                isRequired: true,
                isNumeric: false, // KORREKTUR
              ),
              _buildFoodInputField(
                controller: _brandController,
                label: l10n.formFieldBrand,
                isNumeric: false, // KORREKTUR
              ),

              const SizedBox(height: DesignConstants.spacingXL),
              _buildSectionTitle(context, l10n.formSectionMainNutrients),
              const SizedBox(height: DesignConstants.spacingL),
              _buildFoodInputField(
                controller: _caloriesController,
                label: l10n.formFieldCalories,
                isNumeric: true, // KORREKTUR
              ),
              _buildFoodInputField(
                controller: _proteinController,
                label: l10n.formFieldProtein,
                isNumeric: true, // KORREKTUR
              ),
              _buildFoodInputField(
                controller: _carbsController,
                label: l10n.formFieldCarbs,
                isNumeric: true, // KORREKTUR
              ),
              _buildFoodInputField(
                controller: _fatController,
                label: l10n.formFieldFat,
                isNumeric: true, // KORREKTUR
              ),

              const SizedBox(height: DesignConstants.spacingXL),
              _buildSectionTitle(context, l10n.formSectionOptionalNutrients),
              const SizedBox(height: DesignConstants.spacingL),
              _buildFoodInputField(
                controller: _sugarController,
                label: l10n.formFieldSugar,
                isNumeric: true, // KORREKTUR
              ),
              _buildFoodInputField(
                controller: _fiberController,
                label: l10n.formFieldFiber,
                isNumeric: true, // KORREKTUR
              ),
              _buildFoodInputField(
                controller: _saltController,
                label: l10n.formFieldSalt,
                isNumeric: true, // KORREKTUR
              ),

              const SizedBox(height: 32),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildFoodInputField({
    required TextEditingController controller,
    required String label,
    bool isRequired = false,
    bool isNumeric = false, // KORREKTUR: Neuer Parameter
  }) {
    final l10n = AppLocalizations.of(context)!;
    return Padding(
      padding: const EdgeInsets.only(bottom: 12.0),
      child: TextFormField(
        controller: controller,
        decoration: InputDecoration(labelText: label),
        // KORREKTUR: Tastaturtyp wird jetzt gesteuert
        keyboardType: isNumeric
            ? const TextInputType.numberWithOptions(decimal: true)
            : TextInputType.text,
        validator: (value) {
          if (isRequired && (value == null || value.isEmpty)) {
            return l10n.validatorPleaseEnterName;
          }
          // KORREKTUR: Validierung nur für numerische Felder
          if (isNumeric &&
              value != null &&
              value.isNotEmpty &&
              double.tryParse(value.replaceAll(',', '.')) == null) {
            return l10n.validatorPleaseEnterNumber;
          }
          return null;
        },
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/statistics_hub_screen.dart =====

// lib/screens/statistics_hub_screen.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/screens/measurements_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/bottom_content_spacer.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:table_calendar/table_calendar.dart';

class StatisticsHubScreen extends StatefulWidget {
  const StatisticsHubScreen({super.key});

  @override
  State<StatisticsHubScreen> createState() => _StatisticsHubScreenState();
}

class _StatisticsHubScreenState extends State<StatisticsHubScreen> {
  late final l10n = AppLocalizations.of(context)!;
  DateTime _focusedDay = DateTime.now();
  DateTime? _selectedDay;
  bool _isLoading = true;
  String _recommendationText = '';

  Set<int> _workoutDays = {};
  Set<int> _nutritionLogDays = {};
  Set<int> _supplementDays = {};

  @override
  void initState() {
    super.initState();
    _selectedDay = _focusedDay;
    _loadAllData();
  }

  Future<void> _loadAllData() async {
    if (!mounted) return;
    setState(() => _isLoading = true);

    await _loadMonthData(_focusedDay);
    final recommendation = await _getRecommendation();

    if (mounted) {
      setState(() {
        _recommendationText = recommendation;
        _isLoading = false;
      });
    }
  }

  Future<void> _loadMonthData(DateTime month) async {
    final workoutDays =
        await WorkoutDatabaseHelper.instance.getWorkoutDaysInMonth(month);
    final nutritionDays =
        await DatabaseHelper.instance.getNutritionLogDaysInMonth(month);
    final supplementDays =
        await DatabaseHelper.instance.getSupplementLogDaysInMonth(month);

    if (mounted) {
      setState(() {
        _workoutDays = workoutDays;
        _nutritionLogDays = nutritionDays;
        _supplementDays = supplementDays;
      });
    }
  }

  Future<String> _getRecommendation() async {
    final prefs = await SharedPreferences.getInstance();
    final targetCalories = prefs.getInt('targetCalories') ?? 2500;
    final today = DateTime.now();
    final sevenDaysAgo = today.subtract(const Duration(days: 6));
    final recentEntries = await DatabaseHelper.instance.getEntriesForDateRange(
      sevenDaysAgo,
      today,
    );

    if (recentEntries.isEmpty) {
      return l10n.recommendationDefault;
    }

    final uniqueDaysTracked =
        recentEntries.map((e) => DateFormat.yMd().format(e.timestamp)).toSet();
    final numberOfTrackedDays = uniqueDaysTracked.length;
    int totalRecentCalories = 0;
    for (final entry in recentEntries) {
      final foodItem = await ProductDatabaseHelper.instance.getProductByBarcode(
        entry.barcode,
      );
      if (foodItem != null) {
        totalRecentCalories +=
            (foodItem.calories / 100 * entry.quantityInGrams).round();
      }
    }

    final totalTargetCalories = targetCalories * numberOfTrackedDays;
    final difference = totalRecentCalories - totalTargetCalories;
    final tolerance = totalTargetCalories * 0.05;

    if (numberOfTrackedDays > 1) {
      if (difference > tolerance) {
        return l10n.recommendationOverTarget(
          numberOfTrackedDays,
          difference.round(),
        );
      } else if (difference < -tolerance) {
        return l10n.recommendationUnderTarget(
          numberOfTrackedDays,
          (-difference).round(),
        );
      } else {
        return l10n.recommendationOnTarget(numberOfTrackedDays);
      }
    } else {
      return l10n.recommendationFirstEntry;
    }
  }

  @override
  Widget build(BuildContext context) {
    final double appBarHeight =
        MediaQuery.of(context).padding.top; // + kToolbarHeight;

    // 2. Get your base padding from your design constants
    const EdgeInsets basePadding =
        DesignConstants.cardPadding; // This is EdgeInsets.all(16.0)

    // 3. Create the final combined padding
    final EdgeInsets finalPadding = basePadding.copyWith(
      // Take the original top value (16.0) and add the app bar height
      top: basePadding.top + appBarHeight,
    );
    return _isLoading
        ? const Center(child: CircularProgressIndicator())
        : RefreshIndicator(
            onRefresh: _loadAllData,
            child: ListView(
              padding: finalPadding,
              children: [
                _buildSectionTitle(context, l10n.my_consistency),
                SummaryCard(
                  child: Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: TableCalendar(
                      locale: Localizations.localeOf(context).toString(),
                      firstDay: DateTime.utc(2020, 1, 1),
                      lastDay: DateTime.now().add(const Duration(days: 365)),
                      focusedDay: _focusedDay,
                      selectedDayPredicate: (day) =>
                          isSameDay(_selectedDay, day),
                      calendarFormat: CalendarFormat.month,
                      headerStyle: HeaderStyle(
                        formatButtonVisible: false,
                        titleCentered: true,
                        titleTextStyle: Theme.of(
                          context,
                        ).textTheme.titleMedium!,
                      ),
                      onDaySelected: (selectedDay, focusedDay) {
                        setState(() {
                          _selectedDay = selectedDay;
                          _focusedDay = focusedDay;
                        });
                      },
                      onPageChanged: (focusedDay) {
                        setState(() {
                          _focusedDay = focusedDay;
                        });
                        _loadMonthData(focusedDay);
                      },
                      calendarBuilders: CalendarBuilders(
                        markerBuilder: (context, day, events) {
                          final isNutritionDay = _nutritionLogDays.contains(
                            day.day,
                          );
                          final isSupplementDay = _supplementDays.contains(
                            day.day,
                          );

                          return Positioned(
                            bottom: 4,
                            child: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                if (isNutritionDay)
                                  Container(
                                    width: 6,
                                    height: 6,
                                    decoration: const BoxDecoration(
                                      shape: BoxShape.circle,
                                      color: Colors.blueAccent,
                                    ),
                                  ),
                                if (isNutritionDay && isSupplementDay)
                                  const SizedBox(width: 2),
                                if (isSupplementDay)
                                  Container(
                                    width: 6,
                                    height: 6,
                                    decoration: const BoxDecoration(
                                      shape: BoxShape.circle,
                                      color: Colors.amber,
                                    ),
                                  ),
                              ],
                            ),
                          );
                        },
                        defaultBuilder: (context, day, focusedDay) {
                          final isWorkoutDay = _workoutDays.contains(day.day);
                          if (isWorkoutDay) {
                            return Center(
                              child: Container(
                                width: 32,
                                height: 32,
                                decoration: BoxDecoration(
                                  shape: BoxShape.circle,
                                  color: Theme.of(
                                    context,
                                  ).colorScheme.primary,
                                ),
                                child: Center(
                                  child: Text(
                                    '${day.day}',
                                    style: TextStyle(
                                      color: Theme.of(
                                        context,
                                      ).colorScheme.onPrimary,
                                    ),
                                  ),
                                ),
                              ),
                            );
                          }
                          return null;
                        },
                      ),
                    ),
                  ),
                ),
                //const SizedBox(height: DesignConstants.spacingS),
                //_buildBannerCard(l10n),
                const SizedBox(height: DesignConstants.spacingXL),
                _buildSectionTitle(context, l10n.in_depth_analysis),
                _buildAnalysisGateway(
                  context: context,
                  icon: Icons.monitor_weight_outlined,
                  title: l10n.body_measurements,
                  subtitle: l10n.measurements_description,
                  onTap: () {
                    Navigator.of(context).push(
                      MaterialPageRoute(
                        builder: (context) => const MeasurementsScreen(),
                      ),
                    );
                  },
                ),
                //const SizedBox(height: DesignConstants.spacingM),
                /*
                  _buildAnalysisGateway(
                    context: context,
                    icon: Icons.pie_chart_outline_rounded,
                    title: l10n.nutritionScreenTitle,
                    subtitle: l10n.nutrition_description,
                    onTap: () {
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (context) => const NutritionScreen(),
                        ),
                      );
                    },
                  ),
                  //const SizedBox(height: DesignConstants.spacingM),
                  _buildAnalysisGateway(
                    context: context,
                    icon: Icons.bar_chart_rounded,
                    title: l10n.training_analysis,
                    subtitle: l10n.training_analysis_description,
                    onTap: () {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text(l10n.soon_available_snackbar)),
                      );
                    },
                  ),
                  */
                const BottomContentSpacer(),
              ],
            ),
          );
  }

  Widget _buildBannerCard(AppLocalizations l10n) {
    return SummaryCard(
      child: Container(
        height: 100,
        alignment: Alignment.center,
        child: Text(
          _recommendationText.isEmpty ? l10n.load_dots : _recommendationText,
          textAlign: TextAlign.center,
          style: TextStyle(
            color: Theme.of(context).colorScheme.onSurfaceVariant,
            fontSize: 22,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildAnalysisGateway({
    required BuildContext context,
    required IconData icon,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
  }) {
    return SummaryCard(
      child: ListTile(
        contentPadding: const EdgeInsets.symmetric(
          vertical: 12.0,
          horizontal: 16.0,
        ),
        leading: Icon(
          icon,
          size: 40,
          color: Theme.of(context).colorScheme.primary,
        ),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Text(subtitle),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/workout_hub_screen.dart =====

// lib/screens/workout_hub_screen.dart (Final, mit einheitlichem Design)

import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/screens/edit_routine_screen.dart';
import 'package:lightweight/screens/exercise_catalog_screen.dart';
import 'package:lightweight/screens/live_workout_screen.dart';
import 'package:lightweight/screens/routines_screen.dart';
import 'package:lightweight/screens/workout_history_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/bottom_content_spacer.dart';
import 'package:lightweight/widgets/summary_card.dart';

class WorkoutHubScreen extends StatefulWidget {
  const WorkoutHubScreen({super.key});

  @override
  State<WorkoutHubScreen> createState() => _WorkoutHubScreenState();
}

class _WorkoutHubScreenState extends State<WorkoutHubScreen> {
  bool _isLoading = true;
  List<Routine> _routines = [];
  late final l10n = AppLocalizations.of(context)!;

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  Future<void> _loadData() async {
    setState(() => _isLoading = true);
    final routines = await WorkoutDatabaseHelper.instance.getAllRoutines();
    if (mounted) {
      setState(() {
        _routines = routines;
        _isLoading = false;
      });
    }
  }

  void _startEmptyWorkout() async {
    final newLog = await WorkoutDatabaseHelper.instance.startWorkout(
      routineName: l10n.free_training,
    );
    if (mounted) {
      Navigator.of(context)
          .push(
            MaterialPageRoute(
              builder: (context) => LiveWorkoutScreen(workoutLog: newLog),
            ),
          )
          .then((_) => _loadData());
    }
  }

  void _startRoutine(Routine routine) async {
    // Wir brauchen die vollen Details der Routine zum Starten
    final detailedRoutine = await WorkoutDatabaseHelper.instance.getRoutineById(
      routine.id!,
    );
    if (detailedRoutine == null) return;

    final newLog = await WorkoutDatabaseHelper.instance.startWorkout(
      routineName: routine.name,
    );
    if (mounted) {
      Navigator.of(context)
          .push(
            MaterialPageRoute(
              builder: (context) => LiveWorkoutScreen(
                routine: detailedRoutine,
                workoutLog: newLog,
              ),
            ),
          )
          .then((_) => _loadData());
    }
  }

  Future<void> _createNewRoutine() async {
    // Navigiert zum Editor für eine neue Routine und lädt danach die Daten neu.
    await Navigator.of(context).push(
      MaterialPageRoute(builder: (context) => const EditRoutineScreen()),
    );
    _loadData();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final double appBarHeight =
        MediaQuery.of(context).padding.top; // + kToolbarHeight;

    // 2. Get your base padding from your design constants
    const EdgeInsets basePadding =
        DesignConstants.cardPadding; // This is EdgeInsets.all(16.0)

    // 3. Create the final combined padding
    final EdgeInsets finalPadding = basePadding.copyWith(
      // Take the original top value (16.0) and add the app bar height
      top: basePadding.top + appBarHeight,
    );

    return _isLoading
        ? const Center(child: CircularProgressIndicator())
        : RefreshIndicator(
            onRefresh: _loadData,
            child: ListView(
              padding: finalPadding,
              children: [
                _buildSectionTitle(context, l10n.startCapsLock),
                SummaryCard(
                  child: InkWell(
                    onTap: _startEmptyWorkout,
                    borderRadius: BorderRadius.circular(
                      DesignConstants.borderRadiusM,
                    ),
                    child: Padding(
                      padding: const EdgeInsets.all(20.0),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          const Icon(Icons.add_circle_outline, size: 28),
                          const SizedBox(width: 12),
                          Text(
                            l10n.startEmptyWorkoutButton,
                            style: Theme.of(context).textTheme.titleLarge,
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: DesignConstants.spacingXL),
                _buildSectionTitle(context, l10n.my_plans_capslock),
                _routines.isEmpty
                    ? _buildEmptyRoutinesCard(context, l10n)
                    : SizedBox(
                        height: 150,
                        child: ListView.builder(
                          scrollDirection: Axis.horizontal,
                          clipBehavior: Clip.none,
                          itemCount: _routines.length + 1, // HIER DIE ANPASSUNG
                          itemBuilder: (context, index) {
                            if (index == 0) {
                              // HIER DIE ANPASSUNG
                              return _buildCreateRoutineCard(context, l10n);
                            }
                            return _buildRoutineCard(
                              context,
                              _routines[index - 1], // HIER DIE ANPASSUNG
                            );
                          },
                        ),
                      ),
                const SizedBox(height: DesignConstants.spacingXL),
                _buildSectionTitle(context, l10n.overview_capslock),
                _buildNavigationTile(
                  context: context,
                  icon: Icons.history,
                  title: l10n.workoutHistoryButton,
                  onTap: () => Navigator.of(context).push(
                    MaterialPageRoute(
                      builder: (context) => const WorkoutHistoryScreen(),
                    ),
                  ),
                ),
                _buildNavigationTile(
                  context: context,
                  icon: Icons.list_alt_rounded,
                  title: l10n.manage_all_plans,
                  onTap: () => Navigator.of(context)
                      .push(
                        MaterialPageRoute(
                          builder: (context) => const RoutinesScreen(),
                        ),
                      )
                      .then((_) => _loadData()),
                ),
                _buildNavigationTile(
                  context: context,
                  icon: Icons.folder_open_outlined,
                  title: l10n.drawerExerciseCatalog,
                  onTap: () => Navigator.of(context).push(
                    MaterialPageRoute(
                      builder: (context) => const ExerciseCatalogScreen(),
                    ),
                  ),
                ),
                const BottomContentSpacer(),
              ],
            ),
          );
  }

  Widget _buildCreateRoutineCard(BuildContext context, AppLocalizations l10n) {
    final screenWidth = MediaQuery.of(context).size.width;
    final cardWidth = (screenWidth - 32 - 12) / 2.5; // Etwas schmaler
    return SizedBox(
      width: cardWidth,
      child: Padding(
        padding: const EdgeInsets.only(right: 12.0),
        child: SummaryCard(
          child: InkWell(
            onTap: _createNewRoutine,
            borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM),
            child: Padding(
              padding: DesignConstants.cardPadding,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.add_circle_outline,
                      size: 40, color: Theme.of(context).colorScheme.primary),
                  const SizedBox(height: 8),
                  Text(l10n.addRoutineButton, textAlign: TextAlign.center),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
  /*
  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    return Scaffold(
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : RefreshIndicator(
              onRefresh: _loadData,
              child: ListView(
                padding: DesignConstants.cardPadding,
                children: [
                  _buildSectionTitle(context, l10n.startCapsLock),
                  SummaryCard(
                    child: InkWell(
                      onTap: _startEmptyWorkout,
                      borderRadius: BorderRadius.circular(
                        DesignConstants.borderRadiusM,
                      ),
                      child: Padding(
                        padding: const EdgeInsets.all(20.0),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            const Icon(Icons.add_circle_outline, size: 28),
                            const SizedBox(width: 12),
                            Text(
                              l10n.startEmptyWorkoutButton,
                              style: Theme.of(context).textTheme.titleLarge,
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: DesignConstants.spacingXL),
                  _buildSectionTitle(context, l10n.my_plans_capslock),
                  _routines.isEmpty
                      ? _buildEmptyRoutinesCard(context, l10n)
                      : SizedBox(
                          height: 150,
                          child: ListView.builder(
                            scrollDirection: Axis.horizontal,
                            clipBehavior: Clip.none,
                            itemCount: _routines.length,
                            itemBuilder: (context, index) {
                              return _buildRoutineCard(
                                context,
                                _routines[index],
                              );
                            },
                          ),
                        ),
                  const SizedBox(height: DesignConstants.spacingXL),
                  _buildSectionTitle(context, l10n.overview_capslock),
                  _buildNavigationTile(
                    context: context,
                    icon: Icons.history,
                    title: l10n.workoutHistoryButton,
                    onTap: () => Navigator.of(context).push(
                      MaterialPageRoute(
                        builder: (context) => const WorkoutHistoryScreen(),
                      ),
                    ),
                  ),
                  //const SizedBox(height: DesignConstants.spacingS),
                  _buildNavigationTile(
                    context: context,
                    icon: Icons.list_alt_rounded,
                    title: l10n.manage_all_plans,
                    onTap: () => Navigator.of(context)
                        .push(
                          MaterialPageRoute(
                            builder: (context) => const RoutinesScreen(),
                          ),
                        )
                        .then((_) => _loadData()),
                  ),
                  //const SizedBox(height: DesignConstants.spacingM),
                  _buildNavigationTile(
                    context: context,
                    icon: Icons.folder_open_outlined,
                    title: l10n.drawerExerciseCatalog,
                    onTap: () => Navigator.of(context).push(
                      MaterialPageRoute(
                        builder: (context) => const ExerciseCatalogScreen(),
                      ),
                    ),
                  ),
                  const BottomContentSpacer(),
                ],
              ),
            ),
    );
  }
  */

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildRoutineCard(BuildContext context, Routine routine) {
    final screenWidth = MediaQuery.of(context).size.width;
    final cardWidth = (screenWidth - 32 - 12) / 2;

    return SizedBox(
      width: cardWidth,
      // KORREKTUR: Wir fügen den Abstand hier als Padding hinzu, nicht als Margin.
      child: Padding(
        padding: const EdgeInsets.only(right: 12.0),
        child: SummaryCard(
          child: InkWell(
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (_) => EditRoutineScreen(routine: routine),
                ),
              );
            },
            borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM),
            child: Padding(
              padding: DesignConstants.cardPadding,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    routine.name,
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  ElevatedButton(
                    onPressed: () => _startRoutine(routine),
                    child: Text(l10n.start_button),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildEmptyRoutinesCard(BuildContext context, AppLocalizations l10n) {
    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          children: [
            Text(
              l10n.emptyRoutinesTitle,
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: DesignConstants.spacingS),
            Text(
              l10n.emptyRoutinesSubtitle,
              textAlign: TextAlign.center,
              style: Theme.of(context).textTheme.bodySmall,
            ),
            const SizedBox(height: DesignConstants.spacingL),
            TextButton.icon(
              onPressed: () => Navigator.of(context)
                  .push(
                    MaterialPageRoute(
                      builder: (context) => const RoutinesScreen(),
                    ),
                  )
                  .then((_) => _loadData()),
              icon: const Icon(Icons.add),
              label: Text(l10n.createFirstRoutineButton),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNavigationTile({
    required BuildContext context,
    required IconData icon,
    required String title,
    required VoidCallback onTap,
  }) {
    return SummaryCard(
      child: ListTile(
        leading: Icon(icon, color: Theme.of(context).colorScheme.primary),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/exercise_catalog_screen.dart =====

// lib/screens/exercise_catalog_screen.dart (Final & De-Materialisiert)

import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/screens/exercise_detail_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
import 'package:lightweight/widgets/global_app_bar.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/wger_attribution_widget.dart';
import 'package:lightweight/screens/create_exercise_screen.dart';
import 'package:lightweight/widgets/glass_fab.dart';

class ExerciseCatalogScreen extends StatefulWidget {
  final bool isSelectionMode;
  const ExerciseCatalogScreen({super.key, this.isSelectionMode = false});

  @override
  State<ExerciseCatalogScreen> createState() => _ExerciseCatalogScreenState();
}

class _ExerciseCatalogScreenState extends State<ExerciseCatalogScreen> {
  List<Exercise> _foundExercises = [];
  bool _isLoading = true;
  final _searchController = TextEditingController();
  List<String> _allCategories = [];
  List<String> _selectedCategories = [];

  @override
  void initState() {
    super.initState();
    _searchController.addListener(() => _runFilter(_searchController.text));
    _loadCategories();
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  Future<void> _loadCategories() async {
    final categories = await WorkoutDatabaseHelper.instance.getAllCategories();
    setState(() {
      _allCategories = categories;
      _isLoading = false;
    });
    _runFilter(_searchController.text); // Erste Ladung oder Filter
  }

  void _runFilter(String enteredKeyword) async {
    final results = await WorkoutDatabaseHelper.instance.searchExercises(
      query: enteredKeyword,
      selectedCategories: _selectedCategories,
    );
    if (mounted) {
      setState(() {
        _foundExercises = results;
      });
    }
  }

  // In lib/screens/exercise_catalog_screen.dart

  void _showFilterDialog(BuildContext context, AppLocalizations l10n) {
    showGlassBottomMenu(
      context: context,
      title: l10n.filterByCategory,
      contentBuilder: (ctx, close) {
        // Lokaler State für das Bottom Sheet
        List<String> tempSelected = List.from(_selectedCategories);

        return StatefulBuilder(
          builder: (context, setStateSB) {
            return Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Scrollbare Liste der Kategorien
                ConstrainedBox(
                  constraints: const BoxConstraints(maxHeight: 400),
                  child: ListView.builder(
                    shrinkWrap: true,
                    itemCount: _allCategories.length,
                    itemBuilder: (context, index) {
                      final category = _allCategories[index];
                      final isSelected = tempSelected.contains(category);
                      return CheckboxListTile(
                        title: Text(category),
                        value: isSelected,
                        activeColor: Theme.of(context).colorScheme.primary,
                        onChanged: (bool? value) {
                          setStateSB(() {
                            if (value == true) {
                              tempSelected.add(category);
                            } else {
                              tempSelected.remove(category);
                            }
                          });
                        },
                      );
                    },
                  ),
                ),
                const SizedBox(height: 16),
                // Buttons
                Row(
                  children: [
                    Expanded(
                      child: OutlinedButton(
                        onPressed: () {
                          close(); // Schließen ohne Speichern
                        },
                        child: Text(l10n.cancel),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: FilledButton(
                        onPressed: () {
                          // State des Haupt-Screens aktualisieren
                          setState(() {
                            _selectedCategories = tempSelected;
                          });
                          _runFilter(_searchController.text);
                          close();
                        },
                        child: Text(l10n.doneButtonLabel),
                      ),
                    ),
                  ],
                ),
              ],
            );
          },
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    return Scaffold(
      appBar: GlobalAppBar(
        title: l10n.exerciseCatalogTitle,
        actions: [
          if (widget.isSelectionMode)
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: Text(
                l10n.doneButtonLabel,
                style: TextStyle(
                  color: Theme.of(context).colorScheme.primary,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
        ],
      ),

      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      // KORREKTUR 1: AppBar entfernt, Titel und Aktionen im Body
      // Body ohne doppelten Titel
      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(
              horizontal: 16.0,
              vertical: 24.0,
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const SizedBox(height: DesignConstants.spacingS),
                TextField(
                  controller: _searchController,
                  decoration: InputDecoration(
                    hintText: l10n.searchHintText,
                    prefixIcon: Icon(
                      Icons.search,
                      color: colorScheme.onSurfaceVariant,
                      size: 20,
                    ),
                    suffixIcon: _searchController.text.isNotEmpty
                        ? IconButton(
                            icon: Icon(
                              Icons.clear,
                              color: colorScheme.onSurfaceVariant,
                            ),
                            onPressed: () => _searchController.clear(),
                          )
                        : null,
                  ),
                ),
                const SizedBox(height: DesignConstants.spacingL),
                _buildFilterButton(context, l10n),
              ],
            ),
          ),
          Divider(
            height: 1,
            thickness: 1,
            color: colorScheme.onSurfaceVariant.withOpacity(0.1),
          ),
          Expanded(
            child: _isLoading
                ? const Center(child: CircularProgressIndicator())
                : _foundExercises.isEmpty
                    ? Center(
                        child: Text(
                          l10n.noExercisesFound,
                          style: textTheme.titleMedium,
                        ),
                      )
                    : ListView.builder(
                        padding: DesignConstants.cardPadding,
                        itemCount: _foundExercises.length,
                        itemBuilder: (context, index) {
                          final exercise = _foundExercises[index];
                          return SummaryCard(
                            // KORREKTUR 3: Übungs-Card
                            child: ListTile(
                              leading: const Icon(Icons.fitness_center),
                              title: Text(
                                exercise.getLocalizedName(context),
                                style: const TextStyle(
                                    fontWeight: FontWeight.bold),
                              ),
                              subtitle: Text(exercise.categoryName),
                              trailing: widget.isSelectionMode
                                  ? IconButton(
                                      // Auswahl-Modus: Hinzufügen-Icon
                                      icon: Icon(
                                        Icons.add_circle_outline,
                                        color: colorScheme.primary,
                                      ),
                                      onPressed: () =>
                                          Navigator.of(context).pop(exercise),
                                    )
                                  : const Icon(
                                      Icons.chevron_right,
                                    ), // Anzeige-Modus: Pfeil
                              onTap: () {
                                if (widget.isSelectionMode) {
                                  // Im Auswahl-Modus: Bei Klick auch auswählen
                                  Navigator.of(context).pop(exercise);
                                } else {
                                  // Im Anzeige-Modus: Detail-Screen öffnen
                                  Navigator.of(context).push(
                                    MaterialPageRoute(
                                      builder: (context) =>
                                          ExerciseDetailScreen(
                                              exercise: exercise),
                                    ),
                                  );
                                }
                              },
                            ),
                          );
                        },
                      ),
          ),
          // KORREKTUR 4: WgerAttributionWidget am Ende
          Padding(
            padding: const EdgeInsets.only(top: 16.0, bottom: 8.0),
            child: WgerAttributionWidget(
              textStyle: textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
            ),
          ),
        ],
      ),
      floatingActionButton: GlassFab(
        label: l10n.create_exercise_screen_title,
        onPressed: () {
          Navigator.of(context)
              .push(
            MaterialPageRoute(
              builder: (context) => const CreateExerciseScreen(),
            ),
          )
              .then((wasCreated) {
            // Wenn der Screen mit 'true' zurückkehrt, wurde eine Übung erstellt.
            // Lade die Liste neu, um die neue Übung anzuzeigen.
            if (wasCreated == true) {
              _runFilter(_searchController.text);
            }
          });
        },
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  // KORREKTUR 5: Helfer-Widget für den Filter-Button
  Widget _buildFilterButton(BuildContext context, AppLocalizations l10n) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final textTheme = theme.textTheme;

    return Padding(
      padding: const EdgeInsets.only(top: 8.0),
      child: GestureDetector(
        onTap: () => _showFilterDialog(context, l10n),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
          decoration: BoxDecoration(
            color: _selectedCategories.isNotEmpty
                ? colorScheme.primary
                : colorScheme.surfaceContainerHighest.withOpacity(0.5),
            borderRadius: BorderRadius.circular(10.0),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                Icons.filter_list,
                size: 20,
                color: _selectedCategories.isNotEmpty
                    ? colorScheme.onPrimary
                    : colorScheme.onSurfaceVariant,
              ),
              const SizedBox(width: 8),
              Text(
                l10n.filterByCategory,
                style: textTheme.labelLarge?.copyWith(
                  color: _selectedCategories.isNotEmpty
                      ? colorScheme.onPrimary
                      : colorScheme.onSurfaceVariant,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/routines_screen.dart =====

// lib/screens/routines_screen.dart (Final & De-Materialisiert - Korrigiert)

import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/screens/edit_routine_screen.dart';
import 'package:lightweight/screens/live_workout_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/global_app_bar.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';

class RoutinesScreen extends StatefulWidget {
  final int? initialRoutineId;
  const RoutinesScreen({super.key, this.initialRoutineId});
  @override
  State<RoutinesScreen> createState() => _RoutinesScreenState();
}

class _RoutinesScreenState extends State<RoutinesScreen> {
  bool _isLoading = true;
  List<Routine> _routines = [];
  // final l10n wurde entfernt, da es in didChangeDependencies instanziiert wird

  @override
  void initState() {
    super.initState();
    // _loadRoutines wird jetzt von didChangeDependencies aufgerufen
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Sicherstellen, dass l10n verfügbar ist, bevor _loadRoutines aufgerufen wird.
    // l10n wird hier instanziiert, wo context sicher verfügbar ist.
    _loadRoutines(AppLocalizations.of(context)!);
  }

  Future<void> _loadRoutines(AppLocalizations l10n) async {
    // l10n als Parameter hinzugefügt
    setState(() => _isLoading = true);
    final data = await WorkoutDatabaseHelper.instance.getAllRoutines();
    if (mounted) {
      setState(() {
        _routines = data;
        _isLoading = false;
      });
      // Wenn eine initialRoutineId übergeben wurde, direkt dorthin navigieren
      if (widget.initialRoutineId != null) {
        final routineToEdit = _routines.firstWhere(
          (r) => r.id == widget.initialRoutineId,
          orElse: () => throw Exception(l10n.errorRoutineNotFound),
        ); // l10n hier verwenden
        WidgetsBinding.instance.addPostFrameCallback((_) {
          Navigator.of(context)
              .push(
                MaterialPageRoute(
                  builder: (context) =>
                      EditRoutineScreen(routine: routineToEdit),
                ),
              )
              .then((_) => _loadRoutines(l10n)); // l10n hier übergeben
        });
      }
    }
  }

  void _startWorkout(Routine routine) async {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const Center(child: CircularProgressIndicator()),
    );
    final fullRoutine = await WorkoutDatabaseHelper.instance.getRoutineById(
      routine.id!,
    );
    final newWorkoutLog = await WorkoutDatabaseHelper.instance.startWorkout(
      routineName: routine.name,
    );
    if (!mounted) return;
    Navigator.of(context).pop();
    if (fullRoutine != null) {
      final l10n = AppLocalizations.of(context)!; // l10n im Build-Kontext holen
      Navigator.of(context)
          .push(
            MaterialPageRoute(
              builder: (context) => LiveWorkoutScreen(
                routine: fullRoutine,
                workoutLog: newWorkoutLog,
              ),
            ),
          )
          .then((_) => _loadRoutines(l10n)); // l10n hier übergeben
    }
  }

  void _startEmptyWorkout() async {
    final l10n = AppLocalizations.of(context)!;
    final newWorkoutLog = await WorkoutDatabaseHelper.instance.startWorkout(
      routineName: l10n.freeWorkoutTitle,
    );
    if (!mounted) return;
    Navigator.of(context)
        .push(
          MaterialPageRoute(
            builder: (context) => LiveWorkoutScreen(workoutLog: newWorkoutLog),
          ),
        )
        .then((_) => _loadRoutines(l10n)); // l10n hier übergeben
  }

  void _createNewRoutine() {
    final l10n = AppLocalizations.of(context)!; // l10n im Build-Kontext holen
    Navigator.of(context)
        .push(
          MaterialPageRoute(builder: (context) => const EditRoutineScreen()),
        )
        .then((_) => _loadRoutines(l10n)); // l10n hier übergeben
  }

  // NEUE METHODEN FÜR DAS MENÜ
  void _duplicateRoutine(int routineId) async {
    await WorkoutDatabaseHelper.instance.duplicateRoutine(routineId);
    final l10n = AppLocalizations.of(context)!; // l10n im Build-Kontext holen
    _loadRoutines(l10n); // l10n hier übergeben
  }

  // 1. Die Methode für das Menü
  void _deleteRoutine(BuildContext context, Routine routine) async {
    final l10n = AppLocalizations.of(context)!;
    // NEU: Helper
    final confirmed = await showDeleteConfirmation(
      context,
      content: l10n.deleteRoutineConfirmContent(routine.name),
    );

    if (confirmed) {
      await WorkoutDatabaseHelper.instance.deleteRoutine(routine.id!);
      _loadRoutines(l10n);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final textTheme = Theme.of(context).textTheme; // Hier definiert

    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      extendBodyBehindAppBar: true,
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: GlobalAppBar(
        title: l10n.workoutRoutinesTitle,
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _routines.isEmpty
              ? _buildEmptyState(context, l10n, textTheme)
              : ListView.builder(
                  padding: DesignConstants.cardPadding.copyWith(
                    top: DesignConstants.cardPadding.top + topPadding,
                  ),
                  itemCount: _routines.length + 1, // statt +2
                  itemBuilder: (context, index) {
                    if (index == 0) {
                      return _buildStartEmptyWorkoutCard(context, l10n);
                    }
                    final routine = _routines[index - 1];
                    return Dismissible(
                      key: Key('routine_${routine.id}'),
                      direction: DismissDirection.endToStart,

                      // gleiche Hintergründe wie im Nutrition Screen
                      background: const SwipeActionBackground(
                        color: Colors.redAccent,
                        icon: Icons.delete,
                        alignment: Alignment.centerRight,
                      ),

                      // Swipe-Logik wie bei Nutrition:
                      // links→rechts = Edit (nicht wirklich dismissen),
                      // rechts→links = Delete (mit Bestätigung)
                      confirmDismiss: (direction) async {
                        // NEU: Helper
                        return await showDeleteConfirmation(context);
                      },

                      onDismissed: (direction) {
                        if (direction == DismissDirection.endToStart) {
                          _deleteRoutine(context, routine); // wirklich löschen
                        }
                      },

                      child: SummaryCard(
                        child: ListTile(
                          leading: ElevatedButton(
                            onPressed: () => _startWorkout(routine),
                            child: Text(l10n.startButton),
                          ),
                          title: Text(
                            routine.name,
                            style: const TextStyle(fontWeight: FontWeight.bold),
                          ),
                          subtitle: Text(l10n.editRoutineSubtitle),
                          trailing: PopupMenuButton<String>(
                            icon: Icon(
                              Icons.more_vert,
                              color: textTheme.bodyMedium?.color,
                            ),
                            onSelected: (value) {
                              if (value == 'duplicate') {
                                _duplicateRoutine(routine.id!);
                              } else if (value == 'delete') {
                                _deleteRoutine(context, routine);
                              }
                            },
                            itemBuilder: (BuildContext context) =>
                                <PopupMenuEntry<String>>[
                              PopupMenuItem<String>(
                                value: 'duplicate',
                                child: Text(l10n.duplicate),
                              ),
                              PopupMenuItem<String>(
                                value: 'delete',
                                child: Text(l10n.delete),
                              ),
                            ],
                          ),
                          onTap: () {
                            Navigator.of(context)
                                .push(
                                  MaterialPageRoute(
                                    builder: (context) =>
                                        EditRoutineScreen(routine: routine),
                                  ),
                                )
                                .then(
                                  (_) => _loadRoutines(l10n),
                                ); // l10n hier übergeben
                          },
                        ),
                      ),
                    );
                  },
                ),
      floatingActionButton: GlassFab(
        label: l10n.addRoutineButton,
        onPressed: _createNewRoutine,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  // KORREKTUR 5: _buildStartEmptyWorkoutCard als SummaryCard-Button
  Widget _buildStartEmptyWorkoutCard(
    BuildContext context,
    AppLocalizations l10n,
  ) {
    return SummaryCard(
      child: ListTile(
        leading: const Icon(Icons.play_circle_fill),
        title: Text(
          l10n.startEmptyWorkoutButton,
          style: const TextStyle(fontWeight: FontWeight.bold),
        ),
        onTap: _startEmptyWorkout,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(DesignConstants.borderRadiusM),
        ),
      ),
    );
  }

  // In RoutinesScreen: _buildEmptyState ersetzen/erweitern

  Widget _buildEmptyState(
    BuildContext context,
    AppLocalizations l10n,
    TextTheme textTheme,
  ) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.list_alt_outlined,
              size: 80,
              color: Colors.grey.shade400,
            ),
            const SizedBox(height: DesignConstants.spacingL),
            Text(
              l10n.emptyRoutinesTitle,
              style: textTheme.headlineSmall,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: DesignConstants.spacingS),
            Text(
              l10n.emptyRoutinesSubtitle,
              textAlign: TextAlign.center,
              style: textTheme.bodyLarge?.copyWith(color: Colors.grey.shade600),
            ),
            const SizedBox(height: DesignConstants.spacingXL),

            // Bestehender Button: Routine erstellen
            ElevatedButton.icon(
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(
                  horizontal: 24,
                  vertical: 12,
                ),
              ),
              onPressed: _createNewRoutine,
              icon: const Icon(Icons.add),
              label: Text(
                l10n.createFirstRoutineButton,
                style: textTheme.titleMedium?.copyWith(
                  color: Theme.of(context).colorScheme.onPrimary,
                ),
              ),
            ),

            const SizedBox(height: DesignConstants.spacingM),

            // NEU: Freies Training starten (sichtbar auch im Empty-State)
            OutlinedButton.icon(
              style: OutlinedButton.styleFrom(
                padding: const EdgeInsets.symmetric(
                  horizontal: 24,
                  vertical: 12,
                ),
              ),
              onPressed: _startEmptyWorkout,
              icon: const Icon(Icons.play_circle_fill),
              label: Text(l10n.startEmptyWorkoutButton),
            ),
          ],
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/live_workout_screen.dart =====

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/models/routine_exercise.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/services/workout_session_manager.dart';
import 'package:lightweight/widgets/wger_attribution_widget.dart';
import 'package:lightweight/widgets/workout_summary_bar.dart';
import 'exercise_catalog_screen.dart';
import 'exercise_detail_screen.dart';
import 'package:provider/provider.dart';
import 'package:lightweight/screens/workout_summary_screen.dart';
import 'package:lightweight/widgets/workout_card.dart';

class LiveWorkoutScreen extends StatefulWidget {
  final Routine? routine;
  final WorkoutLog workoutLog;

  const LiveWorkoutScreen({super.key, this.routine, required this.workoutLog});

  @override
  State<LiveWorkoutScreen> createState() => _LiveWorkoutScreenState();
}

class _LiveWorkoutScreenState extends State<LiveWorkoutScreen> {
  final Map<int, TextEditingController> _weightControllers = {};
  final Map<int, TextEditingController> _repsControllers = {};
  final Map<String, List<SetLog>> _lastPerformances = {};
  bool _isLoading = true;

  // Definieren wir den Listener hier, damit er im ganzen State bekannt ist
  late final VoidCallback _onManagerUpdateCallback;

  @override
  void initState() {
    super.initState();
    // Der Listener wird jetzt einer Variable zugewiesen
    _onManagerUpdateCallback = () {
      if (mounted) {
        final manager = Provider.of<WorkoutSessionManager>(
          context,
          listen: false,
        );
        _syncControllersWithManager(manager);
        // setState() wird hier benötigt, um UI-Änderungen zu triggern,
        // die nicht von Controllern abgedeckt sind (z.B. ein neu hinzugefügter Satz)
        setState(() {});
      }
    };

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _initializeScreen();
      // Der Listener wird registriert
      Provider.of<WorkoutSessionManager>(
        context,
        listen: false,
      ).addListener(_onManagerUpdateCallback);
    });
  }

  // NEUE, KORREKTE dispose-Methode
  @override
  void dispose() {
    // Wir greifen direkt auf die Singleton-Instanz zu, ohne den "context" zu nutzen.
    WorkoutSessionManager().removeListener(_onManagerUpdateCallback);
    _clearControllers();
    super.dispose();
  }

  Future<void> _initializeScreen() async {
    final manager = Provider.of<WorkoutSessionManager>(context, listen: false);
    List<RoutineExercise> exercisesToInit = [];

    if (!manager.isActive) {
      exercisesToInit = widget.routine?.exercises ?? [];
      manager.startWorkout(widget.workoutLog, exercisesToInit);
    } else {
      exercisesToInit = manager.exercises;
    }

    // Lade die "Last Time"-Daten für alle Übungen, die bereits im Workout sind
    for (var re in exercisesToInit) {
      final lastSets = await WorkoutDatabaseHelper.instance
          .getLastSetsForExercise(re.exercise.nameEn);
      if (mounted) {
        _lastPerformances[re.exercise.nameEn] = lastSets;
      }
    }

    _syncControllersWithManager(manager);
    if (mounted) {
      //manager.addListener(_onManagerUpdate);
      setState(() => _isLoading = false);
    }
  }

  void _syncControllersWithManager(WorkoutSessionManager manager) {
    manager.setLogs.forEach((templateId, setLog) {
      if (!_weightControllers.containsKey(templateId)) {
        _weightControllers[templateId] = TextEditingController(
          text: setLog.weightKg?.toStringAsFixed(1).replaceAll('.0', '') ?? '',
        );
        _repsControllers[templateId] = TextEditingController(
          text: setLog.reps?.toString() ?? '',
        );

        _weightControllers[templateId]!.addListener(() {
          final currentManagerValue = manager.setLogs[templateId]?.weightKg;
          final controllerText = _weightControllers[templateId]!.text;
          final controllerValue = double.tryParse(
            controllerText.replaceAll(',', '.'),
          );

          // Nur updaten, wenn sich der WERT tatsächlich geändert hat, oder das Feld leer ist.
          if (controllerValue != currentManagerValue) {
            // Wenn das Feld leer ist, senden wir 0.0, um den Wert im Manager zurückzusetzen.
            manager.updateSet(templateId, weight: controllerValue ?? 0.0);
          }
        });

        _repsControllers[templateId]!.addListener(() {
          final currentManagerValue = manager.setLogs[templateId]?.reps;
          final controllerText = _repsControllers[templateId]!.text;
          final controllerValue = int.tryParse(controllerText);

          if (controllerValue != currentManagerValue) {
            manager.updateSet(templateId, reps: controllerValue ?? 0);
          }
        });
      } else {
        // Hier ist die entscheidende Änderung:
        // Setze den Controller-Text nur, wenn das Feld NICHT den Fokus hat.
        // Das verhindert, dass der Wert beim Tippen zurückspringt.
        final weightText = setLog.weightKg == 0
            ? ''
            : setLog.weightKg?.toStringAsFixed(1).replaceAll('.0', '') ?? '';
        final repsText = setLog.reps == 0 ? '' : setLog.reps?.toString() ?? '';

        if (_weightControllers[templateId]!.text != weightText) {
          _weightControllers[templateId]!.text = weightText;
        }
        if (_repsControllers[templateId]!.text != repsText) {
          _repsControllers[templateId]!.text = repsText;
        }
      }
    });

    final toRemove = _weightControllers.keys
        .where((id) => !manager.setLogs.containsKey(id))
        .toList();
    for (final id in toRemove) {
      _weightControllers.remove(id)?.dispose();
      _repsControllers.remove(id)?.dispose();
    }
  }

  void _clearControllers() {
    for (var c in _weightControllers.values) {
      c.dispose();
    }
    for (var c in _repsControllers.values) {
      c.dispose();
    }
    _weightControllers.clear();
    _repsControllers.clear();
  }

  Future<void> _finishWorkout() async {
    final l10n = AppLocalizations.of(context)!;
    final manager = Provider.of<WorkoutSessionManager>(context, listen: false);

    final bool? confirmed = await showGlassBottomMenu<bool>(
      context: context,
      title: l10n.finishWorkoutButton, // "Beenden"
      contentBuilder: (ctx, close) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8.0),
              child: Text(
                l10n.dialogFinishWorkoutBody,
                textAlign: TextAlign.center,
              ),
            ),
            const SizedBox(height: 24),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () {
                      close();
                      Navigator.of(ctx).pop(false);
                    },
                    child: Text(l10n.cancel),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton(
                    onPressed: () {
                      close();
                      Navigator.of(ctx).pop(true);
                    },
                    child: Text(l10n.finishWorkoutButton),
                  ),
                ),
              ],
            ),
          ],
        );
      },
    );

    if (confirmed == true && mounted) {
      final logId = manager.workoutLog?.id;
      await manager.finishWorkout();
      if (mounted && logId != null) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(
            builder: (context) => WorkoutSummaryScreen(logId: logId),
          ),
        );
      }
    }
  }

  void _onReorder(int oldIndex, int newIndex) {
    Provider.of<WorkoutSessionManager>(
      context,
      listen: false,
    ).reorderExercise(oldIndex, newIndex);
  }

/*
  void _editPauseTime(RoutineExercise routineExercise) async {
    final l10n = AppLocalizations.of(context)!;
    final manager = Provider.of<WorkoutSessionManager>(context, listen: false);
    final currentPause = manager.pauseTimes[routineExercise.id!];

    final controller = TextEditingController(
      text: currentPause?.toString() ?? '',
    );
    final result = await showDialog<int?>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.editPauseTimeTitle),
        content: TextField(
          controller: controller,
          keyboardType: TextInputType.number,
          decoration: InputDecoration(labelText: l10n.pauseInSeconds),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(),
            child: Text(l10n.cancel),
          ),
          FilledButton(
            onPressed: () =>
                Navigator.of(ctx).pop(int.tryParse(controller.text)),
            child: Text(l10n.save),
          ),
        ],
      ),
    );
    if (result != null) {
      manager.updatePauseTime(routineExercise.id!, result);
    }
  }
*/
  void _removeExercise(RoutineExercise exerciseToRemove) {
    Provider.of<WorkoutSessionManager>(
      context,
      listen: false,
    ).removeExercise(exerciseToRemove.id!);
  }

  void _addExercise() async {
    final manager = Provider.of<WorkoutSessionManager>(context, listen: false);
    final selectedExercise = await Navigator.of(context).push<Exercise>(
      MaterialPageRoute(
        builder: (context) =>
            const ExerciseCatalogScreen(isSelectionMode: true),
      ),
    );

    if (selectedExercise != null) {
      // Lade "Last Time"-Daten für die NEUE Übung
      final lastSets = await WorkoutDatabaseHelper.instance
          .getLastSetsForExercise(selectedExercise.nameEn);
      if (mounted) {
        setState(() {
          _lastPerformances[selectedExercise.nameEn] = lastSets;
        });
      }
      await manager.addExercise(selectedExercise);
    }
  }

  void _addSet(RoutineExercise re) {
    Provider.of<WorkoutSessionManager>(
      context,
      listen: false,
    ).addSetToExercise(re.id!);
  }

  void _removeSet(int templateId) {
    Provider.of<WorkoutSessionManager>(
      context,
      listen: false,
    ).removeSet(templateId);
  }

  void _changeSetType(int templateId, String newType) {
    Provider.of<WorkoutSessionManager>(
      context,
      listen: false,
    ).updateSet(templateId, setType: newType);
  }

  void _showSetTypePicker(int templateId) {
    final l10n = AppLocalizations.of(context)!;

    // Helfer zum Erstellen des Buchstaben-Widgets
    Widget buildSymbol(String char, Color color) {
      return Text(
        char,
        style: TextStyle(
          color: color,
          fontSize: 20,
          fontWeight: FontWeight.bold,
        ),
      );
    }

    final options = [
      {
        'type': 'normal',
        'label': l10n.set_type_normal,
        // Wir nutzen 'N' für Normal im Menü, oder einfach leer lassen wenn du willst
        'symbol': buildSymbol('N', Colors.grey)
      },
      {
        'type': 'warmup',
        'label': l10n.set_type_warmup,
        'symbol': buildSymbol('W', Colors.orange)
      },
      {
        'type': 'failure',
        'label': l10n.set_type_failure,
        'symbol': buildSymbol('F', Colors.red)
      },
      {
        'type': 'dropset',
        'label': l10n.set_type_dropset,
        'symbol': buildSymbol('D', Colors.blue)
      },
    ];

    showGlassBottomMenu(
      context: context,
      title: l10n.changeSetTypTitle,
      actions: options.map((opt) {
        return GlassMenuAction(
          // icon: null, // Brauchen wir nicht mehr
          customIcon:
              opt['symbol'] as Widget, // <-- Hier übergeben wir das Text-Widget
          label: opt['label'] as String,
          onTap: () => _changeSetType(templateId, opt['type'] as String),
        );
      }).toList(),
    );
  }

  void _editPauseTime(RoutineExercise routineExercise) async {
    final l10n = AppLocalizations.of(context)!;
    final manager = Provider.of<WorkoutSessionManager>(context, listen: false);
    final currentPause = manager.pauseTimes[routineExercise.id!];
    final controller =
        TextEditingController(text: currentPause?.toString() ?? '');

    final result = await showGlassBottomMenu<int?>(
      context: context,
      title: l10n.editPauseTimeTitle,
      contentBuilder: (ctx, close) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: controller,
              keyboardType: TextInputType.number,
              autofocus: true,
              decoration: InputDecoration(
                labelText: l10n.pauseInSeconds,
                hintText: "z.B. 90",
                suffixText: "s",
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () {
                      close();
                      Navigator.of(ctx).pop(null);
                    },
                    child: Text(l10n.cancel),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton(
                    onPressed: () {
                      final val = int.tryParse(controller.text);
                      close();
                      Navigator.of(ctx).pop(val);
                    },
                    child: Text(l10n.save),
                  ),
                ),
              ],
            ),
          ],
        );
      },
    );

    if (result != null) {
      manager.updatePauseTime(routineExercise.id!, result);
    }
  }

  // NEUE HELFER-METHODE für den leeren Zustand
  Widget _buildEmptyState(AppLocalizations l10n) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.add_circle_outline,
              size: 80,
              color: Colors.grey.shade400,
            ),
            const SizedBox(height: DesignConstants.spacingL),
            Text(
              l10n.emptyStateAddFirstExercise,
              style: Theme.of(context).textTheme.headlineSmall,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: DesignConstants.spacingS),
            Text(
              "Füge eine Übung hinzu, um mit dem Protokollieren zu beginnen.", // TODO: l10n
              textAlign: TextAlign.center,
              style: Theme.of(
                context,
              ).textTheme.bodyLarge?.copyWith(color: Colors.grey.shade600),
            ),
            const SizedBox(height: DesignConstants.spacingXL),
            ElevatedButton.icon(
              onPressed: _addExercise,
              icon: const Icon(Icons.add),
              label: Text(l10n.fabAddExercise),
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final textTheme = Theme.of(context).textTheme;
    final colorScheme = Theme.of(context).colorScheme;
    final manager = Provider.of<WorkoutSessionManager>(context);
    void editPauseTime(RoutineExercise routineExercise) async {
      final l10n = AppLocalizations.of(context)!;
      final manager =
          Provider.of<WorkoutSessionManager>(context, listen: false);
      final currentPause = manager.pauseTimes[routineExercise.id!];
      final controller =
          TextEditingController(text: currentPause?.toString() ?? '');

      final result = await showGlassBottomMenu<int?>(
        context: context,
        title: l10n.editPauseTimeTitle,
        contentBuilder: (ctx, close) {
          return Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                controller: controller,
                keyboardType: TextInputType.number,
                autofocus: true,
                decoration: InputDecoration(
                  labelText: l10n.pauseInSeconds,
                  hintText: "z.B. 90",
                  suffixText: "s",
                ),
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed: () {
                        close();
                        Navigator.of(ctx).pop(null);
                      },
                      child: Text(l10n.cancel),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: FilledButton(
                      onPressed: () {
                        final val = int.tryParse(controller.text);
                        close();
                        Navigator.of(ctx).pop(val);
                      },
                      child: Text(l10n.save),
                    ),
                  ),
                ],
              ),
            ],
          );
        },
      );

      if (result != null) {
        manager.updatePauseTime(routineExercise.id!, result);
      }
    }

    final mgr = manager;

    // geplante/angelegte Sets = Anzahl aller SetLogs (egal ob erledigt)
    final int planned = mgr.setLogs.length;

    // erledigte Sets = isCompleted == true
    final int completed =
        mgr.setLogs.values.where((s) => s.isCompleted == true).length;

    final double progress = planned == 0 ? 0.0 : completed / planned;

    // NEU: Synchronisiere die Controller bei jedem Build
    // Das ersetzt den alten Listener und ist sicher.
    if (!_isLoading) {
      _syncControllersWithManager(manager);
    }

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        automaticallyImplyLeading: true,
        elevation: 0,
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        scrolledUnderElevation: 0,
        centerTitle: false,
        title: Text(
          manager.workoutLog?.routineName ?? l10n.freeWorkoutTitle,
          style: Theme.of(
            context,
          ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w900),
        ),
        actions: [
          TextButton(
            onPressed: _finishWorkout,
            child: Text(
              l10n.finishWorkoutButton,
              style: TextStyle(
                color: Theme.of(context).colorScheme.primary,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : Column(
              children: [
                WorkoutSummaryBar(
                  duration: mgr.elapsedDuration,
                  volume: mgr.totalVolume,
                  sets:
                      planned, // oder mgr.totalSets, falls das *geplante* Sets sind
                  progress: progress, // LIVE: echter Fortschritt
                ),
                Divider(
                  height: 1,
                  thickness: 1,
                  color: Theme.of(
                    context,
                  ).colorScheme.onSurfaceVariant.withOpacity(0.1),
                ),
                Expanded(
                  child: manager.exercises.isEmpty
                      ? _buildEmptyState(l10n)
                      : ReorderableListView.builder(
                          padding: const EdgeInsets.only(
                              bottom: DesignConstants.bottomContentSpacer),
                          onReorder: _onReorder,
                          itemCount: manager.exercises.length,
                          itemBuilder: (context, index) {
                            final routineExercise = manager.exercises[index];
                            return WorkoutCard(
                              key: ValueKey(routineExercise.id),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  ListTile(
                                    contentPadding: const EdgeInsets.symmetric(
                                      horizontal: 16.0,
                                      vertical: 8.0,
                                    ),
                                    leading: ReorderableDragStartListener(
                                      index: index,
                                      child: const Icon(Icons.drag_handle),
                                    ),
                                    title: InkWell(
                                      onTap: () => Navigator.of(context).push(
                                        MaterialPageRoute(
                                          builder: (context) =>
                                              ExerciseDetailScreen(
                                            exercise: routineExercise.exercise,
                                          ),
                                        ),
                                      ),
                                      child: Padding(
                                        padding: const EdgeInsets.symmetric(
                                          vertical: 4.0,
                                        ),
                                        child: Text(
                                          routineExercise.exercise
                                              .getLocalizedName(context),
                                          style: textTheme.titleLarge?.copyWith(
                                            fontWeight: FontWeight.bold,
                                          ),
                                        ),
                                      ),
                                    ),
                                    // NEUER, KORRIGIERTER trailing-Block
                                    trailing: Row(
                                      mainAxisSize: MainAxisSize.min,
                                      children: [
                                        // Zeigt die eingestellte Pausenzeit an
                                        if (manager.pauseTimes[
                                                    routineExercise.id!] !=
                                                null &&
                                            manager.pauseTimes[
                                                    routineExercise.id!]! >
                                                0)
                                          Padding(
                                            padding: const EdgeInsets.only(
                                              right: 4.0,
                                            ),
                                            child: Text(
                                              "${manager.pauseTimes[routineExercise.id!]}s",
                                              style: textTheme.bodyMedium
                                                  ?.copyWith(
                                                color: colorScheme.primary,
                                                fontWeight: FontWeight.bold,
                                              ),
                                            ),
                                          ),
                                        IconButton(
                                          icon: const Icon(
                                            Icons.timer_outlined,
                                          ),
                                          tooltip: l10n.editPauseTime,
                                          onPressed: () =>
                                              editPauseTime(routineExercise),
                                        ),
                                        IconButton(
                                          icon: const Icon(
                                            Icons.delete_outline,
                                            color: Colors.redAccent,
                                          ),
                                          tooltip: l10n.removeExercise,
                                          onPressed: () =>
                                              _removeExercise(routineExercise),
                                        ),
                                      ],
                                    ),
                                  ),
                                  Padding(
                                    padding: const EdgeInsets.symmetric(
                                      horizontal: 0.0,
                                    ),
                                    child: Column(
                                      crossAxisAlignment:
                                          CrossAxisAlignment.start,
                                      children: [
                                        Row(
                                          crossAxisAlignment:
                                              CrossAxisAlignment.center,
                                          children: [
                                            Expanded(
                                              flex: 2,
                                              child: Center(
                                                child: Text(
                                                  l10n.setLabel,
                                                  textAlign: TextAlign.center,
                                                  style: TextStyle(
                                                    color: Colors.grey[600],
                                                    fontSize: 12,
                                                    fontWeight: FontWeight.bold,
                                                  ),
                                                ),
                                              ),
                                            ),
                                            Expanded(
                                              flex: 3,
                                              child: Center(
                                                child: Text(
                                                  l10n.lastTimeLabel,
                                                  textAlign: TextAlign.center,
                                                  style: TextStyle(
                                                    color: Colors.grey[600],
                                                    fontSize: 12,
                                                    fontWeight: FontWeight.bold,
                                                  ),
                                                ),
                                              ),
                                            ),
                                            Expanded(
                                              flex: 2,
                                              child: Center(
                                                child: Text(
                                                  l10n.kgLabel,
                                                  textAlign: TextAlign.center,
                                                  style: TextStyle(
                                                    color: Colors.grey[600],
                                                    fontSize: 12,
                                                    fontWeight: FontWeight.bold,
                                                  ),
                                                ),
                                              ),
                                            ),
                                            Expanded(
                                              flex: 2,
                                              child: Center(
                                                child: Text(
                                                  l10n.repsLabel,
                                                  textAlign: TextAlign.center,
                                                  style: TextStyle(
                                                    color: Colors.grey[600],
                                                    fontSize: 12,
                                                    fontWeight: FontWeight.bold,
                                                  ),
                                                ),
                                              ),
                                            ),
                                            const SizedBox(width: 48),
                                          ],
                                        ),
                                        ...routineExercise.setTemplates
                                            .asMap()
                                            .entries
                                            .map((setEntry) {
                                          final templateId = setEntry.value.id!;
                                          final setLog =
                                              manager.setLogs[templateId];
                                          if (setLog == null) {
                                            return const SizedBox.shrink();
                                          }
                                          int workingSetIndex = 0;
                                          for (int i = 0;
                                              i <= setEntry.key;
                                              i++) {
                                            final currentTemplateId =
                                                routineExercise
                                                    .setTemplates[i].id!;
                                            if (manager
                                                    .setLogs[currentTemplateId]
                                                    ?.setType !=
                                                'warmup') {
                                              workingSetIndex++;
                                            }
                                          }
                                          return _buildSetRow(
                                            workingSetIndex,
                                            setEntry.key,
                                            templateId,
                                            setLog,
                                            _lastPerformances[routineExercise
                                                    .exercise.nameEn] ??
                                                [], // Hier die Liste übergeben
                                          );
                                        }),
                                        Padding(
                                          padding: const EdgeInsets.symmetric(
                                            horizontal: 16.0,
                                          ),
                                          child: TextButton.icon(
                                            onPressed: () =>
                                                _addSet(routineExercise),
                                            icon: const Icon(Icons.add),
                                            label: Text(l10n.addSetButton),
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                                ],
                              ),
                            );
                          },
                        ),
                ),
              ],
            ),
      // KORRIGIERT: label hinzugefügt
      floatingActionButton: GlassFab(
        label: l10n.fabAddExercise,
        onPressed: _addExercise,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
      // NEUER, KORREKTER bottomNavigationBar
      bottomNavigationBar: Column(
        mainAxisSize:
            MainAxisSize.min, // Wichtig: Nimmt nur so viel Höhe wie nötig
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          // 1. Dein bestehender AnimatedBuilder für die Rest-Timer-Bar
          AnimatedBuilder(
            animation: manager,
            builder: (context, _) {
              final bar = _buildRestBottomBar(l10n, colorScheme, manager);
              return bar ?? const SizedBox.shrink();
            },
          ),
          // 2. Das Wger-Widget direkt darunter (nur wenn kein Timer läuft)
          if (manager.remainingRestSeconds <= 0 && !manager.showRestDone)
            Padding(
              padding: const EdgeInsets.only(bottom: 8.0),
              child: WgerAttributionWidget(
                textStyle: textTheme.bodySmall?.copyWith(
                  color: Colors.grey[600],
                ),
              ),
            ),
        ],
      ),
    );
  }

  // Ersetze diese Methode im _LiveWorkoutScreenState

  Widget _buildSetRow(
    int setIndex,
    int rowIndex,
    int templateId,
    SetLog setLog,
    List<SetLog> lastPerfSets, // Nimmt jetzt eine Liste entgegen
  ) {
    final manager = Provider.of<WorkoutSessionManager>(context, listen: false);
    final isCompleted = setLog.isCompleted ?? false;
    final isLightMode = Theme.of(context).brightness == Brightness.light;
    final bool isColoredRow = rowIndex > 0 && rowIndex.isOdd;
    final Color rowColor = isColoredRow
        ? (isLightMode
            ? Colors.grey.withOpacity(0.1)
            : Colors.white.withOpacity(0.1))
        : Colors.transparent;

    // Finde den korrespondierenden Satz vom letzten Mal
    SetLog? lastPerf;
    if (rowIndex < lastPerfSets.length) {
      lastPerf = lastPerfSets[rowIndex];
    }

    final rowContent = Row(
      children: [
        Expanded(
          flex: 2,
          child: Center(
            child: GestureDetector(
              onTap: () => isCompleted ? null : _showSetTypePicker(templateId),
              child: Text(
                _getSetDisplayText(setLog.setType, setIndex),
                style: TextStyle(
                  color: _getSetTypeColor(setLog.setType),
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
        ),
        Expanded(
          flex: 3,
          child: Text(
            lastPerf != null
                ? "${lastPerf.weightKg?.toStringAsFixed(1).replaceAll('.0', '')}kg × ${lastPerf.reps}"
                : "-",
            textAlign: TextAlign.center,
            style: TextStyle(color: Colors.grey[500], fontSize: 12),
          ),
        ),
        Expanded(
          flex: 2,
          child: TextFormField(
            controller: _weightControllers[templateId],
            textAlign: TextAlign.center,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            decoration: const InputDecoration(
              border: InputBorder.none,
              isDense: true,
              fillColor: Colors.transparent,
            ),
            enabled: !isCompleted,
          ),
        ),
        const SizedBox(width: 8),
        Expanded(
          flex: 2,
          child: TextFormField(
            controller: _repsControllers[templateId],
            textAlign: TextAlign.center,
            keyboardType: TextInputType.number,
            decoration: const InputDecoration(
              border: InputBorder.none,
              isDense: true,
              fillColor: Colors.transparent,
            ),
            enabled: !isCompleted,
          ),
        ),
        Padding(
          padding: const EdgeInsets.only(right: 8.0),
          child: SizedBox(
            width: 48,
            child: IconButton(
              icon: Icon(
                isCompleted ? Icons.check_circle : Icons.check_circle_outline,
                color: isCompleted ? Colors.green : Colors.grey,
              ),
              onPressed: () {
                manager.updateSet(templateId, isCompleted: !isCompleted);
              },
            ),
          ),
        ),
      ],
    );

    return Dismissible(
      key: ValueKey('set_$templateId'),
      direction:
          isCompleted ? DismissDirection.none : DismissDirection.endToStart,
      onDismissed: (_) => _removeSet(templateId),
      background: Container(
        color: Colors.redAccent,
        alignment: Alignment.centerRight,
        padding: const EdgeInsets.symmetric(horizontal: 20),
        child: const Icon(Icons.delete, color: Colors.white),
      ),
      child: Stack(
        children: [
          Positioned.fill(
            child: Container(
              color: isCompleted ? Colors.green.withOpacity(0.2) : rowColor,
            ),
          ),
          rowContent,
        ],
      ),
    );
  }

  Widget? _buildRestBottomBar(
    AppLocalizations l10n,
    ColorScheme colorScheme,
    WorkoutSessionManager manager,
  ) {
    final isRunning = manager.remainingRestSeconds > 0;
    final isDoneBanner = !isRunning && manager.showRestDone;
    if (!isRunning && !isDoneBanner) return null;
    final theme = Theme.of(context);
    if (isRunning) {
      return BottomAppBar(
        color: colorScheme.surface,
        elevation: 0,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                "${l10n.restTimerLabel}: ${manager.remainingRestSeconds}s",
                style: theme.textTheme.titleLarge?.copyWith(
                  fontSize: 22,
                  fontWeight: FontWeight.w700,
                  color: colorScheme.primary,
                ),
              ),
              ElevatedButton(
                onPressed: () {
                  manager.cancelRest();
                },
                child: Text(l10n.skipButton),
              ),
            ],
          ),
        ),
      );
    }
    return BottomAppBar(
      color: Colors.green.shade600,
      elevation: 0,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            const Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 8),
                Text(
                  "Pause vorbei!",
                  style: TextStyle(
                    color: Colors.white,
                    fontWeight: FontWeight.w700,
                    fontSize: 18,
                  ),
                ),
              ],
            ),
            TextButton(
              onPressed: () {
                manager.cancelRest();
              },
              child: Text(
                l10n.snackbar_button_ok,
                style: const TextStyle(color: Colors.white),
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _getSetDisplayText(String setType, int setIndex) {
    switch (setType) {
      case 'warmup':
        return 'W';
      case 'failure':
        return 'F';
      case 'dropset':
        return 'D';
      default:
        return '$setIndex';
    }
  }

  Color _getSetTypeColor(String setType) {
    switch (setType) {
      case 'warmup':
        return Colors.orange;
      case 'dropset':
        return Colors.blue;
      case 'failure':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/manage_supplements_screen.dart =====

// lib/screens/manage_supplements_screen.dart
import 'package:flutter/material.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/screens/create_supplement_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/util/supplement_l10n.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/global_app_bar.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';

class ManageSupplementsScreen extends StatefulWidget {
  const ManageSupplementsScreen({super.key});

  @override
  State<ManageSupplementsScreen> createState() =>
      _ManageSupplementsScreenState();
}

class _ManageSupplementsScreenState extends State<ManageSupplementsScreen> {
  bool _isLoading = true;
  List<Supplement> _supplements = const [];

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    setState(() => _isLoading = true);
    final list = await DatabaseHelper.instance.getAllSupplements();
    if (!mounted) return;
    setState(() {
      _supplements = list;
      _isLoading = false;
    });
  }

  Future<void> _navigateToEdit(Supplement s) async {
    final changed = await Navigator.of(context).push<bool>(
      MaterialPageRoute(
        builder: (_) => CreateSupplementScreen(supplementToEdit: s),
      ),
    );
    if (changed == true) _load();
  }

// In lib/screens/manage_supplements_screen.dart

  Future<void> _delete(Supplement s) async {
    final l10n = AppLocalizations.of(context)!;
    try {
      final ok = await showGlassBottomMenu<bool>(
            context: context,
            title: l10n.deleteConfirmTitle,
            contentBuilder: (ctx, close) {
              return Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 8.0),
                    child: Text(
                      l10n.deleteConfirmContent, // oder spezieller Text für Supplements
                      textAlign: TextAlign.center,
                    ),
                  ),
                  const SizedBox(height: 24),
                  Row(
                    children: [
                      Expanded(
                        child: OutlinedButton(
                          onPressed: () {
                            close();
                            Navigator.of(ctx).pop(false);
                          },
                          child: Text(l10n.cancel),
                        ),
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: FilledButton(
                          style: FilledButton.styleFrom(
                              backgroundColor: Colors.red),
                          onPressed: () {
                            close();
                            Navigator.of(ctx).pop(true);
                          },
                          child: Text(l10n.delete),
                        ),
                      ),
                    ],
                  ),
                ],
              );
            },
          ) ??
          false;

      if (!ok) return;

      await DatabaseHelper.instance.deleteSupplement(s.id!);
      if (!mounted) return;
      _load();
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(l10n.deleted)));
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(l10n.operationNotAllowed)),
      );
    }
  }

  Widget _tile(Supplement s, AppLocalizations l10n) {
    final isBuiltin = s.isBuiltin || s.code == 'caffeine';
    final title = localizeSupplementName(s, l10n);

    final content = SummaryCard(
      child: ListTile(
        leading: const Icon(Icons.set_meal_outlined),
        title: Text(title),
        subtitle: (s.dailyGoal != null || s.dailyLimit != null)
            ? Text(
                [
                  if (s.dailyGoal != null)
                    '${l10n.dailyGoalLabel}: ${s.dailyGoal} ${s.unit}',
                  if (s.dailyLimit != null)
                    '${l10n.dailyLimitLabel}: ${s.dailyLimit} ${s.unit}',
                ].join('  •  '),
              )
            : null,
        trailing: isBuiltin ? null : const Icon(Icons.chevron_right),
        onTap: () => _navigateToEdit(s),
      ),
    );

    if (isBuiltin) return content;

    return Dismissible(
      key: Key('supp_${s.id}'),
      direction: DismissDirection.horizontal,
      background: const SwipeActionBackground(
        color: Colors.blueAccent,
        icon: Icons.edit,
        alignment: Alignment.centerLeft,
      ),
      secondaryBackground: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      confirmDismiss: (direction) async {
        if (direction == DismissDirection.startToEnd) {
          _navigateToEdit(s);
          return false;
        } else {
          _delete(s);
          return false;
        }
      },
      child: content,
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: GlobalAppBar(
        title: l10n.manageSupplementsTitle,
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : RefreshIndicator(
              onRefresh: _load,
              child: ListView(
                padding: DesignConstants.cardPadding.copyWith(
                  top: DesignConstants.cardPadding.top + topPadding,
                ),
                children: [
                  if (_supplements.isEmpty)
                    Padding(
                      padding: const EdgeInsets.symmetric(vertical: 16.0),
                      child: Text(
                        l10n.emptySupplements,
                        textAlign: TextAlign.center,
                      ),
                    )
                  else
                    ..._supplements.map((s) => _tile(s, l10n)),
                ],
              ),
            ),
      floatingActionButton: GlassFab(
        label: l10n.createSupplementTitle,
        onPressed: () async {
          final created = await Navigator.of(context).push<bool>(
            MaterialPageRoute(
              builder: (context) => const CreateSupplementScreen(),
            ),
          );
          if (created == true) _load();
        },
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/meal_screen.dart =====

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';
import 'package:lightweight/screens/food_detail_screen.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';

class MealScreen extends StatefulWidget {
  final Map<String, dynamic> meal; // erwartet: {id, name, notes}
  final bool startInEdit;

  const MealScreen({super.key, required this.meal, this.startInEdit = false});

  @override
  State<MealScreen> createState() => _MealScreenState();
}

class _MealScreenState extends State<MealScreen> {
  late TextEditingController _nameCtrl;
  late TextEditingController _notesCtrl;
  bool _editMode = false;
  bool _saving = false;

  List<Map<String, dynamic>> _items = [];
  bool _loadingItems = true;

  // Totals (werden bei jedem Build aus _items berechnet)
  int _totalKcal = 0;
  double _totalC = 0, _totalF = 0, _totalP = 0;

  @override
  void initState() {
    super.initState();
    _editMode = widget.startInEdit;
    _nameCtrl = TextEditingController(
      text: widget.meal['name'] as String? ?? '',
    );
    _notesCtrl = TextEditingController(
      text: widget.meal['notes'] as String? ?? '',
    );
    _loadItems();
  }

  @override
  void dispose() {
    _nameCtrl.dispose();
    _notesCtrl.dispose();
    super.dispose();
  }

  Future<void> _loadItems() async {
    setState(() => _loadingItems = true);
    final id = widget.meal['id'] as int;
    final rows = await DatabaseHelper.instance.getMealItems(id);
    _items = List<Map<String, dynamic>>.from(rows);
    await _recomputeTotals(); // initiale Totals
    if (mounted) setState(() => _loadingItems = false);
  }

  /// Rechnet die Summen für kcal / C / F / P einmal durch.
  Future<void> _recomputeTotals() async {
    int kcal = 0;
    double c = 0, f = 0, p = 0;

    for (final it in _items) {
      final bc = it['barcode'] as String;
      final qty = (it['quantity_in_grams'] as num?)?.toDouble() ?? 0.0;
      final fi = await ProductDatabaseHelper.instance.getProductByBarcode(bc);
      if (fi == null) continue;

      final factor = qty / 100.0;
      final itemKcal = (fi.calories ?? 0) * factor;
      final itemC = (fi.carbs ?? 0) * factor;
      final itemF = (fi.fat ?? 0) * factor;
      final itemP = (fi.protein ?? 0) * factor;

      kcal += itemKcal.round();
      c += itemC;
      f += itemF;
      p += itemP;
    }

    _totalKcal = kcal;
    _totalC = c;
    _totalF = f;
    _totalP = p;
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    final canSave =
        _nameCtrl.text.trim().isNotEmpty && _items.isNotEmpty && !_saving;

    // Floating Action Button je Modus
    Widget? fab;
    if (_editMode) {
      fab = GlassFab(
        label: l10n.mealAddIngredient, // „Zutat hinzufügen“
        onPressed: _addIngredientFlow,
      );
    } else {
      if (_items.isNotEmpty) {
        fab = GlassFab(
          label: l10n.mealsAddToDiary, // „Zum Tagebuch hinzufügen“
          onPressed: _addMealToDiaryFlow,
        );
      } else {
        fab = null;
      }
    }

    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: true,
        title: Text(
          _editMode
              ? l10n.mealsEdit // (L10n: du kannst das zu „Bearbeiten“ ändern)
              : (_nameCtrl.text.isNotEmpty
                  ? _nameCtrl.text
                  : l10n.mealsViewTitle),
          style: theme.textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.w900,
          ),
        ),
        actions: [
          if (_editMode)
            TextButton(
              onPressed: canSave ? _save : null,
              child: _saving
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : Text(
                      l10n.save,
                      style: TextStyle(
                        color: canSave
                            ? theme.colorScheme.primary
                            : theme.disabledColor,
                        fontWeight: FontWeight.w700,
                      ),
                    ),
            )
          else
            TextButton(
              onPressed: () => setState(() => _editMode = true),
              child: Text(
                l10n.mealsEdit,
                style: TextStyle(
                  color: theme.colorScheme.primary,
                  fontWeight: FontWeight.w700,
                ),
              ),
            ),
        ],
      ),
      floatingActionButton: fab,
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
      body: _loadingItems
          ? const Center(child: CircularProgressIndicator())
          : ListView(
              padding: const EdgeInsets.fromLTRB(16, 12, 16, 96),
              children: [
                // NAME & NOTIZEN
                SummaryCard(
                  child: Padding(
                    padding: const EdgeInsets.all(12),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        _editMode
                            ? TextField(
                                controller: _nameCtrl,
                                textInputAction: TextInputAction.done,
                                decoration: InputDecoration(
                                  labelText: l10n.mealNameLabel,
                                ),
                                onChanged: (_) => setState(() {}),
                              )
                            : Text(
                                _nameCtrl.text.isNotEmpty
                                    ? _nameCtrl.text
                                    : l10n.unknown,
                                style: theme.textTheme.titleMedium?.copyWith(
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                        const SizedBox(height: 8),
                        _editMode
                            ? TextField(
                                controller: _notesCtrl,
                                maxLines: 3,
                                decoration: InputDecoration(
                                  labelText: l10n.mealNotesLabel,
                                ),
                              )
                            : Text(
                                _notesCtrl.text.isNotEmpty
                                    ? _notesCtrl.text
                                    : l10n.noNotes,
                                style: theme.textTheme.bodyMedium?.copyWith(
                                  color: Colors.grey.shade600,
                                ),
                              ),
                      ],
                    ),
                  ),
                ),

                const SizedBox(height: 18),

                // === NÄHRWERTE (Gesamtsumme) ===
                _buildSectionTitle(context, l10n.nutritionSectionLabel),
                SummaryCard(
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 14,
                    ),
                    child: FutureBuilder<void>(
                      future: _recomputeTotals(),
                      builder: (_, __) {
                        return Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              _items.isEmpty ? '– kcal' : '$_totalKcal kcal',
                              style: theme.textTheme.headlineSmall?.copyWith(
                                fontWeight: FontWeight.w800,
                              ),
                            ),
                            const SizedBox(height: 6),
                            Wrap(
                              spacing: 16,
                              runSpacing: 6,
                              children: [
                                _MacroChip(
                                  label: 'C',
                                  value:
                                      _items.isEmpty ? '–' : _format1(_totalC),
                                  unit: 'g',
                                ),
                                _MacroChip(
                                  label: 'F',
                                  value:
                                      _items.isEmpty ? '–' : _format1(_totalF),
                                  unit: 'g',
                                ),
                                _MacroChip(
                                  label: 'P',
                                  value:
                                      _items.isEmpty ? '–' : _format1(_totalP),
                                  unit: 'g',
                                ),
                              ],
                            ),
                          ],
                        );
                      },
                    ),
                  ),
                ),

                const SizedBox(height: 18),

                // === ZUTATEN ===
                _buildSectionTitle(context, l10n.ingredientsCapsLock),

                if (_items.isEmpty)
                  Padding(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    child: Text(
                      l10n.emptyCategory,
                      textAlign: TextAlign.center,
                    ),
                  )
                else
                  Column(
                    children: List.generate(_items.length, (i) {
                      final it = _items[i];
                      return _IngredientCard(
                        key: ValueKey('ing_$i'),
                        item: it,
                        editMode: _editMode,
                        showPerIngredientMacros: !_editMode,
                        onQtyChanged: (val) async {
                          _items[i]['quantity_in_grams'] = val;
                          await _recomputeTotals();
                          if (mounted) setState(() {});
                        },
                        onDelete: () async {
                          // --- KORREKTUR START ---
                          // Statt showDialog nutzen wir jetzt den Glas-Helper
                          final ok = await showDeleteConfirmation(
                            context,
                            title: l10n.deleteConfirmTitle,
                            content: l10n.deleteConfirmContent,
                          );
                          // --- KORREKTUR ENDE ---

                          if (ok) {
                            setState(() => _items.removeAt(i));
                            await _recomputeTotals();
                            if (mounted) setState(() {});
                          }
                        },
                      );
                    }),
                  ),
              ],
            ),
    );
  }

  String _format1(double v) => v.toStringAsFixed(1);

  Future<void> _save() async {
    if (_saving) return;
    final name = _nameCtrl.text.trim();
    if (name.isEmpty || _items.isEmpty) return;

    setState(() => _saving = true);
    try {
      final mealId = widget.meal['id'] as int;
      await DatabaseHelper.instance.updateMeal(
        mealId,
        name: name,
        notes: _notesCtrl.text.trim(),
      );
      await DatabaseHelper.instance.clearMealItems(mealId);
      for (final it in _items) {
        final grams = (it['quantity_in_grams'] as int?) ?? 0;
        await DatabaseHelper.instance.addMealItem(
          mealId,
          barcode: it['barcode'] as String,
          grams: grams,
        );
      }
      if (mounted) {
        setState(() => _editMode = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(AppLocalizations.of(context)!.mealSaved)),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('${AppLocalizations.of(context)!.error}: $e')),
        );
      }
    } finally {
      if (mounted) setState(() => _saving = false);
    }
  }
// In lib/screens/meal_screen.dart

  Future<void> _addIngredientFlow() async {
    final l10n = AppLocalizations.of(context)!;
    final searchCtrl = TextEditingController();
    // Menge standardmäßig auf 100
    final qtyCtrl = TextEditingController(text: '100');

    // 1. Schritt: Produkt auswählen
    // Wir öffnen das Such-Menu. Es gibt ein Tuple (Barcode, Menge) zurück.
    final picked = await showGlassBottomMenu<(String, int)?>(
      context: context,
      title: l10n.mealAddIngredient,
      contentBuilder: (searchCtx, closeSearch) {
        // Lokaler State für Suchergebnisse
        List<FoodItem> results = [];
        bool loading = false;
        Timer? debounce;

        return StatefulBuilder(
          builder: (context, setStateSB) {
            Future<void> runSearch(String q) async {
              if (q.trim().isEmpty) {
                setStateSB(() => results = []);
                return;
              }
              setStateSB(() => loading = true);
              final res =
                  await ProductDatabaseHelper.instance.searchProducts(q.trim());
              setStateSB(() {
                results = res;
                loading = false;
              });
            }

            return Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextField(
                  controller: searchCtrl,
                  autofocus: true,
                  decoration: InputDecoration(
                    hintText: l10n.searchHintText,
                    prefixIcon: const Icon(Icons.search),
                    filled: true,
                    border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                        borderSide: BorderSide.none),
                  ),
                  onChanged: (val) {
                    debounce?.cancel();
                    debounce = Timer(const Duration(milliseconds: 300),
                        () => runSearch(val));
                  },
                ),
                const SizedBox(height: 8),
                if (loading) const LinearProgressIndicator(minHeight: 2),
                ConstrainedBox(
                  constraints: const BoxConstraints(maxHeight: 300),
                  child: results.isEmpty
                      ? Padding(
                          padding: const EdgeInsets.symmetric(vertical: 24),
                          child: Text(searchCtrl.text.isEmpty
                              ? l10n.searchInitialHint
                              : l10n.searchNoResults),
                        )
                      : ListView.separated(
                          shrinkWrap: true,
                          itemCount: results.length,
                          separatorBuilder: (_, __) => const Divider(height: 1),
                          itemBuilder: (_, i) {
                            final fi = results[i];
                            return ListTile(
                              dense: true,
                              title: Text(fi.name),
                              subtitle: Text(fi.brand),
                              trailing: IconButton(
                                icon: const Icon(Icons.add_circle_outline),
                                onPressed: () async {
                                  // HIER IST DER FIX:
                                  // Wir schließen das Such-Menü NICHT sofort.
                                  // Wir öffnen den Mengen-Dialog DARÜBER (nested) oder ersetzen den Content.
                                  // Am sichersten: Wir fragen die Menge in einem separaten Schritt ab.

                                  // Menge abfragen
                                  // HINWEIS: Wir nutzen hier den searchCtx für den Navigator, um im selben Overlay-Kontext zu bleiben
                                  // oder wir schließen und öffnen neu.

                                  // Strategie: Schließen und Ergebnis (Barcode) zurückgeben,
                                  // dann im Parent die Menge abfragen. Das ist am stabilsten.
                                  closeSearch();
                                  Navigator.of(searchCtx).pop((
                                    fi.barcode,
                                    -1
                                  )); // -1 signalisiert: "Barcode gewählt, Menge fragen"
                                },
                              ),
                            );
                          },
                        ),
                ),
              ],
            );
          },
        );
      },
    );

    // Wenn nichts gewählt wurde, abbrechen
    if (picked == null) return;

    final String barcode = picked.$1;
    int quantity = picked.$2;

    // Wenn Menge noch nicht festgelegt (-1), dann jetzt abfragen
    if (quantity == -1) {
      // Produktnamen laden für den Titel
      final fi =
          await ProductDatabaseHelper.instance.getProductByBarcode(barcode);
      final displayName = fi?.name ?? barcode;

      if (!mounted) return;

      final qtyResult = await showGlassBottomMenu<int?>(
        context: context,
        title: displayName,
        contentBuilder: (qtyCtx, closeQty) {
          return Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(l10n.mealIngredientAmountLabel),
              const SizedBox(height: 12),
              TextField(
                controller: qtyCtrl,
                keyboardType: TextInputType.number,
                autofocus: true,
                decoration: const InputDecoration(suffixText: 'g/ml'),
                onSubmitted: (val) {
                  final q = int.tryParse(val);
                  closeQty();
                  Navigator.of(qtyCtx).pop(q);
                },
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                      child: OutlinedButton(
                          onPressed: () {
                            closeQty();
                            Navigator.of(qtyCtx).pop(null);
                          },
                          child: Text(l10n.cancel))),
                  const SizedBox(width: 12),
                  Expanded(
                      child: FilledButton(
                          onPressed: () {
                            final val = int.tryParse(qtyCtrl.text);
                            closeQty();
                            Navigator.of(qtyCtx).pop(val);
                          },
                          child: Text(l10n.add_button))),
                ],
              )
            ],
          );
        },
      );

      if (qtyResult != null && qtyResult > 0) {
        quantity = qtyResult;
      } else {
        return; // Abgebrochen bei Menge
      }
    }

    // Hinzufügen zur Liste
    if (quantity > 0) {
      setState(() {
        _items.add({'barcode': barcode, 'quantity_in_grams': quantity});
      });
      await _recomputeTotals();
      if (mounted) setState(() {});
    }
  }

  /// Aktuelle Mahlzeit als einzelne FoodEntries ins Tagebuch
  Future<void> _addMealToDiaryFlow() async {
    final l10n = AppLocalizations.of(context)!;

    // Load products
    final Map<String, FoodItem?> products = {};
    for (final it in _items) {
      final bc = it['barcode'] as String;
      products[bc] =
          await ProductDatabaseHelper.instance.getProductByBarcode(bc);
    }

    // Controllers for quantities
    final Map<String, TextEditingController> qtyCtrls = {
      for (final it in _items)
        (it['barcode'] as String): TextEditingController(
          text: '${it['quantity_in_grams']}',
        ),
    };

    const internalTypes = [
      'mealtypeBreakfast',
      'mealtypeLunch',
      'mealtypeDinner',
      'mealtypeSnack',
    ];
    String selectedMealType = internalTypes.first;

    final Map<String, String> mealTypeLabel = {
      'mealtypeBreakfast': l10n.mealtypeBreakfast,
      'mealtypeLunch': l10n.mealtypeLunch,
      'mealtypeDinner': l10n.mealtypeDinner,
      'mealtypeSnack': l10n.mealtypeSnack,
    };

    final ok = await showGlassBottomMenu<bool>(
          context: context,
          title: l10n.mealsAddToDiary,
          contentBuilder: (ctx, close) {
            return StatefulBuilder(
              builder: (ctx, modalSetState) {
                return Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(_nameCtrl.text,
                        style: Theme.of(ctx).textTheme.titleMedium),
                    const SizedBox(height: 12),
                    DropdownButtonFormField<String>(
                      initialValue: selectedMealType,
                      decoration: InputDecoration(
                        labelText: l10n.mealTypeLabel,
                        border: const OutlineInputBorder(),
                        isDense: true,
                      ),
                      items: internalTypes
                          .map((key) => DropdownMenuItem(
                                value: key,
                                child: Text(mealTypeLabel[key] ?? key),
                              ))
                          .toList(),
                      onChanged: (v) {
                        if (v != null) {
                          modalSetState(() => selectedMealType = v);
                        }
                      },
                    ),
                    const SizedBox(height: 12),
                    ConstrainedBox(
                      constraints: const BoxConstraints(maxHeight: 360),
                      child: ListView.separated(
                        shrinkWrap: true,
                        itemCount: _items.length,
                        separatorBuilder: (_, __) => const SizedBox(height: 10),
                        itemBuilder: (_, i) {
                          final it = _items[i];
                          final bc = it['barcode'] as String;
                          final fi = products[bc];
                          final displayName =
                              (fi?.name.isNotEmpty ?? false) ? fi!.name : bc;
                          final unit = (fi?.isLiquid == true) ? 'ml' : 'g';

                          return Row(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              const Padding(
                                padding: EdgeInsets.only(top: 14),
                                child: Icon(Icons.lunch_dining),
                              ),
                              const SizedBox(width: 12),
                              Expanded(
                                child: TextFormField(
                                  controller: qtyCtrls[bc],
                                  keyboardType:
                                      const TextInputType.numberWithOptions(
                                    decimal: true,
                                  ),
                                  decoration: InputDecoration(
                                    labelText: displayName,
                                    helperText: l10n.amountLabel,
                                    suffixText: unit,
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(14),
                                    ),
                                  ),
                                ),
                              ),
                            ],
                          );
                        },
                      ),
                    ),
                    const SizedBox(height: 12),
                    Row(
                      children: [
                        Expanded(
                          child: OutlinedButton(
                            onPressed: () {
                              close();
                              Navigator.of(ctx).pop(false);
                            },
                            child: Text(l10n.cancel),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: FilledButton(
                            onPressed: () {
                              close();
                              Navigator.of(ctx).pop(true);
                            },
                            child: Text(l10n.save),
                          ),
                        ),
                      ],
                    ),
                  ],
                );
              },
            );
          },
        ) ??
        false;

    if (!ok) return;

    final ts = DateTime.now();
    for (final it in _items) {
      final bc = it['barcode'] as String;
      final ctrl = qtyCtrls[bc]!;
      final qty =
          int.tryParse(ctrl.text.trim()) ?? (it['quantity_in_grams'] as int);

      await DatabaseHelper.instance.insertFoodEntry(
        FoodEntry(
          barcode: bc,
          timestamp: ts,
          quantityInGrams: qty,
          mealType: selectedMealType,
        ),
      );

      final fi = await ProductDatabaseHelper.instance.getProductByBarcode(bc);
      if (fi != null) {
        if (fi.isLiquid == true) {
          // water logging if desired
        }
        final c100 = fi.caffeineMgPer100ml;
        if (fi.isLiquid == true && c100 != null && c100 > 0) {
          await _logCaffeineDose(c100 * (qty / 100.0), ts);
        }
      }
    }

    if (mounted) {
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text(l10n.mealAddedToDiarySuccess)));
    }
  }

  Future<void> _logCaffeineDose(double doseMg, DateTime timestamp) async {
    if (doseMg <= 0) return;

    final supplements = await DatabaseHelper.instance.getAllSupplements();
    final caffeine = supplements.firstWhere(
      (s) => (s.code == 'caffeine') || s.name.toLowerCase() == 'caffeine',
      orElse: () => Supplement(
        name: 'Caffeine',
        defaultDose: 100,
        unit: 'mg',
        dailyLimit: 400,
        code: 'caffeine',
        isBuiltin: true,
      ),
    );

    final caffeineId = caffeine.id ??
        (await DatabaseHelper.instance.insertSupplement(caffeine)).id!;

    await DatabaseHelper.instance.insertSupplementLog(
      SupplementLog(
        supplementId: caffeineId,
        dose: doseMg,
        unit: 'mg',
        timestamp: timestamp,
      ),
    );
  }
}

/// Kleines “Chip”-Label für C/F/P
class _MacroChip extends StatelessWidget {
  final String label;
  final String value;
  final String unit;
  const _MacroChip({
    required this.label,
    required this.value,
    required this.unit,
  });

  @override
  Widget build(BuildContext context) {
    final text = Theme.of(context).textTheme;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(10),
      ),
      child: Text(
        '$label  $value$unit',
        style: text.labelLarge?.copyWith(fontWeight: FontWeight.w700),
      ),
    );
  }
}

/// Einzelne Zutat als SummaryCard
/// - View-Modus: Name (tappable) + kleine kcal rechts + (darunter) C/F/P
/// - Edit-Modus: rechts Mengenfeld; Swipe nach links = Löschen
class _IngredientCard extends StatelessWidget {
  final Map<String, dynamic> item; // { barcode, quantity_in_grams }
  final bool editMode;
  final bool showPerIngredientMacros;
  final ValueChanged<int> onQtyChanged;
  final VoidCallback onDelete;

  const _IngredientCard({
    super.key,
    required this.item,
    required this.editMode,
    required this.showPerIngredientMacros,
    required this.onQtyChanged,
    required this.onDelete,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final color = theme.colorScheme.primary;
    final bc = item['barcode'] as String;
    final qty = (item['quantity_in_grams'] as num?)?.toDouble() ?? 0.0;

    Widget buildCard(FoodItem? fi) {
      final name = (fi?.name.isNotEmpty ?? false) ? fi!.name : bc;
      final unit = (fi?.isLiquid == true) ? 'ml' : 'g';

      // per-ingredient macros & kcal
      int kcal = 0;
      double c = 0, f = 0, p = 0;
      if (fi != null) {
        final factor = qty / 100.0;
        kcal = ((fi.calories ?? 0) * factor).round();
        c = (fi.carbs ?? 0) * factor;
        f = (fi.fat ?? 0) * factor;
        p = (fi.protein ?? 0) * factor;
      }

      final title = InkWell(
        onTap: () {
          if (fi != null) {
            Navigator.of(context).push(
              MaterialPageRoute(builder: (_) => FoodDetailScreen(foodItem: fi)),
            );
          }
        },
        child: Text(
          name,
          style: theme.textTheme.bodyLarge?.copyWith(
            fontWeight: FontWeight.w600,
          ),
        ),
      );

      final trailingView = Text(
        fi == null ? '–' : '$kcal kcal',
        style: theme.textTheme.labelLarge?.copyWith(
          color: theme.colorScheme.onSurfaceVariant,
          fontWeight: FontWeight.w700,
        ),
      );

      final trailingEdit = SizedBox(
        width: 96,
        child: TextFormField(
          initialValue: '${qty.toInt()}',
          textAlign: TextAlign.right,
          keyboardType: const TextInputType.numberWithOptions(decimal: false),
          decoration: InputDecoration(
            isDense: true,
            suffixText: unit,
            border: const OutlineInputBorder(),
          ),
          onChanged: (v) {
            final parsed = int.tryParse(v.trim());
            if (parsed != null && parsed >= 0) onQtyChanged(parsed);
          },
        ),
      );

      return SummaryCard(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  const SizedBox(width: 4),
                  Icon(Icons.local_dining, color: color),
                  const SizedBox(width: 12),
                  Expanded(child: title),
                  if (!editMode) trailingView else trailingEdit,
                ],
              ),
              if (showPerIngredientMacros && fi != null) ...[
                const SizedBox(height: 6),
                Text(
                  'C ${c.toStringAsFixed(1)} g   •   F ${f.toStringAsFixed(1)} g   •   P ${p.toStringAsFixed(1)} g',
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: Colors.grey.shade600,
                  ),
                ),
              ],
            ],
          ),
        ),
      );
    }

    final card = FutureBuilder<FoodItem?>(
      future: ProductDatabaseHelper.instance.getProductByBarcode(bc),
      builder: (_, snap) => buildCard(snap.data),
    );

    if (!editMode) return card;

    // Edit-Modus: Swipe links = löschen
    return Dismissible(
      key: ValueKey('ing_${item['barcode']}_${item['quantity_in_grams']}'),
      direction: DismissDirection.endToStart,
      background: const SizedBox.shrink(),
      secondaryBackground: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      confirmDismiss: (direction) async {
        if (direction == DismissDirection.endToStart) {
          onDelete();
        }
        return false;
      },
      child: card,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/exercise_detail_screen.dart =====

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/wger_attribution_widget.dart';
import 'package:lightweight/widgets/global_app_bar.dart';

class ExerciseDetailScreen extends StatelessWidget {
  final Exercise exercise;
  const ExerciseDetailScreen({super.key, required this.exercise});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final textTheme = theme.textTheme;
    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      extendBodyBehindAppBar: true,
      appBar: GlobalAppBar(
        title: exercise.getLocalizedName(context),
        actions: [
          Padding(
            padding: const EdgeInsets.only(right: 12),
            child: _CategoryBadge(text: exercise.categoryName),
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: DesignConstants.cardPadding.copyWith(
          top: DesignConstants.cardPadding.top + topPadding,
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Bild / GIF
            if ((exercise.imagePath ?? '').isNotEmpty)
              Container(
                clipBehavior: Clip.antiAlias,
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(16),
                ),
                child: Image.asset(
                  exercise.imagePath!,
                  fit: BoxFit.cover,
                  width: double.infinity,
                  errorBuilder: (_, __, ___) => Container(
                    height: 200,
                    alignment: Alignment.center,
                    color: Colors.black12,
                    child: const Icon(Icons.image_not_supported_outlined),
                  ),
                ),
              ),

            const SizedBox(height: DesignConstants.spacingXL),

            // Beschreibung
            _buildSectionTitle(context, l10n.descriptionLabel.toUpperCase()),
            SummaryCard(
              child: Padding(
                padding: DesignConstants.cardPadding,
                child: Text(
                  exercise.getLocalizedDescription(context).isNotEmpty
                      ? exercise.getLocalizedDescription(context)
                      : l10n.noDescriptionAvailable,
                  style: textTheme.bodyMedium,
                ),
              ),
            ),

            const SizedBox(height: DesignConstants.spacingXL),

            // Muskeln
            _buildSectionTitle(context, l10n.involvedMuscles.toUpperCase()),
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  child: _MuscleGroupCard(
                    title: l10n.primaryLabel,
                    muscles: exercise.primaryMuscles,
                    fallback: l10n.noMusclesSpecified,
                  ),
                ),
                const SizedBox(width: DesignConstants.spacingM),
                Expanded(
                  child: _MuscleGroupCard(
                    title: l10n.secondaryLabel,
                    muscles: exercise.secondaryMuscles,
                    fallback: l10n.noMusclesSpecified,
                  ),
                ),
              ],
            ),

            const SizedBox(height: DesignConstants.spacingL),

            // Attribution
            Center(
              child: Padding(
                padding: const EdgeInsets.only(
                  top: 8.0,
                  bottom: DesignConstants.spacingM,
                ),
                child: WgerAttributionWidget(
                  textStyle: textTheme.bodySmall?.copyWith(
                    color: Colors.grey[600],
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// -----------------------------
// Kategorie-Pill oben rechts
// -----------------------------
class _CategoryBadge extends StatelessWidget {
  final String text;
  const _CategoryBadge({required this.text});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final bg = theme.colorScheme.primary.withOpacity(0.15);
    final fg = theme.colorScheme.primary;
    return Container(
      margin: const EdgeInsets.symmetric(vertical: 10),
      padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(999),
        border: Border.all(color: fg.withOpacity(0.4)),
      ),
      child: Text(
        text,
        style: theme.textTheme.labelLarge?.copyWith(
          color: fg,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
}

// -----------------------------
// Überschriften-Stil (bereit für deine ARB-Texte in CAPS)
// -----------------------------
Widget _buildSectionTitle(BuildContext context, String title) {
  return Padding(
    padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
    child: Text(
      title,
      style: Theme.of(context).textTheme.labelLarge?.copyWith(
            color: Colors.grey[600],
            fontWeight: FontWeight.bold,
          ),
    ),
  );
}

// -----------------------------
// Einzel-Kachel für Primär / Sekundär
// -----------------------------
class _MuscleGroupCard extends StatelessWidget {
  final String title;
  final List<String> muscles;
  final String fallback;

  const _MuscleGroupCard({
    required this.title,
    required this.muscles,
    required this.fallback,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final textTheme = theme.textTheme;
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: theme.colorScheme.surfaceContainerHighest.withOpacity(0.6),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          if (muscles.isEmpty)
            Text(
              fallback,
              style: textTheme.bodyMedium?.copyWith(
                color: Colors.grey.shade600,
              ),
            )
          else
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: muscles
                  .map(
                    (m) => Chip(
                      label: Text(m),
                      visualDensity: VisualDensity.compact,
                      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    ),
                  )
                  .toList(growable: false),
            ),
        ],
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/measurements_screen.dart =====

// lib/screens/measurements_screen.dart (Final & De-Materialisiert - mit AppBar)

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/measurement_session.dart';
import 'package:lightweight/screens/add_measurement_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/bottom_content_spacer.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/global_app_bar.dart';
import 'package:lightweight/widgets/measurement_chart_widget.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/util/l10n_ext.dart';
import 'package:lightweight/widgets/swipe_action_background.dart';

class MeasurementsScreen extends StatefulWidget {
  const MeasurementsScreen({super.key});

  @override
  State<MeasurementsScreen> createState() => _MeasurementsScreenState();
}

class _MeasurementsScreenState extends State<MeasurementsScreen> {
  bool _isLoading = true;
  List<MeasurementSession> _sessions = [];
  String? _selectedChartType;
  List<String> _availableMeasurementTypes = [];

  DateTimeRange _currentChartDateRange = DateTimeRange(
    start: DateTime.now().subtract(const Duration(days: 29)),
    end: DateTime.now(),
  );
  final List<String> _chartDateRangeKeys = ['30D', '90D', '180D', 'All'];
  String _selectedChartRangeKey = '30D';

  @override
  void initState() {
    super.initState();
    _loadMeasurements();
  }

  Future<void> _loadMeasurements() async {
    setState(() => _isLoading = true);
    final sessions = await DatabaseHelper.instance.getMeasurementSessions();

    final Set<String> types = {};
    for (final session in sessions) {
      for (final measurement in session.measurements) {
        types.add(measurement.type);
      }
    }

    if (mounted) {
      setState(() {
        _sessions = sessions;
        _availableMeasurementTypes = types.toList()..sort();
        if (_selectedChartType == null &&
            _availableMeasurementTypes.isNotEmpty) {
          _selectedChartType = _availableMeasurementTypes.first;
        }
        _isLoading = false;
      });
      _loadChartData();
    }
  }

  Future<void> _loadChartData() async {
    if (_selectedChartType == null || _selectedChartType!.isEmpty) return;

    final now = DateTime.now();
    DateTime start;
    DateTime end = DateTime(now.year, now.month, now.day, 23, 59, 59);

    switch (_selectedChartRangeKey) {
      case '90D':
        start = now.subtract(const Duration(days: 89));
        break;
      case '180D':
        start = now.subtract(const Duration(days: 179));
        break;
      case 'All':
        final earliest =
            await DatabaseHelper.instance.getEarliestMeasurementDate();
        start = earliest ?? now;
        break;
      case '30D':
      default:
        start = now.subtract(const Duration(days: 29));
    }

    setState(() {
      _currentChartDateRange = DateTimeRange(start: start, end: end);
    });
  }

  Future<void> _deleteSession(int id) async {
    await DatabaseHelper.instance.deleteMeasurementSession(id);
    _loadMeasurements();
  }

  void _navigateToCreateMeasurement() {
    Navigator.of(context)
        .push(
          MaterialPageRoute(
            // Optional: Hier könnte man DateTime.now() übergeben,
            // oder es leer lassen (Fallback im Screen ist ja now()).
            // Wir lassen es leer, da dieser Screen keine Datums-Auswahl hat.
            builder: (context) =>
                AddMeasurementScreen(initialDate: DateTime.now()),
          ),
        )
        .then((_) => _loadMeasurements());
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;

    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: GlobalAppBar(
        title: l10n.measurementsScreenTitle,
      ),
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _sessions.isEmpty
              ? _buildEmptyState(l10n, context)
              : ListView(
                  padding: DesignConstants.cardPadding.copyWith(
                    top: DesignConstants.cardPadding.top + topPadding,
                  ),
                  children: [
                    if (_availableMeasurementTypes.isNotEmpty) ...[
                      _buildChartSection(
                        l10n,
                        colorScheme,
                        Theme.of(context).textTheme,
                      ),
                      const SizedBox(height: DesignConstants.spacingXL),
                    ],
                    _buildSectionTitle(context, l10n.all_measurements),
                    ..._sessions.map(
                      (session) => _buildMeasurementSessionCard(
                          l10n, colorScheme, session),
                    ),
                    const BottomContentSpacer(),
                  ],
                ),
      floatingActionButton: GlassFab(
        label: l10n.addMeasurement,
        onPressed: _navigateToCreateMeasurement,
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
    );
  }

  Widget _buildEmptyState(AppLocalizations l10n, BuildContext context) {
    return Center(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              l10n.measurementsEmptyState,
              textAlign: TextAlign.center,
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: DesignConstants.spacingXL),
            ElevatedButton.icon(
              onPressed: _navigateToCreateMeasurement,
              icon: const Icon(Icons.add),
              label: Text(l10n.addMeasurement),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildChartSection(
    AppLocalizations l10n,
    ColorScheme colorScheme,
    TextTheme textTheme,
  ) {
    if (_selectedChartType == null) return const SizedBox.shrink();

    return SummaryCard(
      child: Padding(
        padding: DesignConstants.cardPadding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: DropdownButtonHideUnderline(
                    child: DropdownButton<String>(
                      value: _selectedChartType,
                      isExpanded: true,
                      onChanged: (String? newValue) {
                        if (newValue != null) {
                          setState(() {
                            _selectedChartType = newValue;
                          });
                          _loadChartData();
                        }
                      },
                      items: _availableMeasurementTypes
                          .map<DropdownMenuItem<String>>((String value) {
                        return DropdownMenuItem<String>(
                          value: value,
                          child: Text(
                            l10n.getLocalizedMeasurementName(value),
                          ),
                        );
                      }).toList(),
                      style: textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                      icon: Icon(
                        Icons.arrow_drop_down,
                        color: colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ),
                ),
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: _chartDateRangeKeys
                      .map((key) => _buildFilterButton(key, key))
                      .toList(),
                ),
              ],
            ),
            const SizedBox(height: DesignConstants.spacingL),
            MeasurementChartWidget(
              chartType: _selectedChartType!,
              dateRange: _currentChartDateRange,
              // KORREKTUR: Die folgende Zeile wurde entfernt
              // lineColor: colorScheme.primary,
              unit: _getMeasurementUnit(_selectedChartType!),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFilterButton(String label, String key) {
    final theme = Theme.of(context);
    final isSelected = _selectedChartRangeKey == key;
    return GestureDetector(
      onTap: () {
        setState(() {
          _selectedChartRangeKey = key;
        });
        _loadChartData();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10.0, vertical: 6.0),
        decoration: BoxDecoration(
          color: isSelected
              ? theme.colorScheme.primary
              : theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
          borderRadius: BorderRadius.circular(8.0),
        ),
        child: Text(
          label,
          style: theme.textTheme.labelSmall?.copyWith(
            color: isSelected
                ? theme.colorScheme.onPrimary
                : theme.colorScheme.onSurfaceVariant,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  Widget _buildMeasurementSessionCard(
    AppLocalizations l10n,
    ColorScheme colorScheme,
    MeasurementSession session,
  ) {
    final locale = Localizations.localeOf(context).toString();
    final sortedMeasurements = session.measurements.toList()
      ..sort((a, b) => a.type.compareTo(b.type));

    return Dismissible(
      key: Key('session_${session.id}'),
      direction: DismissDirection.endToStart,
      // gleiche Hintergründe wie im Nutrition Screen
      background: const SwipeActionBackground(
        color: Colors.redAccent,
        icon: Icons.delete,
        alignment: Alignment.centerRight,
      ),
      confirmDismiss: (direction) async {
        // NEU: Helper
        return await showDeleteConfirmation(context);
      },
      child: SummaryCard(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            ListTile(
              contentPadding: DesignConstants.screenPadding,
              title: Text(
                DateFormat.yMMMMEEEEd(
                  locale,
                ).add_Hm().format(session.timestamp),
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),
              trailing: const Icon(Icons.chevron_right),
              onTap: () {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text(l10n.measurement_session_detail_view)),
                );
              },
            ),
            Divider(
              height: 1,
              thickness: 1,
              color: colorScheme.onSurfaceVariant.withOpacity(0.1),
            ),
            ...sortedMeasurements.map(
              (measurement) => ListTile(
                contentPadding: const EdgeInsets.symmetric(
                  horizontal: 16.0,
                  vertical: 4.0,
                ),
                leading: _getMeasurementIcon(measurement.type),
                title: Text(l10n.getLocalizedMeasurementName(measurement.type)),
                trailing: Text(
                  "${measurement.value.toStringAsFixed(1)} ${measurement.unit}",
                  style: const TextStyle(fontWeight: FontWeight.bold),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _getMeasurementUnit(String type) {
    // Hier die Einheiten basierend auf dem Typ zurückgeben
    switch (type) {
      case 'weight':
        return 'kg';
      case 'fat_percent':
        return '%';
      case 'neck':
      case 'shoulder':
      case 'chest':
      case 'left_bicep':
      case 'right_bicep':
      case 'left_forearm':
      case 'right_forearm':
      case 'abdomen':
      case 'waist':
      case 'hips':
      case 'left_thigh':
      case 'right_thigh':
      case 'left_calf':
      case 'right_calf':
        return 'cm';
      default:
        return '';
    }
  }

  Icon _getMeasurementIcon(String type) {
    // Hier Icons basierend auf dem Typ zurückgeben
    switch (type) {
      case 'weight':
        return const Icon(Icons.monitor_weight);
      case 'fat_percent':
        return const Icon(Icons.fitness_center);
      case 'neck':
        return const Icon(Icons.accessibility_new);
      case 'shoulder':
        return const Icon(Icons.accessibility_new);
      case 'chest':
        return const Icon(Icons.accessibility_new);
      case 'left_bicep':
        return const Icon(Icons.accessibility_new);
      case 'right_bicep':
        return const Icon(Icons.accessibility_new);
      case 'abdomen':
        return const Icon(Icons.accessibility_new);
      case 'waist':
        return const Icon(Icons.accessibility_new);
      case 'hips':
        return const Icon(Icons.accessibility_new);
      default:
        return const Icon(Icons.straighten);
    }
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/main_screen.dart =====

import 'dart:io';
import 'dart:ui';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/dialogs/log_supplement_dialog_content.dart';
import 'package:lightweight/dialogs/fluid_dialog_content.dart';
import 'package:lightweight/dialogs/log_supplement_menu.dart';
import 'package:lightweight/dialogs/quantity_dialog_content.dart';
import 'package:lightweight/dialogs/water_dialog_content.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_entry.dart';
import 'package:lightweight/models/fluid_entry.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/supplement_log.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/screens/add_food_screen.dart';
import 'package:lightweight/screens/add_measurement_screen.dart';
import 'package:lightweight/screens/diary_screen.dart';
import 'package:lightweight/screens/edit_routine_screen.dart';
import 'package:lightweight/screens/live_workout_screen.dart';
import 'package:lightweight/screens/nutrition_hub_screen.dart';
import 'package:lightweight/screens/profile_screen.dart';
import 'package:lightweight/screens/statistics_hub_screen.dart';
import 'package:lightweight/screens/workout_hub_screen.dart';
import 'package:lightweight/services/profile_service.dart';
import 'package:lightweight/services/theme_service.dart';
import 'package:lightweight/services/workout_session_manager.dart';
import 'package:lightweight/theme/color_constants.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/glass_bottom_menu.dart';
import 'package:lightweight/widgets/glass_bottom_nav_bar.dart';
import 'package:lightweight/widgets/glass_fab.dart';
import 'package:lightweight/widgets/global_app_bar.dart';
import 'package:lightweight/widgets/keep_alive_page.dart';
import 'package:liquid_glass_renderer/liquid_glass_renderer.dart';
import 'package:provider/provider.dart';

class MainScreen extends StatefulWidget {
  final int? initialTabIndex;
  const MainScreen({super.key, this.initialTabIndex});
  @override
  State<MainScreen> createState() => _MainScreenState();
}

class _MainScreenState extends State<MainScreen> with TickerProviderStateMixin {
  late PageController _pageController;
  int _currentIndex = 0;
  final GlobalKey<DiaryScreenState> _tagebuchKey =
      GlobalKey<DiaryScreenState>();
  bool _isAddMenuOpen = false;
  late final AnimationController _menuController;

  ThemeService get themeService =>
      Provider.of<ThemeService>(context, listen: false);
  bool get isLiquid => themeService.visualStyle == 1;

  double get kNavBarHeight => isLiquid ? 65 : 72;
  double kBarFabGap = 12.0;

  double _safe01(double v) => v.isNaN ? 0.0 : v.clamp(0.0, 1.0).toDouble();
  DateTime get _currentActiveDate {
    if (_currentIndex == 0 && _tagebuchKey.currentState != null) {
      return _tagebuchKey.currentState!.selectedDateNotifier.value;
    }
    return DateTime.now();
  }

  @override
  void initState() {
    super.initState();
    _currentIndex = widget.initialTabIndex ?? 0;
    _pageController = PageController(initialPage: _currentIndex);
    _menuController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 400),
    ); // In lib/screens/main_screen.dart

    Future<void> handleAddFood() async {
      final FoodItem? selectedFoodItem =
          await Navigator.of(context).push<FoodItem>(
        MaterialPageRoute(builder: (context) => const AddFoodScreen()),
      );

      if (selectedFoodItem == null || !mounted) return;

      // FIX: Datum holen
      final targetDate = _currentActiveDate;

      // FIX: Datum übergeben (Signatur unten anpassen!)
      final result =
          await _showQuantityMenu(selectedFoodItem, initialDate: targetDate);

      if (result == null || !mounted) return;

      final int quantity = result.quantity;
      final DateTime timestamp =
          result.timestamp; // Das kommt jetzt korrekt aus dem Dialog
      final String mealType = result.mealType;
      final bool isLiquid = result.isLiquid;
      final double? caffeinePer100 = result.caffeinePer100ml;

      // ... (Restliche Logik: insertFoodEntry, insertFluidEntry etc. bleibt gleich) ...
      // Der timestamp hier ist bereits korrekt, weil er aus dem Dialog kommt,
      // der mit targetDate initialisiert wurde.

      final newFoodEntry = FoodEntry(
        barcode: selectedFoodItem.barcode,
        timestamp: timestamp,
        quantityInGrams: quantity,
        mealType: mealType,
      );

      final newFoodEntryId =
          await DatabaseHelper.instance.insertFoodEntry(newFoodEntry);

      if (isLiquid) {
        // ... insertFluidEntry mit timestamp ...
        final newFluidEntry = FluidEntry(
          timestamp: timestamp,
          quantityInMl: quantity,
          name: selectedFoodItem.name,
          kcal: null,
          sugarPer100ml: null,
          carbsPer100ml: null,
          caffeinePer100ml: null,
          linked_food_entry_id: newFoodEntryId,
        );
        await DatabaseHelper.instance.insertFluidEntry(newFluidEntry);
      }

      if (isLiquid && caffeinePer100 != null && caffeinePer100 > 0) {
        // ... logCaffeineDose ...
        final totalCaffeine = (caffeinePer100 / 100.0) * quantity;
        await _logCaffeineDose(totalCaffeine, timestamp,
            foodEntryId: newFoodEntryId);
      }

      _refreshHomeScreen();
    }
  }

  @override
  void dispose() {
    _pageController.dispose();
    _menuController.dispose();
    super.dispose();
  }

  void _onPageChanged(int index) {
    if (_isWarping) {
      return;
    }
    setState(() => _currentIndex = index);
  }

  final _pvBoundaryKey = GlobalKey();
  final bool _isWarping = false;
  ui.Image? _pvSnapshot;

  void _onNavigationTapped(int index) {
    if (!_pageController.hasClients) return;
    _pageController.jumpToPage(index);
  }

  void _toggleAddMenu() {
    setState(() {
      _isAddMenuOpen = !_isAddMenuOpen;
      if (_isAddMenuOpen) {
        _menuController.forward();
      } else {
        _menuController.reverse();
      }
    });
  }

  void _executeAddMenuAction(String action) async {
    final l10n = AppLocalizations.of(context)!;
    switch (action) {
      case 'start_workout':
        _showStartWorkoutMenu();
        break;
      case 'add_measurement':
        // NEU: Datum holen
        final targetDate = _currentActiveDate;

        final success = await Navigator.of(context).push<bool>(
          MaterialPageRoute(
            builder: (context) => AddMeasurementScreen(
              initialDate: targetDate, // <--- ÜBERGABE
            ),
          ),
        );
        if (success == true) _refreshHomeScreen();
        break;
      case 'add_food':
        _handleAddFood();
        break;
      case 'add_liquid':
        await _showAddFluidMenu();
        break;
      case 'log_supplement':
        _showLogSupplementMenu();
        break;
    }
  }

  Future<void> _refreshHomeScreen() async {
    if (_currentIndex == 0) {
      _tagebuchKey.currentState?.loadDataForDate(DateTime.now());
    }
  }

  Future<void> _showLogSupplementMenu() async {
    // ... (Supplement Auswahl bleibt gleich) ...
    final l10n = AppLocalizations.of(context)!;
    final Supplement? selectedSupplement =
        await showGlassBottomMenu<Supplement>(
      context: context,
      title: l10n.logIntakeTitle,
      contentBuilder: (ctx, close) => LogSupplementMenu(close: close),
    );

    if (selectedSupplement == null || !mounted) return;

    // FIX: Datum holen
    final targetDate = _currentActiveDate;

    final result = await showGlassBottomMenu<(double, DateTime)?>(
      context: context,
      title: localizeSupplementName(selectedSupplement, l10n),
      contentBuilder: (ctx, close) {
        return LogSupplementDoseBody(
          supplement: selectedSupplement,
          initialTimestamp: targetDate, // <--- FIX: Datum übergeben
          primaryLabel: l10n.add_button,
          onCancel: close,
          onSubmit: (dose, ts) {
            close();
            Navigator.of(ctx).pop((dose, ts));
          },
        );
      },
    );

    if (result != null) {
      final newLog = SupplementLog(
        supplementId: selectedSupplement.id!,
        dose: result.$1,
        unit: selectedSupplement.unit,
        timestamp: result.$2,
      );
      await DatabaseHelper.instance.insertSupplementLog(newLog);
      _refreshHomeScreen();
    }
  }

  Future<void> _showStartWorkoutMenu() async {
    final l10n = AppLocalizations.of(context)!;
    final routines = await WorkoutDatabaseHelper.instance.getAllRoutines();
    if (!mounted) return;

    // Wir warten auf das Ergebnis des Menüs.
    // Das Menü schließt sich selbst und gibt die Daten zurück.
    final result =
        await showGlassBottomMenu<({WorkoutLog log, Routine? routine})>(
      context: context,
      title: l10n.startWorkout,
      contentBuilder: (ctx, close) {
        final isDark = Theme.of(ctx).brightness == Brightness.dark;
        Widget glassCard({required Widget child, EdgeInsets? padding}) {
          return Material(
            color: Colors.white.withOpacity(isDark ? 0.06 : 0.08),
            borderRadius: BorderRadius.circular(18),
            child: Padding(
              padding: padding ??
                  const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
              child: child,
            ),
          );
        }

        final freeWorkoutTile = glassCard(
          child: InkWell(
            borderRadius: BorderRadius.circular(16),
            onTap: () async {
              // 1. Workout erstellen
              final newWorkoutLog = await WorkoutDatabaseHelper.instance
                  .startWorkout(routineName: l10n.freeWorkoutTitle);

              if (!ctx.mounted) return;

              // 2. Menü schließen und Daten zurückgeben
              // Wir nutzen Navigator.of(ctx).pop(...), nicht 'close()', um Daten zu senden.
              Navigator.of(ctx).pop((log: newWorkoutLog, routine: null));
            },
            child: Row(
              children: [
                const Icon(Icons.play_arrow_rounded),
                const SizedBox(width: 12),
                Text(
                  l10n.startEmptyWorkoutButton,
                  style: Theme.of(ctx).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w700,
                      ),
                ),
              ],
            ),
          ),
        );

        final routinesList = ConstrainedBox(
          constraints: const BoxConstraints(maxHeight: 420),
          child: ListView.separated(
            padding: const EdgeInsets.fromLTRB(4, 0, 4, 4),
            shrinkWrap: true,
            itemCount: routines.length,
            separatorBuilder: (_, __) => const SizedBox(height: 10),
            itemBuilder: (ctx, i) {
              final r = routines[i];
              return glassCard(
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    FilledButton(
                      onPressed: () async {
                        // Ladeindikator AUF dem Menü anzeigen
                        showDialog(
                          context: context,
                          barrierDismissible: false,
                          builder: (_) =>
                              const Center(child: CircularProgressIndicator()),
                        );

                        final fullRoutine = await WorkoutDatabaseHelper.instance
                            .getRoutineById(r.id!);
                        final newWorkoutLog = await WorkoutDatabaseHelper
                            .instance
                            .startWorkout(routineName: r.name);

                        if (!context.mounted) return;
                        Navigator.of(context).pop(); // Ladeindikator schließen

                        if (fullRoutine != null && ctx.mounted) {
                          // Menü schließen und Daten zurückgeben
                          Navigator.of(ctx)
                              .pop((log: newWorkoutLog, routine: fullRoutine));
                        }
                      },
                      child: Text(l10n.startButton),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: InkWell(
                        borderRadius: BorderRadius.circular(12),
                        onTap: () {
                          // Editieren navigiert direkt (das ist ok, da neuer Screen)
                          // Aber besser wäre auch hier pop+push, wir lassen es für Edit so,
                          // da der User zurück zum Menü will beim Editieren.
                          // Hier schließen wir nur das Menü ohne Result.
                          close();
                          Navigator.of(context)
                              .push(
                                MaterialPageRoute(
                                  builder: (_) => EditRoutineScreen(routine: r),
                                ),
                              )
                              .then((_) => _refreshHomeScreen());
                        },
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              r.name,
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                              style: Theme.of(ctx)
                                  .textTheme
                                  .titleMedium
                                  ?.copyWith(fontWeight: FontWeight.w700),
                            ),
                            const SizedBox(height: 2),
                            Text(
                              l10n.editRoutineSubtitle,
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                              style: Theme.of(ctx).textTheme.bodySmall,
                            ),
                          ],
                        ),
                      ),
                    ),
                    const SizedBox(width: 8),
                    Icon(
                      Icons.more_vert_rounded,
                      color: Theme.of(ctx).textTheme.bodyMedium?.color,
                    ),
                  ],
                ),
              );
            },
          ),
        );

        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            freeWorkoutTile,
            if (routines.isNotEmpty) ...[
              const SizedBox(height: 12),
              routinesList,
            ],
          ],
        );
      },
    );

    // HIER passiert die eigentliche Navigation zum Workout,
    // NACHDEM das Menü geschlossen ist.
    if (result != null && mounted) {
      Navigator.of(context)
          .push(
            MaterialPageRoute(
              builder: (_) => LiveWorkoutScreen(
                routine: result.routine,
                workoutLog: result.log,
              ),
            ),
          )
          .then((_) => _refreshHomeScreen());
    }
  }

  Future<void> _handleAddFood() async {
    // FIX: Datum holen
    final targetDate = _currentActiveDate;

    final FoodItem? selectedFoodItem =
        await Navigator.of(context).push<FoodItem>(
      MaterialPageRoute(
        builder: (context) => AddFoodScreen(
          initialDate: targetDate, // <--- ÜBERGABE
          // initialMealType: null, // Default ist ok
        ),
      ),
    );

    if (selectedFoodItem == null || !mounted) return;

    // FIX: Datum übergeben (Signatur unten anpassen!)
    final result =
        await _showQuantityMenu(selectedFoodItem, initialDate: targetDate);

    if (result == null || !mounted) return;

    final int quantity = result.quantity;
    final DateTime timestamp =
        result.timestamp; // Das kommt jetzt korrekt aus dem Dialog
    final String mealType = result.mealType;
    final bool isLiquid = result.isLiquid;
    final double? caffeinePer100 = result.caffeinePer100ml;

    // ... (Restliche Logik: insertFoodEntry, insertFluidEntry etc. bleibt gleich) ...
    // Der timestamp hier ist bereits korrekt, weil er aus dem Dialog kommt,
    // der mit targetDate initialisiert wurde.

    final newFoodEntry = FoodEntry(
      barcode: selectedFoodItem.barcode,
      timestamp: timestamp,
      quantityInGrams: quantity,
      mealType: mealType,
    );

    final newFoodEntryId =
        await DatabaseHelper.instance.insertFoodEntry(newFoodEntry);

    if (isLiquid) {
      // ... insertFluidEntry mit timestamp ...
      final newFluidEntry = FluidEntry(
        timestamp: timestamp,
        quantityInMl: quantity,
        name: selectedFoodItem.name,
        kcal: null,
        sugarPer100ml: null,
        carbsPer100ml: null,
        caffeinePer100ml: null,
        linked_food_entry_id: newFoodEntryId,
      );
      await DatabaseHelper.instance.insertFluidEntry(newFluidEntry);
    }

    if (isLiquid && caffeinePer100 != null && caffeinePer100 > 0) {
      // ... logCaffeineDose ...
      final totalCaffeine = (caffeinePer100 / 100.0) * quantity;
      await _logCaffeineDose(totalCaffeine, timestamp,
          foodEntryId: newFoodEntryId);
    }

    _refreshHomeScreen();
  }

  Future<void> _showAddFluidMenu() async {
    final l10n = AppLocalizations.of(context)!;
    final key = GlobalKey<FluidDialogContentState>();
    final targetDate = _currentActiveDate; // <--- FIX

    await showGlassBottomMenu(
      context: context,
      title: l10n.add_liquid_title,
      contentBuilder: (ctx, close) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            FluidDialogContent(
              key: key,
              initialTimestamp: targetDate, // <--- FIX: Datum übergeben
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: close,
                    child: Text(l10n.cancel),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton(
                    onPressed: () async {
                      final state = key.currentState;
                      if (state == null) return;
                      final quantity = int.tryParse(state.quantityText);
                      if (quantity == null || quantity <= 0) return;

                      final name = state.nameText;
                      final sugarPer100ml = double.tryParse(
                        state.sugarText.replaceAll(',', '.'),
                      );
                      final caffeinePer100ml = double.tryParse(
                        state.caffeineText.replaceAll(',', '.'),
                      );
                      final kcal = (sugarPer100ml != null)
                          ? ((sugarPer100ml / 100) * quantity * 4).round()
                          : null;

                      final newEntry = FluidEntry(
                        timestamp: state.selectedDateTime,
                        quantityInMl: quantity,
                        name: name,
                        kcal: kcal,
                        sugarPer100ml: sugarPer100ml,
                        carbsPer100ml: sugarPer100ml,
                        caffeinePer100ml: caffeinePer100ml,
                      );

                      final newId = await DatabaseHelper.instance
                          .insertFluidEntry(newEntry);

                      if (caffeinePer100ml != null && caffeinePer100ml > 0) {
                        final totalCaffeine =
                            (caffeinePer100ml / 100.0) * quantity;
                        await _logCaffeineDose(
                          totalCaffeine,
                          state.selectedDateTime,
                          fluidEntryId: newId,
                        );
                      }

                      close();
                      _refreshHomeScreen();
                    },
                    child: Text(l10n.add_button),
                  ),
                ),
              ],
            ),
          ],
        );
      },
    );
  }

  Future<void> _logCaffeineDose(
    double doseMg,
    DateTime timestamp, {
    int? foodEntryId,
    int? fluidEntryId,
  }) async {
    if (doseMg <= 0) return;

    final supplements = await DatabaseHelper.instance.getAllSupplements();
    Supplement? caffeineSupplement;
    try {
      caffeineSupplement = supplements.firstWhere((s) => s.code == 'caffeine');
    } catch (e) {
      return;
    }

    if (caffeineSupplement.id == null) return;

    await DatabaseHelper.instance.insertSupplementLog(
      SupplementLog(
        supplementId: caffeineSupplement.id!,
        dose: doseMg,
        unit: 'mg',
        timestamp: timestamp,
        source_food_entry_id: foodEntryId,
        source_fluid_entry_id: fluidEntryId,
      ),
    );
  }

  Future<
          ({
            int quantity,
            DateTime timestamp,
            String mealType,
            bool isLiquid,
            double? sugarPer100ml,
            double? caffeinePer100ml,
          })?>
      _showQuantityMenu(FoodItem item,
          {DateTime? initialDate} // <--- NEUER PARAMETER
          ) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<QuantityDialogContentState> dialogStateKey = GlobalKey();

    return showGlassBottomMenu(
      context: context,
      title: item.name,
      contentBuilder: (ctx, close) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            QuantityDialogContent(
              key: dialogStateKey,
              item: item,
              initialTimestamp:
                  initialDate ?? DateTime.now(), // <--- FIX: Nutzen
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () {
                      close();
                      Navigator.of(ctx).pop(null);
                    },
                    child: Text(l10n.cancel),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton(
                    onPressed: () {
                      final state = dialogStateKey.currentState;
                      if (state != null) {
                        final quantity = int.tryParse(state.quantityText);
                        final sugar = double.tryParse(
                          state.sugarText.replaceAll(',', '.'),
                        );
                        final caffeine = double.tryParse(
                          state.caffeineText.replaceAll(',', '.'),
                        );
                        if (quantity != null && quantity > 0) {
                          close();
                          Navigator.of(ctx).pop((
                            quantity: quantity,
                            timestamp: state.selectedDateTime,
                            mealType: state.selectedMealType,
                            isLiquid: state.isLiquid,
                            sugarPer100ml: sugar,
                            caffeinePer100ml: caffeine,
                          ));
                        }
                      }
                    },
                    child: Text(l10n.add_button),
                  ),
                ),
              ],
            ),
          ],
        );
      },
    );
  }

  void _handleCreateRoutine() {
    Navigator.of(
      context,
    ).push(MaterialPageRoute(builder: (context) => const EditRoutineScreen()));
  }

  Future<(int, DateTime)?> _openWaterDialog({
    int? initialQuantity,
    DateTime? initialTimestamp,
  }) async {
    final l10n = AppLocalizations.of(context)!;
    final key = GlobalKey<WaterDialogContentState>();

    return showDialog<(int, DateTime)?>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.add_liquid_title),
        content: WaterDialogContent(
          key: key,
          initialQuantity: initialQuantity,
          initialTimestamp: initialTimestamp,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(null),
            child: Text(l10n.cancel),
          ),
          FilledButton(
            onPressed: () {
              final s = key.currentState;
              if (s == null) return;
              final qty = int.tryParse(s.quantityText);
              if (qty != null && qty > 0) {
                Navigator.of(ctx).pop((qty, s.selectedDateTime));
              }
            },
            child: Text(l10n.add_button),
          ),
        ],
      ),
    );
  }

  String localizeSupplementName(Supplement s, AppLocalizations l10n) {
    switch (s.code) {
      case 'caffeine':
        return l10n.supplement_caffeine;
      case 'creatine_monohydrate':
        return l10n.supplement_creatine_monohydrate;
      default:
        return s.name;
    }
  }

  Future<void> _handleSupplementAdd() async {
    final allSupplements = await DatabaseHelper.instance.getAllSupplements();
    if (!mounted || allSupplements.isEmpty) return;
    final l10n = AppLocalizations.of(context)!;

    final Supplement? selectedSupplement = await showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.logIntakeTitle),
        content: SizedBox(
          width: double.maxFinite,
          child: ListView.builder(
            shrinkWrap: true,
            itemCount: allSupplements.length,
            itemBuilder: (context, index) {
              final supplement = allSupplements[index];
              return ListTile(
                title: Text(localizeSupplementName(supplement, l10n)),
                onTap: () => Navigator.of(context).pop(supplement),
              );
            },
          ),
        ),
      ),
    );

    if (selectedSupplement != null && mounted) {
      _logSupplement(selectedSupplement);
    }
  }

  Future<void> _logSupplement(Supplement supplement) async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<LogSupplementDialogContentState> dialogStateKey =
        GlobalKey();
    final result = await showDialog<(double, DateTime)?>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(localizeSupplementName(supplement, l10n)),
          content: LogSupplementDialogContent(
            key: dialogStateKey,
            supplement: supplement,
          ),
          actions: [
            TextButton(
              child: Text(l10n.cancel),
              onPressed: () => Navigator.of(context).pop(null),
            ),
            FilledButton(
              child: Text(l10n.add_button),
              onPressed: () {
                final state = dialogStateKey.currentState;
                if (state != null) {
                  final dose = double.tryParse(
                    state.doseText.replaceAll(',', '.'),
                  );
                  if (dose != null && dose > 0) {
                    Navigator.of(context).pop((dose, state.selectedDateTime));
                  }
                }
              },
            ),
          ],
        );
      },
    );
    if (result != null) {
      final newLog = SupplementLog(
        supplementId: supplement.id!,
        dose: result.$1,
        unit: supplement.unit,
        timestamp: result.$2,
      );
      await DatabaseHelper.instance.insertSupplementLog(newLog);
      _refreshHomeScreen();
    }
  }

  Future<(int, DateTime)?> _showWaterDialog() async {
    final l10n = AppLocalizations.of(context)!;
    final GlobalKey<WaterDialogContentState> dialogStateKey = GlobalKey();
    return showDialog<(int, DateTime)?>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(l10n.add_liquid_title),
          content: WaterDialogContent(key: dialogStateKey),
          actions: [
            TextButton(
              child: Text(l10n.cancel),
              onPressed: () => Navigator.of(context).pop(null),
            ),
            FilledButton(
              child: Text(l10n.add_button),
              onPressed: () {
                final state = dialogStateKey.currentState;
                if (state != null) {
                  final quantity = int.tryParse(state.quantityText);
                  if (quantity != null && quantity > 0) {
                    Navigator.of(
                      context,
                    ).pop((quantity, state.selectedDateTime));
                  }
                }
              },
            ),
          ],
        );
      },
    );
  }

  Future<void> _captureSnapshot() async {
    try {
      final boundary = _pvBoundaryKey.currentContext?.findRenderObject()
          as RenderRepaintBoundary?;
      if (boundary == null) return;
      final img = await boundary.toImage(
        pixelRatio: MediaQuery.of(context).devicePixelRatio,
      );
      setState(() => _pvSnapshot = img);
    } catch (_) {
      // fail silently
    }
  }

  void _clearSnapshot() {
    setState(() => _pvSnapshot = null);
  }

  // Top-Inset für Content, damit er direkt unterhalb der GlobalAppBar startet.
  double _topContentInset(BuildContext context) {
    // Content soll unterhalb der Toolbar starten; der Fade-Bereich darf darüberliegen.
    final paddingTop = MediaQuery.of(context).padding.top;
    return paddingTop + kToolbarHeight;
  }

  Widget _withTopSpacer(BuildContext context, Widget child) {
    return Padding(
      padding: EdgeInsets.only(top: _topContentInset(context)),
      child: child,
    );
  }

  // ERSETZE DIESE METHODE
  GlobalAppBar _buildAppBar(
      BuildContext context, int index, AppLocalizations l10n) {
    switch (index) {
      case 1: // Workout
        return GlobalAppBar(
          title: 'Workout', // TODO: l10n
          actions: [_profileAppBarButton(context)],
        );
      case 2: // Stats
        return GlobalAppBar(
          title: l10n.statistics,
          actions: [_profileAppBarButton(context)],
        );
      case 3: // Nutrition Hub
        return GlobalAppBar(
          title: l10n.nutritionHubTitle,
          actions: [_profileAppBarButton(context)],
        );
      case 0: // Diary
      default:
        return GlobalAppBar(
          automaticallyImplyLeading: false,
          titleSpacing: 0,
          titleWidget: DiaryAppBar(
            selectedDateNotifier:
                _tagebuchKey.currentState?.selectedDateNotifier,
          ),
          actions: [
            IconButton(
              icon: const Icon(Icons.chevron_left),
              onPressed: () {
                _tagebuchKey.currentState?.navigateDay(false);
              },
            ),
            IconButton(
              icon: const Icon(Icons.calendar_today),
              onPressed: () {
                _tagebuchKey.currentState?.pickDate();
              },
            ),
            IconButton(
              icon: const Icon(Icons.chevron_right),
              onPressed: () {
                _tagebuchKey.currentState?.navigateDay(true);
              },
            ),
            _profileAppBarButton(context),
          ],
        );
    }
  }

  List<Map<String, dynamic>> _getSpeedDialActions(AppLocalizations l10n) {
    return [
      {
        'icon': Icons.local_drink,
        'label': l10n.addLiquidOption,
        'action': 'add_liquid',
      },
      {
        'icon': Icons.restaurant_menu,
        'label': l10n.addFoodOption,
        'action': 'add_food',
      },
      {
        'icon': Icons.straighten_outlined,
        'label': l10n.addMeasurement,
        'action': 'add_measurement',
      },
      {
        'icon': Icons.fitness_center,
        'label': l10n.startWorkout,
        'action': 'start_workout',
      },
      {
        'icon': Icons.medication_outlined,
        'label': l10n.logIntakeTitle,
        'action': 'log_supplement',
      },
    ];
  }

  String _formatDuration(Duration d) {
    final h = d.inHours;
    final m = d.inMinutes.remainder(60);
    final s = d.inSeconds.remainder(60);
    if (h > 0) {
      return '${h.toString().padLeft(2, '0')}:${m.toString().padLeft(2, '0')}:${s.toString().padLeft(2, '0')}';
    }
    return '${m.toString().padLeft(2, '0')}:${s.toString().padLeft(2, '0')}';
  }

  Widget _pillIcon({
    required IconData icon,
    required VoidCallback onTap,
  }) {
    return InkWell(
      customBorder: const CircleBorder(),
      onTap: () {
        HapticFeedback.selectionClick();
        onTap();
      },
      child: Padding(
        padding: const EdgeInsets.all(8.0),
        child: Icon(
          icon,
          size: 18,
          color: Theme.of(context).colorScheme.onSurface,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final profileService = Provider.of<ProfileService>(context);

    final manager = context.watch<WorkoutSessionManager>();
    final bool isWorkoutRunning = manager.isActive;
    final String elapsed = _formatDuration(manager.elapsedDuration);
    
    // Parameter für Animation
    // const basePad = 120.0; // Unused locally
    // final runningPad = manager.isActive ? 68.0 : 0.0; // Unused locally

    final isDark = Theme.of(context).brightness == Brightness.dark;
    // final bg = isDark ? summary_card_dark_mode : summary_card_white_mode; // Unused locally in build, used in GlassNavBar logic internal

    // Radius für Liquid Animation (falls aktiv)
    // const double rLiquid = 99; // Unused here directly

    return Stack(
      children: [
        Scaffold(
          extendBodyBehindAppBar: true,
          extendBody: true,
          appBar: _buildAppBar(context, _currentIndex, l10n),
          body: PageView(
            controller: _pageController,
            onPageChanged: _onPageChanged,
            children: <Widget>[
              KeepAlivePage(
                storageKey: const PageStorageKey('tab_tagebuch'),
                child: DiaryScreen(key: _tagebuchKey),
              ),
              const KeepAlivePage(
                storageKey: PageStorageKey('tab_workout'),
                child: WorkoutHubScreen(),
              ),
              const KeepAlivePage(
                storageKey: PageStorageKey('tab_stats'),
                child: StatisticsHubScreen(),
              ),
              const KeepAlivePage(
                storageKey: PageStorageKey('tab_nutrition'),
                child: NutritionHubScreen(),
              ),
            ],
          ),
        ),
        // Laufendes Workout Overlay
        if (isWorkoutRunning)
          Positioned(
            bottom: 36 + kNavBarHeight,
            left: 16,
            right: 16,
            child: _FrostedBar(
              child: _RunningWorkoutRow(
                timeText: elapsed,
                onContinue: () {
                  final log = context.read<WorkoutSessionManager>().workoutLog;
                  if (log != null) {
                    Navigator.of(context).push(
                      MaterialPageRoute(
                        builder: (_) =>
                            LiveWorkoutScreen(workoutLog: log, routine: null),
                      ),
                    );
                  }
                },
                onDiscard: () async {
                  final l10n = AppLocalizations.of(context)!;
                  final wsm = context.read<WorkoutSessionManager>();
                  final logId = wsm.workoutLog?.id;

                  // KORREKTUR: showDeleteConfirmation statt showDialog
                  final confirmed = await showDeleteConfirmation(
                    context,
                    title: l10n.discard_button, // "Verwerfen"
                    content: l10n.deleteWorkoutConfirmContent, // "Wirklich löschen?"
                    confirmLabel: l10n.discard_button, // Roter Button: "Verwerfen"
                  );

                  if (confirmed) {
                    if (logId != null) {
                      await WorkoutDatabaseHelper.instance.deleteWorkoutLog(
                        logId,
                      );
                    }
                    await wsm.finishWorkout();
                  }
                },
                l10n: l10n,
              ),
            ),
          ),
        // Bottom Nav Bar & FAB
        Positioned(
          bottom: 24,
          left: 16,
          right: 16,
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Expanded(
                child: GlassBottomNavBar(
                  currentIndex: _currentIndex,
                  onTap: _onNavigationTapped,
                  onFabTap: _toggleAddMenu,
                  items: [
                    BottomNavigationBarItem(
                      icon: const Icon(Icons.book_outlined),
                      label: l10n.diary,
                    ),
                    BottomNavigationBarItem(
                      icon: const Icon(Icons.fitness_center_outlined),
                      label: l10n.workout,
                    ),
                    const BottomNavigationBarItem(
                      icon: Icon(Icons.bar_chart_outlined),
                      label: 'Stats',
                    ),
                    BottomNavigationBarItem(
                      icon: const Icon(Icons.restaurant_menu_rounded),
                      label: l10n.nutrition,
                    ),
                  ],
                ),
              ),
              SizedBox(width: kBarFabGap),
              GlassFab(
                onPressed: _toggleAddMenu,
                icon: Icons.add,
              ),
            ],
          ),
        ),
        // Speed Dial Menu Animation
        AnimatedBuilder(
          animation: _menuController,
          builder: (context, _) {
            final v = _safe01(_menuController.value);
            final themeService = context.watch<ThemeService>();
            final bool isDarkLocal =
                Theme.of(context).brightness == Brightness.dark;
            final Color bgLocal =
                isDarkLocal ? summary_card_dark_mode : summary_card_white_mode;
            final Color neutralTintLocal =
                (isDarkLocal ? Colors.white : Colors.black)
                    .withOpacity(isDarkLocal ? 0.10 : 0.10);
            final Color effectiveGlassLocal = Color.alphaBlend(neutralTintLocal,
                bgLocal.withOpacity(isDarkLocal ? 0.22 : 0.16));
            
            // Radius für Liquid Animation hier lokal definieren oder aus Konstante
            const double rLiquid = 99; 

            return Offstage(
              offstage: v == 0.0,
              child: IgnorePointer(
                ignoring: v == 0.0,
                child: Stack(
                  children: [
                    Opacity(
                      opacity: v,
                      child: GestureDetector(
                        onTap: () {
                          setState(() {
                            _isAddMenuOpen = false;
                            _menuController.reverse();
                          });
                        },
                        child: BackdropFilter(
                          filter: ImageFilter.blur(
                            sigmaX: 6.0 * v,
                            sigmaY: 6.0 * v,
                          ),
                          child: Container(
                            color: Colors.black.withOpacity(0.4 * v),
                          ),
                        ),
                      ),
                    ),
                    Positioned(
                      bottom: 100.0,
                      right: 20.0,
                      child: Material(
                        color: Colors.transparent,
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.end,
                          children: _getSpeedDialActions(l10n)
                              .asMap()
                              .entries
                              .map((entry) {
                            final index = entry.key;
                            final action = entry.value;
                            final curved = CurvedAnimation(
                              parent: _menuController,
                              curve: Interval(
                                (index * 0.12).clamp(0.0, 0.95),
                                1.0,
                                curve: Curves.easeOutBack,
                              ),
                            );
                            final tv = _safe01(curved.value);
                            final offsetY = 90.0 * (index + 1);
                            return Transform.translate(
                              offset: Offset(0, (1 - tv) * offsetY),
                              child: Opacity(
                                opacity: tv,
                                child: Padding(
                                  padding: const EdgeInsets.symmetric(
                                    vertical: 10.0,
                                  ),
                                  child: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      Text(
                                        action['label'],
                                        style: TextStyle(
                                          color: Theme.of(
                                                    context,
                                                  ).brightness ==
                                                  Brightness.light
                                              ? Colors.black87
                                              : Colors.white,
                                          fontWeight: FontWeight.bold,
                                          fontSize: 18,
                                        ),
                                      ),
                                      const SizedBox(width: 16),
                                      GestureDetector(
                                        behavior: HitTestBehavior.opaque,
                                        onTap: () {
                                          setState(() {
                                            _isAddMenuOpen = false;
                                            _menuController.reverse();
                                          });
                                          _executeAddMenuAction(
                                            action['action'],
                                          );
                                        },
                                        child: themeService.visualStyle == 1
                                            ? LiquidGlass.withOwnLayer(
                                                settings: LiquidGlassSettings(
                                                  thickness: 25,
                                                  blur: 5,
                                                  glassColor:
                                                      effectiveGlassLocal,
                                                  lightIntensity: 0.35,
                                                  saturation: 1.10,
                                                ),
                                                shape:
                                                    const LiquidRoundedSuperellipse(
                                                        borderRadius: rLiquid),
                                                child: Container(
                                                  width: 65.0,
                                                  height: 65.0,
                                                  decoration: BoxDecoration(
                                                    color: neutralTintLocal,
                                                    borderRadius:
                                                        BorderRadius.circular(
                                                            rLiquid),
                                                  ),
                                                  foregroundDecoration:
                                                      BoxDecoration(
                                                    borderRadius:
                                                        BorderRadius.circular(
                                                            rLiquid),
                                                    border: Border.all(
                                                      color: isDarkLocal
                                                          ? Colors.white
                                                              .withOpacity(0.20)
                                                          : Colors.black
                                                              .withOpacity(
                                                                  0.08),
                                                      width: 1.2,
                                                    ),
                                                  ),
                                                  alignment: Alignment.center,
                                                  child: Icon(
                                                    action['icon'],
                                                    size: 28,
                                                    color: isDarkLocal
                                                        ? Colors.white
                                                        : Colors.black,
                                                  ),
                                                ),
                                              )
                                            : ClipRRect(
                                                borderRadius:
                                                    BorderRadius.circular(18),
                                                child: BackdropFilter(
                                                  filter: ImageFilter.blur(
                                                      sigmaX: 12, sigmaY: 12),
                                                  child: Container(
                                                    width: 76,
                                                    height: 76,
                                                    decoration: BoxDecoration(
                                                      color:
                                                          bgLocal.withOpacity(0.80),
                                                      borderRadius:
                                                          BorderRadius.circular(
                                                              18),
                                                      border: Border.all(
                                                        color: isDarkLocal
                                                            ? Colors.white
                                                                .withOpacity(
                                                                    0.30)
                                                            : Colors.black
                                                                .withOpacity(
                                                                    0.10),
                                                        width: 1.5,
                                                      ),
                                                      boxShadow: [
                                                        BoxShadow(
                                                          color: Colors.black
                                                              .withOpacity(
                                                                  0.25),
                                                          blurRadius: 10,
                                                          offset: const Offset(
                                                              0, 4),
                                                        ),
                                                      ],
                                                    ),
                                                    alignment: Alignment.center,
                                                    child: Icon(
                                                      action['icon'],
                                                      size: 28,
                                                      color: isDarkLocal
                                                          ? Colors.white
                                                          : Colors.black,
                                                    ),
                                                  ),
                                                ),
                                              ),
                                      ),
                                    ],
                                  ),
                                ),
                              ),
                            );
                          }).toList(),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      ],
    );
  }
  Widget _profileAppBarButton(BuildContext context) {
    final profileService = Provider.of<ProfileService>(context, listen: false);
    return Padding(
      padding: const EdgeInsets.only(
        right: DesignConstants.screenPaddingHorizontal,
      ),
      child: InkWell(
        customBorder: const CircleBorder(),
        onTap: () {
          Navigator.of(context).push(
            MaterialPageRoute(builder: (_) => const ProfileScreen()),
          );
        },
        child: CircleAvatar(
          radius: 18,
          backgroundColor: Colors.grey.shade300,
          backgroundImage: (profileService.profileImagePath != null)
              ? FileImage(File(profileService.profileImagePath!))
              : null,
          child: (profileService.profileImagePath == null)
              ? const Icon(Icons.person, size: 20, color: Colors.black54)
              : null,
        ),
      ),
    );
  }
}

class _FrostedBar extends StatelessWidget {
  final Widget child;
  const _FrostedBar({required this.child});

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final bg = isDark ? summary_card_dark_mode : summary_card_white_mode;
    final themeService = context.watch<ThemeService>();

    final Color neutralTint =
        (isDark ? Colors.white : Colors.black).withOpacity(isDark ? 0.1 : 0.1);
    final Color effectiveGlass =
        Color.alphaBlend(neutralTint, bg.withOpacity(isDark ? 0.8 : 0.5));

    if (themeService.visualStyle == 1) {
      double radius = 99;
      return SizedBox(
        height: 65.0,
        child: LiquidStretch(
          stretch: 0.2,
          interactionScale: 1.04,
          child: LiquidGlass.withOwnLayer(
            settings: LiquidGlassSettings(
              thickness: 30,
              blur: 0.75,
              glassColor: effectiveGlass,
              lightIntensity: 0.35,
              saturation: 1.10,
            ),
            shape: LiquidRoundedSuperellipse(borderRadius: radius),
            child: Stack(
              children: [
                Positioned.fill(
                  child: DecoratedBox(
                    decoration: BoxDecoration(color: neutralTint),
                  ),
                ),
                Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(radius.toDouble()),
                    border: Border.all(
                      color: isDark
                          ? Colors.white.withOpacity(0.20)
                          : Colors.black.withOpacity(0.08),
                      width: 1.2,
                    ),
                  ),
                  child: child,
                ),
              ],
            ),
          ),
        ),
      );
    }
    double radius = 20;
    return ClipRRect(
      borderRadius: BorderRadius.circular(radius.toDouble()),
      child: BackdropFilter(
        filter: ImageFilter.blur(sigmaX: 12, sigmaY: 12),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
          decoration: BoxDecoration(
            color: bg.withOpacity(0.80),
            borderRadius: BorderRadius.circular(radius.toDouble()),
            border: Border.all(
              color: isDark
                  ? Colors.white.withOpacity(0.30)
                  : Colors.black.withOpacity(0.10),
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                blurRadius: 12,
                offset: const Offset(0, 6),
                color: Colors.black.withOpacity(0.3),
              ),
            ],
          ),
          child: child,
        ),
      ),
    );
  }
}

class _RunningWorkoutRow extends StatelessWidget {
  final String timeText;
  final VoidCallback onContinue;
  final VoidCallback onDiscard;
  final AppLocalizations l10n;

  const _RunningWorkoutRow({
    required this.timeText,
    required this.onContinue,
    required this.onDiscard,
    required this.l10n,
  });

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;

    return Row(
      children: [
        Expanded(
          child: Row(
            children: [
              const Icon(Icons.timer_outlined, size: 20),
              const SizedBox(width: 6),
              Text(
                timeText,
                style: TextStyle(
                  fontSize: 16,
                  color: Theme.of(
                    context,
                  ).colorScheme.onSurface.withOpacity(0.9),
                  decoration: TextDecoration.none,
                  fontFeatures: const [FontFeature.tabularFigures()],
                ),
              ),
            ],
          ),
        ),
        FilledButton(
          onPressed: onContinue,
          style: FilledButton.styleFrom(
            backgroundColor: cs.primary,
            foregroundColor: cs.onPrimary,
            minimumSize: const Size(0, 28),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(10),
            ),
          ),
          child: Text(l10n.continue_workout_button),
        ),
        const SizedBox(width: 8),
        FilledButton(
          onPressed: onDiscard,
          style: FilledButton.styleFrom(
            backgroundColor: cs.error,
            foregroundColor: cs.onError,
            minimumSize: const Size(0, 28),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(10),
            ),
          ),
          child: Text(l10n.discard_button),
        ),
      ],
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/exercise_mapping_screen.dart =====

// lib/screens/exercise_mapping_screen.dart
import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/screens/exercise_catalog_screen.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/global_app_bar.dart';

class ExerciseMappingScreen extends StatefulWidget {
  final List<String> unknownNames;
  const ExerciseMappingScreen({super.key, required this.unknownNames});

  @override
  State<ExerciseMappingScreen> createState() => _ExerciseMappingScreenState();
}

class _ExerciseMappingScreenState extends State<ExerciseMappingScreen> {
  final Map<String, Exercise> _selection = {};
  bool _applying = false;

  Future<void> _pickTarget(String sourceName) async {
    final Exercise? picked = await Navigator.of(context).push(
      MaterialPageRoute(
        builder: (_) => const ExerciseCatalogScreen(isSelectionMode: true),
      ),
    );
    if (picked != null && mounted) {
      setState(() => _selection[sourceName] = picked);
    }
  }

  Future<void> _apply() async {
    if (_selection.isEmpty) {
      Navigator.of(context).pop(false);
      return;
    }
    setState(() => _applying = true);
    final mapping = <String, String>{
      for (final e in _selection.entries)
        e.key: e.value.nameDe.isNotEmpty ? e.value.nameDe : e.value.nameEn,
    };
    await WorkoutDatabaseHelper.instance.applyExerciseNameMapping(mapping);
    if (mounted) {
      setState(() => _applying = false);
      Navigator.of(context).pop(true);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: GlobalAppBar(
        title: l10n.mapExercisesTitle,
      ),
      body: Padding(
        padding: DesignConstants.cardPadding.copyWith(
          top: DesignConstants.cardPadding.top + topPadding,
        ),
        child: Column(
          children: [
            const SizedBox(height: DesignConstants.spacingS),
            Expanded(
              child: ListView.builder(
                itemCount: widget.unknownNames.length,
                itemBuilder: (context, index) {
                  final src = widget.unknownNames[index];
                  final picked = _selection[src];
                  return ListTile(
                    title: Text(src),
                    subtitle: picked == null
                        ? Text(l10n.noSelection)
                        : Text('→ ${picked.nameDe} / ${picked.nameEn}'),
                    trailing: TextButton.icon(
                      icon: const Icon(Icons.search),
                      label: Text(l10n.selectButton),
                      onPressed: () => _pickTarget(src),
                    ),
                  );
                },
              ),
            ),
            SafeArea(
              child: Padding(
                padding:
                    const EdgeInsets.only(bottom: DesignConstants.spacingM),
                child: SizedBox(
                  width: double.infinity,
                  child: ElevatedButton.icon(
                    onPressed: _applying ? null : _apply,
                    icon: _applying
                        ? const SizedBox(
                            width: 16,
                            height: 16,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          )
                        : const Icon(Icons.check),
                    label: Text(
                      _applying ? l10n.applyingChanges : l10n.applyMapping,
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/goals_screen.dart =====

// lib/screens/goals_screen.dart

import 'package:flutter/material.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/widgets/global_app_bar.dart';

class GoalsScreen extends StatefulWidget {
  const GoalsScreen({super.key});

  @override
  State<GoalsScreen> createState() => _GoalsScreenState();
}

class _GoalsScreenState extends State<GoalsScreen> {
  final _formKey = GlobalKey<FormState>();
  bool _isLoading = true;

  final _caloriesController = TextEditingController();
  final _proteinController = TextEditingController();
  final _carbsController = TextEditingController();
  final _fatController = TextEditingController();
  final _waterController = TextEditingController();
  final _heightController = TextEditingController();
  final _sugarController = TextEditingController();
  final _fiberController = TextEditingController();
  final _saltController = TextEditingController();

  double _proteinPercent = 40;
  double _carbsPercent = 40;
  double _fatPercent = 20;

  // KORREKTUR: Farben zentral definieren, passend zum NutritionSummaryWidget
  final Map<String, Color> _macroColors = {
    'protein': Colors.red.shade400,
    'carbs': Colors.green.shade400,
    'fat': Colors.purple.shade300,
  };

  @override
  void initState() {
    super.initState();
    _loadSettings();
    _caloriesController.addListener(_recalculateGramsFromSliders);
  }

  @override
  void dispose() {
    _caloriesController.removeListener(_recalculateGramsFromSliders);
    _caloriesController.dispose();
    _proteinController.dispose();
    _carbsController.dispose();
    _fatController.dispose();
    _waterController.dispose();
    _heightController.dispose();
    _sugarController.dispose();
    _fiberController.dispose();
    _saltController.dispose();
    super.dispose();
  }

  Future<void> _loadSettings() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _heightController.text = (prefs.getInt('userHeight') ?? 180).toString();
      _caloriesController.text =
          (prefs.getInt('targetCalories') ?? 2500).toString();
      _proteinController.text =
          (prefs.getInt('targetProtein') ?? 180).toString();
      _carbsController.text = (prefs.getInt('targetCarbs') ?? 250).toString();
      _fatController.text = (prefs.getInt('targetFat') ?? 80).toString();
      _waterController.text = (prefs.getInt('targetWater') ?? 3000).toString();
      _sugarController.text = (prefs.getInt('targetSugar') ?? 50).toString();
      _fiberController.text = (prefs.getInt('targetFiber') ?? 30).toString();
      _saltController.text = (prefs.getInt('targetSalt') ?? 6).toString();
      _isLoading = false;
    });
  }

  Future<void> _saveSettings() async {
    final isValid = _formKey.currentState?.validate() ?? false;
    if (!isValid) return;
    final prefs = await SharedPreferences.getInstance();

    await prefs.setInt('userHeight', int.parse(_heightController.text));
    await prefs.setInt('targetCalories', int.parse(_caloriesController.text));
    await prefs.setInt('targetProtein', int.parse(_proteinController.text));
    await prefs.setInt('targetCarbs', int.parse(_carbsController.text));
    await prefs.setInt('targetFat', int.parse(_fatController.text));
    await prefs.setInt('targetWater', int.parse(_waterController.text));
    await prefs.setInt('targetSugar', int.parse(_sugarController.text));
    await prefs.setInt('targetFiber', int.parse(_fiberController.text));
    await prefs.setInt('targetSalt', int.parse(_saltController.text));

    if (mounted) {
      final l10n = AppLocalizations.of(context)!;
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text(l10n.snackbarGoalsSaved)));
      Navigator.of(context).pop();
    }
  }

  void _recalculateGramsFromSliders() {
    final totalCalories = int.tryParse(_caloriesController.text) ?? 0;
    if (totalCalories <= 0) return;

    final proteinGrams = (totalCalories * (_proteinPercent / 100)) / 4;
    final carbsGrams = (totalCalories * (_carbsPercent / 100)) / 4;
    final fatGrams = (totalCalories * (_fatPercent / 100)) / 9;

    _proteinController.text = proteinGrams.round().toString();
    _carbsController.text = carbsGrams.round().toString();
    _fatController.text = fatGrams.round().toString();
  }

  Widget _buildMacroCalculator() {
    final l10n = AppLocalizations.of(context)!;
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(
          context,
        ).colorScheme.surfaceContainerHighest.withOpacity(0.3),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        children: [
          Text(
            l10n.macroDistribution,
            style: Theme.of(context).textTheme.titleMedium,
          ),
          _buildMacroSliderRow(
            l10n.protein,
            _proteinPercent,
            _macroColors['protein']!,
          ),
          _buildMacroSliderRow(
            l10n.carbs,
            _carbsPercent,
            _macroColors['carbs']!,
          ),
          _buildMacroSliderRow(l10n.fat, _fatPercent, _macroColors['fat']!),
        ],
      ),
    );
  }

  void _updateSliderValues(String changedMacro, double value) {
    setState(() {
      if (changedMacro == 'protein') {
        _proteinPercent = value;
      } else if (changedMacro == 'carbs') {
        _carbsPercent = value;
      } else if (changedMacro == 'fat') {
        _fatPercent = value;
      }

      double sum = _proteinPercent + _carbsPercent + _fatPercent;
      if (sum.round() != 100) {
        double diff = 100 - sum;
        if (changedMacro == 'protein') {
          _carbsPercent += diff / 2;
          _fatPercent += diff / 2;
        } else if (changedMacro == 'carbs') {
          _proteinPercent += diff / 2;
          _fatPercent += diff / 2;
        } else {
          _proteinPercent += diff / 2;
          _carbsPercent += diff / 2;
        }
      }

      // Clamp values between 0 and 100
      _proteinPercent = _proteinPercent.clamp(0, 100);
      _carbsPercent = _carbsPercent.clamp(0, 100);
      _fatPercent = _fatPercent.clamp(0, 100);
    });
    _recalculateGramsFromSliders();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      extendBodyBehindAppBar: true,

      // NEU: Unsere GlobalAppBar
      appBar: GlobalAppBar(
        title: l10n.my_goals,
        actions: [
          // Der Save-Button bleibt, nur etwas anders verpackt
          Padding(
            padding: const EdgeInsets.only(right: 8.0),
            child: TextButton(
              onPressed: _saveSettings,
              child: Text(
                l10n.buttonSave,
                style: TextStyle(
                  color: Theme.of(context).colorScheme.primary,
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
            ),
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
              // Die neue Padding-Logik
              padding: DesignConstants.cardPadding.copyWith(
                top: DesignConstants.cardPadding.top +
                    MediaQuery.of(context).padding.top +
                    kToolbarHeight,
              ),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    _buildSectionTitle(context, l10n.personalDataCL),
                    const SizedBox(height: DesignConstants.spacingM),
                    _buildSettingsField(
                      controller: _heightController,
                      label: l10n.profileUserHeight,
                    ),
                    const SizedBox(height: DesignConstants.spacingXL),
                    _buildSectionTitle(context, l10n.profileDailyGoalsCL),
                    const SizedBox(height: DesignConstants.spacingM),
                    _buildSettingsField(
                      controller: _caloriesController,
                      label: l10n.calories,
                    ),
                    //const SizedBox(height: DesignConstants.spacingL),
                    //_buildMacroCalculator(),
                    //const SizedBox(height: DesignConstants.spacingL),
                    _buildSettingsField(
                      controller: _proteinController,
                      label: l10n.protein,
                    ),
                    _buildSettingsField(
                      controller: _carbsController,
                      label: l10n.carbs,
                    ),
                    _buildSettingsField(
                      controller: _fatController,
                      label: l10n.fat,
                    ),
                    _buildSettingsField(
                      controller: _waterController,
                      label: l10n.water,
                    ),
                    const SizedBox(height: DesignConstants.spacingXL),
                    _buildSectionTitle(context, l10n.detailedNutrientGoalsCL),
                    const SizedBox(height: DesignConstants.spacingM),
                    _buildSettingsField(
                      controller: _sugarController,
                      label: l10n.sugar,
                    ),
                    _buildSettingsField(
                      controller: _fiberController,
                      label: l10n.fiber,
                    ),
                    _buildSettingsField(
                      controller: _saltController,
                      label: l10n.salt,
                    ),

                    // KORREKTUR: Der untere Button wurde entfernt
                  ],
                ),
              ),
            ),
    );
  }

  // KORREKTUR: Das ist die neue Methode zum Stylen der Slider
  Widget _buildMacroSliderRow(String macro, double value, Color color) {
    return Row(
      children: [
        SizedBox(width: 70, child: Text("${macro.capitalize()}:")),
        Expanded(
          child: SliderTheme(
            data: SliderTheme.of(context).copyWith(
              trackHeight: 12.0, // Dicke des Sliders
              thumbShape: const RoundSliderThumbShape(
                enabledThumbRadius: 8.0,
              ), // Kleinerer Kreis
              overlayShape: const RoundSliderOverlayShape(overlayRadius: 16.0),
              activeTrackColor: color, // Farbe für den aktiven Teil
              inactiveTrackColor: color.withOpacity(0.2), // Hintergrundfarbe
              thumbColor: color, // Farbe des Kreises
              trackShape:
                  const RoundedRectSliderTrackShape(), // Abgerundete Ecken
            ),
            child: Slider(
              value: value,
              min: 0,
              max: 100,
              label: '${value.round()}%',
              onChanged: (newValue) {
                _updateSliderValues(macro, newValue);
              },
            ),
          ),
        ),
        SizedBox(
          width: 50,
          child: Text("${value.round()}%", textAlign: TextAlign.right),
        ),
      ],
    );
  }

  Widget _buildSettingsField({
    required TextEditingController controller,
    required String label,
  }) {
    final l10n = AppLocalizations.of(context)!;
    return Padding(
      padding: const EdgeInsets.only(bottom: 12.0),
      child: TextFormField(
        controller: controller,
        decoration: InputDecoration(labelText: label),
        keyboardType: TextInputType.number,
        validator: (value) {
          if (value == null || value.isEmpty || num.tryParse(value) == null) {
            return l10n.validatorPleaseEnterNumber;
          }
          return null;
        },
      ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.labelLarge?.copyWith(
              color: Colors.grey[600],
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }
}

extension StringExtension on String {
  String capitalize() {
    if (isEmpty) return this;
    return "${this[0].toUpperCase()}${substring(1)}";
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/create_supplement_screen.dart =====

// lib/screens/create_supplement_screen.dart
import 'package:flutter/material.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/util/util_convert.dart';
import 'package:lightweight/widgets/global_app_bar.dart';

class CreateSupplementScreen extends StatefulWidget {
  final Supplement? supplementToEdit;
  const CreateSupplementScreen({super.key, this.supplementToEdit});

  @override
  State<CreateSupplementScreen> createState() => _CreateSupplementScreenState();
}

class _CreateSupplementScreenState extends State<CreateSupplementScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _doseController = TextEditingController();
  final _unitController = TextEditingController();
  final _goalController = TextEditingController();
  final _limitController = TextEditingController();
  final _notesController = TextEditingController();

  late final l10n = AppLocalizations.of(context)!;

  bool get _isEditing => widget.supplementToEdit != null;

  late String _unit; // NEU

  @override
  void initState() {
    super.initState();
    if (_isEditing) {
      final s = widget.supplementToEdit!;
      _nameController.text = s.name;
      _doseController.text = s.defaultDose.toString();
      _goalController.text = s.dailyGoal?.toString() ?? '';
      _limitController.text = s.dailyLimit?.toString() ?? '';
      _notesController.text = s.notes ?? '';
      _unit = s.unit; // NEU: verlässlich aus dem Datensatz
    } else {
      _unit = 'mg'; // Default bei Neuanlage
    }
  }

  Future<void> _saveSupplement() async {
    if (!_formKey.currentState!.validate()) return;

    final editing = _isEditing ? widget.supplementToEdit : null;
    final bool isBuiltinCaffeine =
        (editing?.isBuiltin == true) && (editing?.code == 'caffeine');

    // Einheit festlegen/absichern
    String unitToSave = isBuiltinCaffeine ? 'mg' : _unit;

    final newSupplement = Supplement(
      id: editing?.id,
      code: editing?.code, // bei Edit beibehalten; bei New null
      name: _nameController.text.trim(),
      defaultDose:
          double.tryParse(_doseController.text.replaceAll(',', '.')) ?? 0.0,
      unit: unitToSave,
      dailyGoal: _goalController.text.trim().isEmpty
          ? null
          : double.tryParse(_goalController.text.replaceAll(',', '.')),
      dailyLimit: _limitController.text.trim().isEmpty
          ? null
          : double.tryParse(_limitController.text.replaceAll(',', '.')),
      notes: _notesController.text.trim().isEmpty
          ? null
          : _notesController.text.trim(),
      isBuiltin: editing?.isBuiltin ?? false,
    );

    if (_isEditing) {
      await DatabaseHelper.instance.updateSupplement(newSupplement);
    } else {
      await DatabaseHelper.instance.insertSupplement(newSupplement);
    }

    if (!mounted) return;
    Navigator.of(context).pop(true);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    // NEU: Caffeine-Lock bestimmen
    final s = widget.supplementToEdit;
    final bool isBuiltinCaffeine =
        (s?.isBuiltin == true) && (s?.code == 'caffeine');
    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: GlobalAppBar(
        title: _isEditing ? l10n.edit : l10n.createSupplementTitle,
        actions: [
          TextButton(
            onPressed: _saveSupplement,
            child: Text(
              l10n.save,
              style: TextStyle(
                color: Theme.of(context).colorScheme.primary,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: DesignConstants.cardPadding.copyWith(
          top: DesignConstants.cardPadding.top + topPadding,
        ),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              _buildTextField(
                _nameController,
                l10n.supplementNameLabel,
                isRequired: true,
              ),
              const SizedBox(height: DesignConstants.spacingL),
              Row(
                children: [
                  Expanded(
                    child: _buildTextField(
                      _doseController,
                      l10n.defaultDoseLabel,
                      isNumeric: true,
                    ),
                  ),
                  const SizedBox(width: DesignConstants.spacingM),

                  // <- Wichtig: begrenzen!
                  Expanded(
                    child: DropdownButtonFormField<String>(
                      initialValue: _unit,
                      items: allowedUnits
                          .map(
                            (u) => DropdownMenuItem<String>(
                              value: u,
                              child: Text(u),
                            ),
                          )
                          .toList(),
                      onChanged: isBuiltinCaffeine
                          ? null
                          : (val) {
                              if (val == null) return;
                              setState(() => _unit = val);
                            },
                      decoration: InputDecoration(
                        labelText: l10n.unitLabel,
                        isDense: true, // optional, macht's kompakter
                        helperText:
                            isBuiltinCaffeine ? l10n.caffeineUnitLocked : null,
                      ),
                      validator: (val) {
                        if (val == null || val.isEmpty) {
                          return l10n.fieldRequired;
                        }
                        if (!allowedUnits.contains(val)) {
                          return l10n.unitNotSupported;
                        }
                        return null;
                      },
                    ),
                  ),
                ],
              ),
              const SizedBox(height: DesignConstants.spacingXL),
              _buildTextField(
                _goalController,
                l10n.dailyGoalLabel,
                isNumeric: true,
              ),
              const SizedBox(height: DesignConstants.spacingL),
              _buildTextField(
                _limitController,
                l10n.dailyLimitLabel,
                isNumeric: true,
              ),
              const SizedBox(height: DesignConstants.spacingL),
              _buildTextField(_notesController, l10n.notesLabel, maxLines: 3),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTextField(
    TextEditingController controller,
    String label, {
    bool isRequired = false,
    bool isNumeric = false,
    int? maxLines = 1,
  }) {
    return TextFormField(
      controller: controller,
      decoration: InputDecoration(labelText: label),
      keyboardType: isNumeric
          ? const TextInputType.numberWithOptions(decimal: true)
          : TextInputType.text,
      maxLines: maxLines,
      validator: (value) {
        if (isRequired && (value == null || value.trim().isEmpty)) {
          return l10n.validatorPleaseEnterName;
        }
        if (isNumeric &&
            value != null &&
            value.isNotEmpty &&
            double.tryParse(value.replaceAll(',', '.')) == null) {
          return l10n.validatorPleaseEnterNumber;
        }
        return null;
      },
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/meal_editor_screen.dart =====

import 'package:flutter/material.dart';

enum MealType { breakfast, lunch, dinner, snack }

class MealEditorScreen extends StatefulWidget {
  final String? initialName;
  final MealType initialType;

  const MealEditorScreen({
    super.key,
    this.initialName,
    this.initialType = MealType.lunch,
  });

  @override
  State<MealEditorScreen> createState() => _MealEditorScreenState();
}

class _MealEditorScreenState extends State<MealEditorScreen> {
  late final TextEditingController _nameCtrl;
  late MealType _type;
  bool _saving = false;

  bool get _canSave =>
      !_saving && _nameCtrl.text.trim().isNotEmpty; // simpel & robust

  @override
  void initState() {
    super.initState();
    _nameCtrl = TextEditingController(text: widget.initialName ?? '');
    _type = widget.initialType;
    _nameCtrl.addListener(() => setState(() {})); // Button-State aktualisieren
  }

  @override
  void dispose() {
    _nameCtrl.dispose();
    super.dispose();
  }

  Future<void> _onSave() async {
    if (!_canSave) return;
    setState(() => _saving = true);

    try {
      // 🔗 HIER später: Repo/DB call (insert/update).
      // Für jetzt: einfach Erfolg simulieren und zurück.
      await Future.delayed(const Duration(milliseconds: 150));
      if (mounted) Navigator.pop(context, true);
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text('Fehler beim Speichern: $e')));
      setState(() => _saving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Meal bearbeiten'),
        actions: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
            child: ElevatedButton(
              onPressed: _canSave ? _onSave : null,
              child: _saving
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Text('Speichern'),
            ),
          ),
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          TextField(
            controller: _nameCtrl,
            textInputAction: TextInputAction.done,
            decoration: const InputDecoration(
              labelText: 'Meal-Name',
              hintText: 'z. B. Hähnchen Bowl',
            ),
            onSubmitted: (_) => _onSave(),
          ),
          const SizedBox(height: 12),
          DropdownButtonFormField<MealType>(
            initialValue: _type,
            onChanged: (v) => setState(() => _type = v ?? _type),
            decoration: const InputDecoration(labelText: 'Meal-Typ'),
            items: MealType.values
                .map((t) => DropdownMenuItem(value: t, child: Text(_label(t))))
                .toList(),
          ),
          const SizedBox(height: 24),
          // Platzhalter: später Zutaten/Per-Ingredient Anzeige
          Card(
            child: ListTile(
              title: const Text('Zutaten'),
              subtitle: const Text('Noch keine – kommt später'),
              trailing: IconButton(
                icon: const Icon(Icons.add),
                onPressed: () {
                  // später: Produktpicker öffnen
                },
              ),
            ),
          ),
        ],
      ),
    );
  }
}

String _label(MealType t) {
  switch (t) {
    case MealType.breakfast:
      return 'Frühstück';
    case MealType.lunch:
      return 'Mittag';
    case MealType.dinner:
      return 'Abend';
    case MealType.snack:
      return 'Snack';
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/create_exercise_screen.dart =====

// lib/screens/create_exercise_screen.dart
import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/global_app_bar.dart';

class CreateExerciseScreen extends StatefulWidget {
  const CreateExerciseScreen({super.key});
  @override
  State<CreateExerciseScreen> createState() => _CreateExerciseScreenState();
}

class _CreateExerciseScreenState extends State<CreateExerciseScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _descriptionController = TextEditingController();

  // Statt Controller nutzen wir jetzt eine Variable für das Dropdown
  String? _selectedCategory;

  // Fallback-Listen, falls die DB leer ist
  final List<String> _defaultCategories = [
    'Abs',
    'Arms',
    'Back',
    'Calves',
    'Chest',
    'Legs',
    'Shoulders',
    'Cardio'
  ];
  final List<String> _defaultMuscles = [
    'Biceps',
    'Triceps',
    'Quadriceps',
    'Hamstrings',
    'Calves',
    'Chest',
    'Back',
    'Shoulders',
    'Abs',
    'Glutes',
    'Forearms',
    'Traps'
  ];

  List<String> _allCategories = [];
  List<String> _allMuscleGroups = [];

  final List<String> _selectedPrimaryMuscles = [];
  final List<String> _selectedSecondaryMuscles = [];

  bool _isLoading = true;
  bool _saving = false;

  late final l10n = AppLocalizations.of(context)!;

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  @override
  void dispose() {
    _nameController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }

  Future<void> _loadData() async {
    setState(() => _isLoading = true);
    try {
      final db = WorkoutDatabaseHelper.instance;
      final categories = await db.getAllCategories();
      final muscles = await db.getAllMuscleGroups();

      if (mounted) {
        setState(() {
          // Nutze DB-Werte oder Fallback, falls leer
          _allCategories =
              categories.isNotEmpty ? categories : _defaultCategories;
          _allMuscleGroups = muscles.isNotEmpty ? muscles : _defaultMuscles;

          // Sortieren für bessere UX
          _allCategories.sort();
          _allMuscleGroups.sort();

          _isLoading = false;
        });
      }
    } catch (e) {
      debugPrint("Fehler beim Laden der Daten: $e");
      if (mounted) {
        setState(() {
          _allCategories = _defaultCategories;
          _allMuscleGroups = _defaultMuscles;
          _isLoading = false;
        });
      }
    }
  }

  Future<void> _saveExercise() async {
    if (_saving) return;
    if (!_formKey.currentState!.validate()) return;

    setState(() => _saving = true);

    try {
      final newExercise = Exercise(
        // ID ist null, DB vergibt neue ID
        nameDe: _nameController.text.trim(),
        nameEn: _nameController.text.trim(),
        descriptionDe: _descriptionController.text.trim(),
        descriptionEn: _descriptionController.text.trim(),
        categoryName: _selectedCategory ?? 'Other', // Fallback
        primaryMuscles: _selectedPrimaryMuscles,
        secondaryMuscles: _selectedSecondaryMuscles,
        imagePath: null, // Kein Bild für Custom Exercises
      );

      await WorkoutDatabaseHelper.instance.insertExercise(newExercise);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(l10n.snackbarSaveSuccess(newExercise.nameDe))),
        );
        Navigator.of(context).pop(true);
      }
    } catch (e) {
      debugPrint("Fehler beim Speichern: $e");
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('${l10n.error}: $e')),
        );
      }
    } finally {
      if (mounted) setState(() => _saving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: GlobalAppBar(
        title: l10n.create_exercise_screen_title,
        actions: [
          TextButton(
            onPressed: _saving ? null : _saveExercise,
            child: _saving
                ? const SizedBox(
                    width: 16,
                    height: 16,
                    child: CircularProgressIndicator(strokeWidth: 2))
                : Text(
                    l10n.save,
                    style: TextStyle(
                      color: _saving
                          ? Theme.of(context).disabledColor
                          : Theme.of(context).colorScheme.primary,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
              padding: DesignConstants.cardPadding.copyWith(
                top: DesignConstants.cardPadding.top + topPadding,
              ),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    // --- Name ---
                    TextFormField(
                      controller: _nameController,
                      decoration: InputDecoration(
                        labelText: l10n.exercise_name_label,
                        filled: true,
                      ),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return l10n.validatorPleaseEnterName;
                        }
                        return null;
                      },
                      textInputAction: TextInputAction.next,
                    ),
                    const SizedBox(height: DesignConstants.spacingL),

                    // --- Kategorie (Dropdown) ---
                    DropdownButtonFormField<String>(
                      initialValue: _selectedCategory,
                      items: _allCategories.map((cat) {
                        return DropdownMenuItem(
                          value: cat,
                          child: Text(cat),
                        );
                      }).toList(),
                      onChanged: (val) {
                        setState(() => _selectedCategory = val);
                      },
                      decoration: InputDecoration(
                        labelText: l10n.category_label,
                        hintText: l10n.categoryHint,
                        filled: true,
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return l10n.validatorPleaseEnterCategory;
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: DesignConstants.spacingL),

                    // --- Beschreibung ---
                    TextFormField(
                      controller: _descriptionController,
                      decoration: InputDecoration(
                        labelText: l10n.description_optional_label,
                        filled: true,
                      ),
                      maxLines: 3,
                    ),
                    const SizedBox(height: DesignConstants.spacingXL),

                    // --- Primäre Muskeln ---
                    _buildSectionTitle(context, l10n.primary_muscles_label),
                    const SizedBox(height: 8),
                    _buildMuscleSelector(
                      availableMuscles: _allMuscleGroups,
                      selectedMuscles: _selectedPrimaryMuscles,
                    ),
                    const SizedBox(height: DesignConstants.spacingXL),

                    // --- Sekundäre Muskeln ---
                    _buildSectionTitle(context, l10n.secondary_muscles_label),
                    const SizedBox(height: 8),
                    _buildMuscleSelector(
                      availableMuscles: _allMuscleGroups,
                      selectedMuscles: _selectedSecondaryMuscles,
                    ),

                    const SizedBox(height: DesignConstants.spacingXXL),
                  ],
                ),
              ),
            ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Text(
      title,
      style: Theme.of(context).textTheme.titleMedium?.copyWith(
            color: Colors.grey[700],
            fontWeight: FontWeight.bold,
          ),
    );
  }

  Widget _buildMuscleSelector({
    required List<String> availableMuscles,
    required List<String> selectedMuscles,
  }) {
    return Wrap(
      spacing: 8.0,
      runSpacing: 4.0,
      children: availableMuscles.map((muscle) {
        final isSelected = selectedMuscles.contains(muscle);
        return FilterChip(
          label: Text(muscle),
          selected: isSelected,
          onSelected: (bool selected) {
            setState(() {
              if (selected) {
                selectedMuscles.add(muscle);
              } else {
                selectedMuscles.remove(muscle);
              }
            });
          },
          checkmarkColor: Theme.of(context).colorScheme.onPrimaryContainer,
        );
      }).toList(),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/screens/workout_summary_screen.dart =====

// lib/screens/workout_summary_screen.dart

import 'package:flutter/material.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/global_app_bar.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'package:lightweight/widgets/workout_summary_bar.dart';

class WorkoutSummaryScreen extends StatefulWidget {
  final int logId;

  const WorkoutSummaryScreen({super.key, required this.logId});

  @override
  State<WorkoutSummaryScreen> createState() => _WorkoutSummaryScreenState();
}

class _WorkoutSummaryScreenState extends State<WorkoutSummaryScreen> {
  bool _isLoading = true;
  WorkoutLog? _log;
  Map<String, double> _volumePerExercise = {};

  @override
  void initState() {
    super.initState();
    _loadWorkoutDetails();
  }

  Future<void> _loadWorkoutDetails() async {
    final data = await WorkoutDatabaseHelper.instance.getWorkoutLogById(
      widget.logId,
    );

    if (data != null) {
      final Map<String, double> volumeMap = {};
      for (var set in data.sets) {
        final volume = (set.weightKg ?? 0) * (set.reps ?? 0);
        volumeMap.update(
          set.exerciseName,
          (value) => value + volume,
          ifAbsent: () => volume,
        );
      }

      if (mounted) {
        setState(() {
          _log = data;
          _volumePerExercise = volumeMap;
          _isLoading = false;
        });
      }
    } else {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final textTheme = Theme.of(context).textTheme;

    final double topPadding =
        MediaQuery.of(context).padding.top + kToolbarHeight;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: GlobalAppBar(
        title: l10n.workoutSummaryTitle,
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _log == null
              ? Center(child: Text(l10n.workoutNotFound))
              : Padding(
                  padding: DesignConstants.cardPadding,
                  child: Column(
                    children: [
                      // Gesamt-Statistiken
                      WorkoutSummaryBar(
                        duration: _log!.endTime?.difference(_log!.startTime),
                        volume:
                            _volumePerExercise.values.fold(0, (a, b) => a + b),
                        sets: _log!.sets.length,
                        progress: null,
                      ),
                      const SizedBox(height: DesignConstants.spacingXL),

                      // Liste der Übungen
                      Expanded(
                        child: ListView(
                          children: [
                            Text(
                              l10n.workoutSummaryExerciseOverview,
                              style: textTheme.titleMedium,
                            ),
                            const SizedBox(height: DesignConstants.spacingS),
                            ..._volumePerExercise.entries.map((entry) {
                              return SummaryCard(
                                child: ListTile(
                                  title: Text(
                                    entry.key,
                                    style: const TextStyle(
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                  trailing: Text(
                                    "${entry.value.toStringAsFixed(0)} kg",
                                    style: textTheme.bodyLarge,
                                  ),
                                ),
                              );
                            }),
                          ],
                        ),
                      ),
                      const SizedBox(height: DesignConstants.spacingXL),

                      // Fertig-Button
                      SizedBox(
                        width: double.infinity,
                        child: ElevatedButton(
                          style: ElevatedButton.styleFrom(
                            padding: const EdgeInsets.symmetric(vertical: 16),
                          ),
                          onPressed: () {
                            // Schließt den Summary-Screen und kehrt zum vorherigen Screen zurück
                            // (vermutlich der Routines- oder Home-Screen)
                            Navigator.of(context).pop();
                          },
                          child: Text(
                            l10n.doneButtonLabel,
                            style: const TextStyle(fontSize: 18),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/theme/app_colors.dart =====

import 'package:flutter/material.dart';

@immutable
class AppSurfaces extends ThemeExtension<AppSurfaces> {
  final Color summaryCard;
  const AppSurfaces({required this.summaryCard});

  @override
  AppSurfaces copyWith({Color? summaryCard}) =>
      AppSurfaces(summaryCard: summaryCard ?? this.summaryCard);

  @override
  AppSurfaces lerp(ThemeExtension<AppSurfaces>? other, double t) {
    if (other is! AppSurfaces) return this;
    return AppSurfaces(
      summaryCard: Color.lerp(summaryCard, other.summaryCard, t)!,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/theme/color_constants.dart =====

// lib/theme/color_constants.dart

import 'package:flutter/material.dart';

const Color summary_card_dark_mode = Color.fromARGB(
  255,
  40,
  40,
  40,
); // tiefes Grau für Dark Mode
const Color summary_card_white_mode = Color.fromARGB(
  255,
  235,
  235,
  235,
); // sehr helles Grau für Light Mode


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/dialogs/fluid_dialog_content.dart =====

// lib/dialogs/fluid_dialog_content.dart - ERSETZE DIE GESAMTE DATEI

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/design_constants.dart';

class FluidDialogContent extends StatefulWidget {
  final int? initialQuantity;
  final DateTime? initialTimestamp;
  final String? initialName; // <--- NEU
  final double? initialSugar; // <--- NEU
  final double? initialCaffeine; // <--- NEU

  const FluidDialogContent({
    super.key,
    this.initialQuantity,
    this.initialTimestamp,
    this.initialName, // <--- NEU
    this.initialSugar, // <--- NEU
    this.initialCaffeine, // <--- NEU
  });

  @override
  FluidDialogContentState createState() => FluidDialogContentState();
}

class FluidDialogContentState extends State<FluidDialogContent> {
  late final TextEditingController _nameController;
  late final TextEditingController _quantityController;
  late final TextEditingController _caffeineController;
  late final TextEditingController _sugarController;
  late DateTime _selectedDateTime;

  String get nameText => _nameController.text;
  String get quantityText => _quantityController.text;
  String get caffeineText => _caffeineController.text;
  String get sugarText => _sugarController.text;
  DateTime get selectedDateTime => _selectedDateTime;

  @override
  void initState() {
    super.initState();
    _nameController = TextEditingController(
        text: widget.initialName ?? 'Water'); // <--- Initialisierung anpassen
    _quantityController = TextEditingController(
      text: widget.initialQuantity?.toString() ?? '',
    );
    // <--- Hinzufügen der Initialisierung für Nährstoffe
    _caffeineController = TextEditingController(
      text:
          widget.initialCaffeine?.toStringAsFixed(1).replaceAll('.0', '') ?? '',
    );
    _sugarController = TextEditingController(
      text: widget.initialSugar?.toStringAsFixed(1).replaceAll('.0', '') ?? '',
    );
    _selectedDateTime = widget.initialTimestamp ?? DateTime.now();
  }

  @override
  void dispose() {
    _nameController.dispose();
    _quantityController.dispose();
    _caffeineController.dispose();
    _sugarController.dispose();
    super.dispose();
  }

  Future<void> _selectDate() async {
    final locale = Localizations.localeOf(context);
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDateTime,
      firstDate: DateTime(2020),
      lastDate: DateTime.now().add(const Duration(days: 365)),
      locale: locale,
    );
    if (picked != null && picked != _selectedDateTime) {
      setState(() {
        _selectedDateTime = DateTime(
          picked.year,
          picked.month,
          picked.day,
          _selectedDateTime.hour,
          _selectedDateTime.minute,
        );
      });
    }
  }

  Future<void> _selectTime() async {
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(_selectedDateTime),
    );
    if (picked != null) {
      setState(() {
        _selectedDateTime = DateTime(
          _selectedDateTime.year,
          _selectedDateTime.month,
          _selectedDateTime.day,
          picked.hour,
          picked.minute,
        );
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).toString();
    final formattedDate = DateFormat.yMd(locale).format(_selectedDateTime);
    final formattedTime = DateFormat.Hm(locale).format(_selectedDateTime);

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        TextField(
          controller: _nameController,
          decoration: const InputDecoration(labelText: 'Name'),
          autofocus: true,
        ),
        const SizedBox(height: DesignConstants.spacingL),
        TextField(
          controller: _quantityController,
          keyboardType: TextInputType.number,
          decoration: InputDecoration(
            labelText: l10n.amount_in_milliliters,
            suffixText: 'ml',
          ),
          autofocus: true,
        ),
        const SizedBox(height: DesignConstants.spacingL),
        TextField(
          controller: _sugarController,
          keyboardType: const TextInputType.numberWithOptions(decimal: true),
          decoration: InputDecoration(
            labelText: '${l10n.sugar} (g / 100ml)',
            suffixText: 'g',
          ),
        ),
        const SizedBox(height: DesignConstants.spacingL),
        TextField(
          controller: _caffeineController,
          keyboardType: const TextInputType.numberWithOptions(decimal: true),
          decoration: InputDecoration(
            labelText: l10n.caffeinePrompt,
            suffixText: 'mg / 100ml',
          ),
        ),
        const SizedBox(height: DesignConstants.spacingL),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            TextButton.icon(
              icon: const Icon(Icons.calendar_today, size: 20),
              label: Text(formattedDate, style: const TextStyle(fontSize: 16)),
              onPressed: _selectDate,
            ),
            TextButton.icon(
              icon: const Icon(Icons.access_time, size: 20),
              label: Text(formattedTime, style: const TextStyle(fontSize: 16)),
              onPressed: _selectTime,
            ),
          ],
        ),
      ],
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/dialogs/water_dialog_content.dart =====

// lib/dialogs/water_dialog_content.dart

import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/design_constants.dart';

// ===== App-wide modal helpers (temporary location — can be moved to a shared file) =====

enum AppSheetStyle { plain, glass }

/// Unified show function for bottom sheets. Use this everywhere to keep styling consistent.
Future<T?> showAppBottomSheet<T>(
  BuildContext context, {
  required Widget child,
  AppSheetStyle style = AppSheetStyle.plain,
  bool isDismissible = true,
  bool enableDrag = true,
}) {
  return showModalBottomSheet<T>(
    context: context,
    isScrollControlled: true,
    useSafeArea: true,
    isDismissible: isDismissible,
    enableDrag: enableDrag,
    backgroundColor: Colors.transparent, // let our scaffold draw the background
    builder: (ctx) => AppSheetScaffold(
      style: style,
      child: child,
    ),
  );
}

/// Provides a consistent modal surface with rounded corners, padding, and optional "liquid glass".
class AppSheetScaffold extends StatelessWidget {
  final Widget child;
  final AppSheetStyle style;

  const AppSheetScaffold({
    super.key,
    required this.child,
    this.style = AppSheetStyle.plain,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    Widget surface = Container(
      decoration: BoxDecoration(
        color: style == AppSheetStyle.glass
            ? Colors.white.withOpacity(0.20)
            : theme.colorScheme.surface,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(24),
          topRight: Radius.circular(24),
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.08),
            blurRadius: 16,
            offset: const Offset(0, 8),
          )
        ],
        border: style == AppSheetStyle.glass
            ? Border.all(
                color: Colors.white.withOpacity(0.25),
                width: 1,
              )
            : null,
      ),
      padding: const EdgeInsets.fromLTRB(
        DesignConstants.spacingL,
        DesignConstants.spacingL,
        DesignConstants.spacingL,
        DesignConstants.spacingXL, // extra bottom padding for buttons
      ),
      child: child,
    );

    if (style == AppSheetStyle.glass) {
      surface = ClipRRect(
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(24),
          topRight: Radius.circular(24),
        ),
        child: BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 16, sigmaY: 16),
          child: surface,
        ),
      );
    }

    return SafeArea(
      top: false,
      child: surface,
    );
  }
}

class WaterDialogContent extends StatefulWidget {
  final int? initialQuantity;
  final DateTime? initialTimestamp;

  const WaterDialogContent({
    super.key,
    this.initialQuantity,
    this.initialTimestamp,
  });
  @override
  WaterDialogContentState createState() => WaterDialogContentState();
}

class WaterDialogContentState extends State<WaterDialogContent> {
  late final TextEditingController _textController;
  late DateTime _selectedDateTime;
  late final l10n = AppLocalizations.of(context)!;

  String get quantityText => _textController.text;
  DateTime get selectedDateTime => _selectedDateTime;

  @override
  void initState() {
    super.initState();
    _textController = TextEditingController(
      text: widget.initialQuantity?.toString() ?? '',
    );
    _selectedDateTime = widget.initialTimestamp ?? DateTime.now();
  }

  @override
  void dispose() {
    _textController.dispose();
    super.dispose();
  }

  Future<void> _selectDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDateTime,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (picked != null && picked != _selectedDateTime) {
      setState(() {
        _selectedDateTime = DateTime(
          picked.year,
          picked.month,
          picked.day,
          _selectedDateTime.hour,
          _selectedDateTime.minute,
        );
      });
    }
  }

  Future<void> _selectTime() async {
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(_selectedDateTime),
    );
    if (picked != null) {
      setState(() {
        _selectedDateTime = DateTime(
          _selectedDateTime.year,
          _selectedDateTime.month,
          _selectedDateTime.day,
          picked.hour,
          picked.minute,
        );
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final formattedDate = DateFormat('dd.MM.yyyy').format(_selectedDateTime);
    final formattedTime = DateFormat.Hm().format(_selectedDateTime);
    return AppSheetScaffold(
      // Toggle between plain and glass depending on your feature flag or setting.
      style: AppSheetStyle.plain, // or AppSheetStyle.glass
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          TextField(
            controller: _textController,
            keyboardType: TextInputType.number,
            decoration: InputDecoration(
              labelText: l10n.amount_in_milliliters,
              suffixText: 'ml',
            ),
            autofocus: true,
          ),
          const SizedBox(height: DesignConstants.spacingL),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              InkWell(
                onTap: _selectDate,
                child: Padding(
                  padding: DesignConstants.cardMargin,
                  child: Row(
                    children: [
                      const Icon(Icons.calendar_today, size: 20),
                      const SizedBox(width: 8),
                      Text(formattedDate, style: const TextStyle(fontSize: 16)),
                    ],
                  ),
                ),
              ),
              InkWell(
                onTap: _selectTime,
                child: Padding(
                  padding: DesignConstants.cardMargin,
                  child: Row(
                    children: [
                      const Icon(Icons.access_time, size: 20),
                      const SizedBox(width: 8),
                      Text(formattedTime, style: const TextStyle(fontSize: 16)),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

// Example launcher for this dialog using the unified sheet
Future<void> openWaterDialog(BuildContext context,
    {int? initialQuantity,
    DateTime? initialTimestamp,
    AppSheetStyle style = AppSheetStyle.plain}) {
  return showAppBottomSheet(
    context,
    style: style,
    child: WaterDialogContent(
      initialQuantity: initialQuantity,
      initialTimestamp: initialTimestamp,
    ),
  );
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/dialogs/log_supplement_dialog_content.dart =====

// lib/dialogs/log_supplement_dialog_content.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/util/design_constants.dart';

class LogSupplementDialogContent extends StatefulWidget {
  final Supplement supplement;
  final double? initialDose;
  final DateTime? initialTimestamp;

  const LogSupplementDialogContent({
    super.key,
    required this.supplement,
    this.initialDose,
    this.initialTimestamp,
  });

  @override
  LogSupplementDialogContentState createState() =>
      LogSupplementDialogContentState();
}

class LogSupplementDialogContentState
    extends State<LogSupplementDialogContent> {
  late final TextEditingController _doseController;
  late DateTime _selectedDateTime;

  // Getter für den Zugriff von außen
  String get doseText => _doseController.text;
  DateTime get selectedDateTime => _selectedDateTime;

  @override
  void initState() {
    super.initState();
    _doseController = TextEditingController(
      text: widget.initialDose?.toStringAsFixed(1).replaceAll('.0', '') ??
          widget.supplement.defaultDose.toStringAsFixed(1).replaceAll('.0', ''),
    );
    _selectedDateTime = widget.initialTimestamp ?? DateTime.now();
  }

  @override
  void dispose() {
    _doseController.dispose();
    super.dispose();
  }

  Future<void> _selectDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDateTime,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (picked != null && picked != _selectedDateTime) {
      setState(() {
        _selectedDateTime = DateTime(
          picked.year,
          picked.month,
          picked.day,
          _selectedDateTime.hour,
          _selectedDateTime.minute,
        );
      });
    }
  }

  Future<void> _selectTime() async {
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(_selectedDateTime),
    );
    if (picked != null) {
      setState(() {
        _selectedDateTime = DateTime(
          _selectedDateTime.year,
          _selectedDateTime.month,
          _selectedDateTime.day,
          picked.hour,
          picked.minute,
        );
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!; // Holen der l10n Instanz
    final formattedDate = DateFormat('dd.MM.yyyy').format(_selectedDateTime);
    final formattedTime = DateFormat.Hm().format(_selectedDateTime);
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        TextFormField(
          controller: _doseController,
          keyboardType: const TextInputType.numberWithOptions(decimal: true),
          decoration: InputDecoration(
            labelText: l10n.doseLabel, // LOKALISIERT
            suffixText: widget.supplement.unit,
          ),
          autofocus: true,
        ),
        const SizedBox(height: DesignConstants.spacingL),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            InkWell(
              onTap: _selectDate,
              child: Padding(
                padding: DesignConstants.cardMargin,
                child: Row(
                  children: [
                    const Icon(Icons.calendar_today, size: 20),
                    const SizedBox(width: 8),
                    Text(formattedDate, style: const TextStyle(fontSize: 16)),
                  ],
                ),
              ),
            ),
            InkWell(
              onTap: _selectTime,
              child: Padding(
                padding: DesignConstants.cardMargin,
                child: Row(
                  children: [
                    const Icon(Icons.access_time, size: 20),
                    const SizedBox(width: 8),
                    Text(formattedTime, style: const TextStyle(fontSize: 16)),
                  ],
                ),
              ),
            ),
          ],
        ),
      ],
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/dialogs/log_supplement_menu.dart =====

// lib/dialogs/log_supplement_menu.dart
import 'package:flutter/material.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/dialogs/log_supplement_dialog_content.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/util/supplement_l10n.dart';

/// Ein Menü, das eine Liste von Supplements zur Auswahl anzeigt.
class LogSupplementMenu extends StatefulWidget {
  const LogSupplementMenu({super.key, required this.close});

  final VoidCallback close;

  @override
  State<LogSupplementMenu> createState() => _LogSupplementMenuState();
}

class _LogSupplementMenuState extends State<LogSupplementMenu> {
  List<Supplement> _supplements = [];
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadSupplements();
  }

  Future<void> _loadSupplements() async {
    final supplements = await DatabaseHelper.instance.getAllSupplements();
    if (mounted) {
      setState(() {
        _supplements = supplements;
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (_supplements.isEmpty) {
      return Center(child: Text(l10n.emptySupplements));
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        ..._supplements.map(
          (s) => Padding(
            padding: const EdgeInsets.symmetric(vertical: 6, horizontal: 4),
            child: Material(
              color: Colors.white.withOpacity(
                Theme.of(context).brightness == Brightness.dark ? 0.06 : 0.08,
              ),
              borderRadius: BorderRadius.circular(16),
              child: InkWell(
                borderRadius: BorderRadius.circular(16),
                onTap: () => Navigator.of(context).pop(s),
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 14,
                    vertical: 12,
                  ),
                  child: Row(
                    children: [
                      const Icon(Icons.medication_outlined),
                      const SizedBox(width: 12),
                      Expanded(child: Text(localizeSupplementName(s, l10n))),
                      const Icon(Icons.chevron_right_rounded),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
        const SizedBox(height: 12),
        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: widget.close,
                child: Text(l10n.cancel),
              ),
            ),
          ],
        ),
      ],
    );
  }
}

/// Ein wiederverwendbares Widget für die Eingabe von Dosis und Zeit eines Supplements.
class LogSupplementDoseBody extends StatefulWidget {
  final Supplement supplement;
  final double? initialDose;
  final DateTime? initialTimestamp;
  final String primaryLabel;
  final VoidCallback onCancel;
  final void Function(double dose, DateTime timestamp) onSubmit;

  const LogSupplementDoseBody({
    super.key,
    required this.supplement,
    this.initialDose,
    this.initialTimestamp,
    required this.primaryLabel,
    required this.onCancel,
    required this.onSubmit,
  });

  @override
  State<LogSupplementDoseBody> createState() => _LogSupplementDoseBodyState();
}

class _LogSupplementDoseBodyState extends State<LogSupplementDoseBody> {
  final _key = GlobalKey<LogSupplementDialogContentState>();

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        LogSupplementDialogContent(
          key: _key,
          supplement: widget.supplement,
          initialDose: widget.initialDose,
          initialTimestamp: widget.initialTimestamp,
        ),
        const SizedBox(height: 12),
        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: widget.onCancel,
                child: Text(l10n.cancel),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: FilledButton(
                onPressed: () {
                  final st = _key.currentState;
                  if (st == null) return;
                  final dose =
                      double.tryParse(st.doseText.replaceAll(',', '.'));
                  if (dose == null || dose <= 0) return;
                  widget.onSubmit(dose, st.selectedDateTime);
                },
                child: Text(widget.primaryLabel),
              ),
            ),
          ],
        ),
      ],
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/dialogs/quantity_dialog_content.dart =====

// lib/dialogs/quantity_dialog_content.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/util/design_constants.dart';

class QuantityDialogContent extends StatefulWidget {
  final FoodItem item;
  final int? initialQuantity;
  final DateTime? initialTimestamp;
  final String? initialMealType;

  const QuantityDialogContent({
    super.key,
    required this.item,
    this.initialQuantity,
    this.initialTimestamp,
    this.initialMealType,
  });

  @override
  QuantityDialogContentState createState() => QuantityDialogContentState();
}

class QuantityDialogContentState extends State<QuantityDialogContent> {
  late final TextEditingController _quantityController;
  late final TextEditingController _caffeineController;
  late final TextEditingController _sugarController;
  late DateTime _selectedDateTime;
  final List<String> _mealTypes = [
    "mealtypeBreakfast",
    "mealtypeLunch",
    "mealtypeDinner",
    "mealtypeSnack",
  ];
  late String _selectedMealType;
  late bool _isLiquid;

  // Public Getters
  String get quantityText => _quantityController.text;
  String get caffeineText => _caffeineController.text;
  String get sugarText => _sugarController.text;
  DateTime get selectedDateTime => _selectedDateTime;
  String get selectedMealType => _selectedMealType;
  bool get isLiquid => _isLiquid;

  @override
  void initState() {
    super.initState();
    _quantityController = TextEditingController(
      text: widget.initialQuantity?.toString() ?? '100',
    );
    _sugarController = TextEditingController(
      text: widget.item.sugar?.toStringAsFixed(1).replaceAll('.0', '') ?? '',
    );
    _caffeineController = TextEditingController(
      text: widget.item.caffeineMgPer100ml
              ?.toStringAsFixed(1)
              .replaceAll('.0', '') ??
          '',
    );
    _selectedDateTime = widget.initialTimestamp ?? DateTime.now();
    _selectedMealType = widget.initialMealType ?? "mealtypeSnack";
    _isLiquid = widget.item.isLiquid ?? false;
  }

  @override
  void dispose() {
    _quantityController.dispose();
    _caffeineController.dispose();
    _sugarController.dispose();
    super.dispose();
  }

  Future<void> _selectDate() async {
    final locale = Localizations.localeOf(context);
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDateTime,
      firstDate: DateTime(2020),
      lastDate: DateTime.now().add(const Duration(days: 365)),
      locale: locale,
    );
    if (picked != null && picked != _selectedDateTime) {
      setState(() {
        _selectedDateTime = DateTime(
          picked.year,
          picked.month,
          picked.day,
          _selectedDateTime.hour,
          _selectedDateTime.minute,
        );
      });
    }
  }

  Future<void> _selectTime() async {
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(_selectedDateTime),
    );
    if (picked != null) {
      setState(() {
        _selectedDateTime = DateTime(
          _selectedDateTime.year,
          _selectedDateTime.month,
          _selectedDateTime.day,
          picked.hour,
          picked.minute,
        );
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final locale = Localizations.localeOf(context).toString();
    final formattedDate = DateFormat.yMd(locale).format(_selectedDateTime);
    final formattedTime = DateFormat.Hm(locale).format(_selectedDateTime);
    final unit = _isLiquid ? 'ml' : 'g';

    String getLocalizedMealName(String key) {
      switch (key) {
        case "mealtypeBreakfast":
          return l10n.mealtypeBreakfast;
        case "mealtypeLunch":
          return l10n.mealtypeLunch;
        case "mealtypeDinner":
          return l10n.mealtypeDinner;
        case "mealtypeSnack":
          return l10n.mealtypeSnack;
        default:
          return "Snack";
      }
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        TextField(
          controller: _quantityController,
          keyboardType: TextInputType.number,
          decoration: InputDecoration(
            labelText:
                _isLiquid ? l10n.amount_in_milliliters : l10n.amount_in_grams,
            suffixText: unit,
          ),
          autofocus: true,
        ),
        const SizedBox(height: DesignConstants.spacingL),
        DropdownButtonFormField<String>(
          initialValue: _selectedMealType,
          decoration: InputDecoration(labelText: l10n.meal_label),
          items: _mealTypes.map((String key) {
            return DropdownMenuItem<String>(
              value: key,
              child: Text(getLocalizedMealName(key)),
            );
          }).toList(),
          onChanged: (String? newValue) {
            if (newValue != null) setState(() => _selectedMealType = newValue);
          },
        ),
        const SizedBox(height: DesignConstants.spacingL),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            TextButton.icon(
              icon: const Icon(Icons.calendar_today, size: 20),
              label: Text(formattedDate, style: const TextStyle(fontSize: 16)),
              onPressed: _selectDate,
            ),
            TextButton.icon(
              icon: const Icon(Icons.access_time, size: 20),
              label: Text(formattedTime, style: const TextStyle(fontSize: 16)),
              onPressed: _selectTime,
            ),
          ],
        ),
        const Divider(height: 24),
        SwitchListTile(
          title: Text(l10n.add_to_water_intake),
          value: _isLiquid,
          onChanged: (bool value) => setState(() => _isLiquid = value),
          contentPadding: EdgeInsets.zero,
        ),
        if (_isLiquid) ...[
          const SizedBox(height: DesignConstants.spacingS),
          TextFormField(
            controller: _sugarController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            decoration: InputDecoration(
              labelText: '${l10n.sugar} (g / 100ml)',
              suffixText: 'g',
            ),
          ),
          const SizedBox(height: DesignConstants.spacingL),
          TextFormField(
            controller: _caffeineController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            decoration: InputDecoration(
              labelText: l10n.caffeinePrompt,
              suffixText: 'mg / 100ml',
            ),
          ),
        ],
      ],
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/data/database_helper.dart =====

// lib/data/database_helper.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:lightweight/models/fluid_entry.dart';
import 'package:lightweight/models/measurement.dart';
import 'package:lightweight/models/measurement_session.dart';
import '../models/food_entry.dart';
import '../models/chart_data_point.dart';
import '../models/supplement.dart';
import '../models/supplement_log.dart';

class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._init();
  static Database? _database;
  DatabaseHelper._init();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB('vita_user.db');
    return _database!;
  }

  Future<Database> _initDB(String fileName) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, fileName);
    return await openDatabase(
      path,
      version: 19,
      onConfigure: (db) async {
        await db.execute('PRAGMA foreign_keys = ON');
      },
      onCreate: _createDB,
      onUpgrade: _upgradeDB,
    );
  }

  Future<void> _createDB(Database db, int version) async {
    // --- Kern-Tabellen ---
    await db.execute('''
    CREATE TABLE IF NOT EXISTS food_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      barcode TEXT NOT NULL,
      timestamp TEXT NOT NULL,
      quantity_in_grams INTEGER NOT NULL,
      meal_type TEXT NOT NULL DEFAULT "mealtypeSnack",
      sugar_in_grams REAL
    )
  ''');

    // *** KORRIGIERTER BLOCK FÜR fluid_entries ***
    await db.execute('''
    CREATE TABLE IF NOT EXISTS fluid_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      timestamp TEXT NOT NULL,
      quantity_in_ml INTEGER NOT NULL,
      name TEXT NOT NULL,
      kcal INTEGER,
      sugar_per_100ml REAL,
      carbs_per_100ml REAL,
      caffeine_per_100ml REAL,
      linked_food_entry_id INTEGER -- DIESE ZEILE WURDE HINZUGEFÜGT
    )
  ''');
    // *** ENDE DES KORRIGIERTEN BLOCKS ***

    await db.execute('''
    CREATE TABLE IF NOT EXISTS favorites (
      barcode TEXT PRIMARY KEY
    )
  ''');

    await db.execute('''
    CREATE TABLE IF NOT EXISTS measurement_sessions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      timestamp TEXT NOT NULL
    )
  ''');

    await db.execute('''
    CREATE TABLE IF NOT EXISTS measurements (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      session_id INTEGER NOT NULL,
      type TEXT NOT NULL,
      value REAL NOT NULL,
      unit TEXT NOT NULL,
      FOREIGN KEY (session_id) REFERENCES measurement_sessions(id) ON DELETE CASCADE
    )
  ''');

    await db.execute('''
    CREATE TABLE IF NOT EXISTS supplements (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      code TEXT,
      name TEXT NOT NULL,
      default_dose REAL NOT NULL,
      unit TEXT NOT NULL,
      daily_goal REAL,
      daily_limit REAL,
      notes TEXT,
      is_builtin INTEGER NOT NULL DEFAULT 0
    )
  ''');

    // *** KORRIGIERTER BLOCK FÜR supplement_logs ***
    await db.execute('''
    CREATE TABLE IF NOT EXISTS supplement_logs (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      supplement_id INTEGER NOT NULL,
      dose REAL NOT NULL,
      unit TEXT NOT NULL,
      timestamp TEXT NOT NULL,
      source_food_entry_id INTEGER,
      source_fluid_entry_id INTEGER, -- DIESE ZEILE WURDE HINZUGEFÜGT
      FOREIGN KEY (supplement_id) REFERENCES supplements(id) ON DELETE CASCADE,
      FOREIGN KEY (source_food_entry_id) REFERENCES food_entries(id) ON DELETE SET NULL,
      FOREIGN KEY (source_fluid_entry_id) REFERENCES fluid_entries(id) ON DELETE CASCADE
    )
  ''');
    // *** ENDE DES KORRIGIERTEN BLOCKS ***

    await db.execute('''
    CREATE TABLE IF NOT EXISTS meals (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      notes TEXT,
      updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
    )
  ''');

    await db.execute('''
    CREATE TABLE IF NOT EXISTS meal_items (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      meal_id INTEGER NOT NULL,
      barcode TEXT NOT NULL,
      quantity_in_grams INTEGER NOT NULL,
      FOREIGN KEY (meal_id) REFERENCES meals(id) ON DELETE CASCADE
    )
  ''');

    // --- Indizes (NACH den Tabellen) ---
    await db.execute(
      'CREATE UNIQUE INDEX IF NOT EXISTS idx_supplements_code ON supplements(code)',
    );
    await db.execute(
      'CREATE INDEX IF NOT EXISTS idx_food_entries_timestamp ON food_entries(timestamp)',
    );
    await db.execute(
      'CREATE INDEX IF NOT EXISTS idx_food_entries_mealtype_ts ON food_entries(meal_type, timestamp)',
    );
    await db.execute(
      'CREATE INDEX IF NOT EXISTS idx_fluid_entries_timestamp ON fluid_entries(timestamp)',
    );
    await db.execute(
      'CREATE INDEX IF NOT EXISTS idx_supplement_logs_timestamp ON supplement_logs(timestamp)',
    );
    await db.execute(
      'CREATE INDEX IF NOT EXISTS idx_supplement_logs_supplement ON supplement_logs(supplement_id)',
    );

    // --- Built-ins einmalig einfüllen (idempotent) ---
    final caffeRows = await db.query(
      'supplements',
      where: 'code = ?',
      whereArgs: ['caffeine'],
      limit: 1,
    );
    if (caffeRows.isEmpty) {
      await db.insert('supplements', {
        'code': 'caffeine',
        'name': 'Caffeine',
        'default_dose': 100,
        'unit': 'mg',
        'daily_limit': 400,
        'is_builtin': 1,
      });
    }

    final creaRows = await db.query(
      'supplements',
      where: 'code = ?',
      whereArgs: ['creatine_monohydrate'],
      limit: 1,
    );
    if (creaRows.isEmpty) {
      await db.insert('supplements', {
        'code': 'creatine_monohydrate',
        'name': 'Creatine Monohydrate',
        'default_dose': 5,
        'unit': 'g',
        'daily_goal': 5,
        'is_builtin': 0,
      });
    }

    print('Benutzer-DB (v$version) neu erstellt: Tabellen & Indizes angelegt.');
  }

  Future<void> _upgradeDB(Database db, int oldVersion, int newVersion) async {
    // Dieser Block bringt alte Versionen Schritt für Schritt auf den neuesten Stand.
    if (oldVersion < 2) {
      await db.execute('''
      CREATE TABLE IF NOT EXISTS fluid_entries (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp TEXT NOT NULL,
        quantity_in_ml INTEGER NOT NULL,
        name TEXT NOT NULL,
        kcal INTEGER,
        sugar_per_100ml REAL,
        carbs_per_100ml REAL,
        caffeine_per_100ml REAL
      )
    ''');
    }
    if (oldVersion < 4) {
      await db.execute('CREATE TABLE favorites (barcode TEXT PRIMARY KEY)');
    }
    if (oldVersion < 5) {
      await db.execute(
        'ALTER TABLE food_entries ADD COLUMN meal_type TEXT NOT NULL DEFAULT "Snack"',
      );
    }

    // Upgrade von jedem Zustand vor v9 auf v9 (bereinigt alle alten Measurement-Tabellen)
    if (oldVersion < 9) {
      // Lösche alle möglichen alten Versionen der Tabellen, um sicherzugehen.
      await db.execute('DROP TABLE IF EXISTS measurements');
      await db.execute('DROP TABLE IF EXISTS measurement_sessions');
      // Erstelle die Tabellen in der korrekten, finalen Struktur.
      await db.execute(
        'CREATE TABLE measurement_sessions (id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp TEXT NOT NULL)',
      );
      await db.execute(
        'CREATE TABLE measurements (id INTEGER PRIMARY KEY AUTOINCREMENT, session_id INTEGER NOT NULL, type TEXT NOT NULL, value REAL NOT NULL, unit TEXT NOT NULL, FOREIGN KEY (session_id) REFERENCES measurement_sessions(id) ON DELETE CASCADE)',
      );
      print(
        "Datenbank auf Version 9 aktualisiert: Measurement-Tabellen sauber erstellt.",
      );
    }
    // NEU: Upgrade auf Version 10
    if (oldVersion < 10) {
      await db.execute(
        'CREATE TABLE supplements (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, default_dose REAL NOT NULL, unit TEXT NOT NULL, daily_goal REAL, daily_limit REAL, notes TEXT)',
      );
      await db.execute(
        'CREATE TABLE supplement_logs (id INTEGER PRIMARY KEY AUTOINCREMENT, supplement_id INTEGER NOT NULL, dose REAL NOT NULL, unit TEXT NOT NULL, timestamp TEXT NOT NULL, FOREIGN KEY (supplement_id) REFERENCES supplements(id) ON DELETE CASCADE)',
      );

      await db.insert('supplements', {
        'name': 'Caffeine',
        'default_dose': 100,
        'unit': 'mg',
        'daily_limit': 400,
      });
      await db.insert('supplements', {
        'name': 'Creatine Monohydrate',
        'default_dose': 5,
        'unit': 'g',
        'daily_goal': 5,
      });
      print(
        "Datenbank auf Version 10 aktualisiert: Supplement-Tabellen hinzugefügt.",
      );
    }
    // Upgrade auf Version 11
    if (oldVersion < 11) {
      // 1) Spalten ergänzen (ALTER kann fehlschlagen, falls bereits vorhanden – deshalb try/catch)
      try {
        await db.execute(
          'ALTER TABLE supplements ADD COLUMN is_builtin INTEGER NOT NULL DEFAULT 0',
        );
      } catch (_) {}
      try {
        await db.execute(
          'ALTER TABLE supplement_logs ADD COLUMN source_food_entry_id INTEGER',
        );
      } catch (_) {}

      // 2) Caffeine absichern/vereinheitlichen
      final rows = await db.query(
        'supplements',
        where: 'name = ?',
        whereArgs: ['Caffeine'],
        limit: 1,
      );
      if (rows.isEmpty) {
        await db.insert('supplements', {
          'name': 'Caffeine',
          'default_dose': 100,
          'unit': 'mg',
          'daily_limit': 400,
          'is_builtin': 1,
        });
      } else {
        await db.update(
          'supplements',
          {'unit': 'mg', 'is_builtin': 1},
          where: 'name = ?',
          whereArgs: ['Caffeine'],
        );
      }

      print(
        "Datenbank auf Version 11 aktualisiert: builtin-Flag & FoodEntry-Link für Supplements.",
      );
    }
    // Upgrade auf Version 12
    if (oldVersion < 12) {
      try {
        await db.execute('ALTER TABLE supplements ADD COLUMN code TEXT');
      } catch (_) {}
      try {
        await db.execute(
          'CREATE UNIQUE INDEX IF NOT EXISTS idx_supplements_code ON supplements(code)',
        );
      } catch (_) {}

      // Backfill Codes für bestehende Einträge
      // Caffeine
      final caff = await db.query(
        'supplements',
        where: 'name = ?',
        whereArgs: ['Caffeine'],
        limit: 1,
      );
      if (caff.isNotEmpty) {
        await db.update(
          'supplements',
          {'code': 'caffeine', 'is_builtin': 1, 'unit': 'mg'},
          where: 'id = ?',
          whereArgs: [caff.first['id']],
        );
      }
      // Creatine
      final crea = await db.query(
        'supplements',
        where: 'name LIKE ?',
        whereArgs: ['Creatine%'],
        limit: 1,
      );
      if (crea.isNotEmpty) {
        await db.update(
          'supplements',
          {'code': 'creatine_monohydrate'},
          where: 'id = ?',
          whereArgs: [crea.first['id']],
        );
      }

      print("DB v12: supplements.code hinzugefügt & befüllt.");
    }
    // Upgrade auf Version 13: Indizes nachziehen
    if (oldVersion < 13) {
      await db.execute(
        'CREATE UNIQUE INDEX IF NOT EXISTS idx_supplements_code ON supplements(code)',
      );
      await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_food_entries_timestamp ON food_entries(timestamp)',
      );
      await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_fluid_entries_timestamp ON fluid_entries(timestamp)',
      );
      await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_supp_logs_ts ON supplement_logs(timestamp)',
      );
      await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_supp_logs_supp ON supplement_logs(supplement_id)',
      );
      print("DB v13: Performance-Indizes erstellt.");
    }
    // Upgrade auf Version 14: Mahlzeiten
    if (oldVersion < 14) {
      // food_entries
      await db.execute('''
      CREATE TABLE IF NOT EXISTS food_entries (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        barcode TEXT NOT NULL,
        timestamp TEXT NOT NULL,
        quantity_in_grams INTEGER NOT NULL,
        meal_type TEXT NOT NULL DEFAULT "mealtypeSnack"
      )
    ''');

      // fluid_entries
      await db.execute('''
      CREATE TABLE IF NOT EXISTS fluid_entries (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp TEXT NOT NULL,
        quantity_in_ml INTEGER NOT NULL,
        name TEXT NOT NULL,
        kcal INTEGER,
        sugar_per_100ml REAL,
        carbs_per_100ml REAL,
        caffeine_per_100ml REAL
      )
    ''');

      // favorites
      await db.execute('''
      CREATE TABLE IF NOT EXISTS favorites (
        barcode TEXT PRIMARY KEY
      )
    ''');

      // measurements
      await db.execute('''
      CREATE TABLE IF NOT EXISTS measurement_sessions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp TEXT NOT NULL
      )
    ''');
      await db.execute('''
      CREATE TABLE IF NOT EXISTS measurements (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id INTEGER NOT NULL,
        type TEXT NOT NULL,
        value REAL NOT NULL,
        unit TEXT NOT NULL,
        FOREIGN KEY (session_id) REFERENCES measurement_sessions(id) ON DELETE CASCADE
      )
    ''');

      // supplements
      await db.execute('''
      CREATE TABLE IF NOT EXISTS supplements (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        code TEXT,
        name TEXT NOT NULL,
        default_dose REAL NOT NULL,
        unit TEXT NOT NULL,
        daily_goal REAL,
        daily_limit REAL,
        notes TEXT,
        is_builtin INTEGER NOT NULL DEFAULT 0
      )
    ''');

      await db.execute('''
      CREATE TABLE IF NOT EXISTS supplement_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        supplement_id INTEGER NOT NULL,
        dose REAL NOT NULL,
        unit TEXT NOT NULL,
        timestamp TEXT NOT NULL,
        source_food_entry_id INTEGER,
        FOREIGN KEY (supplement_id) REFERENCES supplements(id) ON DELETE CASCADE,
        FOREIGN KEY (source_food_entry_id) REFERENCES food_entries(id) ON DELETE CASCADE
      )
    ''');

      // meals
      await db.execute('''
      CREATE TABLE IF NOT EXISTS meals (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        notes TEXT,
        updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
      )
    ''');
      await db.execute('''
      CREATE TABLE IF NOT EXISTS meal_items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        meal_id INTEGER NOT NULL,
        barcode TEXT NOT NULL,
        quantity_in_grams INTEGER NOT NULL,
        FOREIGN KEY (meal_id) REFERENCES meals(id) ON DELETE CASCADE
      )
    ''');

      // Indizes
      await db.execute(
        'CREATE UNIQUE INDEX IF NOT EXISTS idx_supplements_code ON supplements(code)',
      );
      await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_food_entries_timestamp ON food_entries(timestamp)',
      );
      await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_food_entries_mealtype_ts ON food_entries(meal_type, timestamp)',
      );
      await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_fluid_entries_timestamp ON fluid_entries(timestamp)',
      );
      await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_supplement_logs_timestamp ON supplement_logs(timestamp)',
      );
      await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_supplement_logs_supplement ON supplement_logs(supplement_id)',
      );

      debugPrint('Catch-up: Tabellen + Indizes bis v14 sichergestellt.');
    }

    if (oldVersion < 15) {
      try {
        await db.execute(
          'ALTER TABLE food_entries ADD COLUMN sugar_in_grams REAL',
        );
      } catch (_) {}
      debugPrint("DB v15: food_entries.sugar_in_grams added.");
    }
    if (oldVersion < 16) {
      try {
        await db.execute(
          'ALTER TABLE fluid_entries ADD COLUMN carbs_per_100ml REAL',
        );
      } catch (_) {}
      debugPrint("DB v16: fluid_entries.carbs_per_100ml added.");
    }
    if (oldVersion < 17) {
      try {
        await db.execute(
          'ALTER TABLE supplement_logs ADD COLUMN source_fluid_entry_id INTEGER',
        );
      } catch (_) {}
      debugPrint("DB v17: supplement_logs.source_fluid_entry_id added.");
    }
    if (oldVersion < 18) {
      try {
        await db.execute(
          'ALTER TABLE supplement_logs ADD COLUMN source_fluid_entry_id INTEGER',
        );
        // Füge die Fremdschlüsselbeziehung hinzu, falls sie nicht existiert
        // HINWEIS: Das Hinzufügen von Foreign Keys zu einer bestehenden Tabelle ist in SQLite komplex.
        // Für Einfachheit verlassen wir uns auf die Löschlogik in der App.
        // Aber für Neuinstallationen ist der Foreign Key in _createDB korrekt.
      } catch (_) {}

      // Korrigiere auch den Foreign Key für food_entries, falls er falsch war
      try {
        await db.execute(
          'DROP INDEX IF EXISTS idx_supp_logs_food_entry',
        ); // Beispiel, falls alter Index existierte
        await db.execute('''
          -- Rekonstruktion der Tabelle, um Foreign Key hinzuzufügen, ist aufwändig.
          -- Stattdessen stellen wir sicher, dass die Logik in der App stimmt.
          -- Die Löschung erfolgt jetzt in der App-Logik (deleteFoodEntry, deleteFluidEntry)
        ''');
      } catch (_) {}

      debugPrint(
        "DB v18: supplement_logs.source_fluid_entry_id hinzugefügt und Foreign Keys sichergestellt.",
      );
    }

    if (oldVersion < 19) {
      try {
        await db.execute(
          'ALTER TABLE fluid_entries ADD COLUMN linked_food_entry_id INTEGER',
        );
      } catch (_) {}
      debugPrint("DB v19: fluid_entries.linked_food_entry_id added.");
    }
  }

  // --- FOOD ENTRIES ---
  Future<int> insertFoodEntry(FoodEntry entry) async {
    final db = await database;
    final id = await db.insert(
      'food_entries',
      entry.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
    print(
      "Neuer FoodEntry erfolgreich in der Benutzer-DB gespeichert (id=$id).",
    );
    return id;
  }

  // Diese Methode ist für den Home Screen. Wir aktualisieren sie auch gleich.
  Future<List<FoodEntry>> getEntriesForDate(DateTime date) async {
    final db = await database;
    final dateString = date.toIso8601String().substring(0, 10);
    final List<Map<String, dynamic>> maps = await db.query(
      'food_entries',
      where: 'timestamp LIKE ?',
      whereArgs: ['$dateString%'],
    );
    return List.generate(maps.length, (i) {
      return FoodEntry(
        id: maps[i]['id'],
        barcode: maps[i]['barcode'],
        timestamp: DateTime.parse(maps[i]['timestamp']),
        quantityInGrams: maps[i]['quantity_in_grams'],
        mealType: maps[i]['meal_type'] ?? 'Snack', // Neues Feld auslesen
      );
    });
  }

  Future<List<FoodEntry>> getEntriesForDateRange(
    DateTime start,
    DateTime end,
  ) async {
    final db = await database;
    final startDateString = DateFormat('yyyy-MM-dd').format(start);
    final endDate = DateTime(end.year, end.month, end.day, 23, 59, 59);
    final endDateString = endDate.toIso8601String();
    final List<Map<String, dynamic>> maps = await db.query(
      'food_entries',
      where: 'timestamp BETWEEN ? AND ?',
      whereArgs: [startDateString, endDateString],
    );
    return List.generate(maps.length, (i) {
      return FoodEntry(
        id: maps[i]['id'],
        barcode: maps[i]['barcode'],
        timestamp: DateTime.parse(maps[i]['timestamp']),
        quantityInGrams: maps[i]['quantity_in_grams'],
        mealType: maps[i]['meal_type'] ?? 'Snack', // Neues Feld auslesen
      );
    });
  }

  Future<void> deleteFoodEntry(int id) async {
    final db = await database;
    await db.transaction((txn) async {
      // Lösche zuerst verknüpfte Supplement-Logs (z.B. Koffein)
      await txn.delete(
        'supplement_logs',
        where: 'source_food_entry_id = ?',
        whereArgs: [id],
      );
      // Lösche dann den verknüpften Fluid-Eintrag (falls vorhanden)
      await txn.delete(
        'fluid_entries',
        where: 'linked_food_entry_id = ?',
        whereArgs: [id],
      );
      // Lösche zuletzt den Food-Eintrag selbst
      await txn.delete('food_entries', where: 'id = ?', whereArgs: [id]);
    });
    print(
      "Eintrag mit ID $id und alle verknüpften Daten erfolgreich gelöscht.",
    );
  }

  // --- FLUID ENTRIES ---
  Future<int> insertFluidEntry(FluidEntry entry) async {
    final db = await database;
    final id = await db.insert(
      'fluid_entries',
      entry.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
    print(
      "Neuer FluidEntry erfolgreich in der Benutzer-DB gespeichert (id=$id).",
    );
    return id;
  }

  Future<List<FluidEntry>> getFluidEntriesForDate(DateTime date) async {
    final db = await database;
    final dateString = date.toIso8601String().substring(0, 10);
    final List<Map<String, dynamic>> maps = await db.query(
      'fluid_entries',
      where: 'timestamp LIKE ?',
      whereArgs: ['$dateString%'],
    );
    return List.generate(maps.length, (i) {
      return FluidEntry.fromMap(maps[i]);
    });
  }

  // lib/data/database_helper.dart - ERSETZE DIE GESAMTE METHODE deleteFluidEntry

  Future<void> deleteFluidEntry(int id) async {
    final db = await database;

    // Finde zuerst den Eintrag, um die verknüpfte FoodEntry-ID zu bekommen
    final List<Map<String, dynamic>> maps = await db.query(
      'fluid_entries',
      where: 'id = ?',
      whereArgs: [id],
      limit: 1,
    );

    if (maps.isNotEmpty) {
      final linkedFoodEntryId = maps.first['linked_food_entry_id'] as int?;

      if (linkedFoodEntryId != null) {
        // Dies ist ein FluidEntry, der über einen FoodEntry geloggt wurde (z.B. Saft).
        // Das Löschen dieses FluidEntrys sollte implizit über den FoodEntry erfolgen (Cascading Delete).
        // ABER: Da kein Foreign Key besteht, rufen wir manuell die FoodEntry-Löschung auf,
        // um die Konsistenz zu gewährleisten (löscht FoodEntry, FluidEntry und SuppLogs).
        await deleteFoodEntry(linkedFoodEntryId);
      } else {
        // Dies ist ein eigenständiger FluidEntry (z.B. "Wasser" oder manueller Proteinshake).
        await db.transaction((txn) async {
          // Lösche verknüpfte Supplement-Logs (Koffein-Logs)
          await txn.delete(
            'supplement_logs',
            where: 'source_fluid_entry_id = ?',
            whereArgs: [id],
          );
          // Lösche den FluidEntry selbst
          await txn.delete('fluid_entries', where: 'id = ?', whereArgs: [id]);
        });
      }
      print(
        "Fluid-Eintrag mit ID $id und alle verknüpften Daten erfolgreich gelöscht.",
      );
    }
  }

// lib/data/database_helper.dart - FÜGE DIESE METHODE HINZU (wurde zuvor im DiaryScreen verwendet)

  Future<void> deleteFluidEntryByLinkedFoodId(int foodEntryId) async {
    final db = await database;
    await db.transaction((txn) async {
      // 1. Suche die ID des FluidEntry mit dieser Verknüpfung
      final fluidEntryMaps = await txn.query(
        'fluid_entries',
        columns: ['id'],
        where: 'linked_food_entry_id = ?',
        whereArgs: [foodEntryId],
        limit: 1,
      );

      if (fluidEntryMaps.isNotEmpty) {
        final fluidEntryId = fluidEntryMaps.first['id'] as int;

        // 2. Lösche zugehörige Supplement-Logs (Koffein-Log vom Getränk)
        await txn.delete(
          'supplement_logs',
          where: 'source_fluid_entry_id = ?',
          whereArgs: [fluidEntryId],
        );

        // 3. Lösche den FluidEntry selbst
        await txn.delete(
          'fluid_entries',
          where: 'id = ?',
          whereArgs: [fluidEntryId],
        );
        print("FluidEntry für FoodEntry ID $foodEntryId entfernt.");
      }
    });
  }

  Future<List<FluidEntry>> getFluidEntriesForDateRange(
    DateTime start,
    DateTime end,
  ) async {
    final db = await database;
    final startDateString = DateFormat('yyyy-MM-dd').format(start);
    final endDate = DateTime(end.year, end.month, end.day, 23, 59, 59);
    final endDateString = endDate.toIso8601String();
    final List<Map<String, dynamic>> maps = await db.query(
      'fluid_entries',
      where: 'timestamp BETWEEN ? AND ?',
      whereArgs: [startDateString, endDateString],
    );
    return List.generate(maps.length, (i) {
      return FluidEntry.fromMap(maps[i]);
    });
  }

  Future<void> updateFluidEntry(FluidEntry entry) async {
    final db = await database;
    await db.update(
      'fluid_entries',
      entry.toMap(),
      where: 'id = ?',
      whereArgs: [entry.id],
    );
    print("Fluid-Eintrag mit ID ${entry.id} erfolgreich aktualisiert.");
  }

  // --- FAVORITES ---
  Future<void> addFavorite(String barcode) async {
    final db = await database;
    await db.insert('favorites', {'barcode': barcode});
    print("Favorit $barcode hinzugefügt.");
  }

  Future<void> removeFavorite(String barcode) async {
    final db = await database;
    await db.delete('favorites', where: 'barcode = ?', whereArgs: [barcode]);
    print("Favorit $barcode entfernt.");
  }

  Future<bool> isFavorite(String barcode) async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query(
      'favorites',
      where: 'barcode = ?',
      whereArgs: [barcode],
    );
    return maps.isNotEmpty;
  }

  Future<List<String>> getFavoriteBarcodes() async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query('favorites');
    return List.generate(maps.length, (i) => maps[i]['barcode'] as String);
  }

  // DOC: NEUE METHODE für die "Zuletzt verwendet"-Liste
  Future<List<String>> getRecentlyUsedBarcodes() async {
    final db = await database;
    // Dieses SQL-Statement ist etwas komplexer:
    // 1. SELECT DISTINCT barcode: Wähle jeden Barcode nur einmal aus.
    // 2. FROM food_entries: Aus der Tabelle der Einträge.
    // 3. ORDER BY timestamp DESC: Sortiere sie absteigend nach dem Zeitstempel (die neuesten zuerst).
    // 4. LIMIT 20: Gib uns nur die Top 20 zurück.
    final List<Map<String, dynamic>> maps = await db.query(
      'food_entries',
      distinct: true,
      columns: ['barcode'],
      orderBy: 'timestamp DESC',
      limit: 20,
    );
    return List.generate(maps.length, (i) => maps[i]['barcode'] as String);
  }

  // --- MEASUREMENTS (SESSION-BASED) ---
  Future<void> insertMeasurementSession(MeasurementSession session) async {
    final db = await database;
    await db.transaction((txn) async {
      final sessionId = await txn.insert('measurement_sessions', {
        'timestamp': session.timestamp.toIso8601String(),
      });

      for (final measurement in session.measurements) {
        // WICHTIG: Wir erstellen hier eine NEUE Map aus dem Measurement-Objekt,
        // das KEINEN Timestamp mehr hat, und fügen die session_id hinzu.
        final measurementMap = {
          'session_id': sessionId,
          'type': measurement.type,
          'value': measurement.value,
          'unit': measurement.unit,
        };
        await txn.insert('measurements', measurementMap);
      }
    });
    print("Neue Measurement-Session erfolgreich gespeichert.");
  }

  Future<List<MeasurementSession>> getMeasurementSessions() async {
    final db = await database;
    final List<Map<String, dynamic>> sessionMaps = await db.query(
      'measurement_sessions',
      orderBy: 'timestamp DESC',
    );

    if (sessionMaps.isEmpty) return [];

    final List<MeasurementSession> sessions = [];
    for (final sessionMap in sessionMaps) {
      final sessionId = sessionMap['id'] as int;
      final List<Map<String, dynamic>> measurementMaps = await db.query(
        'measurements',
        where: 'session_id = ?',
        whereArgs: [sessionId],
      );

      // Die fromMap-Methode im korrigierten Measurement-Modell wird hier verwendet.
      final measurements =
          measurementMaps.map((map) => Measurement.fromMap(map)).toList();

      sessions.add(
        MeasurementSession(
          id: sessionId,
          timestamp: DateTime.parse(sessionMap['timestamp'] as String),
          measurements: measurements,
        ),
      );
    }
    return sessions;
  }

  Future<void> deleteMeasurementSession(int id) async {
    final db = await database;
    await db.delete('measurement_sessions', where: 'id = ?', whereArgs: [id]);
    print(
      "Measurement-Session mit ID $id (und zugehörige Messwerte) gelöscht.",
    );
  }

  // --- CHART DATA HELPERS ---

  /// Ruft alle Messwerte eines bestimmten Typs ab und gibt sie als
  /// eine Liste von Datenpunkten für einen Graphen zurück.
  Future<List<ChartDataPoint>> getChartDataForType(String type) async {
    final db = await database;

    // Dies ist eine komplexere SQL-Abfrage. Sie verbindet die beiden Tabellen:
    // Sie holt den 'value' aus der 'measurements'-Tabelle und den zugehörigen
    // 'timestamp' aus der 'measurement_sessions'-Tabelle, filtert nach dem
    // gewünschten Typ und sortiert nach Datum.
    final List<Map<String, dynamic>> maps = await db.rawQuery(
      '''
      SELECT
        s.timestamp,
        m.value
      FROM measurements m
      INNER JOIN measurement_sessions s ON m.session_id = s.id
      WHERE m.type = ?
      ORDER BY s.timestamp ASC 
    ''',
      [type],
    );

    if (maps.isEmpty) {
      return [];
    }

    // Wandle das Ergebnis der Datenbankabfrage in unsere saubere ChartDataPoint-Liste um.
    return maps.map((map) {
      return ChartDataPoint(
        date: DateTime.parse(map['timestamp'] as String),
        value: map['value'] as double,
      );
    }).toList();
  }

  Future<List<ChartDataPoint>> getChartDataForTypeAndRange(
    String type,
    DateTimeRange range,
  ) async {
    final db = await database;

    final List<Map<String, dynamic>> maps = await db.rawQuery(
      '''
      SELECT
        s.timestamp,
        m.value
      FROM measurements m
      INNER JOIN measurement_sessions s ON m.session_id = s.id
      WHERE m.type = ? AND s.timestamp BETWEEN ? AND ?
      ORDER BY s.timestamp ASC 
    ''',
      [type, range.start.toIso8601String(), range.end.toIso8601String()],
    );

    if (maps.isEmpty) {
      return [];
    }

    return maps.map((map) {
      return ChartDataPoint(
        date: DateTime.parse(map['timestamp'] as String),
        value: map['value'] as double,
      );
    }).toList();
  }

  Future<void> updateFoodEntry(FoodEntry entry) async {
    final db = await database;
    await db.update(
      'food_entries',
      entry.toMap(),
      where: 'id = ?',
      whereArgs: [entry.id],
    );
    print("Eintrag mit ID ${entry.id} erfolgreich aktualisiert.");
  }

  Future<DateTime?> getEarliestMeasurementDate() async {
    final db = await database;
    final maps = await db.query(
      'measurement_sessions',
      orderBy: 'timestamp ASC',
      limit: 1,
    );
    if (maps.isNotEmpty) {
      return DateTime.parse(maps.first['timestamp'] as String);
    }
    return null;
  }

  Future<DateTime?> getEarliestFoodEntryDate() async {
    final db = await database;
    final maps = await db.query(
      'food_entries',
      orderBy: 'timestamp ASC',
      limit: 1,
    );
    if (maps.isNotEmpty) {
      return DateTime.parse(maps.first['timestamp'] as String);
    }
    return null;
  }

  Future<List<FoodEntry>> getAllFoodEntries() async {
    final db = await database;
    final maps = await db.query('food_entries');
    return maps
        .map(
          (map) => FoodEntry(
            id: map['id'] as int?,
            barcode: map['barcode'] as String,
            timestamp: DateTime.parse(map['timestamp'] as String),
            quantityInGrams: map['quantity_in_grams'] as int,
            mealType: map['meal_type'] as String,
          ),
        )
        .toList();
  }

  Future<List<FluidEntry>> getAllFluidEntries() async {
    final db = await database;
    final maps = await db.query('fluid_entries');
    return maps.map((map) => FluidEntry.fromMap(map)).toList();
  }

  Future<void> importUserData({
    required List<FoodEntry> foodEntries,
    required List<FluidEntry> fluidEntries,
    required List<String> favoriteBarcodes,
    required List<MeasurementSession> measurementSessions,
    required List<Supplement> supplements, // NEU
    required List<SupplementLog> supplementLogs, // NEU
  }) async {
    final db = await database;
    await db.transaction((txn) async {
      for (final entry in foodEntries) {
        await txn.insert('food_entries', entry.toMap());
      }
      for (final entry in fluidEntries) {
        await txn.insert('fluid_entries', entry.toMap());
      }
      for (final barcode in favoriteBarcodes) {
        await txn.insert('favorites', {'barcode': barcode});
      }
      for (final session in measurementSessions) {
        // KORREKTUR: Erstellt die Map für die Session direkt hier.
        final sessionId = await txn.insert('measurement_sessions', {
          'timestamp': session.timestamp.toIso8601String(),
        });
        for (final measurement in session.measurements) {
          // KORREKTUR: Erstellt die Map für das Measurement hier und fügt die NEUE sessionId hinzu.
          await txn.insert('measurements', {
            ...measurement.toMap(), // Nutzt die existierende toMap()
            'session_id': sessionId, // Überschreibt mit der neuen ID
          });
        }
      }
    });
  }

  /// Gibt ein Set von Tagen (1-31) zurück, an denen im gegebenen Monat Ernährungseinträge existieren.
  Future<Set<int>> getNutritionLogDaysInMonth(DateTime month) async {
    final db = await database;
    final firstDayOfMonth = DateTime(month.year, month.month, 1);
    final lastDayOfMonth = DateTime(month.year, month.month + 1, 0, 23, 59, 59);

    final maps = await db.query(
      'food_entries',
      columns: ['timestamp'],
      where: 'timestamp BETWEEN ? AND ?',
      whereArgs: [
        firstDayOfMonth.toIso8601String(),
        lastDayOfMonth.toIso8601String(),
      ],
    );

    if (maps.isEmpty) return {};

    // Extrahiere den Tag aus jedem Timestamp und füge ihn einem Set hinzu, um Duplikate zu vermeiden.
    return maps
        .map((map) => DateTime.parse(map['timestamp'] as String).day)
        .toSet();
  }

  // --- NEUE METHODEN FÜR SUPPLEMENTS ---

  Future<Supplement> insertSupplement(Supplement supplement) async {
    final db = await database;
    final id = await db.insert(
      'supplements',
      supplement.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
    // Erstelle eine neue Instanz mit der zurückgegebenen ID
    return Supplement(
      id: id,
      name: supplement.name,
      defaultDose: supplement.defaultDose,
      unit: supplement.unit,
      dailyGoal: supplement.dailyGoal,
      dailyLimit: supplement.dailyLimit,
      notes: supplement.notes,
    );
  }

  Future<List<Supplement>> getAllSupplements() async {
    final db = await database;
    final maps = await db.query('supplements', orderBy: 'name ASC');
    return maps.map((map) => Supplement.fromMap(map)).toList();
  }

  Future<void> deleteSupplement(int id) async {
    final db = await database;

    // Built-in blockieren
    final check = await db.query(
      'supplements',
      where: 'id = ?',
      whereArgs: [id],
      limit: 1,
    );
    if (check.isNotEmpty && (check.first['is_builtin'] as int? ?? 0) == 1) {
      throw Exception("Built-in supplement can't be deleted.");
    }

    // Logs + Supplement löschen
    await db.transaction((txn) async {
      await txn.delete(
        'supplement_logs',
        where: 'supplement_id = ?',
        whereArgs: [id],
      );
      await txn.delete('supplements', where: 'id = ?', whereArgs: [id]);
    });
  }

  Future<SupplementLog> insertSupplementLog(SupplementLog log) async {
    final db = await database;
    final id = await db.insert('supplement_logs', log.toMap());
    return SupplementLog(
      id: id,
      supplementId: log.supplementId,
      dose: log.dose,
      unit: log.unit,
      timestamp: log.timestamp,
    );
  }

  Future<void> updateSupplement(Supplement supplement) async {
    if ((supplement.code == 'caffeine') && supplement.unit != 'mg') {
      throw Exception('Caffeine must be in mg.');
    }
    if (supplement.isBuiltin &&
        supplement.code != null &&
        supplement.code!.isNotEmpty) {
      // Name darf lokalisiert sein, code bleibt
    }
    final db = await database;
    await db.update(
      'supplements',
      supplement.toMap(),
      where: 'id = ?',
      whereArgs: [supplement.id],
    );
  }

  Future<void> updateSupplementLog(SupplementLog log) async {
    final db = await database;
    await db.update(
      'supplement_logs',
      log.toMap(),
      where: 'id = ?',
      whereArgs: [log.id],
    );
    print("Supplement-Log mit ID ${log.id} erfolgreich aktualisiert.");
  }

  Future<List<SupplementLog>> getSupplementLogsForDate(DateTime date) async {
    final db = await database;
    final dateString = date.toIso8601String().substring(0, 10);
    final List<Map<String, dynamic>> maps = await db.query(
      'supplement_logs',
      where: 'timestamp LIKE ?',
      whereArgs: ['$dateString%'],
      orderBy: 'timestamp DESC',
    );
    return maps.map((map) => SupplementLog.fromMap(map)).toList();
  }

  Future<void> deleteSupplementLog(int id) async {
    final db = await database;
    await db.delete('supplement_logs', where: 'id = ?', whereArgs: [id]);
  }

  // FÜR BACKUP
  Future<List<SupplementLog>> getAllSupplementLogs() async {
    final db = await database;
    final maps = await db.query('supplement_logs');
    return maps.map((map) => SupplementLog.fromMap(map)).toList();
  }

  // --- CAFFEINE HELPERS (für Getränke-Autologging) ---

  Future<int> _getCaffeineSupplementId() async {
    final db = await database;
    final r = await db.query(
      'supplements',
      columns: ['id'],
      where: 'code = ?',
      whereArgs: ['caffeine'],
      limit: 1,
    );
    if (r.isEmpty) {
      throw Exception('Caffeine supplement missing');
    }
    return r.first['id'] as int;
  }

  /// Upsert eines Koffein-Logs, verknüpft mit einem FoodEntry.
  /// - caffeinePer100ml: mg pro 100 ml (null => entfernen)
  /// - quantityInMl: Menge des Getränks in ml
  Future<void> upsertCaffeineForFoodEntry({
    required int foodEntryId,
    required DateTime timestamp,
    required double? caffeinePer100ml,
    required double quantityInMl,
  }) async {
    final db = await database;

    // Vorherige (falls vorhanden) löschen
    await db.delete(
      'supplement_logs',
      where: 'source_food_entry_id = ?',
      whereArgs: [foodEntryId],
    );

    if (caffeinePer100ml == null) return;

    final caffeineId = await _getCaffeineSupplementId();

    // mg = (mg / 100 ml) * (ml / 100)
    final double doseMg = caffeinePer100ml * (quantityInMl / 100.0);

    await db.insert(
        'supplement_logs',
        {
          'supplement_id': caffeineId,
          'dose': doseMg,
          'unit': 'mg',
          'timestamp': timestamp.toIso8601String(),
          'source_food_entry_id': foodEntryId,
        },
        conflictAlgorithm: ConflictAlgorithm.replace);
  }

  @override
  Future<void> clearAllUserData() async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('food_entries');
      await txn.delete('fluid_entries');
      await txn.delete('favorites');
      await txn.delete('measurements');
      await txn.delete('measurement_sessions');
      await txn.delete('supplement_logs');
      await txn.delete('supplements');
      // Built-ins wiederherstellen
      await txn.insert('supplements', {
        'code': 'caffeine',
        'name': 'Caffeine',
        'default_dose': 100,
        'unit': 'mg',
        'daily_limit': 400,
        'is_builtin': 1,
      });
      await txn.insert('supplements', {
        'code': 'creatine_monohydrate',
        'name': 'Creatine Monohydrate',
        'default_dose': 5,
        'unit': 'g',
        'daily_goal': 5,
        'is_builtin': 0,
      });
    });
  }

  // NEUE METHODE
  Future<Set<int>> getSupplementLogDaysInMonth(DateTime month) async {
    final db = await database;
    final firstDayOfMonth = DateTime(month.year, month.month, 1);
    final lastDayOfMonth = DateTime(month.year, month.month + 1, 0, 23, 59, 59);

    final maps = await db.query(
      'supplement_logs',
      columns: ['timestamp'],
      where: 'timestamp BETWEEN ? AND ?',
      whereArgs: [
        firstDayOfMonth.toIso8601String(),
        lastDayOfMonth.toIso8601String(),
      ],
    );

    if (maps.isEmpty) return {};

    return maps
        .map((map) => DateTime.parse(map['timestamp'] as String).day)
        .toSet();
  }
  // --- MEALS API ---

  Future<int> insertMeal({required String name, String? notes}) async {
    final db = await database;
    final now = DateTime.now().toIso8601String();
    return await db.insert('meals', {
      'name': name.trim(),
      'notes': (notes ?? '').trim().isEmpty ? null : notes!.trim(),
      //'created_at': now,
      'updated_at': now,
    });
  }

  Future<void> updateMeal(int id, {required String name, String? notes}) async {
    final db = await database;
    final now = DateTime.now().toIso8601String();
    await db.update(
      'meals',
      {
        'name': name.trim(),
        'notes': (notes ?? '').trim().isEmpty ? null : notes!.trim(),
        'updated_at': now,
      },
      where: 'id = ?',
      whereArgs: [id],
    );
  }

  Future<void> deleteMeal(int id) async {
    final db = await database;
    await db.delete('meals', where: 'id = ?', whereArgs: [id]);
  }

  Future<List<Map<String, dynamic>>> getMeals() async {
    final db = await database;
    return await db.query('meals', orderBy: 'updated_at DESC');
  }

  Future<List<Map<String, dynamic>>> getMealItems(int mealId) async {
    final db = await database;
    return await db.query(
      'meal_items',
      where: 'meal_id = ?',
      whereArgs: [mealId],
    );
  }

  Future<int> addMealItem(
    int mealId, {
    required String barcode,
    required int grams,
  }) async {
    final db = await database;
    return await db.insert('meal_items', {
      'meal_id': mealId,
      'barcode': barcode,
      'quantity_in_grams': grams,
    });
  }

  Future<void> removeMealItem(int itemId) async {
    final db = await database;
    await db.delete('meal_items', where: 'id = ?', whereArgs: [itemId]);
  }

  Future<void> clearMealItems(int mealId) async {
    final db = await database;
    await db.delete('meal_items', where: 'meal_id = ?', whereArgs: [mealId]);
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/data/base_db_exporter.dart =====

// lib/data/base_db_exporter.dart
import 'package:share_plus/share_plus.dart';
import 'package:mime/mime.dart';
import 'package:path/path.dart';
import 'product_database_helper.dart';

class BaseDbExporter {
  static Future<void> shareBaseDb({String? subject}) async {
    final path = await ProductDatabaseHelper.instance.getBaseDbPath();
    final file = XFile(
      path,
      mimeType: lookupMimeType(path) ?? 'application/octet-stream',
      name: basename(path),
    );
    await Share.shareXFiles([file], subject: subject ?? 'vita_base_foods.db');
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/data/workout_database_helper.dart =====

// lib/data/workout_database_helper.dart
// VOLLSTÄNDIGER CODE

import 'dart:convert';
import 'dart:io';
import 'package:flutter/services.dart';
import 'package:lightweight/util/mapping_prefs.dart';
import 'package:path/path.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:sqflite/sqflite.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:lightweight/models/routine.dart';
import 'package:lightweight/models/routine_exercise.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/set_template.dart';
import 'package:lightweight/models/workout_log.dart';

class WorkoutDatabaseHelper {
  static final WorkoutDatabaseHelper instance = WorkoutDatabaseHelper._init();
  static Database? _database;
  WorkoutDatabaseHelper._init();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB('vita_training.db');
    return _database!;
  }

  Future<Database> _initDB(String fileName) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, fileName);

    // --- KORREKTUR START: Versionierungslogik für Asset-DB ---
    const int currentAssetVersion =
        9; // Erhöhe diese Zahl, wenn du die vita_training.db in den Assets aktualisierst
    const String assetVersionKey = 'training_db_asset_version';

    final prefs = await SharedPreferences.getInstance();
    final lastCopiedVersion = prefs.getInt(assetVersionKey) ?? 0;
    final exists = await databaseExists(path);

    if (!exists || lastCopiedVersion < currentAssetVersion) {
      print(
        "Datenbank '$fileName' ist veraltet (Lokal: v$lastCopiedVersion, Asset: v$currentAssetVersion) oder nicht vorhanden. Kopiere neu...",
      );
      try {
        // Alte DB löschen, falls vorhanden, um eine saubere Kopie zu gewährleisten
        if (exists) {
          await deleteDatabase(path);
        }
        await Directory(dirname(path)).create(recursive: true);
        ByteData data = await rootBundle.load(join('assets/db', fileName));
        List<int> bytes = data.buffer.asUint8List(
          data.offsetInBytes,
          data.lengthInBytes,
        );
        await File(path).writeAsBytes(bytes, flush: true);

        // Neue Version in SharedPreferences speichern
        await prefs.setInt(assetVersionKey, currentAssetVersion);
        print(
            "Datenbank '$fileName' erfolgreich auf v$currentAssetVersion kopiert.");
      } catch (e) {
        print("Fehler beim Kopieren der Datenbank '$fileName': $e");
        rethrow;
      }
    } else {
      print(
          "Bestehende und aktuelle Datenbank '$fileName' (v$lastCopiedVersion) gefunden.");
    }
    // --- KORREKTUR ENDE ---

    return await openDatabase(path, version: 11, onUpgrade: _upgradeDB);
  }

  Future<void> _upgradeDB(Database db, int oldVersion, int newVersion) async {
    print("Führe DB-Upgrade von v$oldVersion auf v$newVersion aus...");
    if (oldVersion < 2) {
      await db
          .execute('ALTER TABLE set_logs ADD COLUMN rest_time_seconds INTEGER')
          .catchError((_) {});
      await db
          .execute('ALTER TABLE set_logs ADD COLUMN is_completed INTEGER')
          .catchError((_) {});
    }
    if (oldVersion < 3) {
      await db
          .execute(
            "ALTER TABLE workout_logs ADD COLUMN status TEXT NOT NULL DEFAULT 'completed'",
          )
          .catchError((_) {});
    }
    if (oldVersion < 4) {
      await db
          .execute(
            "ALTER TABLE routine_exercises ADD COLUMN pause_seconds INTEGER",
          )
          .catchError((_) {});
    }
    if (oldVersion < 5) {
      await db
          .execute("ALTER TABLE set_logs ADD COLUMN log_order INTEGER")
          .catchError((_) {});
    }
    if (oldVersion < 6) {
      print("Upgrade DB auf v6: Entferne set_index aus set_logs...");
      await db.transaction((txn) async {
        await txn.execute('ALTER TABLE set_logs RENAME TO set_logs_old');
        await txn.execute('''
          CREATE TABLE set_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            workout_log_id INTEGER,
            exercise_name TEXT,
            set_type TEXT,
            weight_kg REAL,
            reps INTEGER,
            rest_time_seconds INTEGER,
            is_completed INTEGER,
            log_order INTEGER
          )
        ''');
        await txn.execute('''
          INSERT INTO set_logs (id, workout_log_id, exercise_name, set_type, weight_kg, reps, rest_time_seconds, is_completed, log_order)
          SELECT id, workout_log_id, exercise_name, set_type, weight_kg, reps, rest_time_seconds, is_completed, log_order FROM set_logs_old
        ''');
        await txn.execute('DROP TABLE set_logs_old');
      });
    }
    if (oldVersion < 7) {
      print("Upgrade DB auf v7: Füge Detail-Spalten zu set_logs hinzu...");
      await db
          .execute("ALTER TABLE set_logs ADD COLUMN notes TEXT")
          .catchError((_) {});
      await db
          .execute("ALTER TABLE set_logs ADD COLUMN distance_km REAL")
          .catchError((_) {});
      await db
          .execute("ALTER TABLE set_logs ADD COLUMN duration_seconds INTEGER")
          .catchError((_) {});
      await db
          .execute("ALTER TABLE set_logs ADD COLUMN rpe INTEGER")
          .catchError((_) {});
    }
    if (oldVersion < 8) {
      print("Upgrade DB auf v8: Füge superset_id zu set_logs hinzu...");
      await db
          .execute("ALTER TABLE set_logs ADD COLUMN superset_id INTEGER")
          .catchError((_) {});
    }
    if (oldVersion < 9) {
      print("Upgrade DB auf v9: Erstelle exercise_mapping Tabelle...");
      await db.execute('''
        CREATE TABLE exercise_mapping (
          external_name TEXT PRIMARY KEY COLLATE NOCASE,
          target_name TEXT NOT NULL
        )
      ''');
      final oldMappings = await MappingPrefs.load();
      if (oldMappings.isNotEmpty) {
        print("Migriere ${oldMappings.length} bestehende Mappings...");
        final batch = db.batch();
        for (final entry in oldMappings.entries) {
          batch.insert(
              'exercise_mapping',
              {
                'external_name': entry.key,
                'target_name': entry.value,
              },
              conflictAlgorithm: ConflictAlgorithm.replace);
        }
        await batch.commit(noResult: true);
        print("Migration abgeschlossen.");
      }
    }
    if (oldVersion < 10) {
      print("Upgrade DB auf v10: Füge is_custom zu exercises hinzu...");
      try {
        // Füge die neue Spalte hinzu, Standardwert 0 (nicht custom)
        await db.execute(
          'ALTER TABLE exercises ADD COLUMN is_custom INTEGER NOT NULL DEFAULT 0',
        );
        print("Spalte 'is_custom' erfolgreich zu 'exercises' hinzugefügt.");
      } catch (e) {
        print(
            "Fehler beim Hinzufügen der Spalte 'is_custom' (evtl. existiert sie schon): $e");
      }
    }
    if (oldVersion < 11) {
      print(
          "Upgrade DB auf v11: Fehlende Spalten für Custom Exercises hinzufügen...");

      final columnsToAdd = [
        "name_de TEXT",
        "name_en TEXT",
        "description_de TEXT",
        "description_en TEXT",
        "category_name TEXT",
        "primaryMuscles TEXT",
        "secondaryMuscles TEXT",
        "image_path TEXT"
      ];

      for (var col in columnsToAdd) {
        try {
          await db.execute("ALTER TABLE exercises ADD COLUMN $col");
        } catch (e) {
          // Spalte existiert evtl. schon, Fehler ignorieren
        }
      }
    }
    print("DB-Upgrade auf v$newVersion erfolgreich abgeschlossen.");
  }

  // HINZUGEFÜGT: Neue Methode zur Wiederherstellung
  /// Sucht nach einem laufenden Workout in der DB. Es sollte immer nur eines geben.
  Future<WorkoutLog?> getOngoingWorkout() async {
    final db = await database;
    final maps = await db.query(
      'workout_logs',
      where: "status = 'ongoing'",
      orderBy: 'start_time DESC',
      limit: 1,
    );

    if (maps.isNotEmpty) {
      // Wenn ein laufendes Workout gefunden wird, holen wir auch alle zugehörigen Sätze.
      final logId = maps.first['id'] as int;
      return getWorkoutLogById(logId);
    }

    return null;
  }

  Future<Map<String, String>> getExerciseMappings() async {
    final db = await database;
    final maps = await db.query('exercise_mapping');
    return {
      for (var map in maps)
        (map['external_name'] as String): (map['target_name'] as String),
    };
  }

  // --- EXERCISE MANAGEMENT ---
  Future<List<String>> getAllCategories() async {
    final db = await database;

    // 1. Kategorien aus den Standard-Daten (View)
    final List<Map<String, dynamic>> standardMaps = await db.query(
      'exercises_flat',
      columns: ['category_name'],
      distinct: true,
    );

    // 2. Kategorien aus den eigenen Übungen (Tabelle)
    final List<Map<String, dynamic>> customMaps = await db.query(
      'exercises',
      columns: ['category_name'],
      where: 'is_custom = 1',
      distinct: true,
    );

    final Set<String> categories = {};

    for (var map in standardMaps) {
      if (map['category_name'] != null) {
        categories.add(map['category_name'] as String);
      }
    }
    for (var map in customMaps) {
      if (map['category_name'] != null) {
        categories.add(map['category_name'] as String);
      }
    }

    final sortedList = categories.toList()..sort();
    return sortedList;
  }

  Future<List<Exercise>> searchExercises(
      {String query = '', List<String> selectedCategories = const []}) async {
    final db = await database;

    // --- TEIL A: Standard-Daten aus der View laden ---
    List<String> whereClausesFlat = [];
    List<dynamic> whereArgsFlat = [];

    if (query.isNotEmpty) {
      // Hinweis: In der View heißen die Spalten evtl. noch alt, aber dein Model erwartet name_de/name_en.
      // Die View exercises_flat mappt das oft schon. Wir suchen hier im Standard.
      whereClausesFlat.add('(name_de LIKE ? OR name_en LIKE ?)');
      whereArgsFlat.addAll(['%$query%', '%$query%']);
    }
    if (selectedCategories.isNotEmpty) {
      String placeholders =
          List.filled(selectedCategories.length, '?').join(', ');
      whereClausesFlat.add('category_name IN ($placeholders)');
      whereArgsFlat.addAll(selectedCategories);
    }
    String whereStringFlat =
        whereClausesFlat.isNotEmpty ? whereClausesFlat.join(' AND ') : '';

    final List<Map<String, dynamic>> standardMaps = await db.query(
      'exercises_flat',
      where: whereStringFlat.isEmpty ? null : whereStringFlat,
      whereArgs: whereArgsFlat.isEmpty ? null : whereArgsFlat,
    );

    // --- TEIL B: Eigene Daten aus der Tabelle laden ---
    List<String> whereClausesCustom = ['is_custom = 1']; // Nur Custom
    List<dynamic> whereArgsCustom = [];

    if (query.isNotEmpty) {
      whereClausesCustom.add('(name_de LIKE ? OR name_en LIKE ?)');
      whereArgsCustom.addAll(['%$query%', '%$query%']);
    }
    if (selectedCategories.isNotEmpty) {
      String placeholders =
          List.filled(selectedCategories.length, '?').join(', ');
      whereClausesCustom.add('category_name IN ($placeholders)');
      whereArgsCustom.addAll(selectedCategories);
    }

    final List<Map<String, dynamic>> customMaps = await db.query(
      'exercises',
      where: whereClausesCustom.join(' AND '),
      whereArgs: whereArgsCustom,
    );

    // --- TEIL C: Zusammenfügen ---
    List<Exercise> allExercises = [];

    // Custom zuerst (optional)
    for (var map in customMaps) {
      allExercises.add(Exercise.fromMap(map));
    }
    for (var map in standardMaps) {
      allExercises.add(Exercise.fromMap(map));
    }

    // Sortieren: Custom zuerst, dann alphabetisch
    allExercises.sort((a, b) {
      // Sortiere nach Name DE
      return a.nameDe.toLowerCase().compareTo(b.nameDe.toLowerCase());
    });

    return allExercises;
  }

  Future<Exercise?> getExerciseByName(String name) async {
    final db = await database;

    // 1. Zuerst in den Custom Exercises suchen (Priorität)
    final customMaps = await db.query(
      'exercises',
      where: 'is_custom = 1 AND (name_de = ? OR name_en = ?)',
      whereArgs: [name, name],
      limit: 1,
    );
    if (customMaps.isNotEmpty) {
      return Exercise.fromMap(customMaps.first);
    }

    // 2. Fallback auf Standard View
    final standardMaps = await db.query('exercises_flat',
        where: 'name_de = ? OR name_en = ?', whereArgs: [name, name], limit: 1);

    if (standardMaps.isNotEmpty) {
      return Exercise.fromMap(standardMaps.first);
    }

    return null;
  }

  // --- ROUTINE MANAGEMENT ---
  Future<Routine> createRoutine(String name) async {
    final db = await database;
    final id = await db.insert(
        'routines',
        {
          'name': name,
        },
        conflictAlgorithm: ConflictAlgorithm.replace);
    return Routine(id: id, name: name);
  }

  Future<void> updateRoutineName(int routineId, String newName) async {
    final db = await database;
    await db.update(
      'routines',
      {'name': newName},
      where: 'id = ?',
      whereArgs: [routineId],
    );
  }

  Future<RoutineExercise?> addExerciseToRoutine(
    int routineId,
    int exerciseId,
  ) async {
    final db = await database;
    // --- START FIX ---
    // Query the VIEW 'exercises_flat' instead of the TABLE 'exercises'
    // to ensure all necessary fields (like muscle groups) are correctly loaded.
    final exerciseMaps = await db.query(
      'exercises_flat', // CORRECT: Use the view
      where: 'id = ?',
      whereArgs: [exerciseId],
    );
    // --- END FIX ---

    if (exerciseMaps.isEmpty) return null;
    final result = await db.rawQuery(
      'SELECT MAX(exercise_order) as max_order FROM routine_exercises WHERE routine_id = ?',
      [routineId],
    );
    final maxOrder = (result.first['max_order'] as int?) ?? -1;
    final routineExerciseId = await db.insert('routine_exercises', {
      'routine_id': routineId,
      'exercise_id': exerciseId,
      'exercise_order': maxOrder + 1,
    });
    final List<SetTemplate> newTemplates = [];
    for (int i = 0; i < 3; i++) {
      final setId = await db.insert('routine_set_templates', {
        'routine_exercise_id': routineExerciseId,
        'set_index': i,
        'set_type': 'normal',
      });
      newTemplates.add(
        SetTemplate(id: setId, setType: 'normal', targetReps: '8-12'),
      );
    }
    return RoutineExercise(
      id: routineExerciseId,
      exercise: Exercise.fromMap(exerciseMaps.first),
      setTemplates: newTemplates,
    );
  }

  Future<void> removeExerciseFromRoutine(int routineExerciseId) async {
    final db = await database;
    await db.delete(
      'routine_exercises',
      where: 'id = ?',
      whereArgs: [routineExerciseId],
    );
  }

  Future<void> updateExerciseOrder(
    int routineId,
    List<RoutineExercise> orderedExercises,
  ) async {
    final db = await database;
    final batch = db.batch();
    for (int i = 0; i < orderedExercises.length; i++) {
      final routineExercise = orderedExercises[i];
      batch.update(
        'routine_exercises',
        {'exercise_order': i},
        where: 'id = ?',
        whereArgs: [routineExercise.id],
      );
    }
    await batch.commit(noResult: true);
  }

  Future<List<Routine>> getAllRoutines() async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query(
      'routines',
      orderBy: 'name ASC',
    );
    return List.generate(
      maps.length,
      (i) => Routine(id: maps[i]['id'], name: maps[i]['name']),
    );
  }

// In lib/data/workout_database_helper.dart

  Future<Routine?> getRoutineById(int id) async {
    final db = await database;
    final routineMaps =
        await db.query('routines', where: 'id = ?', whereArgs: [id]);
    if (routineMaps.isEmpty) return null;

    final routineExerciseMaps = await db.query('routine_exercises',
        where: 'routine_id = ?',
        whereArgs: [id],
        orderBy: 'exercise_order ASC');

    final List<RoutineExercise> routineExercises = [];
    for (final reMap in routineExerciseMaps) {
      final routineExerciseId = reMap['id'] as int;
      final exerciseId = reMap['exercise_id'] as int;

      // --- FIX START: Intelligentes Laden der Übungsdetails ---

      // 1. Versuch: Direkt aus der Tabelle laden (für Custom Exercises essentiell)
      List<Map<String, dynamic>> exerciseMaps =
          await db.query('exercises', where: 'id = ?', whereArgs: [exerciseId]);

      bool usableDataFound = false;
      if (exerciseMaps.isNotEmpty) {
        final row = exerciseMaps.first;
        // Wir prüfen, ob wir hier Namen finden (Indikator für Custom Exercise mit unseren neuen Spalten)
        if ((row['name_de'] != null && row['name_de'].toString().isNotEmpty) ||
            (row['name_en'] != null && row['name_en'].toString().isNotEmpty)) {
          usableDataFound = true;
        }
      }

      // 2. Versuch: Wenn Tabelle keine Namen lieferte (Standard-Übung), fallback auf die View
      if (!usableDataFound) {
        exerciseMaps = await db
            .query('exercises_flat', where: 'id = ?', whereArgs: [exerciseId]);
      }
      // --- FIX ENDE ---

      if (exerciseMaps.isEmpty) continue;

      final setTemplateMaps = await db.query('routine_set_templates',
          where: 'routine_exercise_id = ?',
          whereArgs: [routineExerciseId],
          orderBy: 'set_index ASC');
      final setTemplates =
          setTemplateMaps.map((stMap) => SetTemplate.fromMap(stMap)).toList();

      routineExercises.add(RoutineExercise(
        id: routineExerciseId,
        exercise: Exercise.fromMap(exerciseMaps.first),
        setTemplates: setTemplates,
        pauseSeconds: reMap['pause_seconds'] as int?,
      ));
    }

    return Routine(
        id: id,
        name: routineMaps.first['name'] as String,
        exercises: routineExercises);
  }

  Future<void> updateSetTemplate(SetTemplate setTemplate) async {
    final db = await database;
    await db.update(
      'routine_set_templates',
      {
        'set_type': setTemplate.setType,
        'target_reps': setTemplate.targetReps,
        'target_weight': setTemplate.targetWeight,
      },
      where: 'id = ?',
      whereArgs: [setTemplate.id],
    );
  }

  Future<void> replaceSetTemplatesForExercise(
    int routineExerciseId,
    List<SetTemplate> newTemplates,
  ) async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete(
        'routine_set_templates',
        where: 'routine_exercise_id = ?',
        whereArgs: [routineExerciseId],
      );
      for (int i = 0; i < newTemplates.length; i++) {
        final set = newTemplates[i];
        await txn.insert('routine_set_templates', {
          'routine_exercise_id': routineExerciseId,
          'set_index': i,
          'set_type': set.setType,
          'target_reps': set.targetReps,
          'target_weight': set.targetWeight,
        });
      }
    });
  }

  Future<void> deleteRoutine(int routineId) async {
    final db = await database;
    await db.transaction((txn) async {
      final reMaps = await txn.query(
        'routine_exercises',
        where: 'routine_id = ?',
        whereArgs: [routineId],
      );
      for (var reMap in reMaps) {
        await txn.delete(
          'routine_set_templates',
          where: 'routine_exercise_id = ?',
          whereArgs: [reMap['id']],
        );
      }
      await txn.delete(
        'routine_exercises',
        where: 'routine_id = ?',
        whereArgs: [routineId],
      );
      await txn.delete('routines', where: 'id = ?', whereArgs: [routineId]);
    });
  }

  Future<void> duplicateRoutine(int routineId) async {
    final db = await database;
    final originalRoutine = await getRoutineById(routineId);
    if (originalRoutine == null) return;
    await db.transaction((txn) async {
      final newRoutineId = await txn.insert('routines', {
        'name': '${originalRoutine.name} (Kopie)',
      });
      for (var re in originalRoutine.exercises) {
        final newRoutineExerciseId = await txn.insert('routine_exercises', {
          'routine_id': newRoutineId,
          'exercise_id': re.exercise.id,
          'exercise_order': originalRoutine.exercises.indexOf(re),
          'pause_seconds': re.pauseSeconds,
        });
        for (var st in re.setTemplates) {
          await txn.insert('routine_set_templates', {
            'routine_exercise_id': newRoutineExerciseId,
            'set_index': re.setTemplates.indexOf(st),
            'set_type': st.setType,
            'target_reps': st.targetReps,
            'target_weight': st.targetWeight,
          });
        }
      }
    });
  }

  Future<void> updatePauseTime(int routineExerciseId, int? seconds) async {
    final db = await database;
    await db.update(
      'routine_exercises',
      {'pause_seconds': seconds},
      where: 'id = ?',
      whereArgs: [routineExerciseId],
    );
  }

  // --- WORKOUT LOGGING ---
  Future<WorkoutLog> startWorkout({String? routineName}) async {
    final db = await database;
    final now = DateTime.now();
    final id = await db.insert('workout_logs', {
      'routine_name': routineName,
      'start_time': now.toIso8601String(),
      'status': 'ongoing',
    });
    return WorkoutLog(id: id, routineName: routineName, startTime: now);
  }

  Future<int> insertSetLog(SetLog setLog) async {
    final db = await database;

    if (setLog.id != null) {
      print("--- DEBUG: Update SetLog ID=${setLog.id} ---");
      return await db.update(
        'set_logs',
        setLog.toMap(),
        where: 'id = ?',
        whereArgs: [setLog.id],
      );
    }

    final id = await db.insert(
      'set_logs',
      setLog.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
    print(
      "--- DEBUG: Insert SetLog (${setLog.exerciseName}, ${setLog.weightKg}kg x ${setLog.reps}) → ID=$id ---",
    );
    return id;
  }

  Future<void> finishWorkout(int workoutLogId) async {
    final db = await database;
    await db.update(
      'workout_logs',
      {'end_time': DateTime.now().toIso8601String(), 'status': 'completed'},
      where: 'id = ?',
      whereArgs: [workoutLogId],
    );
  }

  Future<SetLog?> getLastPerformance(String exerciseName) async {
    final db = await database;
    final maps = await db.rawQuery(
      '''
      SELECT * FROM set_logs
      WHERE exercise_name = ? AND set_type != 'warmup' AND reps IS NOT NULL AND weight_kg IS NOT NULL
      ORDER BY id DESC LIMIT 1
    ''',
      [exerciseName],
    );
    if (maps.isNotEmpty) return SetLog.fromMap(maps.first);
    return null;
  }

  // --- WORKOUT HISTORY ---
  Future<void> deleteWorkoutLog(int logId) async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete(
        'set_logs',
        where: 'workout_log_id = ?',
        whereArgs: [logId],
      );
      await txn.delete('workout_logs', where: 'id = ?', whereArgs: [logId]);
    });
  }

  Future<List<WorkoutLog>> getWorkoutLogs() async {
    final db = await database;
    final maps = await db.query(
      'workout_logs',
      where: "status = 'completed'",
      orderBy: 'start_time DESC',
    );
    return maps.map((map) => WorkoutLog.fromMap(map)).toList();
  }

  Future<WorkoutLog?> getWorkoutLogById(int id) async {
    final db = await database;
    print("--- DEBUG: getWorkoutLogById gestartet für ID: $id ---");

    final logMaps = await db.query(
      'workout_logs',
      where: 'id = ?',
      whereArgs: [id],
    );
    if (logMaps.isEmpty) {
      print("--- DEBUG: KEINEN WorkoutLog für ID $id gefunden. Breche ab.");
      return null;
    }
    print("--- DEBUG: WorkoutLog gefunden: ${logMaps.first}");

    final setMaps = await db.query(
      'set_logs',
      where: 'workout_log_id = ?',
      whereArgs: [id],
      orderBy: 'id ASC',
    );

    print(
      "--- DEBUG: Für workout_log_id $id wurden ${setMaps.length} Sätze in der DB gefunden.",
    );
    if (setMaps.isNotEmpty) {
      print("--- DEBUG: Erster gefundener Satz: ${setMaps.first}");
    }

    final sets = setMaps.map((map) => SetLog.fromMap(map)).toList();

    return WorkoutLog.fromMap(logMaps.first, sets: sets);
  }

  Future<WorkoutLog?> getLatestWorkoutLog() async {
    final db = await database;
    final maps = await db.query(
      'workout_logs',
      orderBy: 'start_time DESC',
      limit: 1,
    );
    if (maps.isNotEmpty) {
      return WorkoutLog.fromMap(maps.first);
    }
    return null;
  }
// lib/data/workout_database_helper.dart

  Future<List<WorkoutLog>> getWorkoutLogsForDateRange(
    DateTime start,
    DateTime end,
  ) async {
    final db = await database;

    // HIER IST DIE KORREKTUR: Erzeuge einen validen Datumsbereich für den ganzen Tag.
    final effectiveStart = DateTime(start.year, start.month, start.day);
    final effectiveEnd = DateTime(end.year, end.month, end.day, 23, 59, 59);

    final maps = await db.query(
      'workout_logs',
      where: 'start_time >= ? AND start_time <= ? AND status = ?',
      whereArgs: [
        effectiveStart.toIso8601String(),
        effectiveEnd.toIso8601String(),
        'completed'
      ],
      orderBy: 'start_time DESC',
    );

    List<WorkoutLog> logs = [];
    for (final map in maps) {
      final sets = await getSetLogsForWorkout(map['id'] as int);
      logs.add(WorkoutLog.fromMap(map, sets: sets));
    }
    return logs;
  }

  Future<Routine?> getRoutineByName(String name) async {
    final db = await database;
    final maps = await db.query(
      'routines',
      where: 'name = ?',
      whereArgs: [name],
      limit: 1,
    );
    if (maps.isNotEmpty) {
      return getRoutineById(maps.first['id'] as int);
    }
    return null;
  }

  Future<void> updateWorkoutLogDetails(
    int logId,
    DateTime startTime,
    String? notes,
  ) async {
    final db = await database;
    await db.update(
      'workout_logs',
      {'start_time': startTime.toIso8601String(), 'notes': notes},
      where: 'id = ?',
      whereArgs: [logId],
    );
  }

  Future<void> updateSetLogs(List<SetLog> updatedSets) async {
    if (updatedSets.isEmpty) return;
    final db = await database;
    final batch = db.batch();
    for (final setLog in updatedSets) {
      batch.update(
        'set_logs',
        setLog.toMap(),
        where: 'id = ?',
        whereArgs: [setLog.id],
      );
    }
    await batch.commit(noResult: true);
  }

  Future<void> deleteSetLogs(List<int> idsToDelete) async {
    if (idsToDelete.isEmpty) return;
    final db = await database;
    final batch = db.batch();
    for (final id in idsToDelete) {
      batch.delete('set_logs', where: 'id = ?', whereArgs: [id]);
    }
    await batch.commit(noResult: true);
  }

  Future<List<SetLog>> getSetLogsForWorkout(int workoutLogId) async {
    final db = await database;
    final maps = await db.query(
      'set_logs',
      where: 'workout_log_id = ?',
      whereArgs: [workoutLogId],
      orderBy: 'log_order ASC',
    );

    return maps.map((map) => SetLog.fromMap(map)).toList();
  }
  // --- NEUE METHODEN FÜR BACKUP & RESTORE ---

  Future<List<Routine>> getAllRoutinesWithDetails() async {
    final routines = await getAllRoutines();
    final detailedRoutines = <Routine>[];
    for (final routine in routines) {
      if (routine.id != null) {
        final detailedRoutine = await getRoutineById(routine.id!);
        if (detailedRoutine != null) {
          detailedRoutines.add(detailedRoutine);
        }
      }
    }
    return detailedRoutines;
  }

  Future<List<WorkoutLog>> getFullWorkoutLogs() async {
    final db = await database;
    final maps = await db.query('workout_logs', orderBy: 'start_time DESC');
    final logs = <WorkoutLog>[];
    for (final map in maps) {
      final log = await getWorkoutLogById(map['id'] as int);
      if (log != null) {
        logs.add(log);
      }
    }
    return logs;
  }

  Future<void> importWorkoutData(
      {required List<Routine> routines,
      required List<WorkoutLog> workoutLogs}) async {
    final db = await database;
    await db.transaction((txn) async {
      // A. Routinen importieren
      for (final routine in routines) {
        // Wir nutzen die ID aus dem Backup, falls vorhanden
        int routineId;
        if (routine.id != null) {
          await txn.insert(
              'routines',
              {
                'id': routine.id, // ID erzwingen
                'name': routine.name
              },
              conflictAlgorithm: ConflictAlgorithm.replace);
          routineId = routine.id!;
        } else {
          routineId = await txn.insert('routines', {'name': routine.name});
        }

        for (final re in routine.exercises) {
          // Auch hier: routine_exercise ID erzwingen, falls vorhanden (für perfekte Kopie)
          // Wichtig ist aber vor allem 'exercise_id', die auf die Custom Exercise zeigt
          await txn.insert('routine_exercises', {
            // 'id': re.id, // Optional, können wir auch neu generieren lassen, aber sicherer ist mit.
            'routine_id': routineId,
            'exercise_id':
                re.exercise.id, // Das muss matchen mit importCustomExercises!
            'exercise_order': routine.exercises.indexOf(re),
            'pause_seconds': re.pauseSeconds,
          });

          // Da wir die ID von routine_exercises oben nicht zwingend holen (da auto-increment im Backup evtl fehlt),
          // müssen wir die letzte ID abfragen oder Logik anpassen.
          // Einfacherer Weg für Import: Wir verlassen uns darauf, dass die Reihenfolge stimmt.
          // BESSERER WEG: Wir holen uns die ID des gerade eingefügten 'routine_exercises'.

          final lastReRow =
              await txn.rawQuery('SELECT last_insert_rowid() as id');
          final newReId = lastReRow.first['id'] as int;

          for (final st in re.setTemplates) {
            final stMap = st.toMap();
            stMap.remove(
                'id'); // Set Template IDs sind nicht so wichtig für Verknüpfungen
            stMap['routine_exercise_id'] = newReId;
            stMap['set_index'] = re.setTemplates.indexOf(st);
            await txn.insert('routine_set_templates', stMap);
          }
        }
      }

      // B. Workout Logs importieren
      for (final log in workoutLogs) {
        final logMap = log.toMap();
        // Hier behalten wir die ID, falls wir später mal Logs editieren und die ID referenzieren
        // logMap.remove('id');
        logMap['status'] = 'completed';

        final newLogId = await txn.insert('workout_logs', logMap,
            conflictAlgorithm: ConflictAlgorithm.replace);

        for (final setLog in log.sets) {
          final setMap = setLog.toMap();
          setMap.remove(
              'id'); // SetLog IDs sind egal, solange sie dem Workout gehören
          setMap['workout_log_id'] = newLogId;
          await txn.insert('set_logs', setMap);
        }
      }
    });
  }

  Future<List<String>> findUnknownExerciseNames() async {
    final db = await database;
    final rows = await db.rawQuery('''
    SELECT DISTINCT sl.exercise_name
    FROM set_logs sl
    LEFT JOIN exercises e
      ON e.name_de = sl.exercise_name OR e.name_en = sl.exercise_name
    WHERE e.id IS NULL
    ORDER BY sl.exercise_name COLLATE NOCASE ASC
  ''');
    return rows
        .map((r) => (r['exercise_name'] as String?) ?? '')
        .where((s) => s.isNotEmpty)
        .toList();
  }

  Future<void> applyExerciseNameMapping(Map<String, String> map) async {
    if (map.isEmpty) return;
    final db = await database;
    await db.transaction((txn) async {
      final batch = txn.batch();
      for (final e in map.entries) {
        batch.insert(
            'exercise_mapping',
            {
              'external_name': e.key,
              'target_name': e.value,
            },
            conflictAlgorithm: ConflictAlgorithm.replace);
      }
      await batch.commit(noResult: true);

      for (final e in map.entries) {
        await txn.update(
          'set_logs',
          {'exercise_name': e.value},
          where: 'exercise_name = ?',
          whereArgs: [e.key],
        );
      }
    });
  }

  Future<List<String>> getAllMuscleGroups() async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query(
      'exercises',
      columns: ['primaryMuscles', 'secondaryMuscles'],
      distinct: true,
    );

    final Set<String> allMuscles = {};

    List<String> parseMuscles(String? jsonString) {
      if (jsonString == null || jsonString.isEmpty) return [];
      try {
        // Versuche JSON zu decodieren
        final decoded = jsonDecode(jsonString);
        if (decoded is List) {
          return decoded.map((item) => item.toString()).toList();
        }
        // Fallback: Falls es als CSV gespeichert wurde (legacy data)
        if (jsonString.contains(',')) {
          return jsonString.split(',').map((e) => e.trim()).toList();
        }
        return [];
      } catch (e) {
        return [];
      }
    }

    for (final map in maps) {
      final primary = parseMuscles(map['primaryMuscles'] as String?);
      final secondary = parseMuscles(map['secondaryMuscles'] as String?);
      allMuscles.addAll(primary);
      allMuscles.addAll(secondary);
    }

    final sortedList = allMuscles.toList()..sort();
    return sortedList;
  }

  Future<Set<int>> getWorkoutDaysInMonth(DateTime month) async {
    final db = await database;
    final firstDayOfMonth = DateTime(month.year, month.month, 1);
    final lastDayOfMonth = DateTime(month.year, month.month + 1, 0, 23, 59, 59);

    final maps = await db.query(
      'workout_logs',
      columns: ['start_time'],
      where: 'start_time BETWEEN ? AND ?',
      whereArgs: [
        firstDayOfMonth.toIso8601String(),
        lastDayOfMonth.toIso8601String(),
      ],
    );

    if (maps.isEmpty) return {};

    return maps
        .map((map) => DateTime.parse(map['start_time'] as String).day)
        .toSet();
  }

  /// Findet das letzte Workout, das eine bestimmte Übung enthielt,
  /// und gibt alle Sätze dieser Übung aus jenem Workout zurück.
  Future<List<SetLog>> getLastSetsForExercise(String exerciseName) async {
    final db = await database;

    // Schritt 1: Finde die ID des letzten Workout-Logs, das diese Übung enthält.
    final latestLogResult = await db.rawQuery(
      '''
      SELECT l.id
      FROM workout_logs l
      INNER JOIN set_logs s ON l.id = s.workout_log_id
      WHERE s.exercise_name = ? AND l.status = 'completed'
      ORDER BY l.start_time DESC
      LIMIT 1
    ''',
      [exerciseName],
    );

    if (latestLogResult.isEmpty) {
      return []; // Kein vorheriges Workout mit dieser Übung gefunden.
    }

    final logId = latestLogResult.first['id'] as int;

    // Schritt 2: Hole alle Sätze für diese Übung aus genau diesem Workout-Log.
    final setMaps = await db.query(
      'set_logs',
      where: 'workout_log_id = ? AND exercise_name = ?',
      whereArgs: [logId, exerciseName],
      orderBy: 'id ASC', // Sortiert nach der Reihenfolge der Erstellung
    );

    return setMaps.map((map) => SetLog.fromMap(map)).toList();
  }

// In lib/data/workout_database_helper.dart

  Future<Exercise> insertExercise(Exercise exercise) async {
    final db = await database;

    // Dein Model nutzt toMap(), was JSON-Listen korrekt in Strings umwandelt
    final Map<String, Object?> exerciseMap = exercise.toMap();

    // WICHTIG: ID entfernen, damit die DB eine neue generiert
    exerciseMap.remove('id');

    // WICHTIG: Als eigene Übung markieren
    exerciseMap['is_custom'] = 1;

    final id = await db.insert(
      'exercises',
      exerciseMap,
      conflictAlgorithm: ConflictAlgorithm.replace,
    );

    print(
        "Benutzerdefinierte Übung '${exercise.nameDe}' mit ID $id eingefügt.");
    return exercise.copyWith(id: id);
  }

  // *** NEU: Methode zum Abrufen benutzerdefinierter Übungen für das Backup ***
  Future<List<Exercise>> getCustomExercises() async {
    final db = await database;
    final maps = await db.query(
      'exercises',
      where: 'is_custom = ?',
      whereArgs: [1], // Nur benutzerdefinierte
    );
    // Wichtig: 'is_custom' wird von fromMap nicht direkt gelesen, aber das ist ok.
    return maps.map((map) => Exercise.fromMap(map)).toList();
  }

  Future<void> importCustomExercises(List<Exercise> exercises) async {
    if (exercises.isEmpty) return;
    final db = await database;
    await db.transaction((txn) async {
      final batch = txn.batch();
      for (final exercise in exercises) {
        final exerciseMap = exercise.toMap();
        exerciseMap['is_custom'] = 1;

        // WICHTIG: Wir entfernen die ID NICHT.
        // Wir wollen exakt dieselbe ID wiederherstellen, damit Routinen funktionieren.
        // exerciseMap.remove('id'); <--- DAS WAR DER FEHLERQUELLE

        batch.insert(
          'exercises',
          exerciseMap,
          conflictAlgorithm:
              ConflictAlgorithm.replace, // Überschreiben, falls da
        );
      }
      await batch.commit(noResult: true);
      print(
          "${exercises.length} benutzerdefinierte Übungen erfolgreich importiert (IDs erhalten).");
    });
  }

  // *** WICHTIG: Methode 'clearAllWorkoutData' anpassen ***
  Future<void> clearAllWorkoutData() async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('set_logs');
      await txn.delete('workout_logs');
      await txn.delete('routine_set_templates');
      await txn.delete('routine_exercises');
      await txn.delete('routines');
      // *** NEU: Lösche NUR benutzerdefinierte Übungen ***
      await txn.delete('exercises', where: 'is_custom = ?', whereArgs: [1]);
      print("Alle Trainingsdaten (Logs, Routinen, Custom Exercises) gelöscht.");
    });
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/data/backup_manager.dart =====

// lib/data/backup_manager.dart (Finale Version)

import 'dart:convert';
import 'dart:io';
import 'package:csv/csv.dart';
import 'package:flutter/services.dart';
import 'package:intl/intl.dart';
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/data/product_database_helper.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/models/food_item.dart';
import 'package:lightweight/models/lightweight_backup.dart';
import 'package:sqflite/sqflite.dart'; // KORREKTUR: Importiert das neue Modell
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lightweight/util/encryption_util.dart';
import 'package:path/path.dart' as p;
import 'dart:typed_data';
import 'package:archive/archive.dart'; // for GZipDecoder (add to pubspec if not present)

class BackupManager {
  final _userDb = DatabaseHelper.instance;
  final _productDb = ProductDatabaseHelper.instance;
  final _workoutDb = WorkoutDatabaseHelper.instance;

  static const int currentSchemaVersion = 1;

  Future<bool> exportFullBackup() async {
    try {
      final foodEntries = await _userDb.getAllFoodEntries();
      final fluidEntries = await _userDb.getAllFluidEntries();
      final favoriteBarcodes = await _userDb.getFavoriteBarcodes();
      final measurementSessions = await _userDb.getMeasurementSessions();
      final productDb = await _productDb.offDatabase;
      final customFoodMaps = await productDb?.query(
            'products',
            where: 'barcode LIKE ?',
            whereArgs: ['user_created_%'],
          ) ??
          [];
      final customFoodItems = customFoodMaps
          .map((map) => FoodItem.fromMap(map, source: FoodItemSource.user))
          .toList();
      final routines = await _workoutDb.getAllRoutinesWithDetails();
      final workoutLogs = await _workoutDb.getFullWorkoutLogs();
      // --- HINZUGEFÜGT: Benutzereinstellungen auslesen ---
      final prefs = await SharedPreferences.getInstance();
      final userPrefs = <String, dynamic>{};
      final keys = prefs.getKeys();
      for (String key in keys) {
        userPrefs[key] = prefs.get(key);
      }
      final supplements = await _userDb.getAllSupplements();
      final supplementLogs = await _userDb.getAllSupplementLogs();
      final customExercises = await _workoutDb.getCustomExercises();
      final backup = LightweightBackup(
        // KORREKTUR: Nutzt das neue Modell
        schemaVersion: currentSchemaVersion,
        foodEntries: foodEntries,
        fluidEntries: fluidEntries,
        favoriteBarcodes: favoriteBarcodes,
        customFoodItems: customFoodItems,
        measurementSessions: measurementSessions,
        routines: routines,
        workoutLogs: workoutLogs,
        userPreferences: userPrefs,
        supplements: supplements,
        supplementLogs: supplementLogs,
        customExercises: customExercises,
      );
      final jsonString = jsonEncode(backup.toJson());

      // ... (Logik zum Speichern und Teilen der Datei bleibt identisch)
      final tempDir = await getTemporaryDirectory();
      final timestamp = DateFormat('yyyy-MM-dd_HH-mm').format(DateTime.now());
      final tempFile = File(
        '${tempDir.path}/lightweight_backup_v$currentSchemaVersion-[$timestamp].json',
      );
      await tempFile.writeAsString(jsonString);
      final result = await Share.shareXFiles([
        XFile(tempFile.path, mimeType: 'application/json'),
      ], subject: 'Lightweight App Backup - $timestamp');
      await tempFile.delete();
      return result.status == ShareResultStatus.success;
    } catch (e) {
      print("Fehler beim Exportieren der Daten: $e");
      return false;
    }
  }

  Future<bool> importFullBackup(String filePath) async {
    try {
      final file = File(filePath);
      final jsonString = await file.readAsString();
      final jsonMap = jsonDecode(jsonString);

      final backup = LightweightBackup.fromJson(
        jsonMap,
      ); // KORREKTUR: Nutzt das neue Modell

      if (backup.schemaVersion > currentSchemaVersion) {
        print(
          "Backup-Version (${backup.schemaVersion}) ist neuer als die App-Version ($currentSchemaVersion). Import abgebrochen.",
        );
        return false;
      }

      // ... (Logik zum Löschen und Einfügen der Daten bleibt identisch)
      // HINZUGEFÜGT: Alte Einstellungen löschen
      final prefs = await SharedPreferences.getInstance();
      await prefs.clear();

      await _userDb.clearAllUserData();
      await _workoutDb.clearAllWorkoutData();
      final productDb = await _productDb.offDatabase;
      await productDb?.delete(
        'products',
        where: 'barcode LIKE ?',
        whereArgs: ['user_created_%'],
      );
      // HINZUGEFÜGT: Neue Einstellungen wiederherstellen
      for (final entry in backup.userPreferences.entries) {
        final key = entry.key;
        final value = entry.value;
        if (value is bool) {
          await prefs.setBool(key, value);
        } else if (value is int) {
          await prefs.setInt(key, value);
        } else if (value is double) {
          await prefs.setDouble(key, value);
        } else if (value is String) {
          await prefs.setString(key, value);
        } else if (value is List<String>) {
          await prefs.setStringList(key, value);
        }
      }
      await _userDb.importUserData(
        foodEntries: backup.foodEntries,
        fluidEntries: backup.fluidEntries,
        favoriteBarcodes: backup.favoriteBarcodes,
        measurementSessions: backup.measurementSessions,
        supplements: backup.supplements,
        supplementLogs: backup.supplementLogs,
      );
      if (productDb != null) {
        // --- FIX START ---
        final cols = await _getTableColumns(productDb, 'products');
        final batch = productDb.batch();
        for (final item in backup.customFoodItems) {
          final raw = item.toMap();
          final filtered = _filterMapForColumns(raw, cols);
          batch.insert(
            'products',
            filtered,
            conflictAlgorithm: ConflictAlgorithm.replace,
          );
        }
        await batch.commit(noResult: true);
        // --- FIX END ---
      }
      await _workoutDb.importWorkoutData(
        routines: backup.routines,
        workoutLogs: backup.workoutLogs,
      );

      print("Import erfolgreich abgeschlossen.");
      return true;
    } catch (e) {
      print("Fehler beim Importieren der Daten: $e");
      return false;
    }
  }
  // ... (Rest der Datei, inklusive der neuen Helper am Ende)

  Future<Set<String>> _getTableColumns(Database db, String table) async {
    final rows = await db.rawQuery('PRAGMA table_info($table)');
    return rows.map((r) => (r['name'] as String)).toSet();
  }

  Map<String, Object?> _filterMapForColumns(
    Map<String, Object?> src,
    Set<String> allowedCols,
  ) {
    final out = <String, Object?>{};
    src.forEach((k, v) {
      if (allowedCols.contains(k)) out[k] = v;
    });
    return out;
  }
  // --- NEUE METHODEN FÜR CSV-EXPORT ---

  /// Exportiert das gesamte Ernährungstagebuch als CSV-Datei.
  Future<bool> exportNutritionAsCsv() async {
    try {
      final entries = await _userDb.getAllFoodEntries();
      if (entries.isEmpty) return false; // Nichts zu exportieren

      // Performance-Optimierung: Alle benötigten Produkte auf einmal laden
      final uniqueBarcodes = entries.map((e) => e.barcode).toSet().toList();
      final products = await _productDb.getProductsByBarcodes(uniqueBarcodes);
      final productMap = {for (var p in products) p.barcode: p};

      List<List<dynamic>> rows = [];
      // Header-Zeile
      rows.add([
        'date',
        'time',
        'meal_type',
        'food_name',
        'brand',
        'quantity_grams',
        'calories_kcal',
        'protein_g',
        'carbs_g',
        'fat_g',
        'barcode',
      ]);

      for (final entry in entries) {
        final product = productMap[entry.barcode];
        if (product == null) continue;

        final factor = entry.quantityInGrams / 100.0;
        rows.add([
          DateFormat('yyyy-MM-dd').format(entry.timestamp),
          DateFormat('HH:mm').format(entry.timestamp),
          entry.mealType,
          product.name,
          product.brand,
          entry.quantityInGrams,
          (product.calories * factor).round(),
          (product.protein * factor).toStringAsFixed(1),
          (product.carbs * factor).toStringAsFixed(1),
          (product.fat * factor).toStringAsFixed(1),
          entry.barcode,
        ]);
      }
      return await _createAndShareCsv(rows, 'lightweight_nutrition_export');
    } catch (e) {
      print("Fehler beim CSV-Export der Ernährung: $e");
      return false;
    }
  }

  /// Exportiert alle Messwerte als CSV-Datei.
  Future<bool> exportMeasurementsAsCsv() async {
    try {
      final sessions = await _userDb.getMeasurementSessions();
      if (sessions.isEmpty) return false;

      List<List<dynamic>> rows = [];
      rows.add(['date', 'time', 'measurement_type', 'value', 'unit']);

      for (final session in sessions) {
        for (final measurement in session.measurements) {
          rows.add([
            DateFormat('yyyy-MM-dd').format(session.timestamp),
            DateFormat('HH:mm').format(session.timestamp),
            measurement.type,
            measurement.value,
            measurement.unit,
          ]);
        }
      }
      return await _createAndShareCsv(rows, 'lightweight_measurements_export');
    } catch (e) {
      print("Fehler beim CSV-Export der Messwerte: $e");
      return false;
    }
  }

  /// Exportiert den gesamten Trainingsverlauf als CSV-Datei.
  Future<bool> exportWorkoutsAsCsv() async {
    try {
      final logs = await _workoutDb.getFullWorkoutLogs();
      if (logs.isEmpty) return false;

      List<List<dynamic>> rows = [];
      rows.add([
        'workout_start_time',
        'workout_end_time',
        'routine_name',
        'exercise_name',
        'set_order',
        'set_type',
        'weight_kg',
        'reps',
        'rest_seconds',
        'notes',
      ]);

      for (final log in logs) {
        int setOrder = 1;
        for (final set in log.sets) {
          rows.add([
            log.startTime.toIso8601String(),
            log.endTime?.toIso8601String() ?? '',
            log.routineName ?? 'Freies Training',
            set.exerciseName,
            setOrder++,
            set.setType,
            set.weightKg ?? 0,
            set.reps ?? 0,
            set.restTimeSeconds ?? 0,
            log.notes ?? '',
          ]);
        }
      }
      return await _createAndShareCsv(rows, 'lightweight_workouts_export');
    } catch (e) {
      print("Fehler beim CSV-Export der Workouts: $e");
      return false;
    }
  }

  /// Private Helfer-Methode zum Erstellen, Speichern und Teilen einer CSV-Datei.
  Future<bool> _createAndShareCsv(
    List<List<dynamic>> rows,
    String baseFileName,
  ) async {
    final String csvData = const ListToCsvConverter().convert(rows);
    final tempDir = await getTemporaryDirectory();
    final timestamp = DateFormat('yyyy-MM-dd').format(DateTime.now());
    final tempFile = File('${tempDir.path}/$baseFileName-$timestamp.csv');
    await tempFile.writeAsString(csvData);

    final result = await Share.shareXFiles([
      XFile(tempFile.path, mimeType: 'text/csv'),
    ], subject: baseFileName);

    await tempFile.delete();
    return result.status == ShareResultStatus.success;
  }

  Future<bool> exportFullBackupEncrypted(String passphrase) async {
    try {
      // Daten sammeln (wie in exportFullBackup)
      final foodEntries = await _userDb.getAllFoodEntries();
      final fluidEntries = await _userDb.getAllFluidEntries();
      final favoriteBarcodes = await _userDb.getFavoriteBarcodes();
      final measurementSessions = await _userDb.getMeasurementSessions();
      final productDb = await _productDb.offDatabase;
      final customFoodMaps = await productDb?.query(
            'products',
            where: 'barcode LIKE ?',
            whereArgs: ['user_created_%'],
          ) ??
          [];
      final customFoodItems = customFoodMaps
          .map((m) => FoodItem.fromMap(m, source: FoodItemSource.user))
          .toList();
      final routines = await _workoutDb.getAllRoutinesWithDetails();
      final workoutLogs = await _workoutDb.getFullWorkoutLogs();
      final prefs = await SharedPreferences.getInstance();
      final userPrefs = <String, dynamic>{};
      for (final k in prefs.getKeys()) {
        userPrefs[k] = prefs.get(k);
      }
      final supplements = await _userDb.getAllSupplements();
      final supplementLogs = await _userDb.getAllSupplementLogs();
      final customExercises = await _workoutDb.getCustomExercises();
      final backup = LightweightBackup(
        schemaVersion: currentSchemaVersion,
        foodEntries: foodEntries,
        fluidEntries: fluidEntries,
        favoriteBarcodes: favoriteBarcodes,
        customFoodItems: customFoodItems,
        measurementSessions: measurementSessions,
        routines: routines,
        workoutLogs: workoutLogs,
        userPreferences: userPrefs,
        supplements: supplements,
        supplementLogs: supplementLogs,
        customExercises: customExercises,
      );
      final jsonString = jsonEncode(backup.toJson());

      // Verschlüsseln
      final wrapper = await EncryptionUtil.encryptString(
        jsonString,
        passphrase,
      );
      final wrappedJson = jsonEncode(wrapper);

      final tempDir = await getTemporaryDirectory();
      final ts = DateFormat('yyyy-MM-dd_HH-mm').format(DateTime.now());
      final tempFile = File(
        p.join(
          tempDir.path,
          'lightweight_backup_enc_v$currentSchemaVersion-[$ts].json',
        ),
      );
      await tempFile.writeAsString(wrappedJson);
      final result = await Share.shareXFiles([
        XFile(tempFile.path, mimeType: 'application/json'),
      ], subject: 'Lightweight Encrypted Backup - $ts');
      await tempFile.delete();
      return result.status == ShareResultStatus.success;
    } catch (e) {
      print('Fehler beim verschlüsselten Export: $e');
      return false;
    }
  }

  Future<bool> importFullBackupAuto(
    String filePath, {
    String? passphrase,
  }) async {
    try {
      final file = File(filePath);
      final raw = await file.readAsString();
      final top = jsonDecode(raw);

      Map<String, dynamic> payload;
      if (top is Map && top['enc'] == EncryptionUtil.wrapperVersion) {
        // Leeres Passwort zulassen (Legacy-Cases) – EncryptionUtil sollte "" akzeptieren
        final effectivePw = (passphrase ?? "");
        try {
          final clear = await EncryptionUtil.decryptToString(
            Map<String, dynamic>.from(top),
            effectivePw,
          );
          payload = jsonDecode(clear) as Map<String, dynamic>;
        } catch (e) {
          // Falsches/fehlendes Passwort → sauber false zurückgeben,
          // damit der UI-Flow den Dialog zeigen/erneut versuchen kann.
          print('Decrypt failed: $e');
          return false;
        }
      } else {
        // Unverschlüsselt (plain JSON)
        payload = (top as Map).cast<String, dynamic>();
      }

      final backup = LightweightBackup.fromJson(payload);
      if (backup.schemaVersion > currentSchemaVersion) {
        print(
          'Backup-Version (${backup.schemaVersion}) ist neuer als App-Version ($currentSchemaVersion).',
        );
        return false;
      }

      final prefs = await SharedPreferences.getInstance();
      await prefs.clear();
      await _userDb.clearAllUserData();
      await _workoutDb.clearAllWorkoutData();

      final productDb = await _productDb.offDatabase;
      await productDb?.delete(
        'products',
        where: 'barcode LIKE ?',
        whereArgs: ['user_created_%'],
      );

      await _workoutDb.importCustomExercises(backup.customExercises);

      for (final e in backup.userPreferences.entries) {
        final k = e.key;
        final v = e.value;
        if (v is bool) {
          await prefs.setBool(k, v);
        } else if (v is int)
          await prefs.setInt(k, v);
        else if (v is double)
          await prefs.setDouble(k, v);
        else if (v is String)
          await prefs.setString(k, v);
        else if (v is List<String>) await prefs.setStringList(k, v);
      }

      await _userDb.importUserData(
        foodEntries: backup.foodEntries,
        fluidEntries: backup.fluidEntries,
        favoriteBarcodes: backup.favoriteBarcodes,
        measurementSessions: backup.measurementSessions,
        supplements: backup.supplements, // NEU
        supplementLogs: backup.supplementLogs, // NEU
      );

      if (productDb != null) {
        final cols = await _getTableColumns(productDb, 'products'); // <-- neu
        final batch = productDb.batch();
        for (final item in backup.customFoodItems) {
          final raw = item.toMap();
          final filtered = _filterMapForColumns(raw, cols); // <-- neu
          batch.insert(
            'products',
            filtered,
            conflictAlgorithm: ConflictAlgorithm.replace,
          );
        }
        await batch.commit(noResult: true);
      }

      await _workoutDb.importWorkoutData(
        routines: backup.routines,
        workoutLogs: backup.workoutLogs,
      );

      print('Import erfolgreich (auto).');
      return true;
    } catch (e) {
      print('Fehler beim Auto-Import: $e');
      return false;
    }
  }

  // lib/data/backup_manager.dart

  Future<bool> runAutoBackupIfDue({
    Duration interval = const Duration(days: 1),
    bool encrypted = false,
    String? passphrase,
    int retention = 7,
    String? dirPath,
    bool force = false, // NEU
  }) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final lastMs = prefs.getInt('auto_backup_last_ms') ?? 0;
      final nowMs = DateTime.now().millisecondsSinceEpoch;
      if (!force && (nowMs - lastMs < interval.inMilliseconds)) {
        print('Auto-Backup: nicht fällig (force=false)'); // Hinweis
        return false;
      }

      // 1) Daten sammeln (wie schon implementiert)
      final foodEntries = await _userDb.getAllFoodEntries();
      final fluidEntries = await _userDb.getAllFluidEntries();
      final favoriteBarcodes = await _userDb.getFavoriteBarcodes();
      final measurementSessions = await _userDb.getMeasurementSessions();
      final productDb = await _productDb.offDatabase;
      final customFoodMaps = await productDb?.query(
            'products',
            where: 'barcode LIKE ?',
            whereArgs: ['user_created_%'],
          ) ??
          [];
      final customFoodItems = customFoodMaps
          .map((m) => FoodItem.fromMap(m, source: FoodItemSource.user))
          .toList();
      final routines = await _workoutDb.getAllRoutinesWithDetails();
      final workoutLogs = await _workoutDb.getFullWorkoutLogs();
      final userPrefs = <String, dynamic>{};
      for (final k in prefs.getKeys()) {
        userPrefs[k] = prefs.get(k);
      }
      final supplements = await _userDb.getAllSupplements();
      final supplementLogs = await _userDb.getAllSupplementLogs();
      final customExercises = await _workoutDb.getCustomExercises();
      final backup = LightweightBackup(
          schemaVersion: currentSchemaVersion,
          foodEntries: foodEntries,
          fluidEntries: fluidEntries,
          favoriteBarcodes: favoriteBarcodes,
          customFoodItems: customFoodItems,
          measurementSessions: measurementSessions,
          routines: routines,
          workoutLogs: workoutLogs,
          userPreferences: userPrefs,
          supplements: supplements,
          supplementLogs: supplementLogs,
          customExercises: customExercises);
      final jsonString = jsonEncode(backup.toJson());

      // 2) Zielordner auflösen
      final docs = await getApplicationDocumentsDirectory();
      final saved = prefs.getString('auto_backup_dir');
      Directory baseDir = (dirPath != null && dirPath.trim().isNotEmpty)
          ? Directory(dirPath)
          : ((saved != null && saved.trim().isNotEmpty)
              ? Directory(saved)
              : Directory(p.join(docs.path, 'Backups')));
      await baseDir.create(recursive: true);
      final ts = DateFormat('yyyy-MM-dd_HH-mm').format(DateTime.now());

      // 3) Klar/verschlüsselt vorbereiten
      late final String content;
      late final String name;
      if (encrypted) {
        if (passphrase == null || passphrase.isEmpty) {
          print('Auto-Backup ENC: Passwort fehlt');
          return false;
        }
        final wrapper = await EncryptionUtil.encryptString(
          jsonString,
          passphrase,
        );
        content = jsonEncode(wrapper);
        name = 'lightweight_auto_enc_v$currentSchemaVersion-[$ts].json';
      } else {
        content = jsonString;
        name = 'lightweight_auto_v$currentSchemaVersion-[$ts].json';
      }

      // 4) Schreiben mit Fallback bei Fehler
      File outFile = File(p.join(baseDir.path, name));
      try {
        await outFile.writeAsString(content);
      } on FileSystemException catch (e) {
        print(
          'Auto-Backup: Schreiben in $baseDir fehlgeschlagen, Fallback → App-Ordner ($e)',
        );
        baseDir = Directory(p.join(docs.path, 'Backups'));
        await baseDir.create(recursive: true);
        outFile = File(p.join(baseDir.path, name));
        await outFile.writeAsString(content);
      }

      print('Auto-Backup geschrieben: ${outFile.path}');

      // 5) Retention
      final files = baseDir
          .listSync()
          .whereType<File>()
          .where((f) => p.basename(f.path).startsWith('lightweight_auto'))
          .toList()
        ..sort(
          (a, b) => b.lastModifiedSync().compareTo(a.lastModifiedSync()),
        );
      for (var i = retention; i < files.length; i++) {
        try {
          files[i].deleteSync();
        } catch (_) {}
      }

      await prefs.setInt('auto_backup_last_ms', nowMs);
      return true;
    } catch (e) {
      print('Auto-Backup fehlgeschlagen: $e');
      return false;
    }
  }
}

class ProbeResult {
  final bool encrypted;
  final bool gzipped;
  ProbeResult({required this.encrypted, required this.gzipped});
}

ProbeResult _probeBackup(Uint8List bytes) {
  // 1) Quick JSON sniff
  if (bytes.isNotEmpty &&
      (bytes.first == 0x7B /* '{' */ || bytes.first == 0x5B /* '[' */)) {
    // Looks like plain JSON (very common for unencrypted exports)
    return ProbeResult(encrypted: false, gzipped: false);
  }

  // 2) GZIP magic: 1F 8B
  if (bytes.length >= 2 && bytes[0] == 0x1F && bytes[1] == 0x8B) {
    // Might be gzipped JSON (unencrypted) or gzipped+encrypted (rare)
    // We'll try inflate first; if it fails later we can still treat as encrypted
    return ProbeResult(encrypted: false, gzipped: true);
  }

  // 3) Optional custom magic headers you may have used
  // e.g., "VITA1" or "ENC1"... adapt if your exporter wrote a header.
  const encHeader = [0x45, 0x4E, 0x43, 0x31]; // "ENC1"
  if (bytes.length >= 4 &&
      bytes[0] == encHeader[0] &&
      bytes[1] == encHeader[1] &&
      bytes[2] == encHeader[2] &&
      bytes[3] == encHeader[3]) {
    return ProbeResult(encrypted: true, gzipped: false);
  }

  // 4) Default: treat as encrypted blob (e.g., {salt|iv|ciphertext} container)
  return ProbeResult(encrypted: true, gzipped: false);
}

class BackupPasswordError implements Exception {}

Future<void> importBackupBytes(Uint8List bytes, {String? password}) async {
  final probe = _probeBackup(bytes);

  Uint8List plainBytes;

  if (!probe.encrypted) {
    // Try direct JSON first
    try {
      final sourceBytes = probe.gzipped
          ? Uint8List.fromList(const GZipDecoder().decodeBytes(bytes))
          : bytes;
      // Basic JSON sanity check
      jsonDecode(utf8.decode(sourceBytes));
      plainBytes = sourceBytes;
    } catch (_) {
      // If JSON/gzip decode failed, fall back to encrypted flow
      plainBytes = await _tryDecryptWithCandidates(
        bytes,
        passwordCandidates: [password, "", null],
      );
    }
  } else {
    // Encrypted flow straight away
    plainBytes = await _tryDecryptWithCandidates(
      bytes,
      passwordCandidates: [password, "", null],
    );
  }

  final jsonStr = utf8.decode(plainBytes);
  final Map<String, dynamic> payload =
      jsonDecode(jsonStr) as Map<String, dynamic>;

  // ✅ Apply payload to DB (your current restore routine)
  await _applyBackupPayload(payload);
}

/// Tries multiple password candidates in order.
/// If all fail, throws BackupPasswordError.
Future<Uint8List> _tryDecryptWithCandidates(
  Uint8List encrypted, {
  required List<String?> passwordCandidates,
}) async {
  for (final cand in passwordCandidates) {
    try {
      final plain = await _decryptPayload(encrypted, cand);
      // Quick sanity check to ensure we actually decrypted JSON
      final s = utf8.decode(plain);
      jsonDecode(s);
      return plain;
    } catch (_) {
      // continue
    }
  }
  throw BackupPasswordError();
}

/// Replace with your real decryption (AES-GCM, etc.)
/// Contract: when `password` is `null` or `""`, handle legacy “no password” backups
Future<Uint8List> _decryptPayload(Uint8List encrypted, String? password) async {
  // Example structure assumption (adjust to your format):
  // [salt(16) | iv(12) | ciphertext(...) | tag(16)]
  // Or if you stored a JSON envelope with base64 fields, parse that here.

  // PSEUDO:
  // final salt = encrypted.sublist(0, 16);
  // final iv = encrypted.sublist(16, 28);
  // final ct = encrypted.sublist(28);
  // final key = await _deriveKey(password ?? "", salt); // treat null == empty string
  // final plain = aesGcmDecrypt(key, iv, ct);
  // return plain;

  // For now we throw to force you to wire this to your actual crypto util:
  throw UnimplementedError(
    "Wire _decryptPayload to your existing AES-GCM routine",
  );
}

/// Your existing apply logic (truncate & insert or merge)
Future<void> _applyBackupPayload(Map<String, dynamic> payload) async {
  // e.g. payload['food_entries'], payload['water_entries'], etc.
  // Make sure to wrap in a transaction & validate shapes.
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/data/product_database_helper.dart =====

// lib/data/product_database_helper.dart
/*
import 'dart:async';
import 'dart:io';
import 'package:flutter/services.dart';
import 'package:path/path.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:sqflite/sqflite.dart';
import '../models/food_item.dart';
import './database_helper.dart';

class ProductDatabaseHelper {
  static final ProductDatabaseHelper instance = ProductDatabaseHelper._init();
  ProductDatabaseHelper._init();

  static Database? _offDatabase;
  static Database? _baseDatabase;

  // Ein einfacher Sperrmechanismus, um doppelte Initialisierung zu verhindern.
  static bool _isInitializing = false;
  // --- NEU: kleine Helpers ganz oben in der Klasse ---
  bool _isOpen(Database? db) => db != null && db.isOpen;

  Future<void> _ensureDatabasesAlive() async {
    if (_offDatabase != null && !_offDatabase!.isOpen) {
      _offDatabase = await _initDB('vita_prep_de.db');
    }
    if (_baseDatabase != null && !_baseDatabase!.isOpen) {
      _baseDatabase = await _initDB('vita_base_foods.db');
    }
  }

  Future<void> reloadBaseDb() async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, 'vita_base_foods.db');
    try {
      await _baseDatabase?.close();
    } catch (_) {}
    _baseDatabase = await openDatabase(path);
  }

  // Stellt sicher, dass die Datenbanken geladen sind, bevor eine Abfrage erfolgt.
  Future<void> _ensureDatabasesInitialized() async {
    // Wenn die DBs schon da sind, ist alles gut.
    if (_offDatabase != null) {
      return;
    }

    // Wenn die Initialisierung bereits läuft, warte kurz.
    // Dies ist eine einfache Absicherung, keine komplexe Sperre.
    if (_isInitializing) {
      await Future.delayed(const Duration(milliseconds: 50));
      return _ensureDatabasesInitialized();
    }

    _isInitializing = true;

    // EINFACHE, SEQUENZIELLE INITIALISIERUNG - KEIN Future.wait
    try {
      _offDatabase = await _initDB('vita_prep_de.db');
    } catch (e) {
      print(
        "KRITISCHER FEHLER: Die Haupt-Produktdatenbank konnte nicht geladen werden: $e",
      );
    }

    try {
      _baseDatabase = await _initDB('vita_base_foods.db');
    } catch (e) {
      print(
        "INFO: Die optionale Grundnahrungsmittel-DB wurde nicht gefunden. Das ist normal, wenn sie noch nicht hinzugefügt wurde. Fehler: $e",
      );
    }

    _isInitializing = false;
  }

  Future<Database> _initDB(String fileName) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, fileName);

    // --- KORREKTUR START: Versionierungslogik für Asset-DBs ---
    // Definiere hier die aktuellen Versionen deiner Asset-Datenbanken.
    // **WICHTIG: Erhöhe die Version hier, wenn du die entsprechende Datei in /assets/db änderst!**
    const assetVersions = {
      'vita_base_foods.db': 1, // Start mit Version 1
      'vita_prep_de.db': 1, // Start mit Version 1
    };
    const assetVersionKeys = {
      'vita_base_foods.db': 'base_foods_db_asset_version',
      'vita_prep_de.db': 'off_db_asset_version',
    };

    final currentAssetVersion = assetVersions[fileName];
    final assetVersionKey = assetVersionKeys[fileName];
    final exists = await databaseExists(path);

    if (currentAssetVersion != null && assetVersionKey != null) {
      final prefs = await SharedPreferences.getInstance();
      final lastCopiedVersion = prefs.getInt(assetVersionKey) ?? 0;

      if (!exists || lastCopiedVersion < currentAssetVersion) {
        print(
          "Datenbank '$fileName' ist veraltet (Lokal: v$lastCopiedVersion, Asset: v$currentAssetVersion) oder nicht vorhanden. Kopiere neu...",
        );
        try {
          if (exists) {
            await deleteDatabase(path);
          }
          await Directory(dirname(path)).create(recursive: true);
          ByteData data = await rootBundle.load(join('assets/db', fileName));
          List<int> bytes =
              data.buffer.asUint8List(data.offsetInBytes, data.lengthInBytes);
          await File(path).writeAsBytes(bytes, flush: true);

          await prefs.setInt(assetVersionKey, currentAssetVersion);
          print(
              "Datenbank '$fileName' erfolgreich auf v$currentAssetVersion kopiert.");
        } catch (e) {
          print("Fehler beim Kopieren der Datenbank '$fileName': $e");
          if (await File(path).exists()) await File(path).delete();
          throw Exception(
              "Konnte Datenbank '$fileName' nicht aus den Assets laden.");
        }
      } else {
        print(
            "Bestehende und aktuelle Datenbank '$fileName' (v$lastCopiedVersion) gefunden.");
      }
    } else {
      // Fallback für nicht-versionierte DBs (altes Verhalten)
      if (!exists) {
        try {
          await Directory(dirname(path)).create(recursive: true);
          ByteData data = await rootBundle.load(join('assets/db', fileName));
          List<int> bytes =
              data.buffer.asUint8List(data.offsetInBytes, data.lengthInBytes);
          await File(path).writeAsBytes(bytes, flush: true);
        } catch (e) {
          throw Exception(
              "Konnte Datenbank '$fileName' nicht aus den Assets laden.");
        }
      }
    }
    // --- KORREKTUR ENDE ---

    return await openDatabase(path);
  }

  // ÖFFENTLICHER GETTER FÜR DEN BACKUP-MANAGER
  Future<Database?> get offDatabase async {
    await _ensureDatabasesInitialized();
    return _offDatabase;
  }

  Future<List<FoodItem>> searchProducts(String query) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    final List<FoodItem> combinedResults = [];

    if (_baseDatabase != null) {
      final List<Map<String, dynamic>> baseMaps = await _baseDatabase!.query(
        'products',
        where: 'name LIKE ? OR name_de LIKE ? OR name_en LIKE ?',
        whereArgs: ['%$query%', '%$query%', '%$query%'],
        limit: 25,
      );
      combinedResults.addAll(
        baseMaps.map(
          (map) => FoodItem.fromMap(map, source: FoodItemSource.base),
        ),
      );
    }

    // Die Haupt-DB muss existieren, sonst stürzt die App hier ab, was korrekt ist.
    if (_offDatabase != null) {
      final List<Map<String, dynamic>> offMaps = await _offDatabase!.query(
        'products',
        where: 'name LIKE ? OR brand LIKE ?',
        whereArgs: ['%$query%', '%$query%'],
        limit: 50,
      );
      combinedResults.addAll(
        offMaps.map((map) => FoodItem.fromMap(map, source: FoodItemSource.off)),
      );
    }

    final uniqueResults = <String, FoodItem>{};
    for (var item in combinedResults) {
      uniqueResults.putIfAbsent(item.barcode, () => item);
    }
    return uniqueResults.values.toList();
  }

  Future<FoodItem?> getProductByBarcode(String barcode) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();

    // Lokaler Helper mit anderem Namen als das Keyword "try"
    Future<FoodItem?> attempt() async {
      if (_baseDatabase != null) {
        final baseMaps = await _baseDatabase!.query(
          'products',
          where: 'barcode = ?',
          whereArgs: [barcode],
          limit: 1,
        );
        if (baseMaps.isNotEmpty) {
          return FoodItem.fromMap(baseMaps.first, source: FoodItemSource.base);
        }
      }

      if (_offDatabase != null) {
        final offMaps = await _offDatabase!.query(
          'products',
          where: 'barcode = ?',
          whereArgs: [barcode],
          limit: 1,
        );
        if (offMaps.isNotEmpty) {
          return FoodItem.fromMap(offMaps.first, source: FoodItemSource.off);
        }
      }

      return null;
    }

    try {
      return await attempt();
    } on DatabaseException catch (e) {
      // Falls eine der DBs zwischenzeitlich geschlossen wurde → wiederbeleben & einmalig erneut versuchen
      final msg = e.toString().toLowerCase();
      if (msg.contains('database_closed') ||
          msg.contains('attempt to reopen')) {
        await _ensureDatabasesAlive();
        return await attempt();
      }
      rethrow;
    }
  }

  Future<void> insertProduct(FoodItem item) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    if (_offDatabase == null) return;
    await _offDatabase!.insert(
      'products',
      item.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  Future<List<FoodItem>> _getProductsByBarcodes(List<String> barcodes) async {
    if (barcodes.isEmpty) return [];
    final results = <FoodItem>[];
    for (final barcode in barcodes) {
      final product = await getProductByBarcode(barcode);
      if (product != null) results.add(product);
    }
    return results;
  }

  Future<List<FoodItem>> getFavoriteProducts() async {
    final favoriteBarcodes =
        await DatabaseHelper.instance.getFavoriteBarcodes();
    return await _getProductsByBarcodes(favoriteBarcodes);
  }

  Future<List<FoodItem>> getRecentProducts() async {
    final recentBarcodes =
        await DatabaseHelper.instance.getRecentlyUsedBarcodes();
    return await _getProductsByBarcodes(recentBarcodes);
  }

  Future<List<FoodItem>> getProductsByBarcodes(List<String> barcodes) async {
    if (barcodes.isEmpty) return [];
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();

    final db = _offDatabase;
    if (db == null) return [];

    // Erstellt eine Kette von '?' für die IN-Klausel
    final placeholders = List.filled(barcodes.length, '?').join(',');
    final maps = await db.query(
      'products',
      where: 'barcode IN ($placeholders)',
      whereArgs: barcodes,
    );
    return maps
        .map((map) => FoodItem.fromMap(map, source: FoodItemSource.off))
        .toList();
  }

  Future<void> updateProduct(FoodItem item) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    if (_offDatabase == null) return;
    await _offDatabase!.update(
      'products',
      item.toMap(),
      where: 'barcode = ?',
      whereArgs: [item.barcode],
    );
  }

  // === NEU: Grundnahrungsmittel lesen (optional mit Kategorie) ===
  Future<List<FoodItem>> getBaseFoods({
    String? categoryKey,
    int limit = 200,
    int offset = 0,
    String? search,
  }) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    if (_baseDatabase == null) return [];

    final whereParts = <String>[];
    final whereArgs = <Object?>[];

    if (categoryKey != null && categoryKey.isNotEmpty) {
      whereParts.add('category_key = ?');
      whereArgs.add(categoryKey);
    }

    if (search != null && search.trim().isNotEmpty) {
      // Suche über name/name_de/name_en
      whereParts.add('(name LIKE ? OR name_de LIKE ? OR name_en LIKE ?)');
      final q = '%${search.trim()}%';
      whereArgs.addAll([q, q, q]);
    }

    final rows = await _baseDatabase!.query(
      'products',
      where: whereParts.isEmpty ? null : whereParts.join(' AND '),
      whereArgs: whereArgs.isEmpty ? null : whereArgs,
      orderBy: 'name COLLATE NOCASE',
      limit: limit,
      offset: offset,
    );

    return rows
        .map((m) => FoodItem.fromMap(m, source: FoodItemSource.base))
        .toList();
  }

  // === NEU: Kategorien (für späteren Filter / Anzeige) ===
  Future<List<Map<String, dynamic>>> getBaseCategories() async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    if (_baseDatabase == null) return [];
    return _baseDatabase!.query(
      'categories',
      columns: ['key', 'name_de', 'name_en', 'emoji'],
      orderBy: 'name_de COLLATE NOCASE',
    );
  }

  // === DEV: Felder eines Basis-Eintrags aktualisieren (barcode bleibt) ===
  Future<void> updateBaseProductFields({
    required String barcode,
    required Map<String, Object?> fields, // nur Spalten, die du ändern willst
  }) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    if (_baseDatabase == null) {
      throw Exception('Basis-DB nicht geladen');
    }
    if (fields.isEmpty) return;

    // Safety: Barcode niemals überschreiben
    final safe = Map<String, Object?>.from(fields)..remove('barcode');

    await _baseDatabase!.update(
      'products',
      safe,
      where: 'barcode = ?',
      whereArgs: [barcode],
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  // === DEV: Pfad der Basis-DB ermitteln (für Export/Share) ===
  Future<String> getBaseDbPath() async {
    final dbPath = await getDatabasesPath();
    return join(dbPath, 'vita_base_foods.db');
  }
}
*/
// lib/data/product_database_helper.dart

import 'dart:async';
import 'dart:io';
import 'package:flutter/services.dart';
import 'package:path/path.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:sqflite/sqflite.dart';
import '../models/food_item.dart';
import './database_helper.dart';

class ProductDatabaseHelper {
  static final ProductDatabaseHelper instance = ProductDatabaseHelper._init();
  ProductDatabaseHelper._init();

  static Database? _offDatabase;
  static Database? _baseDatabase;

  // Ein einfacher Sperrmechanismus, um doppelte Initialisierung zu verhindern.
  static bool _isInitializing = false;
  // --- NEU: kleine Helpers ganz oben in der Klasse ---
  bool _isOpen(Database? db) => db != null && db.isOpen;

  Future<void> _ensureDatabasesAlive() async {
    if (_offDatabase != null && !_offDatabase!.isOpen) {
      _offDatabase = await _initDB('vita_prep_de.db');
    }
    if (_baseDatabase != null && !_baseDatabase!.isOpen) {
      _baseDatabase = await _initDB('vita_base_foods.db');
    }
  }

  Future<void> reloadBaseDb() async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, 'vita_base_foods.db');
    try {
      await _baseDatabase?.close();
    } catch (_) {}
    _baseDatabase = await openDatabase(path);
  }

  // Stellt sicher, dass die Datenbanken geladen sind, bevor eine Abfrage erfolgt.
  Future<void> _ensureDatabasesInitialized() async {
    // Wenn die DBs schon da sind, ist alles gut.
    if (_offDatabase != null) {
      return;
    }

    // Wenn die Initialisierung bereits läuft, warte kurz.
    // Dies ist eine einfache Absicherung, keine komplexe Sperre.
    if (_isInitializing) {
      await Future.delayed(const Duration(milliseconds: 50));
      return _ensureDatabasesInitialized();
    }

    _isInitializing = true;

    // EINFACHE, SEQUENZIELLE INITIALISIERUNG - KEIN Future.wait
    try {
      _offDatabase = await _initDB('vita_prep_de.db');
    } catch (e) {
      print(
        "KRITISCHER FEHLER: Die Haupt-Produktdatenbank konnte nicht geladen werden: $e",
      );
    }

    try {
      _baseDatabase = await _initDB('vita_base_foods.db');
    } catch (e) {
      print(
        "INFO: Die optionale Grundnahrungsmittel-DB wurde nicht gefunden. Das ist normal, wenn sie noch nicht hinzugefügt wurde. Fehler: $e",
      );
    }

    _isInitializing = false;
  }

  Future<Database> _initDB(String fileName) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, fileName);

    // --- KORREKTUR START: Versionierungslogik für Asset-DBs ---
    // Definiere hier die aktuellen Versionen deiner Asset-Datenbanken.
    // **WICHTIG: Erhöhe die Version hier, wenn du die entsprechende Datei in /assets/db änderst!**
    const assetVersions = {
      'vita_base_foods.db': 1, // Start mit Version 1
      'vita_prep_de.db': 1, // Start mit Version 1
    };
    const assetVersionKeys = {
      'vita_base_foods.db': 'base_foods_db_asset_version',
      'vita_prep_de.db': 'off_db_asset_version',
    };

    final currentAssetVersion = assetVersions[fileName];
    final assetVersionKey = assetVersionKeys[fileName];
    final exists = await databaseExists(path);

    if (currentAssetVersion != null && assetVersionKey != null) {
      final prefs = await SharedPreferences.getInstance();
      final lastCopiedVersion = prefs.getInt(assetVersionKey) ?? 0;

      if (!exists || lastCopiedVersion < currentAssetVersion) {
        print(
          "Datenbank '$fileName' ist veraltet (Lokal: v$lastCopiedVersion, Asset: v$currentAssetVersion) oder nicht vorhanden. Kopiere neu...",
        );
        try {
          if (exists) {
            await deleteDatabase(path);
          }
          await Directory(dirname(path)).create(recursive: true);
          ByteData data = await rootBundle.load(join('assets/db', fileName));
          List<int> bytes =
              data.buffer.asUint8List(data.offsetInBytes, data.lengthInBytes);
          await File(path).writeAsBytes(bytes, flush: true);

          await prefs.setInt(assetVersionKey, currentAssetVersion);
          print(
              "Datenbank '$fileName' erfolgreich auf v$currentAssetVersion kopiert.");
        } catch (e) {
          print("Fehler beim Kopieren der Datenbank '$fileName': $e");
          if (await File(path).exists()) await File(path).delete();
          throw Exception(
              "Konnte Datenbank '$fileName' nicht aus den Assets laden.");
        }
      } else {
        print(
            "Bestehende und aktuelle Datenbank '$fileName' (v$lastCopiedVersion) gefunden.");
      }
    } else {
      // Fallback für nicht-versionierte DBs (altes Verhalten)
      if (!exists) {
        try {
          await Directory(dirname(path)).create(recursive: true);
          ByteData data = await rootBundle.load(join('assets/db', fileName));
          List<int> bytes =
              data.buffer.asUint8List(data.offsetInBytes, data.lengthInBytes);
          await File(path).writeAsBytes(bytes, flush: true);
        } catch (e) {
          throw Exception(
              "Konnte Datenbank '$fileName' nicht aus den Assets laden.");
        }
      }
    }
    // --- KORREKTUR ENDE ---

    return await openDatabase(path);
  }

  // ÖFFENTLICHER GETTER FÜR DEN BACKUP-MANAGER
  Future<Database?> get offDatabase async {
    await _ensureDatabasesInitialized();
    return _offDatabase;
  }

  Future<List<FoodItem>> searchProducts(String query) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    final List<FoodItem> combinedResults = [];

    if (_baseDatabase != null) {
      final List<Map<String, dynamic>> baseMaps = await _baseDatabase!.query(
        'products',
        where: 'name LIKE ? OR name_de LIKE ? OR name_en LIKE ?',
        whereArgs: ['%$query%', '%$query%', '%$query%'],
        limit: 25,
      );
      combinedResults.addAll(
        baseMaps.map(
          (map) => FoodItem.fromMap(map, source: FoodItemSource.base),
        ),
      );
    }

    // Die Haupt-DB muss existieren, sonst stürzt die App hier ab, was korrekt ist.
    if (_offDatabase != null) {
      final List<Map<String, dynamic>> offMaps = await _offDatabase!.query(
        'products',
        where: 'name LIKE ? OR brand LIKE ?',
        whereArgs: ['%$query%', '%$query%'],
        limit: 50,
      );
      combinedResults.addAll(
        offMaps.map((map) => FoodItem.fromMap(map, source: FoodItemSource.off)),
      );
    }

    final uniqueResults = <String, FoodItem>{};
    for (var item in combinedResults) {
      uniqueResults.putIfAbsent(item.barcode, () => item);
    }
    return uniqueResults.values.toList();
  }

  Future<FoodItem?> getProductByBarcode(String barcode) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();

    // Lokaler Helper mit anderem Namen als das Keyword "try"
    Future<FoodItem?> attempt() async {
      if (_baseDatabase != null) {
        final baseMaps = await _baseDatabase!.query(
          'products',
          where: 'barcode = ?',
          whereArgs: [barcode],
          limit: 1,
        );
        if (baseMaps.isNotEmpty) {
          return FoodItem.fromMap(baseMaps.first, source: FoodItemSource.base);
        }
      }

      if (_offDatabase != null) {
        final offMaps = await _offDatabase!.query(
          'products',
          where: 'barcode = ?',
          whereArgs: [barcode],
          limit: 1,
        );
        if (offMaps.isNotEmpty) {
          return FoodItem.fromMap(offMaps.first, source: FoodItemSource.off);
        }
      }

      return null;
    }

    try {
      return await attempt();
    } on DatabaseException catch (e) {
      // Falls eine der DBs zwischenzeitlich geschlossen wurde → wiederbeleben & einmalig erneut versuchen
      final msg = e.toString().toLowerCase();
      if (msg.contains('database_closed') ||
          msg.contains('attempt to reopen')) {
        await _ensureDatabasesAlive();
        return await attempt();
      }
      rethrow;
    }
  }

  Future<void> insertProduct(FoodItem item) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    if (_offDatabase == null) return;
    // --- FIX START ---
    final cols = await _getTableColumns(_offDatabase!, 'products');
    final filteredMap = _filterMapForColumns(item.toMap(), cols);
    await _offDatabase!.insert(
      'products',
      filteredMap,
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
    // --- FIX END ---
  }

  Future<List<FoodItem>> _getProductsByBarcodes(List<String> barcodes) async {
    if (barcodes.isEmpty) return [];
    final results = <FoodItem>[];
    for (final barcode in barcodes) {
      final product = await getProductByBarcode(barcode);
      if (product != null) results.add(product);
    }
    return results;
  }

  Future<List<FoodItem>> getFavoriteProducts() async {
    final favoriteBarcodes =
        await DatabaseHelper.instance.getFavoriteBarcodes();
    return await _getProductsByBarcodes(favoriteBarcodes);
  }

  Future<List<FoodItem>> getRecentProducts() async {
    final recentBarcodes =
        await DatabaseHelper.instance.getRecentlyUsedBarcodes();
    return await _getProductsByBarcodes(recentBarcodes);
  }

  Future<List<FoodItem>> getProductsByBarcodes(List<String> barcodes) async {
    if (barcodes.isEmpty) return [];
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();

    final db = _offDatabase;
    if (db == null) return [];

    // Erstellt eine Kette von '?' für die IN-Klausel
    final placeholders = List.filled(barcodes.length, '?').join(',');
    final maps = await db.query(
      'products',
      where: 'barcode IN ($placeholders)',
      whereArgs: barcodes,
    );
    return maps
        .map((map) => FoodItem.fromMap(map, source: FoodItemSource.off))
        .toList();
  }

  Future<void> updateProduct(FoodItem item) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    if (_offDatabase == null) return;
    // --- FIX START ---
    final cols = await _getTableColumns(_offDatabase!, 'products');
    final filteredMap = _filterMapForColumns(item.toMap(), cols);
    await _offDatabase!.update(
      'products',
      filteredMap,
      where: 'barcode = ?',
      whereArgs: [item.barcode],
    );
    // --- FIX END ---
  }

  // === NEU: Grundnahrungsmittel lesen (optional mit Kategorie) ===
  Future<List<FoodItem>> getBaseFoods({
    String? categoryKey,
    int limit = 200,
    int offset = 0,
    String? search,
  }) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    if (_baseDatabase == null) return [];

    final whereParts = <String>[];
    final whereArgs = <Object?>[];

    if (categoryKey != null && categoryKey.isNotEmpty) {
      whereParts.add('category_key = ?');
      whereArgs.add(categoryKey);
    }

    if (search != null && search.trim().isNotEmpty) {
      // Suche über name/name_de/name_en
      whereParts.add('(name LIKE ? OR name_de LIKE ? OR name_en LIKE ?)');
      final q = '%${search.trim()}%';
      whereArgs.addAll([q, q, q]);
    }

    final rows = await _baseDatabase!.query(
      'products',
      where: whereParts.isEmpty ? null : whereParts.join(' AND '),
      whereArgs: whereArgs.isEmpty ? null : whereArgs,
      orderBy: 'name COLLATE NOCASE',
      limit: limit,
      offset: offset,
    );

    return rows
        .map((m) => FoodItem.fromMap(m, source: FoodItemSource.base))
        .toList();
  }

  // === NEU: Kategorien (für späteren Filter / Anzeige) ===
  Future<List<Map<String, dynamic>>> getBaseCategories() async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    if (_baseDatabase == null) return [];
    return _baseDatabase!.query(
      'categories',
      columns: ['key', 'name_de', 'name_en', 'emoji'],
      orderBy: 'name_de COLLATE NOCASE',
    );
  }

  // === DEV: Felder eines Basis-Eintrags aktualisieren (barcode bleibt) ===
  Future<void> updateBaseProductFields({
    required String barcode,
    required Map<String, Object?> fields, // nur Spalten, die du ändern willst
  }) async {
    await _ensureDatabasesInitialized();
    await _ensureDatabasesAlive();
    if (_baseDatabase == null) {
      throw Exception('Basis-DB nicht geladen');
    }
    if (fields.isEmpty) return;

    // Safety: Barcode niemals überschreiben
    final safe = Map<String, Object?>.from(fields)..remove('barcode');

    await _baseDatabase!.update(
      'products',
      safe,
      where: 'barcode = ?',
      whereArgs: [barcode],
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  // === DEV: Pfad der Basis-DB ermitteln (für Export/Share) ===
  Future<String> getBaseDbPath() async {
    final dbPath = await getDatabasesPath();
    return join(dbPath, 'vita_base_foods.db');
  }

  // --- NEUE HELFER-METHODEN ---
  Future<Set<String>> _getTableColumns(Database db, String table) async {
    final rows = await db.rawQuery('PRAGMA table_info($table)');
    return rows.map((r) => (r['name'] as String)).toSet();
  }

  Map<String, Object?> _filterMapForColumns(
    Map<String, Object?> src,
    Set<String> allowedCols,
  ) {
    final out = <String, Object?>{};
    src.forEach((k, v) {
      if (allowedCols.contains(k)) out[k] = v;
    });
    return out;
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/data/import_manager.dart =====

// lib/data/import_manager.dart (Final, mit Deutsch-Support)

import 'dart:io';
import 'package:csv/csv.dart';
import 'package:file_picker/file_picker.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/models/set_log.dart';

class ImportManager {
  Future<int> importHevyCsv() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['csv'],
      );
      if (result == null || result.files.single.path == null) return 0;
      final filePath = result.files.single.path!;
      final file = File(filePath);
      final content = await file.readAsString();
      final List<List<dynamic>> rows = const CsvToListConverter(
        shouldParseNumbers: false,
        eol: '\n',
      ).convert(content);

      if (rows.length < 2) return 0;

      final workoutGroups = <String, List<Map<String, dynamic>>>{};
      final header = rows.first.map((e) => e.toString().trim()).toList();

      for (var i = 1; i < rows.length; i++) {
        final row = rows[i];
        if (row.length != header.length) continue;
        final rowMap = Map<String, dynamic>.fromIterables(header, row);

        if (rowMap['start_time'] == null ||
            rowMap['start_time'].toString().trim().isEmpty) {
          continue;
        }

        final key = "${rowMap['title']}_${rowMap['start_time']}";
        if (workoutGroups.containsKey(key)) {
          workoutGroups[key]!.add(rowMap);
        } else {
          workoutGroups[key] = [rowMap];
        }
      }

      final db = WorkoutDatabaseHelper.instance;
      int importedWorkouts = 0;
      final knownMap = await db.getExerciseMappings();
      for (var group in workoutGroups.values) {
        final firstRow = group.first;
        final newLog = await db.startWorkout(routineName: firstRow['title']);

        final dbInstance = await db.database;
        await dbInstance.update(
          'workout_logs',
          {
            'start_time': _parseHevyDate(
              firstRow['start_time'],
            ).toIso8601String(),
            'end_time': _parseHevyDate(firstRow['end_time']).toIso8601String(),
            'notes': firstRow['description'],
            'status': 'completed',
          },
          where: 'id = ?',
          whereArgs: [newLog.id],
        );

        int setOrder = 0;
        for (var row in group) {
          final rawName = row['exercise_title']?.toString() ?? '';
          final mappedName = knownMap[rawName.trim().toLowerCase()] ?? rawName;

          final setLog = SetLog(
            workoutLogId: newLog.id!,
            exerciseName: mappedName, // <— statt rawName
            setType: row['set_type'] ?? 'normal',
            weightKg: double.tryParse(row['weight_kg']?.toString() ?? ''),
            reps: int.tryParse(row['reps']?.toString() ?? ''),
            log_order: setOrder++,
            notes: row['exercise_notes'],
            distanceKm: double.tryParse(row['distance_km']?.toString() ?? ''),
            durationSeconds: int.tryParse(
              row['duration_seconds']?.toString() ?? '',
            ),
            rpe: int.tryParse(row['rpe']?.toString() ?? ''),
            supersetId: int.tryParse(row['superset_id']?.toString() ?? ''),
          );
          await db.insertSetLog(setLog);
        }
        importedWorkouts++;
      }
      return importedWorkouts;
    } catch (e) {
      print("Hevy Import Error: $e");
      return -1;
    }
  }

  /// KORREKTUR: Die Parser-Funktion unterstützt jetzt explizit deutsche Monatsnamen.
  DateTime _parseHevyDate(dynamic rawDateString) {
    final dateString = rawDateString?.toString().trim();
    if (dateString == null || dateString.isEmpty) {
      print(
        "Leere oder null Datumszeichenfolge erhalten. Fallback auf DateTime.now()",
      );
      return DateTime.now();
    }

    // Die Liste der Formate wurde um das deutsche Locale erweitert.
    final List<DateFormat> formats = [
      DateFormat(
        "dd MMM yyyy, HH:mm",
        "en_US",
      ), // Probiert zuerst Englisch (Jan, Feb, Apr...)
      DateFormat(
        "dd MMM yyyy, HH:mm",
        "de_DE",
      ), // Dann Deutsch (März, Mai, Juni...)
      DateFormat("yyyy-MM-dd HH:mm:ss"),
      DateFormat("dd.MM.yyyy, HH:mm"),
    ];

    for (final format in formats) {
      try {
        return format.parse(dateString);
      } catch (e) {
        continue;
      }
    }

    print("Konnte Datum nicht mit bekannten Formaten parsen: '$dateString'");
    return DateTime.now();
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/services/ui_state_service.dart =====

// lib/services/ui_state_service.dart

class UiStateService {
  // Statische Instanz, die beim ersten Zugriff erstellt wird (Singleton-Pattern)
  static final UiStateService instance = UiStateService._internal();

  // Privater Konstruktor
  UiStateService._internal();

  // Der Zustand, den wir speichern wollen
  bool isNutritionSummaryExpanded = true; // Standardmäßig AN, wie gewünscht
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/services/profile_service.dart =====

// lib/services/profile_service.dart
import 'dart:io';
import 'package:flutter/material.dart';
// Wichtig für ImageCache
import 'package:image_picker/image_picker.dart';
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';

class ProfileService extends ChangeNotifier {
  static final ProfileService _instance = ProfileService._internal();
  factory ProfileService() => _instance;
  ProfileService._internal();

  String? _profileImagePath;
  String? get profileImagePath => _profileImagePath;

  // CacheBuster hilft dem Widget, aber wir brauchen auch evict() für den ImageProvider
  int cacheBuster = 0;

  bool _isPickerActive = false;
  static const String _profileImageKey = 'profileImagePath';

  Future<void> initialize() async {
    final prefs = await SharedPreferences.getInstance();
    _profileImagePath = prefs.getString(_profileImageKey);

    // Validierung: Existiert die Datei wirklich noch?
    if (_profileImagePath != null) {
      final file = File(_profileImagePath!);
      if (!await file.exists()) {
        _profileImagePath = null;
        await prefs.remove(_profileImageKey);
      }
    }
    notifyListeners();
  }

  Future<void> pickAndSaveProfileImage() async {
    if (_isPickerActive) return;
    _isPickerActive = true;

    try {
      final picker = ImagePicker();
      final pickedFile = await picker.pickImage(source: ImageSource.gallery);

      if (pickedFile != null) {
        final appDir = await getApplicationDocumentsDirectory();
        const fileName = 'profile_image.jpg';
        final localPath = '${appDir.path}/$fileName';
        final targetFile = File(localPath);

        // 1. WICHTIG: Das alte Bild aus dem Flutter-Cache werfen,
        // bevor wir das neue schreiben.
        try {
          await FileImage(targetFile).evict();
        } catch (e) {
          // Ignorieren, falls es nicht im Cache war
        }

        // 2. Datei kopieren/überschreiben
        await File(pickedFile.path).copy(localPath);

        // 3. Pfad speichern
        final prefs = await SharedPreferences.getInstance();
        await prefs.setString(_profileImageKey, localPath);

        _profileImagePath = localPath;
        cacheBuster++; // Zwingt das Widget zum Neu-Zeichnen
        notifyListeners();
      }
    } catch (e) {
      debugPrint('Fehler beim Bild-Upload: $e');
    } finally {
      _isPickerActive = false;
    }
  }

  Future<void> deleteProfileImage() async {
    final prefs = await SharedPreferences.getInstance();
    final currentPath = prefs.getString(_profileImageKey);

    if (currentPath != null) {
      // 1. Aus Cache entfernen (WICHTIG!)
      try {
        await FileImage(File(currentPath)).evict();
      } catch (e) {
        // Egal, wenn es nicht im Cache war
      }

      // 2. UI sofort aktualisieren (Optimistic UI update)
      _profileImagePath = null;
      await prefs.remove(_profileImageKey);
      cacheBuster++;
      notifyListeners();

      // 3. Datei physisch löschen
      try {
        final imageFile = File(currentPath);
        if (await imageFile.exists()) {
          await imageFile.delete();
        }
      } catch (e) {
        debugPrint('Fehler beim Löschen der Datei: $e');
      }
    }
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/services/db_service.dart =====

import 'dart:io';
import 'package:flutter/services.dart' show rootBundle;
import 'package:path/path.dart' as p;
import 'package:sqflite/sqflite.dart';

class DbService {
  static Database? _db;
  static final DbService I = DbService._();
  DbService._();

  Future<Database> get database async {
    if (_db != null) return _db!;
    _db = await _init();
    return _db!;
  }

  Future<Database> _init() async {
    final dbDir = await getDatabasesPath();
    final dbPath = p.join(dbDir, 'vita_training.db');

    // Falls Datei noch nicht existiert: aus Assets kopieren
    if (!await File(dbPath).exists()) {
      final bytes = await rootBundle.load('assets/db/vita_training.db');
      await File(dbPath).writeAsBytes(
        bytes.buffer.asUint8List(bytes.offsetInBytes, bytes.lengthInBytes),
        flush: true,
      );
    }

    // readOnly ist optional – wenn du später migrieren willst, weglassen.
    return openDatabase(dbPath, readOnly: true);
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/services/theme_service.dart =====

import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

class ThemeService extends ChangeNotifier {
  static const _themeKey = 'theme_mode';
  static const _styleKey = 'visual_style'; // NEU
  ThemeMode _themeMode = ThemeMode.system;
  int _visualStyle = 0; // NEU: 0 = Standard, 1 = Liquid

  ThemeMode get themeMode => _themeMode;
  int get visualStyle => _visualStyle; // NEU

  ThemeService() {
    _loadThemeMode();
    _loadVisualStyle(); // NEU
  }
  // Im Konstruktor aufrufen:
  //_loadVisualStyle();

  Future<void> _loadThemeMode() async {
    final prefs = await SharedPreferences.getInstance();
    final themeIndex = prefs.getInt(_themeKey) ?? ThemeMode.system.index;
    _themeMode = ThemeMode.values[themeIndex];
    notifyListeners();
  }

  // --- NEUE METHODE ---
  Future<void> _loadVisualStyle() async {
    final prefs = await SharedPreferences.getInstance();
    _visualStyle = prefs.getInt(_styleKey) ?? 0;
    notifyListeners();
  }

  Future<void> setVisualStyle(int style) async {
    if (style == _visualStyle) return;
    _visualStyle = style;
    notifyListeners();
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt(_styleKey, style);
  }

  Future<void> setThemeMode(ThemeMode mode) async {
    if (mode == _themeMode) return;
    _themeMode = mode;
    notifyListeners();
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt(_themeKey, mode.index);
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/services/workout_session_manager.dart =====

// lib/services/workout_session_manager.dart
// VOLLSTÄNDIGER CODE (FINAL)

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:lightweight/models/exercise.dart';
import 'package:vibration/vibration.dart';
import 'package:lightweight/models/routine_exercise.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/models/workout_log.dart';
import 'package:lightweight/data/workout_database_helper.dart';
import 'package:lightweight/models/set_template.dart';

class WorkoutSessionManager extends ChangeNotifier {
  static final WorkoutSessionManager _instance =
      WorkoutSessionManager._internal();
  factory WorkoutSessionManager() => _instance;
  WorkoutSessionManager._internal();

  WorkoutLog? _workoutLog;
  List<RoutineExercise> _exercises = [];
  final Map<int, SetLog> _setLogs = {};

  final Map<int, int?> pauseTimes = {};

  Timer? _restTimer;
  int _remainingRestSeconds = 0;
  Timer? _restDoneBannerTimer;
  bool _showRestDone = false;

  Timer? _workoutDurationTimer;
  Duration _elapsedDuration = Duration.zero;
  double _totalVolume = 0.0;
  int _totalSets = 0;

  double get totalVolume => _totalVolume;
  int get totalSets => _totalSets;
  WorkoutLog? get workoutLog => _workoutLog;
  List<RoutineExercise> get exercises => _exercises;
  int get remainingRestSeconds => _remainingRestSeconds;
  bool get isActive => _workoutLog != null && _workoutLog!.endTime == null;
  bool get showRestDone => _showRestDone;
  Duration get elapsedDuration => _elapsedDuration;
  Map<int, SetLog> get setLogs => _setLogs;

  // Ersetze diese Methode in lib/services/workout_session_manager.dart

  // Ersetze diese Methode in lib/services/workout_session_manager.dart

  Future<void> restoreWorkoutSession(WorkoutLog logToRestore) async {
    final db = WorkoutDatabaseHelper.instance;
    _workoutLog = logToRestore;
    _exercises = [];
    pauseTimes.clear();
    _setLogs.clear();

    // 1. Hole alle einzigartigen Übungen, sortiert nach ihrem ersten Auftreten (log_order)
    final sortedSets = logToRestore.sets
      ..sort((a, b) => (a.log_order ?? 999).compareTo(b.log_order ?? 999));
    final orderedUniqueExerciseNames =
        sortedSets.map((s) => s.exerciseName).toSet().toList();

    // 2. Baue die _exercises-Liste in der korrekten Reihenfolge auf
    for (final name in orderedUniqueExerciseNames) {
      final exerciseDetail = await db.getExerciseByName(name);
      if (exerciseDetail != null) {
        final setsForThisExercise =
            sortedSets.where((s) => s.exerciseName == name).toList();

        final routineExercise = RoutineExercise(
          id: DateTime.now().millisecondsSinceEpoch + _exercises.length,
          exercise: exerciseDetail,
          setTemplates: setsForThisExercise
              .map((s) => SetTemplate(id: s.id!, setType: s.setType))
              .toList(),
        );
        _exercises.add(routineExercise);

        // Fülle die _setLogs Map und die Pausenzeiten
        for (final setLog in setsForThisExercise) {
          _setLogs[setLog.id!] = setLog;
        }
        if (setsForThisExercise.isNotEmpty) {
          pauseTimes[routineExercise.id!] =
              setsForThisExercise.first.restTimeSeconds;
        }
      }
    }

    _recalculateStats();
    _startWorkoutTimer();
    notifyListeners();
  }

  Future<void> startWorkout(
    WorkoutLog log,
    List<RoutineExercise> routineExercises,
  ) async {
    _workoutLog = log;
    _exercises = routineExercises;
    _setLogs.clear();
    pauseTimes.clear();

    final db = WorkoutDatabaseHelper.instance;

    for (var re in routineExercises) {
      pauseTimes[re.id!] = re.pauseSeconds;
      final exerciseIndex = routineExercises.indexOf(re);

      for (final template in re.setTemplates) {
        final placeholder = SetLog(
          workoutLogId: _workoutLog!.id!,
          exerciseName: re.exercise.nameEn,
          setType: template.setType,
          isCompleted: false,
          log_order: exerciseIndex,
        );
        final newId = await db.insertSetLog(placeholder);
        _setLogs[template.id!] = placeholder.copyWith(id: newId);
      }
    }

    _recalculateStats();
    _startWorkoutTimer();
    notifyListeners();
  }

  // Ersetze diese Methode in lib/services/workout_session_manager.dart

  Future<void> updateSet(
    int templateId, {
    double? weight,
    int? reps,
    String? setType,
    bool? isCompleted,
  }) async {
    if (_workoutLog == null || !_setLogs.containsKey(templateId)) return;

    SetLog currentLog = _setLogs[templateId]!;
    final exerciseIndex = _exercises.indexWhere(
      (e) => e.setTemplates.any((t) => t.id == templateId),
    );

    // Hole die aktuelle Pausenzeit für diese Übung
    int? currentRestTime;
    if (exerciseIndex != -1) {
      currentRestTime = pauseTimes[_exercises[exerciseIndex].id!];
    }

    _setLogs[templateId] = currentLog.copyWith(
      weightKg: weight,
      reps: reps,
      setType: setType,
      isCompleted: isCompleted,
      log_order: exerciseIndex,
      restTimeSeconds:
          currentRestTime, // KORREKTUR: Speichere die Pause immer mit
    );

    final db = WorkoutDatabaseHelper.instance;
    final logToSave = _setLogs[templateId]!;

    if (logToSave.id != null && logToSave.id! > 0) {
      await db.insertSetLog(logToSave);
    } else {
      final newId = await db.insertSetLog(logToSave);
      _setLogs[templateId] = logToSave.copyWith(id: newId);
    }

    if (isCompleted != null) {
      _recalculateStats();
      if (isCompleted) {
        if (exerciseIndex != -1) {
          final re = _exercises[exerciseIndex];
          final restTime = pauseTimes[re.id!];
          if (restTime != null && restTime > 0) {
            _startRestTimer(restTime);
          }
        }
      }
    }
    notifyListeners();
  }

  // Ersetze diese Methode in lib/services/workout_session_manager.dart

  void reorderExercise(int oldIndex, int newIndex) {
    if (newIndex > oldIndex) {
      newIndex -= 1;
    }
    final item = _exercises.removeAt(oldIndex);
    _exercises.insert(newIndex, item);

    // Aktualisiere den log_order für alle Sätze basierend auf der neuen Reihenfolge der Übungen
    for (int i = 0; i < _exercises.length; i++) {
      final re = _exercises[i];
      for (final template in re.setTemplates) {
        if (_setLogs.containsKey(template.id!)) {
          // Hier rufen wir direkt updateSet auf, um die Änderung auch in die DB zu schreiben
          updateSet(
            template.id!,
            isCompleted: _setLogs[template.id!]!.isCompleted,
          );
        }
      }
    }
    notifyListeners();
  }

  void updatePauseTime(int routineExerciseId, int newSeconds) {
    pauseTimes[routineExerciseId] = newSeconds;
    // Finde die zugehörigen Sätze und speichere die neue Pausezeit in der DB
    final exercise = _exercises.firstWhere((e) => e.id == routineExerciseId);
    for (final template in exercise.setTemplates) {
      if (_setLogs.containsKey(template.id!)) {
        updateSet(
          template.id!,
          isCompleted: _setLogs[template.id!]!.isCompleted,
        );
      }
    }
    notifyListeners();
  }

  Future<void> removeExercise(int routineExerciseId) async {
    final exerciseToRemove = _exercises.firstWhere(
      (e) => e.id == routineExerciseId,
    );

    final idsToDelete = <int>[];
    for (final template in exerciseToRemove.setTemplates) {
      final log = _setLogs[template.id!];
      if (log?.id != null) idsToDelete.add(log!.id!);
      _setLogs.remove(template.id!);
    }
    if (idsToDelete.isNotEmpty) {
      await WorkoutDatabaseHelper.instance.deleteSetLogs(idsToDelete);
    }

    _exercises.removeWhere((e) => e.id == routineExerciseId);
    pauseTimes.remove(routineExerciseId);
    _recalculateStats();
    notifyListeners();
  }

  // Ersetze diese Methode in lib/services/workout_session_manager.dart

  Future<RoutineExercise?> addExercise(Exercise exercise) async {
    if (_workoutLog == null) return null;

    final newRoutineExercise = RoutineExercise(
      id: DateTime.now().millisecondsSinceEpoch,
      exercise: exercise,
      setTemplates: [
        SetTemplate(
          id: DateTime.now().millisecondsSinceEpoch + 1,
          setType: 'normal',
        ),
      ],
    );
    _exercises.add(newRoutineExercise);
    pauseTimes[newRoutineExercise.id!] = null;

    final newTemplate = newRoutineExercise.setTemplates.first;
    final db = WorkoutDatabaseHelper.instance;
    final placeholder = SetLog(
      workoutLogId: _workoutLog!.id!,
      exerciseName: exercise.nameEn,
      setType: newTemplate.setType,
      isCompleted: false,
      log_order: _exercises.length - 1,
    );
    final newId = await db.insertSetLog(placeholder);
    _setLogs[newTemplate.id!] = placeholder.copyWith(id: newId);

    notifyListeners();
    return newRoutineExercise;
  }

  Future<SetTemplate?> addSetToExercise(int routineExerciseId) async {
    final exerciseIndex = _exercises.indexWhere(
      (e) => e.id == routineExerciseId,
    );
    if (exerciseIndex == -1) return null;

    final newTemplate = SetTemplate(
      id: DateTime.now().millisecondsSinceEpoch,
      setType: 'normal',
    );
    _exercises[exerciseIndex].setTemplates.add(newTemplate);

    final db = WorkoutDatabaseHelper.instance;
    final placeholder = SetLog(
      workoutLogId: _workoutLog!.id!,
      exerciseName: _exercises[exerciseIndex].exercise.nameEn,
      setType: newTemplate.setType,
      isCompleted: false,
      log_order: exerciseIndex,
    );
    final newId = await db.insertSetLog(placeholder);
    _setLogs[newTemplate.id!] = placeholder.copyWith(id: newId);

    notifyListeners();
    return newTemplate;
  }

  Future<void> removeSet(int templateId) async {
    final existing = _setLogs[templateId];
    if (existing?.id != null) {
      await WorkoutDatabaseHelper.instance.deleteSetLogs([existing!.id!]);
    }
    for (final re in _exercises) {
      re.setTemplates.removeWhere((t) => t.id == templateId);
    }
    _setLogs.remove(templateId);
    _recalculateStats();
    notifyListeners();
  }

  Future<void> finishWorkout() async {
    if (_workoutLog == null) return;
    final db = WorkoutDatabaseHelper.instance;
    final emptySetIds = _setLogs.values
        .where((sl) => sl.isCompleted != true && sl.id != null)
        .map((sl) => sl.id!)
        .toList();

    if (emptySetIds.isNotEmpty) {
      await db.deleteSetLogs(emptySetIds);
    }
    await db.finishWorkout(_workoutLog!.id!);
    _stopWorkoutTimer();
    _restTimer?.cancel();
    _workoutLog = null;
    _exercises = [];
    _setLogs.clear();
    _recalculateStats();
    notifyListeners();
  }

  void _recalculateStats() {
    double newVolume = 0.0;
    int newSets = 0;
    for (final setLog in _setLogs.values) {
      if (setLog.isCompleted == true) {
        newVolume += (setLog.weightKg ?? 0.0) * (setLog.reps ?? 0);
        newSets++;
      }
    }
    _totalVolume = newVolume;
    _totalSets = newSets;
    notifyListeners();
  }

  void cancelRest() {
    _restTimer?.cancel();
    _restDoneBannerTimer?.cancel();
    _remainingRestSeconds = 0;
    _showRestDone = false;
    notifyListeners();
  }

  void _startRestTimer(int seconds) {
    _restTimer?.cancel();
    _restDoneBannerTimer?.cancel();
    _remainingRestSeconds = seconds;
    _showRestDone = false;
    notifyListeners();
    _restTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_remainingRestSeconds > 0) {
        _remainingRestSeconds--;
        notifyListeners();
      } else {
        timer.cancel();
        Vibration.vibrate(duration: 500);
        _showRestDone = true;
        notifyListeners();
        _restDoneBannerTimer = Timer(const Duration(seconds: 10), () {
          _showRestDone = false;
          notifyListeners();
        });
      }
    });
  }

  void skipRestTimer() {
    _restTimer?.cancel();
    _remainingRestSeconds = 0;
    notifyListeners();
  }

  void _startWorkoutTimer() {
    _workoutDurationTimer?.cancel();
    _elapsedDuration = Duration.zero;
    if (_workoutLog != null) {
      _elapsedDuration = DateTime.now().difference(_workoutLog!.startTime);
    }
    _workoutDurationTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_workoutLog != null) {
        _elapsedDuration = DateTime.now().difference(_workoutLog!.startTime);
        notifyListeners();
      } else {
        timer.cancel();
      }
    });
  }

  void _stopWorkoutTimer() {
    _workoutDurationTimer?.cancel();
  }

  Future<void> tryRestoreSession() async {
    final db = WorkoutDatabaseHelper.instance;
    final WorkoutLog? ongoingWorkout = await db.getOngoingWorkout();

    if (ongoingWorkout != null) {
      print(
        "Laufendes Workout gefunden (ID: ${ongoingWorkout.id}). Stelle Session wieder her...",
      );
      await restoreWorkoutSession(ongoingWorkout);
      print("Session erfolgreich wiederhergestellt.");
    } else {
      print("Kein laufendes Workout gefunden. Starte normal.");
    }
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/compact_nutrition_bar.dart =====

// lib/widgets/compact_nutrition_bar.dart

import 'package:flutter/material.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/util/design_constants.dart';

class CompactNutritionBar extends StatelessWidget {
  final DailyNutrition nutritionData;
  const CompactNutritionBar({super.key, required this.nutritionData});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: DesignConstants.cardMargin,
      child: Column(
        children: [
          _buildProgressBar(
            context: context,
            label: 'Kalorien',
            value: nutritionData.calories.toDouble(),
            target: nutritionData.targetCalories.toDouble(),
            unit: 'kcal',
            color: Colors.orange,
          ),
          const SizedBox(height: DesignConstants.spacingM),
          _buildProgressBar(
            context: context,
            label: 'Protein',
            value: nutritionData.protein.toDouble(),
            target: nutritionData.targetProtein.toDouble(),
            unit: 'g',
            color: Colors.red.shade400,
          ),
          const SizedBox(height: DesignConstants.spacingM),
          _buildProgressBar(
            context: context,
            label: 'Wasser',
            value: nutritionData.water.toDouble(),
            target: nutritionData.targetWater.toDouble(),
            unit: 'L',
            isWater: true,
            color: Colors.blue,
          ),
        ],
      ),
    );
  }

  Widget _buildProgressBar({
    required BuildContext context,
    required String label,
    required double value,
    required double target,
    required String unit,
    required Color color,
    bool isWater = false,
  }) {
    final progress = target > 0 ? (value / target).clamp(0.0, 1.0) : 0.0;
    final displayValue =
        isWater ? (value / 1000).toStringAsFixed(1) : value.toStringAsFixed(0);
    final displayTarget = isWater
        ? (target / 1000).toStringAsFixed(0)
        : target.toStringAsFixed(0);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              label,
              style: Theme.of(
                context,
              ).textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.bold),
            ),
            Text(
              '$displayValue / $displayTarget $unit',
              style: Theme.of(context).textTheme.bodySmall,
            ),
          ],
        ),
        const SizedBox(height: 4),
        LinearProgressIndicator(
          value: progress,
          backgroundColor: color.withOpacity(0.2),
          color: color,
          minHeight: 8,
          borderRadius: BorderRadius.circular(4),
        ),
      ],
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/workout_summary_bar.dart =====

// lib/widgets/workout_summary_bar.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/time_util.dart'; // Wir erstellen diese Hilfsdatei gleich

class WorkoutSummaryBar extends StatelessWidget {
  const WorkoutSummaryBar({
    super.key,
    this.duration,
    required this.volume,
    required this.sets,
    this.progress, // NULL => Spacer-Modus
  });

  final Duration? duration;
  final double volume;
  final int sets;
  final double? progress; // 0..1 oder null

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        // Header ohne grauen Kasten
        Container(
          margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: [
              _buildStatColumn(
                context: context,
                label: l10n.durationLabel,
                value: formatDuration(duration ?? Duration.zero),
                highlight: true,
              ),
              _buildStatColumn(
                context: context,
                label: l10n.volumeLabel,
                value: "${volume.toStringAsFixed(0)} kg",
              ),
              _buildStatColumn(
                context: context,
                label: l10n.setsLabel,
                value: sets.toString(),
              ),
            ],
          ),
        ),

        // Progress / Spacer: volle Breite, kein Padding
        SizedBox(
          width: double.infinity,
          child: _WorkoutProgressBar(value: progress),
        ),
      ],
    );
  }

  /// Ein kleines Helfer-Widget für eine einzelne Statistik-Spalte.
  Widget _buildStatColumn({
    required BuildContext context,
    required String label,
    required String value,
    bool highlight = false,
  }) {
    final theme = Theme.of(context);
    final valueStyle = theme.textTheme.titleMedium?.copyWith(
      fontWeight: highlight ? FontWeight.bold : FontWeight.normal,
      color: highlight
          ? theme.colorScheme.primary
          : theme.textTheme.titleMedium?.color,
    );

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          label.toUpperCase(),
          style: theme.textTheme.labelSmall?.copyWith(
            color: Colors.grey[600],
            letterSpacing: 0.8,
          ),
        ),
        const SizedBox(height: 4),
        Text(value, style: valueStyle),
      ],
    );
  }
}

class _WorkoutProgressBar extends StatelessWidget {
  const _WorkoutProgressBar({required this.value});
  final double? value; // null => Spacer

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    final bg = Colors.white.withOpacity(0.10); // dezentes Grau
    final fg = cs.primary;

    final bar = ClipRRect(
      borderRadius: BorderRadius.circular(999),
      child: LayoutBuilder(
        builder: (context, c) {
          final v = (value ?? 0).clamp(0.0, 1.0);
          final w = c.maxWidth * v;
          return Stack(
            children: [
              Container(height: 6, color: bg),
              if (value != null)
                AnimatedContainer(
                  duration: const Duration(milliseconds: 250),
                  curve: Curves.easeOut,
                  width: w,
                  height: 6,
                  color: fg,
                ),
            ],
          );
        },
      ),
    );

    // kein Außenabstand → wirklich von ganz links bis ganz rechts
    return bar;
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/set_type_chip.dart =====

// lib/widgets/set_type_chip.dart

import 'package:flutter/material.dart';

class SetTypeChip extends StatelessWidget {
  final String setType;
  final int? setIndex;
  final bool isCompleted;
  final VoidCallback? onTap;

  const SetTypeChip({
    super.key,
    required this.setType,
    this.setIndex, // setIndex ist jetzt optional
    this.isCompleted = false,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final Map<String, dynamic> typeInfo = {
      'normal': {'char': setIndex.toString(), 'color': Colors.grey},
      'warmup': {'char': 'W', 'color': Colors.orange},
      'failure': {'char': 'F', 'color': Colors.red},
      'dropset': {'char': 'D', 'color': Colors.blue},
    };
    final type = typeInfo[setType] ?? typeInfo['normal']!;
    final Color textColor = type['color'];

    return GestureDetector(
      onTap: isCompleted ? null : onTap,
      child: SizedBox(
        width: 40, // Feste Breite für die Spalte
        height: 40, // Feste Höhe
        child: Center(
          child: Text(
            type['char'],
            style: TextStyle(
              color: textColor,
              fontSize: 20, // Größere Schriftart
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/measurement_chart_widget.dart =====

import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:lightweight/data/database_helper.dart';
import 'package:lightweight/models/chart_data_point.dart';
import 'package:intl/intl.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:flutter/services.dart';

class MeasurementChartWidget extends StatefulWidget {
  final String chartType;
  final DateTimeRange dateRange;
  final String unit;

  const MeasurementChartWidget({
    super.key,
    required this.chartType,
    required this.dateRange,
    required this.unit,
  });

  @override
  State<MeasurementChartWidget> createState() => _MeasurementChartWidgetState();
}

class _MeasurementChartWidgetState extends State<MeasurementChartWidget> {
  List<ChartDataPoint> _dataPoints = [];
  bool _isLoadingChart = true;
  int? _touchedIndex;

  @override
  void initState() {
    super.initState();
    _loadChartData();
  }

  @override
  void didUpdateWidget(covariant MeasurementChartWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.chartType != widget.chartType ||
        oldWidget.dateRange != widget.dateRange) {
      _loadChartData();
    }
  }

  Future<void> _loadChartData() async {
    setState(() {
      _isLoadingChart = true;
      _touchedIndex = null;
    });
    final data = await DatabaseHelper.instance.getChartDataForTypeAndRange(
      widget.chartType,
      widget.dateRange,
    );
    if (mounted) {
      setState(() {
        _dataPoints = data;
        _isLoadingChart = false;
      });
    }
  }

  void _setTouchedIndexWithHaptics(int? newIndex) {
    if (newIndex == _touchedIndex) return; // nur bei echter Änderung vibrieren
    _touchedIndex = newIndex;
    if (newIndex != null) {
      HapticFeedback.mediumImpact();
    }
    if (mounted) setState(() {});
  }

  void _handleTouchCallback(FlTouchEvent event, LineTouchResponse? response) {
    if (event is FlPanEndEvent || event is FlTapUpEvent) {
      // Finger losgelassen: Auswahl zurücksetzen (ohne Haptik)
      _touchedIndex = null;
      if (mounted) setState(() {});
      return;
    }

    final spots = response?.lineBarSpots;
    if (spots != null && spots.isNotEmpty) {
      // Index des aktuell getroffenen Punktes
      final idx = spots.first.spotIndex;
      _setTouchedIndexWithHaptics(idx);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    if (_isLoadingChart) {
      return const SizedBox(
        height: 250,
        child: Center(child: CircularProgressIndicator()),
      );
    }
    if (_dataPoints.isEmpty) {
      return SizedBox(
        height: 250,
        child: Center(child: Text(l10n.chart_no_data_for_period)),
      );
    }

    // Punkt zur Anzeige (entweder getouched oder letzter)
    final int lastIdx = _dataPoints.length - 1;
    final int shownIdx = (_touchedIndex != null &&
            _touchedIndex! >= 0 &&
            _touchedIndex! < _dataPoints.length)
        ? _touchedIndex!
        : lastIdx;

    // 2) Anzeigezeile oben (unverändert)
    final ChartDataPoint displayPoint = _dataPoints[shownIdx];
    final String displayValue =
        '${displayPoint.value.toStringAsFixed(1)} ${widget.unit}';
    final String displayDate = DateFormat.yMMMd().format(displayPoint.date);

    final Color lineColor = Theme.of(context).colorScheme.primary;
    final DateTime baseDate = _dataPoints.first.date;
    final int totalDays = widget.dateRange.end
        .difference(widget.dateRange.start)
        .inDays
        .clamp(1, 100000); // Schutz

    // 1) Basisdaten: auf Tagesgrenzen normalisieren und SPAN berechnen
    final DateTime firstDate = DateTime(
      _dataPoints.first.date.year,
      _dataPoints.first.date.month,
      _dataPoints.first.date.day,
    );
    final DateTime lastDate = DateTime(
      _dataPoints.last.date.year,
      _dataPoints.last.date.month,
      _dataPoints.last.date.day,
    );

    final int spanDays = lastDate.difference(firstDate).inDays;
    final double lastX = spanDays.toDouble();

    // ~6 Labels anpeilen (mind. 1)
    const int desiredLabels = 6;
    final int labelEvery = (spanDays / desiredLabels).ceil().clamp(1, 100000);

    // Kompaktes Datumsformat abhängig von der Spannweite
    String labelFor(DateTime d) {
      if (spanDays > 365 * 2) return DateFormat('yyyy').format(d);
      if (spanDays > 365) return DateFormat('MMM yyyy').format(d);
      if (spanDays > 31) return DateFormat('MMM d').format(d);
      return DateFormat.MMMd().format(d);
    }

    return SizedBox(
      height: 250,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // LINKS bündig: Gewicht groß + Datum rechts daneben
          Row(
            mainAxisAlignment: MainAxisAlignment.start,
            children: [
              Text(
                displayValue,
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
              ),
              const SizedBox(width: 8),
              Text(
                displayDate,
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      color: Theme.of(
                        context,
                      ).colorScheme.onSurface.withOpacity(0.6),
                    ),
              ),
            ],
          ),
          const SizedBox(height: DesignConstants.spacingS),

          Expanded(
            child: LineChart(
              LineChartData(
                minX: 0,
                maxX: lastX == 0 ? 1 : lastX, // bei nur einem Punkt min Breite
                clipData: const FlClipData
                    .none(), // vermeidet Clipping am rechten Rand
                lineTouchData: LineTouchData(
                  handleBuiltInTouches: true,
                  touchTooltipData: LineTouchTooltipData(
                    //tooltipBgColor: Colors.transparent,
                    getTooltipItems: (touchedSpots) =>
                        List<LineTooltipItem?>.filled(
                      touchedSpots.length,
                      null,
                      growable: false,
                    ),
                  ),
                  touchCallback: _handleTouchCallback,
                ),

                extraLinesData: ExtraLinesData(
                  horizontalLines: [
                    HorizontalLine(
                      y: _dataPoints.first.value,
                      color: Colors.grey.withOpacity(0.5),
                      strokeWidth: 1,
                      dashArray: [3, 4],
                    ),
                  ],
                ),
                gridData: const FlGridData(show: false),
                borderData: FlBorderData(show: false),

                titlesData: FlTitlesData(
                  leftTitles: const AxisTitles(
                    sideTitles: SideTitles(showTitles: false),
                  ),
                  topTitles: const AxisTitles(
                    sideTitles: SideTitles(showTitles: false),
                  ),
                  rightTitles: AxisTitles(
                    sideTitles: SideTitles(
                      showTitles: true,
                      reservedSize: 40,
                      getTitlesWidget: (value, meta) => Text(
                        value.toStringAsFixed(0),
                        style: Theme.of(context).textTheme.bodySmall,
                        textAlign: TextAlign.right,
                      ),
                    ),
                  ),
                  bottomTitles: AxisTitles(
                    sideTitles: SideTitles(
                      showTitles: true,
                      reservedSize: 30,
                      // WIR benutzen zusätzlich eine Guard im Builder, damit niemals zu viele Labels erscheinen:
                      interval: 1, // technisch 1, aber wir filtern im Builder
                      getTitlesWidget: (value, meta) {
                        final int v = value.round();

                        // Immer erstes und letztes Label zeigen …
                        final bool isEdge = (v == 0) || (v == spanDays);
                        // … und sonst nur jeden 'labelEvery'-ten Tag
                        final bool show = isEdge || (v % labelEvery == 0);

                        if (!show) return const SizedBox.shrink();

                        final date = firstDate.add(Duration(days: v));
                        return SideTitleWidget(
                          meta: meta,
                          space: 8,
                          child: Text(
                            labelFor(date),
                            style: Theme.of(context).textTheme.bodySmall,
                          ),
                        );
                      },
                    ),
                  ),
                ),
                lineBarsData: [
                  LineChartBarData(
                    spots: _dataPoints.map((p) {
                      final x = DateTime(
                        p.date.year,
                        p.date.month,
                        p.date.day,
                      ).difference(firstDate).inDays.toDouble();
                      return FlSpot(x, p.value);
                    }).toList(),
                    isCurved: false, // gerade Linien
                    color: Theme.of(context).colorScheme.primary,
                    barWidth: 3,
                    isStrokeCapRound: true,
                    // Dot nur beim getouchten Punkt:
                    dotData: FlDotData(
                      show: true,
                      checkToShowDot: (spot, bar) {
                        if (_touchedIndex == null) return false;
                        final idx = bar.spots.indexOf(spot);
                        return idx == _touchedIndex;
                      },
                      getDotPainter: (spot, percent, bar, index) =>
                          FlDotCirclePainter(
                        radius: 6,
                        color: Theme.of(context).colorScheme.primary,
                        strokeWidth: 2,
                        strokeColor: Theme.of(
                          context,
                        ).scaffoldBackgroundColor,
                      ),
                    ),
                    belowBarData: BarAreaData(
                      show: true,
                      gradient: LinearGradient(
                        colors: [
                          Theme.of(
                            context,
                          ).colorScheme.primary.withOpacity(0.3),
                          Theme.of(
                            context,
                          ).colorScheme.primary.withOpacity(0.0),
                        ],
                        begin: Alignment.topCenter,
                        end: Alignment.bottomCenter,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/global_app_bar.dart =====

// lib/widgets/global_app_bar.dart

import 'dart:ui';
import 'package:flutter/material.dart';

class GlobalAppBar extends StatelessWidget implements PreferredSizeWidget {
  final String? title;
  final Widget? titleWidget;
  final List<Widget>? actions;
  final Widget? leading;
  final bool automaticallyImplyLeading;
  final double? titleSpacing;

  const GlobalAppBar({
    super.key,
    this.title,
    this.titleWidget,
    this.actions,
    this.leading,
    this.automaticallyImplyLeading = true,
    this.titleSpacing,
  }) : assert(
          title == null || titleWidget == null,
          'Cannot provide both a title and a titleWidget',
        );

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    // Der sichtbare Inhalt der AppBar (Titel, Icons etc.)
    final appBarContent = AppBar(
      backgroundColor: Colors.transparent,
      elevation: 0,
      scrolledUnderElevation: 0,
      foregroundColor: theme.colorScheme.onSurface,
      centerTitle: false,
      leading: leading,
      automaticallyImplyLeading: automaticallyImplyLeading,
      titleSpacing: titleSpacing,
      title: titleWidget ??
          Text(
            title ?? '',
            style: Theme.of(
              context,
            ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w900),
          ),
      actions: actions,
    );

    // Farbe für das durchscheinende "Glas"
    final Color glassColor =
        isDark ? Colors.black.withOpacity(0.5) : Colors.white.withOpacity(0.3);

    // Farbe für die feine Trennlinie am unteren Rand
    final Color dividerColor = isDark
        ? Colors.white.withOpacity(0.15)
        : Colors.black.withOpacity(0.10);

    // Die finale Struktur mit statischem Blur
    return ClipRect(
      child: BackdropFilter(
        filter: ImageFilter.blur(
          sigmaX: 14,
          sigmaY: 14,
        ),
        child: Container(
          // Die Decoration sorgt für die Farbe und die untere Kante
          decoration: BoxDecoration(
            color: glassColor,
            //border: Border(
            //  bottom: BorderSide(color: dividerColor, width: 0.5),
            //),
          ),
          child: SafeArea(
            bottom: false,
            child: SizedBox(
              height: kToolbarHeight,
              child: appBarContent,
            ),
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/frosted_container.dart =====

//lib/widgets/frosted_container.dart
import 'dart:ui';
import 'package:flutter/material.dart';

class FrostedContainer extends StatelessWidget {
  final Widget child;
  final EdgeInsetsGeometry margin;
  final EdgeInsetsGeometry padding;
  final double radius;
  final double blurSigma;

  const FrostedContainer({
    super.key,
    required this.child,
    this.margin = const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
    this.padding = const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
    this.radius = 20,
    this.blurSigma = 14,
  });

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Padding(
      padding: margin,
      child: ClipRRect(
        borderRadius: BorderRadius.circular(radius),
        child: BackdropFilter(
          filter: ImageFilter.blur(sigmaX: blurSigma, sigmaY: blurSigma),
          child: Container(
            padding: padding,
            decoration: BoxDecoration(
              color: Theme.of(context).brightness == Brightness.dark
                  ? Colors.black.withOpacity(0.6)
                  : Colors.white.withOpacity(0.7),
              borderRadius: BorderRadius.circular(radius),
              border: Border.all(
                color: cs.onSurface.withOpacity(0.08),
                width: 1,
              ),
              boxShadow: const [
                BoxShadow(
                  blurRadius: 18,
                  offset: Offset(0, 6),
                  color: Colors.black26,
                ),
              ],
            ),
            child: child,
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/glass_bottom_nav_bar.dart =====

import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:lightweight/services/theme_service.dart';
import 'package:lightweight/theme/color_constants.dart';
import 'package:liquid_glass_renderer/liquid_glass_renderer.dart';
import 'package:provider/provider.dart';

class GlassBottomNavBar extends StatelessWidget {
  final int currentIndex;
  final ValueChanged<int> onTap;
  final VoidCallback onFabTap;
  final List<BottomNavigationBarItem> items;

  const GlassBottomNavBar({
    super.key,
    required this.currentIndex,
    required this.onTap,
    required this.onFabTap,
    required this.items,
  });

  Widget _buildNavItem(
    BuildContext context,
    BottomNavigationBarItem item,
    bool isSelected,
    VoidCallback onTap,
  ) {
    final cs = Theme.of(context).colorScheme;
    final isDarkLocal = Theme.of(context).brightness == Brightness.dark;
    final color =
        isSelected ? cs.primary : (isDarkLocal ? Colors.white : Colors.black);
    return Expanded(
      child: Material(
        type: MaterialType.transparency,
        child: InkWell(
          onTap: () {
            HapticFeedback.lightImpact();
            onTap();
          },
          borderRadius: BorderRadius.circular(16),
          splashColor: Colors.transparent,
          highlightColor: Colors.transparent,
          hoverColor: Colors.transparent,
          focusColor: Colors.transparent,
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 10),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                IconTheme(
                  data: IconThemeData(color: color, size: 18),
                  child: item.icon,
                ),
                const SizedBox(height: 4),
                Text(
                  item.label ?? '',
                  maxLines: 1,
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    color: color,
                    fontSize: 10,
                    fontWeight: isSelected ? FontWeight.w700 : FontWeight.w400,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  /// Berechnet die Align-X-Position (-1..1) für den selektierten Bubble-Hintergrund.
  double _alignmentXForIndex(int index, int count) {
    if (count <= 0) return 0;
    final centerFrac = (index + 0.5) / count; // 0..1
    return centerFrac * 2 - 1; // -1..1
  }

  /// Mappt eine lokale X-Position (0..width) auf den Tab-Index.
  int _indexFromDx(double dx, double width, int itemCount) {
    if (width <= 0 || itemCount <= 0) return 0;
    final frac = (dx / width).clamp(0.0, 0.9999);
    final idx = (frac * itemCount).floor();
    return idx.clamp(0, itemCount - 1);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final bg = isDark ? summary_card_dark_mode : summary_card_white_mode;
    final themeService = context.watch<ThemeService>();

    final navItemsRow = Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        ...List.generate(items.length, (index) {
          final item = items[index];
          final isSelected = index == currentIndex;
          return _buildNavItem(
            context,
            item,
            isSelected,
            () => onTap(index),
          );
        }),
      ],
    );

    final double barHeight = themeService.visualStyle == 1 ? 65 : 76.0;

    switch (themeService.visualStyle) {
      case 1:
        // neutrale Tönung ableiten (funktioniert auf Weiß & Schwarz)
        final Color neutralTint = (isDark ? Colors.white : Colors.black)
            .withOpacity(isDark ? 0.1 : 0.1);

        // smarteres Glas: bg-Color + neutraler Tint "verheiraten"
        final Color effectiveGlass =
            Color.alphaBlend(neutralTint, bg.withOpacity(isDark ? 0.8 : 0.5));

        // Drag-to-select + Release-to-activate: über GestureDetector
        return LayoutBuilder(
          builder: (context, constraints) {
            double? lastDx;
            int? lastHoverIndex;
            final barWidth = constraints.maxWidth;
            return GestureDetector(
              behavior: HitTestBehavior.translucent,
              onTapUp: (details) {
                final idx = _indexFromDx(
                  details.localPosition.dx,
                  barWidth,
                  items.length,
                );
                onTap(idx);
                HapticFeedback.lightImpact(); // Feedback bei einfachem Tap
              },
              onPanStart: (details) {
                lastDx = details.localPosition.dx;
                final idx = _indexFromDx(lastDx!, barWidth, items.length);
                lastHoverIndex = idx;
                HapticFeedback
                    .selectionClick(); // leichtes Feedback beim ersten Kontakt
              },
              onPanUpdate: (details) {
                lastDx = details.localPosition.dx;
                final idx = _indexFromDx(lastDx!, barWidth, items.length);
                if (idx != lastHoverIndex) {
                  lastHoverIndex = idx;
                  HapticFeedback
                      .lightImpact(); // leichtes Feedback beim Wechseln der Zone
                }
              },
              onPanEnd: (_) {
                if (lastHoverIndex != null) {
                  onTap(lastHoverIndex!);
                }
                lastDx = null;
                lastHoverIndex = null;
              },
              child: LiquidStretch(
                stretch: 0.2,
                interactionScale: 1.04,
                child: LiquidGlass.withOwnLayer(
                  settings: LiquidGlassSettings(
                    thickness: 30,
                    blur: 0.75,
                    glassColor: effectiveGlass,
                    lightIntensity: 0.35,
                    saturation: 1.10,
                  ),
                  shape: const LiquidRoundedSuperellipse(borderRadius: 99),
                  child: GlassGlow(
                    glowColor: Colors.white.withOpacity(isDark ? 0.24 : 0.18),
                    glowRadius: 1.0,
                    child: SizedBox(
                      height: barHeight,
                      child: Stack(
                        children: [
                          Positioned.fill(
                            child: DecoratedBox(
                              decoration: BoxDecoration(color: neutralTint),
                            ),
                          ),
                          Positioned.fill(
                            child: Padding(
                              padding:
                                  const EdgeInsets.symmetric(horizontal: 12),
                              child: navItemsRow,
                            ),
                          ),
                          Positioned.fill(
                            child: IgnorePointer(
                              child: Container(
                                decoration: BoxDecoration(
                                  borderRadius: BorderRadius.circular(99),
                                  border: Border.all(
                                    color: isDark
                                        ? Colors.white.withOpacity(0.20)
                                        : Colors.black.withOpacity(0.08),
                                    width: 1.2,
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            );
          },
        );

      default:
        // Standard: bisheriger Backdrop-Filter
        return ClipRRect(
          borderRadius: BorderRadius.circular(20),
          child: BackdropFilter(
            filter: ImageFilter.blur(sigmaX: 12, sigmaY: 12),
            child: Container(
              height: barHeight,
              padding: const EdgeInsets.symmetric(horizontal: 12),
              decoration: BoxDecoration(
                color: bg.withOpacity(0.8),
                borderRadius: BorderRadius.circular(20),
                border: Border.all(
                  color: isDark
                      ? Colors.white.withOpacity(0.30)
                      : Colors.black.withOpacity(0.10),
                  width: 1.5,
                ),
              ),
              child: navItemsRow,
            ),
          ),
        );
    }
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/workout_card.dart =====

// lib/widgets/workout_card.dart
import 'package:flutter/material.dart';

class WorkoutCard extends StatelessWidget {
  final EdgeInsetsGeometry padding;
  final EdgeInsetsGeometry margin;
  final Widget child;

  const WorkoutCard({
    super.key,
    required this.child,
    this.padding = EdgeInsets.zero,
    this.margin = EdgeInsets.zero,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      key: key, // Key an den Container weitergeben
      margin: margin,
      padding: padding,
      decoration: BoxDecoration(
        color: Colors.transparent, // Komplett transparent
        borderRadius: BorderRadius.circular(20),
      ),
      child: ClipRRect(
        // Stellt sicher, dass die Ecken der Kinder abgerundet sind
        borderRadius: BorderRadius.circular(20),
        child: child,
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/wger_attribution_widget.dart =====

// lib/widgets/wger_attribution_widget.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:url_launcher/url_launcher.dart';

class WgerAttributionWidget extends StatelessWidget {
  final TextStyle? textStyle;

  const WgerAttributionWidget({super.key, this.textStyle});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final currentTextStyle = textStyle ??
        theme.textTheme.bodySmall?.copyWith(color: Colors.grey[600]);

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(8.0),
        child: GestureDetector(
          // Macht den Text klickbar
          onTap: () async {
            final uri = Uri.parse("https://wger.de/"); // <-- Geänderte URL
            try {
              if (await canLaunchUrl(uri)) {
                await launchUrl(uri);
              } else {
                throw 'Could not launch $uri';
              }
            } catch (e) {
              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(l10n.snackbar_could_not_open_open_link),
                  ),
                );
              }
            }
          },
          child: Text(
            l10n.exerciseDataAttribution, // <-- Geänderter Text
            style: currentTextStyle,
            textAlign: TextAlign.center,
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/supplement_summary_widget.dart =====

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/supplement.dart';
import 'package:lightweight/models/tracked_supplement.dart';
import 'package:lightweight/widgets/glass_progress_bar.dart';
import 'package:lightweight/theme/color_constants.dart';

class SupplementSummaryWidget extends StatelessWidget {
  final List<TrackedSupplement> trackedSupplements;
  final VoidCallback onTap;

  const SupplementSummaryWidget({
    super.key,
    required this.trackedSupplements,
    required this.onTap,
  });
  String localizeSupplementName(Supplement s, AppLocalizations l10n) {
    switch (s.code) {
      case 'caffeine':
        return l10n.supplement_caffeine;
      case 'creatine_monohydrate':
        return l10n.supplement_creatine_monohydrate;
      default:
        // Fallback: benutzerdefinierte Supplements behalten ihren Namen
        return s.name;
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final goalOnlySupplements = trackedSupplements
        .where(
          (ts) =>
              ts.supplement.dailyGoal != null &&
              ts.supplement.dailyLimit == null,
        )
        .toList();

    final progressSupplements = trackedSupplements
        .where((ts) => ts.supplement.dailyLimit != null)
        .toList();

    if (goalOnlySupplements.isEmpty && progressSupplements.isEmpty) {
      return const SizedBox.shrink();
    }

    return Column(
      children: [
        ...goalOnlySupplements.map(
          (ts) => GestureDetector(
            onTap: onTap,
            child: _CheckmarkCard(trackedSupplement: ts),
          ),
        ),
        ...progressSupplements.map((ts) {
          final supplement = ts.supplement;
          return GestureDetector(
            onTap: onTap,
            child: Padding(
              padding: const EdgeInsets.symmetric(vertical: 4.0),
              child: GlassProgressBar(
                label: localizeSupplementName(supplement, l10n),
                unit: supplement.unit,
                value: ts.totalDosedToday,
                target: supplement.dailyLimit!,
                color: Colors.amber.shade600,
                height: 50,
                borderRadius: 16,
              ),
            ),
          );
        }),
      ],
    );
  }
}

class _CheckmarkCard extends StatelessWidget {
  final TrackedSupplement trackedSupplement;
  const _CheckmarkCard({required this.trackedSupplement});

  String localizeSupplementName(Supplement s, AppLocalizations l10n) {
    switch (s.code) {
      case 'caffeine':
        return l10n.supplement_caffeine;
      case 'creatine_monohydrate':
        return l10n.supplement_creatine_monohydrate;
      default:
        // Fallback: benutzerdefinierte Supplements behalten ihren Namen
        return s.name;
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final brightness = theme.brightness;
    final supplement = trackedSupplement.supplement;
    final doseTaken = trackedSupplement.totalDosedToday;
    final isDone = doseTaken > 0;
    final l10n = AppLocalizations.of(context)!;

    final String displayText;
    if (isDone) {
      displayText =
          '${doseTaken.toStringAsFixed(1).replaceAll('.0', '')} ${supplement.unit}';
    } else {
      displayText =
          '${supplement.dailyGoal?.toStringAsFixed(1).replaceAll('.0', '') ?? ''} ${supplement.unit}';
    }

    final backgroundColor = brightness == Brightness.dark
        ? summary_card_dark_mode
        : summary_card_white_mode;

    return Container(
      height: 50,
      margin: const EdgeInsets.symmetric(vertical: 4.0),
      padding: const EdgeInsets.symmetric(horizontal: 12.0),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(16),
      ),
      child: Row(
        children: [
          Icon(
            isDone ? Icons.check_circle : Icons.radio_button_unchecked,
            color: isDone ? Colors.green.shade400 : Colors.grey.shade600,
            size: 20,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              localizeSupplementName(supplement, l10n),
              style: TextStyle(
                color: theme.colorScheme.onSurface,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          Text(
            displayText,
            style: TextStyle(
              color: theme.colorScheme.onSurface.withOpacity(0.8),
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/add_menu_sheet.dart =====

// lib/widgets/add_menu_sheet.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/design_constants.dart';

class AddMenuSheet extends StatelessWidget {
  const AddMenuSheet({super.key});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;

    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Text(
              l10n.addMenuTitle,
              style: Theme.of(context).textTheme.titleLarge,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: DesignConstants.spacingXL),
            _buildMenuOption(
              context: context,
              colorScheme: colorScheme,
              icon: Icons.fitness_center,
              title: l10n.startWorkout,
              onTap: () => Navigator.of(context).pop('start_workout'),
            ),
            const SizedBox(height: DesignConstants.spacingM),
            _buildMenuOption(
              context: context,
              colorScheme: colorScheme,
              icon: Icons.straighten_outlined,
              title: l10n.addMeasurement,
              onTap: () => Navigator.of(context).pop('add_measurement'),
            ),
            const Divider(height: 24, indent: 16, endIndent: 16),
            _buildMenuOption(
              context: context,
              colorScheme: colorScheme,
              icon: Icons.restaurant_menu,
              title: l10n.addFoodOption,
              onTap: () => Navigator.of(context).pop('add_food'),
            ),
            const SizedBox(height: DesignConstants.spacingM),
            _buildMenuOption(
              context: context,
              colorScheme: colorScheme,
              icon: Icons.local_drink,
              title: l10n.addLiquidOption,
              onTap: () => Navigator.of(context).pop('add_liquid'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMenuOption({
    required BuildContext context,
    required ColorScheme colorScheme,
    required IconData icon,
    required String title,
    required VoidCallback onTap,
  }) {
    return ListTile(
      leading: Icon(icon, color: colorScheme.primary),
      title: Text(
        title,
        style: TextStyle(
          color: colorScheme.primary,
          fontWeight: FontWeight.w500,
        ),
      ),
      tileColor: colorScheme.surfaceContainerHighest.withOpacity(0.5),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      onTap: onTap,
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/editable_set_row.dart =====

// lib/widgets/editable_set_row.dart

import 'package:flutter/material.dart';
import 'package:lightweight/models/set_log.dart';
import 'package:lightweight/widgets/set_type_chip.dart';
import 'package:lightweight/generated/app_localizations.dart';

class EditableSetRow extends StatefulWidget {
  const EditableSetRow({
    super.key,
    required this.setLog,
    required this.setIndex,
    required this.onWeightChanged,
    required this.onRepsChanged,
    required this.onDelete,
  });

  final SetLog setLog;
  final int setIndex;
  final ValueChanged<String> onWeightChanged;
  final ValueChanged<String> onRepsChanged;
  final VoidCallback onDelete;

  @override
  State<EditableSetRow> createState() => _EditableSetRowState();
}

class _EditableSetRowState extends State<EditableSetRow> {
  late final TextEditingController _weightController;
  late final TextEditingController _repsController;

  @override
  void initState() {
    super.initState();
    _weightController = TextEditingController(
      text: widget.setLog.weightKg?.toStringAsFixed(2).replaceAll('.00', '') ??
          '',
    );
    _repsController = TextEditingController(
      text: widget.setLog.reps?.toString() ?? '',
    );

    // Melde Änderungen an den Parent-Screen
    _weightController.addListener(() {
      widget.onWeightChanged(_weightController.text);
    });
    _repsController.addListener(() {
      widget.onRepsChanged(_repsController.text);
    });
  }

  @override
  void dispose() {
    _weightController.dispose();
    _repsController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          SetTypeChip(
            setType: widget.setLog.setType,
            setIndex: widget.setIndex,
          ),
          const SizedBox(width: 16),
          Expanded(
            child: TextFormField(
              controller: _weightController,
              decoration: InputDecoration(
                labelText: l10n.kgLabel,
                isDense: true,
              ),
              keyboardType: const TextInputType.numberWithOptions(
                decimal: true,
              ),
              validator: (value) => (value == null ||
                      value.trim().isEmpty ||
                      double.tryParse(value.replaceAll(',', '.')) == null)
                  ? "!"
                  : null,
            ),
          ),
          const SizedBox(width: 8),
          const Text("x"),
          const SizedBox(width: 8),
          Expanded(
            child: TextFormField(
              controller: _repsController,
              decoration: InputDecoration(
                labelText: l10n.repsLabel,
                isDense: true,
              ),
              keyboardType: TextInputType.number,
              validator: (value) => (value == null ||
                      value.trim().isEmpty ||
                      int.tryParse(value) == null)
                  ? "!"
                  : null,
            ),
          ),
          IconButton(
            icon: const Icon(Icons.delete_outline, color: Colors.redAccent),
            tooltip: l10n.delete,
            onPressed: widget.onDelete,
          ),
        ],
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/glass_menu.dart =====

import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:lightweight/util/design_constants.dart';

class GlassMenuItem {
  final IconData icon;
  final String label;
  final VoidCallback onTap;

  GlassMenuItem({required this.icon, required this.label, required this.onTap});
}

class GlassMenu extends StatefulWidget {
  final List<GlassMenuItem> items;
  final VoidCallback onDismiss;

  const GlassMenu({super.key, required this.items, required this.onDismiss});

  @override
  State<GlassMenu> createState() => _GlassMenuState();
}

class _GlassMenuState extends State<GlassMenu>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 400),
    )..forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: widget.onDismiss,
      child: Scaffold(
        backgroundColor: Colors.black.withOpacity(0.4),
        body: Center(
          child: Wrap(
            spacing: 24,
            runSpacing: 24,
            children: List.generate(widget.items.length, (index) {
              final item = widget.items[index];
              final intervalStart = index * 0.1;
              final intervalEnd = intervalStart + 0.5;

              final animation = CurvedAnimation(
                parent: _controller,
                curve: Interval(
                  intervalStart,
                  intervalEnd,
                  curve: Curves.easeOutBack,
                ),
              );

              return ScaleTransition(
                scale: animation,
                child: FadeTransition(
                  opacity: animation,
                  child: GestureDetector(
                    onTap: () {
                      item.onTap();
                      widget.onDismiss();
                    },
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        _buildGlassIcon(item.icon),
                        const SizedBox(height: DesignConstants.spacingM),
                        Text(
                          item.label,
                          style:
                              Theme.of(context).textTheme.titleLarge?.copyWith(
                                    color: Colors.white,
                                    fontWeight: FontWeight.bold,
                                  ),
                        ),
                      ],
                    ),
                  ),
                ),
              );
            }),
          ),
        ),
      ),
    );
  }

  Widget _buildGlassIcon(IconData icon) {
    return ClipRRect(
      borderRadius: BorderRadius.circular(20),
      child: BackdropFilter(
        filter: ImageFilter.blur(sigmaX: 12, sigmaY: 12),
        child: Container(
          width: 76,
          height: 76,
          decoration: BoxDecoration(
            color: Colors.white.withOpacity(0.15),
            borderRadius: BorderRadius.circular(20),
            border: Border.all(
              color: Colors.white.withOpacity(0.3),
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.3),
                blurRadius: 12,
                offset: const Offset(0, 6),
              ),
            ],
          ),
          child: Icon(icon, size: 34, color: Colors.white),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/summary_card.dart =====

import 'package:flutter/material.dart';
import 'package:lightweight/theme/color_constants.dart';

class SummaryCard extends StatelessWidget {
  final Widget child;
  final EdgeInsetsGeometry padding;

  const SummaryCard({
    super.key,
    required this.child,
    this.padding = const EdgeInsets.all(12.0),
  });

  ///*
  @override
  Widget build(BuildContext context) {
    final brightness = Theme.of(context).brightness;

    final background = brightness == Brightness.dark
        ? summary_card_dark_mode
        : summary_card_white_mode;

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 6.0),
      padding: padding,
      decoration: BoxDecoration(
        color: background,
        //borderRadius: BorderRadius.circular(10),
        borderRadius: BorderRadius.circular(20),
        /*
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.25),
            blurRadius: 6,
            offset: const Offset(0, 2),
          ),
        ],
        */
      ),
      child: child,
    );
  }
}

//*/
/*
  @override
  Widget build(BuildContext context) {
    final brightness = Theme.of(context).brightness;

    // KORREKTUR: Hintergrund im Light Mode weniger transparent für besseren Kontrast
    final backgroundColor = brightness == Brightness.dark
        ? Colors.white.withOpacity(0.10)
        : Colors.white.withOpacity(0.65); // War 0.40, jetzt weniger durchsichtig

    // KORREKTUR: Randfarbe im Light Mode ist jetzt ein dunkles Grau statt Weiß
    final borderColor = brightness == Brightness.dark
        ? Colors.white.withOpacity(0.20)
        : Colors.black.withOpacity(0.12); // War Weiß, jetzt dunkles Grau mit Transparenz

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 6.0),
      // WICHTIG: Kein Padding mehr direkt hier, wird jetzt vom Child gesteuert
      // padding: padding, // Diese Zeile entfernen oder auskommentieren
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
          color: borderColor,
          width: 1.5,
        ),
        boxShadow: const [],
      ),
      // WICHTIG: ClipRRect, damit der Blur-Effekt die Ecken respektiert
      child: ClipRRect(
        borderRadius: BorderRadius.circular(20),
        child: BackdropFilter(
          // Der eigentliche "Frostglas"-Effekt
          filter: ImageFilter.blur(sigmaX: 10.0, sigmaY: 10.0),
          child: Padding(
            // Das Padding wird jetzt innerhalb des Blur-Effekts angewendet
            padding: padding,
            child: child,
          ),
        ),
      ),
    );
  }
}
*/


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/running_workout_bar.dart =====

// lib/widgets/running_workout_bar.dart

import 'package:flutter/material.dart';

class RunningWorkoutBar extends StatelessWidget {
  final String timeText; // z.B. "13:12"
  final VoidCallback onResume;
  final VoidCallback onDiscard;

  const RunningWorkoutBar({
    super.key,
    required this.timeText,
    required this.onResume,
    required this.onDiscard,
  });

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Row(
      children: [
        // Zeit (links)
        Expanded(
          child: Row(
            children: [
              const Icon(Icons.timer_outlined, size: 20),
              const SizedBox(width: 6),
              Text(
                timeText,
                style: const TextStyle(
                  fontFeatures: [FontFeature.tabularFigures()],
                ),
              ),
            ],
          ),
        ),
        // Fortsetzen (Accent)
        FilledButton(
          onPressed: onResume,
          style: FilledButton.styleFrom(
            backgroundColor: cs.primary,
            foregroundColor: cs.onPrimary,
            minimumSize: const Size(0, 36),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(10),
            ),
          ),
          child: const Text('Fortsetzen'),
        ),
        const SizedBox(width: 8),
        // Verwerfen (Rot)
        FilledButton(
          onPressed: onDiscard,
          style: FilledButton.styleFrom(
            backgroundColor: cs.error,
            foregroundColor: cs.onError,
            minimumSize: const Size(0, 36),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(10),
            ),
          ),
          child: const Text('Verwerfen'),
        ),
      ],
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/bottom_content_spacer.dart =====

//bottom_content_spacer.dart

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:lightweight/services/workout_session_manager.dart';

/// Visual overlay heights (your glass bar + detached FAB)
const double kOverlayBaseHeight = 120.0; // bottom bar + FAB + margins
const double kOverlayRunningExtra = 68.0; // extra when workout bar is shown

/// Use in ListView/Column: adds a scrollable spacer at the end.
class BottomContentSpacer extends StatelessWidget {
  final double extra; // if a screen needs a bit more room
  const BottomContentSpacer({super.key, this.extra = 0});

  @override
  Widget build(BuildContext context) {
    final bool isRunning = context.select<WorkoutSessionManager, bool>(
      (m) => m.isActive,
    );
    final double safe = MediaQuery.of(context).padding.bottom;
    final double h = kOverlayBaseHeight +
        (isRunning ? kOverlayRunningExtra : 0) +
        safe +
        extra;
    return SizedBox(height: h);
  }
}

/// Use in CustomScrollView: sliver variant.
class SliverBottomContentSpacer extends StatelessWidget {
  final double extra;
  const SliverBottomContentSpacer({super.key, this.extra = 0});

  @override
  Widget build(BuildContext context) {
    return SliverToBoxAdapter(child: BottomContentSpacer(extra: extra));
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/swipe_action_background.dart =====

import 'package:flutter/material.dart';

class SwipeActionBackground extends StatelessWidget {
  final Color color;
  final IconData icon;
  final Alignment alignment;

  const SwipeActionBackground({
    super.key,
    required this.color,
    required this.icon,
    required this.alignment,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.symmetric(
        vertical: 6.0,
      ), // Selber Margin wie SummaryCard
      decoration: BoxDecoration(
        color: color,
        borderRadius: BorderRadius.circular(
          20,
        ), // Selber Radius wie SummaryCard
      ),
      child: Align(
        alignment: alignment,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 20.0),
          child: Icon(icon, color: Colors.white),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/shadow_container.dart =====

// lib/widgets/shadow_container.dart

import 'package:flutter/material.dart';

class ShadowContainer extends StatelessWidget {
  final Widget child;
  final BorderRadiusGeometry borderRadius;
  final List<BoxShadow>? boxShadow;
  final EdgeInsetsGeometry? margin; // Optionaler externer Margin

  const ShadowContainer({
    super.key,
    required this.child,
    this.borderRadius = const BorderRadius.all(Radius.circular(16.0)),
    this.boxShadow,
    this.margin,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: margin,
      decoration: BoxDecoration(
        borderRadius: borderRadius,
        boxShadow: boxShadow ??
            [
              // Standard-Schatten, wenn keiner angegeben ist
              BoxShadow(
                color: Colors.black.withOpacity(0.08),
                blurRadius: 15,
                spreadRadius: 0,
                offset: const Offset(0, 8),
              ),
            ],
      ),
      child: ClipRRect(
        // ClipRRect, um den Inhalt innerhalb der Ecken zu halten
        borderRadius: borderRadius,
        child: child,
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/glass_fab.dart =====

import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:lightweight/services/theme_service.dart';
import 'package:lightweight/theme/color_constants.dart';
import 'package:liquid_glass_renderer/liquid_glass_renderer.dart';
import 'package:provider/provider.dart';

class GlassFab extends StatefulWidget {
  final VoidCallback onPressed;
  final IconData icon;
  final String? label;

  const GlassFab({
    super.key,
    required this.onPressed,
    this.icon = Icons.add,
    this.label,
  });

  @override
  State<GlassFab> createState() => _GlassFabState();
}

class _GlassFabState extends State<GlassFab>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 150),
      lowerBound: 0.0,
      upperBound: 0.1,
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _onTapDown(TapDownDetails details) => _controller.forward();
  void _onTapUp(TapUpDetails details) {
    _controller.reverse();
    HapticFeedback.lightImpact();
    widget.onPressed();
  }

  @override
  Widget build(BuildContext context) {
    final themeService = context.watch<ThemeService>();
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final bg = isDark ? summary_card_dark_mode : summary_card_white_mode;
    final hasLabel = widget.label != null;
    final Color neutralTint =
        (isDark ? Colors.white : Colors.black).withOpacity(isDark ? 0.1 : 0.1);
    final Color effectiveGlass =
        Color.alphaBlend(neutralTint, bg.withOpacity(isDark ? 0.8 : 0.5));

    final iconAndText = Padding(
      padding: hasLabel
          ? const EdgeInsets.symmetric(horizontal: 24.0)
          : EdgeInsets.zero,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            widget.icon,
            size: 30,
            color: isDark ? Colors.white : Colors.black,
          ),
          if (hasLabel) ...[
            const SizedBox(width: 12),
            Text(
              widget.label!,
              style: TextStyle(
                color: isDark ? Colors.white : Colors.black,
                fontWeight: FontWeight.bold,
                fontSize: 18,
              ),
            ),
          ],
        ],
      ),
    );

    Widget content;

    switch (themeService.visualStyle) {
      case 1:
        final hasLabel = widget.label != null;

        content = LiquidStretch(
          stretch: 0.2,
          interactionScale: 1.04,
          child: LiquidGlass.withOwnLayer(
            settings: LiquidGlassSettings(
              thickness: 30,
              blur: 0.75,
              glassColor: effectiveGlass,
              lightIntensity: 0.35,
              saturation: 1.10,
            ),
            shape: hasLabel
                ? const LiquidRoundedSuperellipse(borderRadius: 99)
                : const LiquidOval(),
            child: GlassGlow(
              glowColor: Colors.white.withOpacity(isDark ? 0.24 : 0.18),
              glowRadius: 1.0,
              child: hasLabel
                  // PILLE: Breite aus Inhalt + Padding
                  ? Container(
                      height: 65.0,
                      padding: const EdgeInsets.symmetric(horizontal: 24.0),
                      decoration: BoxDecoration(
                        color: neutralTint, // << Grundtönung
                        borderRadius: BorderRadius.circular(99),
                      ),
                      foregroundDecoration: BoxDecoration(
                        // << Rim oben drauf
                        borderRadius: BorderRadius.circular(99),
                        border: Border.all(
                          color: isDark
                              ? Colors.white.withOpacity(0.20)
                              : Colors.black.withOpacity(0.08),
                          width: 1.2,
                        ),
                      ),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(widget.icon,
                              size: 30,
                              color: isDark ? Colors.white : Colors.black),
                          const SizedBox(width: 12),
                          Text(
                            widget.label!,
                            style: TextStyle(
                              color: isDark ? Colors.white : Colors.black,
                              fontWeight: FontWeight.bold,
                              fontSize: 18,
                            ),
                          ),
                        ],
                      ),
                    )
                  // KREIS: feste 76×76
                  : Container(
                      height: 65.0,
                      width: 65.0,
                      decoration: BoxDecoration(
                        color: neutralTint,
                        borderRadius: BorderRadius.circular(999), // „Kreis“
                      ),
                      foregroundDecoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(999),
                        border: Border.all(
                          color: isDark
                              ? Colors.white.withOpacity(0.20)
                              : Colors.black.withOpacity(0.08),
                          width: 1.2,
                        ),
                      ),
                      alignment: Alignment.center,
                      child: Icon(widget.icon,
                          size: 30,
                          color: isDark ? Colors.white : Colors.black),
                    ),
            ),
          ),
        );
        break;

      default:
        content = ClipRRect(
          borderRadius: BorderRadius.circular(20),
          child: BackdropFilter(
            filter: ImageFilter.blur(sigmaX: 12, sigmaY: 12),
            child: Container(
              height: 76,
              width: hasLabel ? null : 76,
              decoration: BoxDecoration(
                color: bg.withOpacity(0.8),
                borderRadius: BorderRadius.circular(20),
                border: Border.all(
                  color: isDark
                      ? Colors.white.withOpacity(0.3)
                      : Colors.black.withOpacity(0.1),
                  width: 1.5,
                ),
              ),
              child: iconAndText,
            ),
          ),
        );
    }

    return GestureDetector(
      onTapDown: _onTapDown,
      onTapUp: _onTapUp,
      onTapCancel: () => _controller.reverse(),
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, child) {
          final scale = 1 - _controller.value;
          return Transform.scale(scale: scale, child: child);
        },
        child: content,
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/nutrition_summary_widget.dart =====

/*// lib/widgets/nutrition_summary_widget.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/util/design_constants.dart';
import 'package:lightweight/widgets/summary_card.dart';
import 'dart:ui'; // Für den ImageFilter.blur

class _NutrientSpec {
  final String label;
  final String unit;
  final double value;
  final double target;
  final Color color;

  _NutrientSpec({
    required this.label,
    required this.unit,
    required this.value,
    required this.target,
    required this.color,
  });
}

class NutritionSummaryWidget extends StatelessWidget {
  final DailyNutrition nutritionData;
  final bool isExpandedView;
  final AppLocalizations l10n;

  const NutritionSummaryWidget({
    super.key,
    required this.nutritionData,
    this.isExpandedView = false,
    required this.l10n,
  });

  @override
  Widget build(BuildContext context) {
    final specs = <String, _NutrientSpec>{
      'calories': _NutrientSpec(
          label: l10n.calories,
          unit: 'kcal',
          value: nutritionData.calories.toDouble(),
          target: nutritionData.targetCalories.toDouble(),
          color: Colors.orange),
      'water': _NutrientSpec(
          label: l10n.water,
          unit: 'ml',
          value: nutritionData.water.toDouble(),
          target: nutritionData.targetWater.toDouble(),
          color: Colors.blue),
      'protein': _NutrientSpec(
          label: l10n.protein,
          unit: 'g',
          value: nutritionData.protein.toDouble(),
          target: nutritionData.targetProtein.toDouble(),
          color: Colors.red.shade400),
      'carbs': _NutrientSpec(
          label: l10n.carbs,
          unit: 'g',
          value: nutritionData.carbs.toDouble(),
          target: nutritionData.targetCarbs.toDouble(),
          color: Colors.green.shade400),
      'fat': _NutrientSpec(
          label: l10n.fat,
          unit: 'g',
          value: nutritionData.fat.toDouble(),
          target: nutritionData.targetFat.toDouble(),
          color: Colors.purple.shade300),
      'sugar': _NutrientSpec(
          label: l10n.sugar,
          unit: 'g',
          value: nutritionData.sugar,
          target: nutritionData.targetSugar.toDouble(),
          color: Colors.pink.shade200),
      'fiber': _NutrientSpec(
          label: l10n.fiber,
          unit: 'g',
          value: nutritionData.fiber,
          target: nutritionData.targetFiber.toDouble(),
          color: Colors.brown.shade400),
      'salt': _NutrientSpec(
          label: l10n.salt,
          unit: 'g',
          value: nutritionData.salt,
          target: nutritionData.targetSalt.toDouble(),
          color: Colors.grey.shade500),
    };

    return SummaryCard(
      // KORREKTUR: internalPadding für diese spezifische Karte ist 12.0
      //internalPadding: const EdgeInsets.all(12.0),
      child: IntrinsicHeight(
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Expanded(
              flex: 3, // KORREKTUR 2: Flex-Wert erhöht, um mehr Platz zu geben
              child: Column(
                children: [
                  Expanded(child: _InfoBox(spec: specs['calories']!)),
                  const SizedBox(height: DesignConstants.spacingS),
                  Expanded(child: _InfoBox(spec: specs['water']!)),
                ],
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              flex: 4, // KORREKTUR 2: Flex-Wert erhöht
              child: Column(
                children: [
                  Expanded(child: _InfoBox(spec: specs['protein']!)),
                  const SizedBox(height: DesignConstants.spacingS),
                  Expanded(child: _InfoBox(spec: specs['carbs']!)),
                  const SizedBox(height: DesignConstants.spacingS),
                  Expanded(child: _InfoBox(spec: specs['fat']!)),
                ],
              ),
            ),
            if (isExpandedView) ...[
              const SizedBox(width: 8),
              Expanded(
                flex: 4, // KORREKTUR 2: Flex-Wert erhöht
                child: Column(
                  children: [
                    Expanded(child: _InfoBox(spec: specs['sugar']!)),
                    const SizedBox(height: DesignConstants.spacingS),
                    Expanded(child: _InfoBox(spec: specs['fiber']!)),
                    const SizedBox(height: DesignConstants.spacingS),
                    Expanded(child: _InfoBox(spec: specs['salt']!)),
                  ],
                ),
              ),
            ]
          ],
        ),
      ),
    );
  }
}
// Ersetze die komplette _InfoBox Klasse in lib/widgets/nutrition_summary_widget.dart

class _InfoBox extends StatelessWidget {
  final _NutrientSpec spec;
  const _InfoBox({required this.spec});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final brightness = theme.brightness;
    final colorScheme = theme.colorScheme;

    final hasTarget = spec.target > 0;
    final rawProgress = hasTarget ? (spec.value / spec.target) : 0.0;
    final progress = rawProgress.clamp(0.0, 1.0);

    // Farben für den Glas-Effekt, identisch zur SummaryCard
    final backgroundColor = brightness == Brightness.dark
        ? Colors.white.withOpacity(0.10)
        : Colors.white.withOpacity(0.65);

    final borderColor = brightness == Brightness.dark
        ? Colors.white.withOpacity(0.20)
        : Colors.black.withOpacity(0.12);

    return Container(
      // Die Dekoration ist jetzt die Glas-Dekoration
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(
            9), // Etwas weniger Rundung für die kleinen Boxen
        border: Border.all(
          color: borderColor,
          width: 1.0, // Etwas dünnerer Rand
        ),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(9),
        child: BackdropFilter(
          filter:
              ImageFilter.blur(sigmaX: 8.0, sigmaY: 8.0), // Etwas weniger Blur
          child: Stack(
            fit: StackFit.expand,
            children: [
              // Der animierte Füllbalken bleibt erhalten
              Align(
                alignment: Alignment.centerLeft,
                child: TweenAnimationBuilder<double>(
                  tween: Tween(begin: 0, end: progress),
                  duration: const Duration(milliseconds: 350),
                  curve: Curves.easeOutCubic,
                  builder: (context, p, child) =>
                      FractionallySizedBox(widthFactor: p, child: child),
                  child: Container(color: spec.color),
                ),
              ),
              // Der Text-Inhalt liegt über dem Füllbalken
              Padding(
                padding:
                    const EdgeInsets.symmetric(horizontal: 10.0, vertical: 4.0),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    FittedBox(
                      fit: BoxFit.scaleDown,
                      child: Text(
                        spec.label,
                        maxLines: 1,
                        style: TextStyle(
                            color: colorScheme.onSurface,
                            fontSize: 16,
                            fontWeight: FontWeight.bold),
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      hasTarget
                          ? '${spec.value.toStringAsFixed(1)} / ${spec.target.toStringAsFixed(0)} ${spec.unit}'
                          : '${spec.value.toStringAsFixed(1)} ${spec.unit}',
                      style: TextStyle(
                        color: colorScheme.onSurface.withOpacity(0.8),
                        fontSize: 14,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
*/
// lib/widgets/nutrition_summary_widget.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/models/daily_nutrition.dart';
import 'package:lightweight/util/design_constants.dart';
import 'dart:ui';

import 'package:lightweight/widgets/glass_progress_bar.dart'; // Für den ImageFilter.blur

class _NutrientSpec {
  final String label;
  final String unit;
  final double value;
  final double target;
  final Color color;

  _NutrientSpec({
    required this.label,
    required this.unit,
    required this.value,
    required this.target,
    required this.color,
  });
}

class NutritionSummaryWidget extends StatelessWidget {
  final DailyNutrition nutritionData;
  final bool isExpandedView;
  final AppLocalizations l10n;

  const NutritionSummaryWidget({
    super.key,
    required this.nutritionData,
    this.isExpandedView = false,
    required this.l10n,
  });

  @override
  Widget build(BuildContext context) {
    return IntrinsicHeight(
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Expanded(
            flex: 3,
            child: Column(
              children: [
                Expanded(
                  child: GlassProgressBar(
                    label: l10n.calories,
                    unit: 'kcal',
                    value: nutritionData.calories.toDouble(),
                    target: nutritionData.targetCalories.toDouble(),
                    color: Colors.orange,
                  ),
                ),
                const SizedBox(height: DesignConstants.spacingS),
                Expanded(
                  child: GlassProgressBar(
                    label: l10n.water,
                    unit: 'ml',
                    value: nutritionData.water.toDouble(),
                    target: nutritionData.targetWater.toDouble(),
                    color: Colors.blue,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            flex: 4,
            child: Column(
              children: [
                Expanded(
                  child: GlassProgressBar(
                    label: l10n.protein,
                    unit: 'g',
                    value: nutritionData.protein.toDouble(),
                    target: nutritionData.targetProtein.toDouble(),
                    color: Colors.red.shade400,
                  ),
                ),
                const SizedBox(height: DesignConstants.spacingS),
                Expanded(
                  child: GlassProgressBar(
                    label: l10n.carbs,
                    unit: 'g',
                    value: nutritionData.carbs.toDouble(),
                    target: nutritionData.targetCarbs.toDouble(),
                    color: Colors.green.shade400,
                  ),
                ),
                const SizedBox(height: DesignConstants.spacingS),
                Expanded(
                  child: GlassProgressBar(
                    label: l10n.fat,
                    unit: 'g',
                    value: nutritionData.fat.toDouble(),
                    target: nutritionData.targetFat.toDouble(),
                    color: Colors.purple.shade300,
                  ),
                ),
              ],
            ),
          ),
          if (isExpandedView) ...[
            const SizedBox(width: 8),
            Expanded(
              flex: 4,
              child: Column(
                children: [
                  Expanded(
                    child: GlassProgressBar(
                      label: l10n.sugar,
                      unit: 'g',
                      value: nutritionData.sugar,
                      target: nutritionData.targetSugar.toDouble(),
                      color: Colors.pink.shade200,
                    ),
                  ),
                  const SizedBox(height: DesignConstants.spacingS),
                  Expanded(
                    child: GlassProgressBar(
                      label: l10n.fiber,
                      unit: 'g',
                      value: nutritionData.fiber,
                      target: nutritionData.targetFiber.toDouble(),
                      color: Colors.brown.shade400,
                    ),
                  ),
                  const SizedBox(height: DesignConstants.spacingS),
                  Expanded(
                    child: GlassProgressBar(
                      label: l10n.salt,
                      unit: 'g',
                      value: nutritionData.salt,
                      target: nutritionData.targetSalt.toDouble(),
                      color: Colors.grey.shade500,
                    ),
                  ),
                  const SizedBox(height: DesignConstants.spacingS),
                  Expanded(
                    child: GlassProgressBar(
                      label: l10n.supplement_caffeine,
                      unit: 'mg',
                      value: nutritionData.caffeine,
                      target: nutritionData.targetCaffeine.toDouble(),
                      color: Colors.brown,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ],
      ),
    );
  }
}

class _InfoBox extends StatelessWidget {
  final _NutrientSpec spec;
  const _InfoBox({required this.spec});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final brightness = theme.brightness;
    final colorScheme = theme.colorScheme;

    final hasTarget = spec.target > 0;
    final rawProgress = hasTarget ? (spec.value / spec.target) : 0.0;
    final progress = rawProgress.clamp(0.0, 1.0);

    final backgroundColor = brightness == Brightness.dark
        ? Colors.white.withOpacity(0.10)
        : Colors.white.withOpacity(0.65);

    final borderColor = brightness == Brightness.dark
        ? Colors.white.withOpacity(0.20)
        : Colors.black.withOpacity(0.12);

    return Container(
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(9),
        border: Border.all(color: borderColor, width: 1.0),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(9),
        child: BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 8.0, sigmaY: 8.0),
          child: Stack(
            fit: StackFit.expand,
            children: [
              Align(
                alignment: Alignment.centerLeft,
                child: TweenAnimationBuilder<double>(
                  tween: Tween(begin: 0, end: progress),
                  duration: const Duration(milliseconds: 350),
                  curve: Curves.easeOutCubic,
                  builder: (context, p, child) =>
                      FractionallySizedBox(widthFactor: p, child: child),
                  child: Container(color: spec.color),
                ),
              ),
              Padding(
                padding: const EdgeInsets.symmetric(
                  horizontal: 10.0,
                  vertical: 4.0,
                ),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    FittedBox(
                      fit: BoxFit.scaleDown,
                      child: Text(
                        spec.label,
                        maxLines: 1,
                        style: TextStyle(
                          color: colorScheme.onSurface,
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      hasTarget
                          ? '${spec.value.toStringAsFixed(1)} / ${spec.target.toStringAsFixed(0)} ${spec.unit}'
                          : '${spec.value.toStringAsFixed(1)} ${spec.unit}',
                      style: TextStyle(
                        color: colorScheme.onSurface.withOpacity(0.8),
                        fontSize: 14,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/glass_bottom_menu.dart =====

// lib/widgets/glass_bottom_menu.dart
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/services/theme_service.dart';
import 'package:liquid_glass_renderer/liquid_glass_renderer.dart';
import 'package:provider/provider.dart';

class GlassMenuAction {
  final IconData? icon; // Jetzt nullable
  final Widget? customIcon; // NEU: Für deine Buchstaben
  final String label;
  final String? subtitle;
  final VoidCallback onTap;

  GlassMenuAction({
    this.icon,
    this.customIcon, // NEU
    required this.label,
    this.subtitle,
    required this.onTap,
  }) : assert(icon != null || customIcon != null,
            'Icon or customIcon must be provided');
}

// ... (showGlassBottomMenu und _GlassBottomMenuSheet bleiben unverändert) ...
// ... BITTE DEN CODE DAZWISCHEN NICHT LÖSCHEN, NUR ÜBERSPRINGEN ...

Future<T?> showGlassBottomMenu<T>({
  required BuildContext context,
  String? title,
  List<GlassMenuAction>? actions,
  Widget Function(BuildContext, VoidCallback)? contentBuilder,
}) {
  assert(
    (actions != null && contentBuilder == null) ||
        (actions == null && contentBuilder != null),
    'Either actions OR contentBuilder must be provided',
  );

  final isDark = Theme.of(context).brightness == Brightness.dark;
  final themeService = Provider.of<ThemeService>(context, listen: false);
  final bool isLiquid = themeService.visualStyle == 1;

  final Color barrierColor = isDark
      ? (!isLiquid
          ? Colors.grey.withOpacity(0.187)
          : Colors.black.withOpacity(0.5))
      : Colors.black.withOpacity(0.3);

  return showModalBottomSheet<T>(
    context: context,
    isScrollControlled: true,
    useRootNavigator: true,
    backgroundColor: Colors.transparent,
    barrierColor: barrierColor,
    builder: (ctx) {
      final kb = MediaQuery.of(ctx).viewInsets.bottom;
      return AnimatedPadding(
        duration: const Duration(milliseconds: 220),
        curve: Curves.easeOutCubic,
        padding: EdgeInsets.only(bottom: kb),
        child: _GlassBottomMenuSheet(
          title: title,
          actions: actions ?? const <GlassMenuAction>[],
          contentBuilder: contentBuilder,
        ),
      );
    },
  );
}

class _GlassBottomMenuSheet extends StatelessWidget {
  const _GlassBottomMenuSheet({
    this.title,
    this.contentBuilder,
    this.actions = const <GlassMenuAction>[],
  });

  final String? title;
  final Widget Function(BuildContext, VoidCallback)? contentBuilder;
  final List<GlassMenuAction> actions;

  @override
  Widget build(BuildContext context) {
    // ... (Dieser Teil bleibt 1:1 identisch wie in deiner aktuellen Datei) ...
    // ...
    final media = MediaQuery.of(context);
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final bottomInset = media.viewPadding.bottom;
    final themeService = context.watch<ThemeService>();

    final Color neutralTint = (isDark
        ? Colors.white.withOpacity(0.05)
        : Colors.white.withOpacity(0.22));

    final Color effectiveGlass = Color.alphaBlend(
        neutralTint, theme.colorScheme.surface.withOpacity(isDark ? 0.8 : 0.5));

    const double r = 24;
    const EdgeInsets outerMargin = EdgeInsets.fromLTRB(16, 0, 16, 16);

    Widget contentColumn() {
      return Padding(
        padding: EdgeInsets.only(bottom: bottomInset),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const SizedBox(height: 8),
            Container(
              width: 44,
              height: 5,
              decoration: BoxDecoration(
                color: Colors.white.withOpacity(0.75),
                borderRadius: BorderRadius.circular(100),
              ),
            ),
            if (title != null) ...[
              const SizedBox(height: 10),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                child: Text(
                  title!,
                  textAlign: TextAlign.center,
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w700,
                  ),
                ),
              ),
            ],
            if (contentBuilder != null) ...[
              const SizedBox(height: 8),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 12),
                child: contentBuilder!(
                  context,
                  () => Navigator.of(context).maybePop(),
                ),
              ),
            ] else if (actions.isNotEmpty) ...[
              ConstrainedBox(
                constraints: const BoxConstraints(maxHeight: 420),
                child: SingleChildScrollView(
                  child: Padding(
                    padding: const EdgeInsets.fromLTRB(8, 12, 8, 8),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: List.generate(actions.length, (i) {
                        final a = actions[i];
                        return Padding(
                          padding: const EdgeInsets.only(bottom: 8.0),
                          child: _GlassTile(
                            icon: a.icon,
                            customIcon: a.customIcon, // <--- NEU übergeben
                            title: a.label,
                            subtitle: a.subtitle,
                            onTap: () {
                              HapticFeedback.selectionClick();
                              Navigator.of(context).maybePop();
                              WidgetsBinding.instance.addPostFrameCallback(
                                (_) => a.onTap(),
                              );
                            },
                          ),
                        );
                      }),
                    ),
                  ),
                ),
              ),
            ],
          ],
        ),
      );
    }

    // ... (liquidCard und plainCard bleiben identisch, hier gekürzt) ...
    Widget liquidCard() {
      return Stack(
        children: [
          Positioned.fill(
            child: DecoratedBox(
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(r),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.18),
                    blurRadius: 30,
                    spreadRadius: 4,
                    offset: const Offset(0, 14),
                  ),
                ],
              ),
            ),
          ),
          LiquidGlass.withOwnLayer(
            settings: LiquidGlassSettings(
              thickness: 30,
              blur: 8,
              glassColor: effectiveGlass,
              lightIntensity: 0.35,
              saturation: 1.10,
            ),
            shape: const LiquidRoundedSuperellipse(borderRadius: r),
            child: Stack(
              children: [
                Positioned.fill(
                  child: DecoratedBox(
                    decoration: BoxDecoration(
                      color: neutralTint,
                      borderRadius: BorderRadius.circular(r),
                    ),
                  ),
                ),
                Positioned.fill(
                  child: IgnorePointer(
                    child: Container(
                      decoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(r),
                        border: Border.all(
                          color: isDark
                              ? Colors.white.withOpacity(0.20)
                              : Colors.black.withOpacity(0.08),
                          width: 1.2,
                        ),
                      ),
                    ),
                  ),
                ),
                contentColumn(),
              ],
            ),
          ),
        ],
      );
    }

    Widget plainCard() {
      return Stack(
        children: [
          Positioned.fill(
            child: DecoratedBox(
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(r),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.18),
                    blurRadius: 30,
                    spreadRadius: 4,
                    offset: const Offset(0, 14),
                  ),
                ],
              ),
            ),
          ),
          ClipRRect(
            borderRadius: BorderRadius.circular(r),
            child: BackdropFilter(
              filter: ImageFilter.blur(sigmaX: 20, sigmaY: 20),
              child: Container(
                decoration: BoxDecoration(
                  color: theme.colorScheme.surface.withOpacity(
                    isDark ? 0.80 : 0.92,
                  ),
                ),
                child: contentColumn(),
              ),
            ),
          ),
        ],
      );
    }

    return SafeArea(
      top: false,
      bottom: false,
      child: Align(
        alignment: Alignment.bottomCenter,
        child: Padding(
          padding: outerMargin,
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 680),
            child: themeService.visualStyle == 1 ? liquidCard() : plainCard(),
          ),
        ),
      ),
    );
  }
}
// In lib/widgets/glass_bottom_menu.dart

class _GlassTile extends StatelessWidget {
  const _GlassTile({
    this.icon,
    this.customIcon,
    required this.title,
    this.subtitle,
    required this.onTap,
  });

  final IconData? icon;
  final Widget? customIcon;
  final String title;
  final String? subtitle;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final textTheme = theme.textTheme;
    final themeService = context.watch<ThemeService>();

    // Hintergrund-Tint etwas anpassen
    final Color neutralTint =
        (isDark ? Colors.white : Colors.black).withOpacity(0.05);

    final Color effectiveGlass = Color.alphaBlend(
        neutralTint, Colors.white.withOpacity(isDark ? 0.10 : 0.12));

    final Widget leadingWidget =
        customIcon != null ? customIcon! : Icon(icon, size: 22);

    final tileContent = Padding(
      padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 12),
      child: Row(
        children: [
          Container(
            width: 42,
            height: 42,
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              color: isDark
                  ? Colors.white.withOpacity(0.1)
                  : Colors.white.withOpacity(0.2),
              border: Border.all(
                color: Colors.white.withOpacity(isDark ? 0.14 : 0.18),
                width: 1,
              ),
            ),
            child: Center(child: leadingWidget),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                if (subtitle != null) ...[
                  const SizedBox(height: 2),
                  Text(
                    subtitle!,
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                    style: textTheme.bodySmall?.copyWith(
                      color: textTheme.bodySmall?.color?.withOpacity(0.8),
                    ),
                  ),
                ],
              ],
            ),
          ),
          const SizedBox(width: 12),
          Icon(
            Icons.chevron_right_rounded,
            size: 22,
            color: Colors.white.withOpacity(0.8),
          ),
        ],
      ),
    );

    if (themeService.visualStyle == 1) {
      return LiquidGlass.withOwnLayer(
        settings: LiquidGlassSettings(
          // HIER GEÄNDERT: thickness 0 entfernt die Verzerrung/Verschiebung
          thickness: 0,
          blur: 5,
          glassColor: effectiveGlass,
          // HIER GEÄNDERT: Weniger Lichtintensität reduziert harte Kanten
          lightIntensity: 0.1,
          saturation: 1.10,
        ),
        shape: const LiquidRoundedSuperellipse(borderRadius: 18),
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: onTap,
            borderRadius: BorderRadius.circular(18),
            splashColor: Colors.transparent,
            highlightColor: Colors.transparent,
            hoverColor: Colors.transparent,
            focusColor: Colors.transparent,
            child: Stack(
              children: [
                Positioned.fill(
                  child: DecoratedBox(
                    // BorderRadius hier hilft zusätzlich bei der visuellen Abgrenzung
                    decoration: BoxDecoration(
                      color: neutralTint,
                      borderRadius: BorderRadius.circular(18),
                    ),
                  ),
                ),
                tileContent,
              ],
            ),
          ),
        ),
      );
    }

    return Material(
      color: isDark
          ? Colors.white.withOpacity(0.06)
          : Colors.white.withOpacity(0.08),
      borderRadius: BorderRadius.circular(18),
      clipBehavior: Clip.antiAlias,
      child: InkWell(
        onTap: onTap,
        child: tileContent,
      ),
    );
  }
}

/// Eine wiederverwendbare Lösch-Bestätigung im Glas-Design.
/// Gibt true zurück, wenn gelöscht werden soll.
Future<bool> showDeleteConfirmation(
  BuildContext context, {
  String? title,
  String? content,
  String? confirmLabel,
}) async {
  final l10n = AppLocalizations.of(context)!;
  final effectiveTitle = title ?? l10n.deleteConfirmTitle;
  final effectiveContent = content ?? l10n.deleteConfirmContent;
  final effectiveConfirmLabel = confirmLabel ?? l10n.delete;

  final result = await showGlassBottomMenu<bool>(
    context: context,
    title: effectiveTitle,
    contentBuilder: (ctx, close) {
      return Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8.0),
            child: Text(
              effectiveContent,
              textAlign: TextAlign.center,
              style: Theme.of(ctx).textTheme.bodyMedium,
            ),
          ),
          const SizedBox(height: 24),
          Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: () {
                    close();
                    Navigator.of(ctx).pop(false);
                  },
                  child: Text(l10n.cancel),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: FilledButton(
                  style: FilledButton.styleFrom(
                    backgroundColor: Colors.red,
                    foregroundColor: Colors.white,
                  ),
                  onPressed: () {
                    close();
                    Navigator.of(ctx).pop(true);
                  },
                  child: Text(effectiveConfirmLabel),
                ),
              ),
            ],
          ),
        ],
      );
    },
  );

  return result ?? false;
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/keep_alive_page.dart =====

import 'package:flutter/widgets.dart';

class KeepAlivePage extends StatefulWidget {
  final Widget child;
  final Key? storageKey; // optional, falls du’s später brauchen willst

  const KeepAlivePage({super.key, required this.child, this.storageKey});

  @override
  State<KeepAlivePage> createState() => _KeepAlivePageState();
}

class _KeepAlivePageState extends State<KeepAlivePage>
    with AutomaticKeepAliveClientMixin<KeepAlivePage> {
  @override
  bool get wantKeepAlive => true;

  @override
  Widget build(BuildContext context) {
    super.build(context); // wichtig für KeepAlive!
    // Kein PageStorage() mehr -> kein bucket nötig.
    // Optional: mit KeyedSubtree den storageKey an den Subtree hängen
    return widget.storageKey == null
        ? widget.child
        : KeyedSubtree(key: widget.storageKey, child: widget.child);
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/glass_progress_bar.dart =====

// lib/widgets/glass_progress_bar.dart
import 'package:flutter/material.dart';
import 'package:lightweight/theme/color_constants.dart';

class GlassProgressBar extends StatelessWidget {
  final String label;
  final String unit;
  final double value;
  final double target;
  final Color color;
  final double height;
  final double borderRadius;

  const GlassProgressBar({
    super.key,
    required this.label,
    required this.unit,
    required this.value,
    required this.target,
    required this.color,
    this.height = 60.0,
    this.borderRadius = 20.0,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final brightness = theme.brightness;
    final colorScheme = theme.colorScheme;

    final hasTarget = target > 0;
    final rawProgress = hasTarget ? (value / target) : 0.0;
    final progress = rawProgress.clamp(0.0, 1.0);

    final backgroundColor = brightness == Brightness.dark
        ? summary_card_dark_mode
        : summary_card_white_mode;

    return Container(
      height: height,
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(borderRadius),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(borderRadius),
        child: Stack(
          fit: StackFit.expand,
          children: [
            Align(
              alignment: Alignment.centerLeft,
              child: FractionallySizedBox(
                widthFactor: progress,
                child: Container(color: color),
              ),
            ),
            Padding(
              padding: const EdgeInsets.symmetric(
                horizontal: 12.0,
                vertical: 4.0,
              ),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  FittedBox(
                    fit: BoxFit.scaleDown,
                    child: Text(
                      label,
                      maxLines: 1,
                      style: TextStyle(
                        color: colorScheme.onSurface,
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    hasTarget
                        ? '${value.toStringAsFixed(1)} / ${target.toStringAsFixed(0)} $unit'
                        : '${value.toStringAsFixed(1)} $unit',
                    style: TextStyle(
                      color: colorScheme.onSurface.withOpacity(0.8),
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/glass_pill_button.dart =====

import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:lightweight/services/theme_service.dart';
import 'package:lightweight/theme/color_constants.dart';
import 'package:liquid_glass_renderer/liquid_glass_renderer.dart';
import 'package:provider/provider.dart';

/// Reusable liquid-glass Pill / Bubble.
/// - Nutze [child], um beliebige Inhalte (Icon, Text, mehrere Elemente) zu platzieren.
/// - Wenn [onTap] gesetzt ist: leichter Scale-Effekt + HapticFeedback.
/// - Wenn [onTap] null ist: nur Surface, innere Widgets können eigene Gesten haben.
class GlassPillButton extends StatefulWidget {
  final Widget child;
  final VoidCallback? onTap;
  final EdgeInsetsGeometry padding;
  final double height;
  final double borderRadius;

  const GlassPillButton({
    super.key,
    required this.child,
    this.onTap,
    this.padding = const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
    this.height = 32,
    this.borderRadius = 99,
  });

  @override
  State<GlassPillButton> createState() => _GlassPillButtonState();
}

class _GlassPillButtonState extends State<GlassPillButton>
    with SingleTickerProviderStateMixin {
  late final AnimationController _controller;

  bool get _hasTap => widget.onTap != null;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 120),
      lowerBound: 0.0,
      upperBound: 0.10,
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _onTapDown(TapDownDetails details) {
    if (_hasTap) _controller.forward();
  }

  void _onTapCancel() {
    if (_hasTap) _controller.reverse();
  }

  void _onTapUp(TapUpDetails details) {
    if (_hasTap) {
      _controller.reverse();
      HapticFeedback.lightImpact();
      widget.onTap!.call();
    }
  }

  @override
  Widget build(BuildContext context) {
    final themeService = context.watch<ThemeService>();
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final bg = isDark ? summary_card_dark_mode : summary_card_white_mode;

    final Color neutralTint =
        (isDark ? Colors.white : Colors.black).withOpacity(0.10);
    final Color effectiveGlass =
        Color.alphaBlend(neutralTint, bg.withOpacity(isDark ? 0.8 : 0.5));

    // Adaptive border radius: round if not Row, pill if Row
    final bool isCircle = widget.child is! Row;
    final double effectiveRadius =
        isCircle ? widget.height / 2 : widget.borderRadius;

    Widget surface;

    if (themeService.visualStyle == 1) {
      // Liquid-Style (mit LiquidStretch)
      surface = LiquidStretch(
        stretch: 0.55,
        interactionScale: 1.04,
        child: LiquidGlass.withOwnLayer(
          settings: LiquidGlassSettings(
            thickness: 25,
            blur: 5,
            glassColor: effectiveGlass,
            lightIntensity: 0.35,
            saturation: 1.10,
          ),
          shape: LiquidRoundedSuperellipse(borderRadius: effectiveRadius),
          child: GlassGlow(
            glowColor: Colors.white.withOpacity(isDark ? 0.24 : 0.18),
            glowRadius: 1.0,
            child: Container(
              // height and width removed here; enforced outside with SizedBox
              padding: isCircle ? EdgeInsets.zero : widget.padding,
              decoration: BoxDecoration(
                color: neutralTint,
                borderRadius: BorderRadius.circular(effectiveRadius),
              ),
              foregroundDecoration: BoxDecoration(
                borderRadius: BorderRadius.circular(effectiveRadius),
                border: Border.all(
                  color: isDark
                      ? Colors.white.withOpacity(0.20)
                      : Colors.black.withOpacity(0.08),
                  width: 1.2,
                ),
              ),
              child: Center(child: widget.child),
            ),
          ),
        ),
      );
    } else {
      // Fallback-Glass
      surface = ClipRRect(
        borderRadius: BorderRadius.circular(effectiveRadius),
        child: BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 12, sigmaY: 12),
          child: Container(
            // height and width removed here; enforced outside with SizedBox
            padding: isCircle ? EdgeInsets.zero : widget.padding,
            decoration: BoxDecoration(
              color: bg.withOpacity(0.80),
              borderRadius: BorderRadius.circular(effectiveRadius),
              border: Border.all(
                color: isDark
                    ? Colors.white.withOpacity(0.30)
                    : Colors.black.withOpacity(0.10),
                width: 1.5,
              ),
            ),
            child: Center(child: widget.child),
          ),
        ),
      );
    }

    // Wrap the surface in a SizedBox to enforce height and width
    final Widget constrainedSurface = SizedBox(
      height: widget.height,
      width: isCircle ? widget.height : null,
      child: surface,
    );

    return GestureDetector(
      behavior: HitTestBehavior.translucent,
      onTapDown: _hasTap ? _onTapDown : null,
      onTapUp: _hasTap ? _onTapUp : null,
      onTapCancel: _hasTap ? _onTapCancel : null,
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, child) {
          final scale = 1 - _controller.value;
          return Transform.scale(scale: scale, child: child);
        },
        child: constrainedSurface,
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/off_attribution_widget.dart =====

// lib/widgets/off_attribution_widget.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:url_launcher/url_launcher.dart';

class OffAttributionWidget extends StatelessWidget {
  final TextStyle? textStyle;

  const OffAttributionWidget({super.key, this.textStyle});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    final currentTextStyle = textStyle ??
        theme.textTheme.bodySmall?.copyWith(color: Colors.grey[600]);

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(8.0),
        child: GestureDetector(
          // Macht den Text klickbar
          onTap: () async {
            final uri = Uri.parse("https://openfoodfacts.org/");
            try {
              if (await canLaunchUrl(uri)) {
                await launchUrl(uri);
              } else {
                throw 'Could not launch $uri';
              }
            } catch (e) {
              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(l10n.snackbar_could_not_open_open_link),
                  ),
                );
              }
            }
          },
          child: Text(
            l10n.openFoodFactsSource,
            style: currentTextStyle,
            textAlign: TextAlign.center,
          ),
        ),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/lib/widgets/todays_workout_summary_card.dart =====

// lib/widgets/todays_workout_summary_card.dart

import 'package:flutter/material.dart';
import 'package:lightweight/generated/app_localizations.dart';
import 'package:lightweight/util/time_util.dart';
import 'package:lightweight/widgets/summary_card.dart';

class TodaysWorkoutSummaryCard extends StatelessWidget {
  final Duration duration;
  final double volume;
  final int sets;
  final int workoutCount;
  final VoidCallback onTap;

  const TodaysWorkoutSummaryCard({
    super.key,
    required this.duration,
    required this.volume,
    required this.sets,
    required this.workoutCount,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    // Erstellt den Subtitle-Text mit allen Statistiken
    final subtitleText =
        '${formatDuration(duration)}  •  ${volume.toStringAsFixed(0)} kg  •  ${l10n.setCount(sets)}';

    return SummaryCard(
      // Padding wird von der ListTile übernommen
      padding: EdgeInsets.zero,
      child: ListTile(
        onTap: onTap,
        contentPadding:
            const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16.0),
        leading: Icon(
          Icons.fitness_center,
          color: theme.colorScheme.primary,
          size: 32,
        ),
        title: Text(
          workoutCount > 1
              ? l10n.workoutsLabel // "Workouts"
              : l10n.workout, // "Workout"
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        subtitle: Text(
          subtitleText,
          style: theme.textTheme.bodyMedium?.copyWith(
            color: theme.textTheme.bodySmall?.color,
          ),
        ),
        trailing: const Icon(Icons.chevron_right),
      ),
    );
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/.dart_tool/flutter_build/dart_plugin_registrant.dart =====

//
// Generated file. Do not edit.
// This file is generated from template in file `flutter_tools/lib/src/flutter_plugins.dart`.
//

// @dart = 3.0

import 'dart:io'; // flutter_ignore: dart_io_import.
import 'package:file_picker/file_picker.dart';
import 'package:image_picker_android/image_picker_android.dart';
import 'package:path_provider_android/path_provider_android.dart';
import 'package:shared_preferences_android/shared_preferences_android.dart';
import 'package:sqflite_android/sqflite_android.dart';
import 'package:url_launcher_android/url_launcher_android.dart';
import 'package:file_picker/file_picker.dart';
import 'package:image_picker_ios/image_picker_ios.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:sqflite_darwin/sqflite_darwin.dart';
import 'package:url_launcher_ios/url_launcher_ios.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:file_picker/file_picker.dart';
import 'package:file_selector_linux/file_selector_linux.dart';
import 'package:image_picker_linux/image_picker_linux.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:share_plus/share_plus.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:url_launcher_linux/url_launcher_linux.dart';
import 'package:file_picker/file_picker.dart';
import 'package:file_selector_macos/file_selector_macos.dart';
import 'package:image_picker_macos/image_picker_macos.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:sqflite_darwin/sqflite_darwin.dart';
import 'package:url_launcher_macos/url_launcher_macos.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:file_picker/file_picker.dart';
import 'package:file_selector_windows/file_selector_windows.dart';
import 'package:image_picker_windows/image_picker_windows.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:share_plus/share_plus.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';
import 'package:url_launcher_windows/url_launcher_windows.dart';

@pragma('vm:entry-point')
class _PluginRegistrant {

  @pragma('vm:entry-point')
  static void register() {
    if (Platform.isAndroid) {
      try {
        FilePickerIO.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerAndroid.registerWith();
      } catch (err) {
        print(
          '`image_picker_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderAndroid.registerWith();
      } catch (err) {
        print(
          '`path_provider_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesAndroid.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqfliteAndroid.registerWith();
      } catch (err) {
        print(
          '`sqflite_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherAndroid.registerWith();
      } catch (err) {
        print(
          '`url_launcher_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isIOS) {
      try {
        FilePickerIO.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerIOS.registerWith();
      } catch (err) {
        print(
          '`image_picker_ios` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqfliteDarwin.registerWith();
      } catch (err) {
        print(
          '`sqflite_darwin` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherIOS.registerWith();
      } catch (err) {
        print(
          '`url_launcher_ios` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isLinux) {
      try {
        DeviceInfoPlusLinuxPlugin.registerWith();
      } catch (err) {
        print(
          '`device_info_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        FilePickerLinux.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        FileSelectorLinux.registerWith();
      } catch (err) {
        print(
          '`file_selector_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerLinux.registerWith();
      } catch (err) {
        print(
          '`image_picker_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PackageInfoPlusLinuxPlugin.registerWith();
      } catch (err) {
        print(
          '`package_info_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderLinux.registerWith();
      } catch (err) {
        print(
          '`path_provider_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharePlusLinuxPlugin.registerWith();
      } catch (err) {
        print(
          '`share_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesLinux.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherLinux.registerWith();
      } catch (err) {
        print(
          '`url_launcher_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isMacOS) {
      try {
        FilePickerMacOS.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        FileSelectorMacOS.registerWith();
      } catch (err) {
        print(
          '`file_selector_macos` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerMacOS.registerWith();
      } catch (err) {
        print(
          '`image_picker_macos` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqfliteDarwin.registerWith();
      } catch (err) {
        print(
          '`sqflite_darwin` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherMacOS.registerWith();
      } catch (err) {
        print(
          '`url_launcher_macos` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isWindows) {
      try {
        DeviceInfoPlusWindowsPlugin.registerWith();
      } catch (err) {
        print(
          '`device_info_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        FilePickerWindows.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        FileSelectorWindows.registerWith();
      } catch (err) {
        print(
          '`file_selector_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerWindows.registerWith();
      } catch (err) {
        print(
          '`image_picker_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PackageInfoPlusWindowsPlugin.registerWith();
      } catch (err) {
        print(
          '`package_info_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderWindows.registerWith();
      } catch (err) {
        print(
          '`path_provider_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharePlusWindowsPlugin.registerWith();
      } catch (err) {
        print(
          '`share_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesWindows.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherWindows.registerWith();
      } catch (err) {
        print(
          '`url_launcher_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    }
  }
}


===== Datei: /Users/richard/Projects/Lightweight/lightweight/.dart_tool/dartpad/web_plugin_registrant.dart =====

// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// @dart = 2.13
// ignore_for_file: type=lint

import 'package:device_info_plus/src/device_info_plus_web.dart';
import 'package:file_picker/_internal/file_picker_web.dart';
import 'package:image_picker_for_web/image_picker_for_web.dart';
import 'package:mobile_scanner/src/web/mobile_scanner_web.dart';
import 'package:package_info_plus/src/package_info_plus_web.dart';
import 'package:share_plus/src/share_plus_web.dart';
import 'package:shared_preferences_web/shared_preferences_web.dart';
import 'package:url_launcher_web/url_launcher_web.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  DeviceInfoPlusWebPlugin.registerWith(registrar);
  FilePickerWeb.registerWith(registrar);
  ImagePickerPlugin.registerWith(registrar);
  MobileScannerWeb.registerWith(registrar);
  PackageInfoPlusWebPlugin.registerWith(registrar);
  SharePlusWebPlugin.registerWith(registrar);
  SharedPreferencesPlugin.registerWith(registrar);
  UrlLauncherPlugin.registerWith(registrar);
  registrar.registerMessageHandler();
}

